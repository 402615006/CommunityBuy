/*!
 * 
 * Spread.Sheets Library 11.2.2
 * 
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the SpreadJS Commercial License.
 * us.sales@grapecity.com
 * http://www.grapecity.com/en/licensing/grapecity/
 * 
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Excel"] = factory();
	else
		root["GC"] = root["GC"] || {}, root["GC"]["Spread"] = root["GC"]["Spread"] || {}, root["GC"]["Spread"]["Excel"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var FileLoader = __webpack_require__(1);
	    var XlsxReader = __webpack_require__(20);
	    var XlsxWriter = __webpack_require__(42);
	    var XlsxEncryptionHelper = __webpack_require__(5);
	    var Sha512 = __webpack_require__(9);
	    var Aes = __webpack_require__(10);
	    var Sha1 = __webpack_require__(17);
	    var errorCode = __webpack_require__(18);
	    var sR = __webpack_require__(19);
	    exports.ErrorCode = errorCode;
	
	    var ls = __webpack_require__(61);
	    if (ls) {
	        ls._ns && ls._ns(exports);
	        var productType = ls._productType;
	        if (productType === 1) {
	            ls._replace();
	        }
	    }
	
	    var IO = (function () {
	       
	        
	        function IO() {
	            this._fileLoader = new FileLoader();
	        }
	
	       
	        
	        IO.prototype.open = function (file, successCallBack, errorCallBack, options) {
	            var self = this;
	            if (!successCallBack) {
	                successCallBack = function () {
	                };
	            }
	            if (!errorCallBack) {
	                errorCallBack = function () {
	                };
	            }
	            self._fileLoader.onFileLoad = function (filesData) {
	                try {
	                    var xlsxReader = new XlsxReader();
	                    var json = xlsxReader._load(filesData);
	                    successCallBack(json); 
	                } catch (e) {
	                    errorCallBack({ 
	                        errorCode: errorCode.fileFormatError,
	                        errorMessage: sR().EXP_FILE_FORMAT
	                    });
	                }
	            };
	            self._fileLoader.onError = errorCallBack;
	            self._fileLoader.loadFile(file, options);
	        };
	
	
	       
	        
	        IO.prototype.save = function (json, successCallBack, errorCallBack, options) {
	            if (!successCallBack) {
	                successCallBack = function () {
	                };
	            }
	            if (!errorCallBack) {
	                errorCallBack = function () {
	                };
	            }
	            var spreadObj, useArrayBuffer;
	
	            if (typeof json === 'object') {
	                spreadObj = JSON.parse(JSON.stringify(json));
	            }
	            if (typeof json === 'string') {
	                spreadObj = JSON.parse(json);
	            }
	            var xlsxWriter = new XlsxWriter(spreadObj);
	            xlsxWriter.onZip = function (data) {
	                if (options && options.password) {
	                    try {
	                        data = XlsxEncryptionHelper._encrypt(data, options.password);
	                        if (!useArrayBuffer) {
	                            data = XlsxEncryptionHelper._arrayBufferToBlob(data);
	                        }
	                    } catch (e) {
	                        errorCallBack({ 
	                            errorCode: errorCode.fileFormatError,
	                            errorMessage: sR().EXP_FILE_FORMAT
	                        });
	                        return;
	                    }
	                }
	                successCallBack(data); 
	            };
	            xlsxWriter.onError = function () {
	                errorCallBack({ 
	                    errorCode: errorCode.fileFormatError,
	                    errorMessage: sR().EXP_FILE_FORMAT
	                });
	            };
	
	            if (options && options.password) {
	                useArrayBuffer = options.useArrayBuffer;
	                options.useArrayBuffer = true;
	            }
	            xlsxWriter._options = options || {};
	            try {
	                xlsxWriter._save();
	            } catch (e) {
	                errorCallBack({ 
	                    errorCode: errorCode.fileFormatError,
	                    errorMessage: sR().EXP_FILE_FORMAT
	                });
	            }
	        };
	
	        return IO;
	    })();
	    exports.IO = IO;
	    exports._sha1 = Sha1;//for unit test
	    exports._sha512 = Sha512;//for unit test
	    exports._aes = Aes;//for unit test
	
	}());

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var JSZip = __webpack_require__(2);
	    var keyword_undefined = void 0, const_undefined = 'undefined';
	    var CompoundFile = __webpack_require__(3);
	    var XlsxEncryptionHelper = __webpack_require__(5);
	    var errorCode = __webpack_require__(18);
	    var sR = __webpack_require__(19);
	
	   
	   
	   
	   
	
	    var FileLoader = (function () {
	        function FileLoader(loadType) {
	            var self = this;
	            if (loadType === keyword_undefined) {
	                self.loadType = 1 ;
	            } else {
	                self.loadType = loadType;
	            }
	            if (typeof FileReader === const_undefined) {
	                throw new Error('The browser doesn\'t support FileReader!');
	            } else {
	                self.fileReader = new FileReader();
	                self.passwordFileReader = new FileReader();
	                self.compoundFile = new CompoundFile();
	            }
	        }
	
	        FileLoader.prototype.loadFile = function (file, options) {
	            var self = this, reader = self.fileReader;
	            if (file instanceof ArrayBuffer) { 
	                self.fileLoad(file, options);
	                return;
	            }
	            if (file && reader) {
	                reader.onload = function (e) {
	                    self.fileLoad(e.target.result, options);
	                };
	                reader.onerror = function () {
	                    self._errorFileIO();
	                };
	                switch (self.loadType) {
	                    case 1 
	                    :
	                        if (reader.readAsArrayBuffer) {
	                            reader.readAsArrayBuffer(file);
	                            break;
	                        }
	                        self.loadType = 0 ;
	                        break;
	                    default:
	                        if (reader.readAsDataURL) {
	                            reader.readAsDataURL(file);
	                        }
	                        break;
	                }
	            }
	        };
	        FileLoader.prototype._errorFileIO = function () {
	            this.onError({
	                errorCode: errorCode.fileIOError,
	                errorMessage: sR().EXP_IO
	            });
	        };
	        FileLoader.prototype._errorFileFormat = function () {
	            this.onError({
	                errorCode: errorCode.fileFormatError,
	                errorMessage: sR().EXP_FILE_FORMAT
	            });
	        };
	        FileLoader.prototype._errorNoPassword = function () {
	            this.onError({
	                errorCode: errorCode.noPassword,
	                errorMessage: sR().EXP_NO_PASSWORD
	            });
	        };
	        FileLoader.prototype._errorInvalidPassword = function () {
	            this.onError({
	                errorCode: errorCode.invalidPassword,
	                errorMessage: sR().EXP_INVALID_PASSWORD
	            });
	        };
	        FileLoader.prototype.fileLoad = function (fileData, options) {
	
	            var self = this;
	            if (options && options.password) {
	                try {
	                    fileData = XlsxEncryptionHelper._decrypt(fileData, options.password);
	                    if (!fileData) {
	                        self._errorInvalidPassword();
	                        return;
	                    }
	                } catch (err) {
	                    self._errorInvalidPassword();
	                    return;
	                }
	            } else if (XlsxEncryptionHelper._hasPassword(fileData)) {
	                self._errorNoPassword();
	                return;
	            }
	
	            var zip = new JSZip();
	            switch (self.loadType) {
	                case 1 
	                :
	                    zip.loadAsync(fileData).then(loadFileArrays).catch(function () {
	                        self._errorFileFormat();
	                    });
	                    break;
	                case 0 
	                :
	                default:
	                    var baseText = 'base64,', textIndex = fileData.indexOf(baseText);
	                    if (textIndex !== -1) {
	                        var data = fileData.substring(textIndex + baseText.length);
	                        zip.loadAsync(data, {base64: true}).then(loadFileArrays).catch(function () {
	                            self._errorFileFormat();
	                        });
	                    }
	                    break;
	            }
	            function loadFileArrays() {
	                var files = zip.files, filesData = {};
	                for (var file in files) {
	                    if (files.hasOwnProperty(file)) {
	                        var fileType;
	                        if (file.substring(file.length - 3) === 'xml') {
	                            fileType = 'text';
	                        } else {
	                            fileType = (file.indexOf('/media/') === -1) ? 'binarystring' : 'base64';
	                        }
	                        files[file].async(fileType).then(function (name) {
	                            return function (content) {
	                                filesData[name.toLowerCase()] = content;
	                               
	                                for (var fileName in files) {
	                                    if (filesData[fileName.toLowerCase()] === keyword_undefined) {
	                                        return;
	                                    }
	                                }
	                                self.onFileLoad(filesData);
	                            };
	                        }(file)).catch(function () {
	                            self._errorFileFormat();
	                        });
	                    }
	                }
	            }
	        };
	
	       
	       
	
	       
	       
	        return FileLoader;
	    })();
	
	    module.exports = FileLoader;
	
	
	}());

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global) {!function (a) {
	    if (true)module.exports = a(); else if ("function" == typeof define && define.amd)define([], a); else {
	        var b;
	        b = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, b.JSZip = a()
	    }
	}(function () {
	    var a;
	    return function b(a, c, d) {
	        function e(g, h) {
	            if (!c[g]) {
	                if (!a[g]) {
	                    var i = "function" == typeof require && require;
	                    if (!h && i)return require(g, !0);
	                    if (f)return f(g, !0);
	                    var j = new Error("Cannot find module '" + g + "'");
	                    throw j.code = "MODULE_NOT_FOUND", j
	                }
	                var k = c[g] = {exports: {}};
	                a[g][0].call(k.exports, function (b) {
	                    var c = a[g][1][b];
	                    return e(c ? c : b)
	                }, k, k.exports, b, a, c, d)
	            }
	            return c[g].exports
	        }
	
	        for (var f = "function" == typeof require && require, g = 0; g < d.length; g++)e(d[g]);
	        return e
	    }({
	        1: [function (a, b, c) {
	            "use strict";
	            var d = a("./utils"), e = a("./support"), f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	            c.encode = function (a) {
	                for (var b, c, e, g, h, i, j, k = [], l = 0, m = a.length, n = m, o = "string" !== d.getTypeOf(a); l < a.length;)n = m - l, o ? (b = a[l++], c = m > l ? a[l++] : 0, e = m > l ? a[l++] : 0) : (b = a.charCodeAt(l++), c = m > l ? a.charCodeAt(l++) : 0, e = m > l ? a.charCodeAt(l++) : 0), g = b >> 2, h = (3 & b) << 4 | c >> 4, i = n > 1 ? (15 & c) << 2 | e >> 6 : 64, j = n > 2 ? 63 & e : 64, k.push(f.charAt(g) + f.charAt(h) + f.charAt(i) + f.charAt(j));
	                return k.join("")
	            }, c.decode = function (a) {
	                var b, c, d, g, h, i, j, k = 0, l = 0;
	                a = a.replace(/[^A-Za-z0-9\+\/\=]/g, "");
	                var m = 3 * a.length / 4;
	                a.charAt(a.length - 1) === f.charAt(64) && m--, a.charAt(a.length - 2) === f.charAt(64) && m--;
	                var n;
	                for (n = e.uint8array ? new Uint8Array(m) : new Array(m); k < a.length;)g = f.indexOf(a.charAt(k++)), h = f.indexOf(a.charAt(k++)), i = f.indexOf(a.charAt(k++)), j = f.indexOf(a.charAt(k++)), b = g << 2 | h >> 4, c = (15 & h) << 4 | i >> 2, d = (3 & i) << 6 | j, n[l++] = b, 64 !== i && (n[l++] = c), 64 !== j && (n[l++] = d);
	                return n
	            }
	        }, {"./support": 27, "./utils": 29}],
	        2: [function (a, b, c) {
	            "use strict";
	            function d(a, b, c, d, e) {
	                this.compressedSize = a, this.uncompressedSize = b, this.crc32 = c, this.compression = d, this.compressedContent = e
	            }
	
	            var e = a("./external"), f = a("./stream/DataWorker"), g = a("./stream/DataLengthProbe"), h = a("./stream/Crc32Probe"), g = a("./stream/DataLengthProbe");
	            d.prototype = {
	                getContentWorker: function () {
	                    var a = new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g("data_length")), b = this;
	                    return a.on("end", function () {
	                        if (this.streamInfo.data_length !== b.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")
	                    }), a
	                }, getCompressedWorker: function () {
	                    return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression)
	                }
	            }, d.createWorkerFrom = function (a, b, c) {
	                return a.pipe(new h).pipe(new g("uncompressedSize")).pipe(b.compressWorker(c)).pipe(new g("compressedSize")).withStreamInfo("compression", b)
	            }, b.exports = d
	        }, {"./external": 6, "./stream/Crc32Probe": 22, "./stream/DataLengthProbe": 23, "./stream/DataWorker": 24}],
	        3: [function (a, b, c) {
	            "use strict";
	            var d = a("./stream/GenericWorker");
	            c.STORE = {
	                magic: "\x00\x00", compressWorker: function (a) {
	                    return new d("STORE compression")
	                }, uncompressWorker: function () {
	                    return new d("STORE decompression")
	                }
	            }, c.DEFLATE = a("./flate")
	        }, {"./flate": 7, "./stream/GenericWorker": 25}],
	        4: [function (a, b, c) {
	            "use strict";
	            function d() {
	                for (var a, b = [], c = 0; 256 > c; c++) {
	                    a = c;
	                    for (var d = 0; 8 > d; d++)a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
	                    b[c] = a
	                }
	                return b
	            }
	
	            function e(a, b, c, d) {
	                var e = h, f = d + c;
	                a = -1 ^ a;
	                for (var g = d; f > g; g++)a = a >>> 8 ^ e[255 & (a ^ b[g])];
	                return -1 ^ a
	            }
	
	            function f(a, b, c, d) {
	                var e = h, f = d + c;
	                a = -1 ^ a;
	                for (var g = d; f > g; g++)a = a >>> 8 ^ e[255 & (a ^ b.charCodeAt(g))];
	                return -1 ^ a
	            }
	
	            var g = a("./utils"), h = d();
	            b.exports = function (a, b) {
	                if ("undefined" == typeof a || !a.length)return 0;
	                var c = "string" !== g.getTypeOf(a);
	                return c ? e(0 | b, a, a.length, 0) : f(0 | b, a, a.length, 0)
	            }
	        }, {"./utils": 29}],
	        5: [function (a, b, c) {
	            "use strict";
	            c.base64 = !1, c.binary = !1, c.dir = !1, c.createFolders = !0, c.date = null, c.compression = null, c.compressionOptions = null, c.comment = null, c.unixPermissions = null, c.dosPermissions = null
	        }, {}],
	        6: [function (a, b, c) {
	            "use strict";
	            var d = a("es6-promise").Promise;
	            b.exports = {Promise: d}
	        }, {"es6-promise": 37}],
	        7: [function (a, b, c) {
	            "use strict";
	            function d(a, b) {
	                h.call(this, "FlateWorker/" + a), this._pako = new f[a]({
	                    raw: !0,
	                    level: b.level || -1
	                }), this.meta = {};
	                var c = this;
	                this._pako.onData = function (a) {
	                    c.push({data: a, meta: c.meta})
	                }
	            }
	
	            var e = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, f = a("pako"), g = a("./utils"), h = a("./stream/GenericWorker"), i = e ? "uint8array" : "array";
	            c.magic = "\b\x00", g.inherits(d, h), d.prototype.processChunk = function (a) {
	                this.meta = a.meta, this._pako.push(g.transformTo(i, a.data), !1)
	            }, d.prototype.flush = function () {
	                h.prototype.flush.call(this), this._pako.push([], !0)
	            }, d.prototype.cleanUp = function () {
	                h.prototype.cleanUp.call(this), this._pako = null
	            }, c.compressWorker = function (a) {
	                return new d("Deflate", a)
	            }, c.uncompressWorker = function () {
	                return new d("Inflate", {})
	            }
	        }, {"./stream/GenericWorker": 25, "./utils": 29, pako: 38}],
	        8: [function (a, b, c) {
	            "use strict";
	            function d(a, b, c, d) {
	                f.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = b, this.zipPlatform = c, this.encodeFileName = d, this.streamFiles = a, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = []
	            }
	
	            var e = a("../utils"), f = a("../stream/GenericWorker"), g = a("../utf8"), h = a("../crc32"), i = a("../signature"), j = function (a, b) {
	                var c, d = "";
	                for (c = 0; b > c; c++)d += String.fromCharCode(255 & a), a >>>= 8;
	                return d
	            }, k = function (a, b) {
	                var c = a;
	                return a || (c = b ? 16893 : 33204), (65535 & c) << 16
	            }, l = function (a, b) {
	                return 63 & (a || 0)
	            }, m = function (a, b, c, d, f, m) {
	                var n, o, p = a.file, q = a.compression, r = m !== g.utf8encode, s = e.transformTo("string", m(p.name)), t = e.transformTo("string", g.utf8encode(p.name)), u = p.comment, v = e.transformTo("string", m(u)), w = e.transformTo("string", g.utf8encode(u)), x = t.length !== p.name.length, y = w.length !== u.length, z = "", A = "", B = "", C = p.dir, D = p.date, E = {
	                    crc32: 0,
	                    compressedSize: 0,
	                    uncompressedSize: 0
	                };
	                b && !c || (E.crc32 = a.crc32, E.compressedSize = a.compressedSize, E.uncompressedSize = a.uncompressedSize);
	                var F = 0;
	                b && (F |= 8), r || !x && !y || (F |= 2048);
	                var G = 0, H = 0;
	                C && (G |= 16), "UNIX" === f ? (H = 798, G |= k(p.unixPermissions, C)) : (H = 20, G |= l(p.dosPermissions, C)), n = D.getUTCHours(), n <<= 6, n |= D.getUTCMinutes(), n <<= 5, n |= D.getUTCSeconds() / 2, o = D.getUTCFullYear() - 1980, o <<= 4, o |= D.getUTCMonth() + 1, o <<= 5, o |= D.getUTCDate(), x && (A = j(1, 1) + j(h(s), 4) + t, z += "up" + j(A.length, 2) + A), y && (B = j(1, 1) + j(h(v), 4) + w, z += "uc" + j(B.length, 2) + B);
	                var I = "";
	                I += "\n\x00", I += j(F, 2), I += q.magic, I += j(n, 2), I += j(o, 2), I += j(E.crc32, 4), I += j(E.compressedSize, 4), I += j(E.uncompressedSize, 4), I += j(s.length, 2), I += j(z.length, 2);
	                var J = i.LOCAL_FILE_HEADER + I + s + z, K = i.CENTRAL_FILE_HEADER + j(H, 2) + I + j(v.length, 2) + "\x00\x00\x00\x00" + j(G, 4) + j(d, 4) + s + z + v;
	                return {fileRecord: J, dirRecord: K}
	            }, n = function (a, b, c, d, f) {
	                var g = "", h = e.transformTo("string", f(d));
	                return g = i.CENTRAL_DIRECTORY_END + "\x00\x00\x00\x00" + j(a, 2) + j(a, 2) + j(b, 4) + j(c, 4) + j(h.length, 2) + h
	            }, o = function (a) {
	                var b = "";
	                return b = i.DATA_DESCRIPTOR + j(a.crc32, 4) + j(a.compressedSize, 4) + j(a.uncompressedSize, 4)
	            };
	            e.inherits(d, f), d.prototype.push = function (a) {
	                var b = a.meta.percent || 0, c = this.entriesCount, d = this._sources.length;
	                this.accumulate ? this.contentBuffer.push(a) : (this.bytesWritten += a.data.length, f.prototype.push.call(this, {
	                    data: a.data,
	                    meta: {currentFile: this.currentFile, percent: c ? (b + 100 * (c - d - 1)) / c : 100}
	                }))
	            }, d.prototype.openedSource = function (a) {
	                if (this.currentSourceOffset = this.bytesWritten, this.currentFile = a.file.name, this.streamFiles && !a.file.dir) {
	                    var b = m(a, this.streamFiles, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
	                    this.push({data: b.fileRecord, meta: {percent: 0}})
	                } else this.accumulate = !0
	            }, d.prototype.closedSource = function (a) {
	                this.accumulate = !1;
	                var b = m(a, this.streamFiles, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
	                if (this.dirRecords.push(b.dirRecord), this.streamFiles && !a.file.dir)this.push({
	                    data: o(a),
	                    meta: {percent: 100}
	                }); else for (this.push({
	                    data: b.fileRecord,
	                    meta: {percent: 0}
	                }); this.contentBuffer.length;)this.push(this.contentBuffer.shift());
	                this.currentFile = null
	            }, d.prototype.flush = function () {
	                for (var a = this.bytesWritten, b = 0; b < this.dirRecords.length; b++)this.push({
	                    data: this.dirRecords[b],
	                    meta: {percent: 100}
	                });
	                var c = this.bytesWritten - a, d = n(this.dirRecords.length, c, a, this.zipComment, this.encodeFileName);
	                this.push({data: d, meta: {percent: 100}})
	            }, d.prototype.prepareNextSource = function () {
	                this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume()
	            }, d.prototype.registerPrevious = function (a) {
	                this._sources.push(a);
	                var b = this;
	                return a.on("data", function (a) {
	                    b.processChunk(a)
	                }), a.on("end", function () {
	                    b.closedSource(b.previous.streamInfo), b._sources.length ? b.prepareNextSource() : b.end()
	                }), a.on("error", function (a) {
	                    b.error(a)
	                }), this
	            }, d.prototype.resume = function () {
	                return f.prototype.resume.call(this) ? !this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0) : !1
	            }, d.prototype.error = function (a) {
	                var b = this._sources;
	                if (!f.prototype.error.call(this, a))return !1;
	                for (var c = 0; c < b.length; c++)try {
	                    b[c].error(a)
	                } catch (a) {
	                }
	                return !0
	            }, d.prototype.lock = function () {
	                f.prototype.lock.call(this);
	                for (var a = this._sources, b = 0; b < a.length; b++)a[b].lock()
	            }, b.exports = d
	        }, {"../crc32": 4, "../signature": 20, "../stream/GenericWorker": 25, "../utf8": 28, "../utils": 29}],
	        9: [function (a, b, c) {
	            "use strict";
	            var d = a("../compressions"), e = a("./ZipFileWorker"), f = function (a, b) {
	                var c = a || b, e = d[c];
	                if (!e)throw new Error(c + " is not a valid compression method !");
	                return e
	            };
	            c.generateWorker = function (a, b, c) {
	                var d = new e(b.streamFiles, c, b.platform, b.encodeFileName), g = 0;
	                try {
	                    a.forEach(function (a, c) {
	                        g++;
	                        var e = f(c.options.compression, b.compression), h = c.options.compressionOptions || b.compressionOptions || {}, i = c.dir, j = c.date;
	                        c._compressWorker(e, h).withStreamInfo("file", {
	                            name: a,
	                            dir: i,
	                            date: j,
	                            comment: c.comment || "",
	                            unixPermissions: c.unixPermissions,
	                            dosPermissions: c.dosPermissions
	                        }).pipe(d)
	                    }), d.entriesCount = g
	                } catch (h) {
	                    d.error(h)
	                }
	                return d
	            }
	        }, {"../compressions": 3, "./ZipFileWorker": 8}],
	        10: [function (a, b, c) {
	            "use strict";
	            function d() {
	                if (!(this instanceof d))return new d;
	                if (arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
	                this.files = {}, this.comment = null, this.root = "", this.clone = function () {
	                    var a = new d;
	                    for (var b in this)"function" != typeof this[b] && (a[b] = this[b]);
	                    return a
	                }
	            }
	
	            d.prototype = a("./object"), d.prototype.loadAsync = a("./load"), d.support = a("./support"), d.defaults = a("./defaults"), d.loadAsync = function (a, b) {
	                return (new d).loadAsync(a, b)
	            }, d.external = a("./external"), b.exports = d
	        }, {"./defaults": 5, "./external": 6, "./load": 11, "./object": 13, "./support": 27}],
	        11: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                return new f.Promise(function (b, c) {
	                    var d = a.decompressed.getContentWorker().pipe(new i);
	                    d.on("error", function (a) {
	                        c(a)
	                    }).on("end", function () {
	                        d.streamInfo.crc32 !== a.decompressed.crc32 ? c(new Error("Corrupted zip : CRC32 mismatch")) : b()
	                    }).resume()
	                })
	            }
	
	            var e = a("./utils"), f = a("./external"), g = a("./utf8"), e = a("./utils"), h = a("./zipEntries"), i = a("./stream/Crc32Probe"), j = a("./nodejsUtils");
	            b.exports = function (a, b) {
	                var c = this;
	                return b = e.extend(b || {}, {
	                    base64: !1,
	                    checkCRC32: !1,
	                    optimizedBinaryString: !1,
	                    createFolders: !1,
	                    decodeFileName: g.utf8decode
	                }), j.isNode && j.isStream(a) ? f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : e.prepareContent("the loaded zip file", a, !0, b.optimizedBinaryString, b.base64).then(function (a) {
	                    var c = new h(b);
	                    return c.load(a), c
	                }).then(function (a) {
	                    var c = [f.Promise.resolve(a)], e = a.files;
	                    if (b.checkCRC32)for (var g = 0; g < e.length; g++)c.push(d(e[g]));
	                    return f.Promise.all(c)
	                }).then(function (a) {
	                    for (var d = a.shift(), e = d.files, f = 0; f < e.length; f++) {
	                        var g = e[f];
	                        c.file(g.fileNameStr, g.decompressed, {
	                            binary: !0,
	                            optimizedBinaryString: !0,
	                            date: g.date,
	                            dir: g.dir,
	                            comment: g.fileCommentStr.length ? g.fileCommentStr : null,
	                            unixPermissions: g.unixPermissions,
	                            dosPermissions: g.dosPermissions,
	                            createFolders: b.createFolders
	                        })
	                    }
	                    return d.zipComment.length && (c.comment = d.zipComment), c
	                })
	            }
	        }, {
	            "./external": 6,
	            "./nodejsUtils": 12,
	            "./stream/Crc32Probe": 22,
	            "./utf8": 28,
	            "./utils": 29,
	            "./zipEntries": 30
	        }],
	        12: [function (a, b, c) {
	            (function (a) {
	                "use strict";
	                b.exports = {
	                    isNode: "undefined" != typeof a, newBuffer: function (b, c) {
	                        return new a(b, c)
	                    }, isBuffer: function (b) {
	                        return a.isBuffer(b)
	                    }, isStream: function (a) {
	                        return a && "function" == typeof a.on && "function" == typeof a.pause && "function" == typeof a.resume
	                    }
	                }
	            }).call(this, "undefined" != typeof Buffer ? Buffer : void 0)
	        }, {}],
	        13: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                return "[object RegExp]" === Object.prototype.toString.call(a)
	            }
	
	            var e = a("./utf8"), f = a("./utils"), g = a("./stream/GenericWorker"), h = a("./stream/StreamHelper"), i = a("./defaults"), j = a("./compressedObject"), k = a("./zipObject"), l = a("./generate"), m = a("./nodejsUtils"), n = a("./nodejs/NodejsStreamInputAdapter"), o = function (a, b, c) {
	                var d, e = f.getTypeOf(b);
	                c = f.extend(c || {}, i), c.date = c.date || new Date, null !== c.compression && (c.compression = c.compression.toUpperCase()), "string" == typeof c.unixPermissions && (c.unixPermissions = parseInt(c.unixPermissions, 8)), c.unixPermissions && 16384 & c.unixPermissions && (c.dir = !0), c.dosPermissions && 16 & c.dosPermissions && (c.dir = !0), c.dir && (a = q(a)), c.createFolders && (d = p(a)) && r.call(this, d, !0);
	                var h = "string" === e && c.binary === !1 && c.base64 === !1;
	                c.binary = !h;
	                var l = b instanceof j && 0 === b.uncompressedSize;
	                (l || c.dir || !b || 0 === b.length) && (c.base64 = !1, c.binary = !0, b = "", c.compression = "STORE", e = "string");
	                var o = null;
	                o = b instanceof j || b instanceof g ? b : m.isNode && m.isStream(b) ? new n(a, b) : f.prepareContent(a, b, c.binary, c.optimizedBinaryString, c.base64);
	                var s = new k(a, o, c);
	                this.files[a] = s
	            }, p = function (a) {
	                "/" === a.slice(-1) && (a = a.substring(0, a.length - 1));
	                var b = a.lastIndexOf("/");
	                return b > 0 ? a.substring(0, b) : ""
	            }, q = function (a) {
	                return "/" !== a.slice(-1) && (a += "/"), a
	            }, r = function (a, b) {
	                return b = "undefined" != typeof b ? b : i.createFolders, a = q(a), this.files[a] || o.call(this, a, null, {
	                    dir: !0,
	                    createFolders: b
	                }), this.files[a]
	            }, s = {
	                load: function () {
	                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
	                }, forEach: function (a) {
	                    var b, c, d;
	                    for (b in this.files)this.files.hasOwnProperty(b) && (d = this.files[b], c = b.slice(this.root.length, b.length), c && b.slice(0, this.root.length) === this.root && a(c, d))
	                }, filter: function (a) {
	                    var b = [];
	                    return this.forEach(function (c, d) {
	                        a(c, d) && b.push(d)
	                    }), b
	                }, file: function (a, b, c) {
	                    if (1 === arguments.length) {
	                        if (d(a)) {
	                            var e = a;
	                            return this.filter(function (a, b) {
	                                return !b.dir && e.test(a)
	                            })
	                        }
	                        var f = this.files[this.root + a];
	                        return f && !f.dir ? f : null
	                    }
	                    return a = this.root + a, o.call(this, a, b, c), this
	                }, folder: function (a) {
	                    if (!a)return this;
	                    if (d(a))return this.filter(function (b, c) {
	                        return c.dir && a.test(b)
	                    });
	                    var b = this.root + a, c = r.call(this, b), e = this.clone();
	                    return e.root = c.name, e
	                }, remove: function (a) {
	                    a = this.root + a;
	                    var b = this.files[a];
	                    if (b || ("/" !== a.slice(-1) && (a += "/"), b = this.files[a]), b && !b.dir)delete this.files[a]; else for (var c = this.filter(function (b, c) {
	                        return c.name.slice(0, a.length) === a
	                    }), d = 0; d < c.length; d++)delete this.files[c[d].name];
	                    return this
	                }, generate: function (a) {
	                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
	                }, generateInternalStream: function (a) {
	                    var b, c = {};
	                    try {
	                        if (c = f.extend(a || {}, {
	                                streamFiles: !1,
	                                compression: "STORE",
	                                compressionOptions: null,
	                                type: "",
	                                platform: "DOS",
	                                comment: null,
	                                mimeType: "application/zip",
	                                encodeFileName: e.utf8encode
	                            }), c.type = c.type.toLowerCase(), c.compression = c.compression.toUpperCase(), "binarystring" === c.type && (c.type = "string"), !c.type)throw new Error("No output type specified.");
	                        f.checkSupport(c.type), "darwin" !== a.platform && "freebsd" !== a.platform && "linux" !== a.platform && "sunos" !== a.platform || (a.platform = "UNIX"), "win32" === a.platform && (a.platform = "DOS");
	                        var d = c.comment || this.comment || "";
	                        b = l.generateWorker(this, c, d)
	                    } catch (i) {
	                        b = new g("error"), b.error(i)
	                    }
	                    return new h(b, c.type || "string", c.mimeType)
	                }, generateAsync: function (a, b) {
	                    return this.generateInternalStream(a).accumulate(b)
	                }, generateNodeStream: function (a, b) {
	                    return a = a || {}, a.type || (a.type = "nodebuffer"), this.generateInternalStream(a).toNodejsStream(b)
	                }
	            };
	            b.exports = s
	        }, {
	            "./compressedObject": 2,
	            "./defaults": 5,
	            "./generate": 9,
	            "./nodejs/NodejsStreamInputAdapter": 35,
	            "./nodejsUtils": 12,
	            "./stream/GenericWorker": 25,
	            "./stream/StreamHelper": 26,
	            "./utf8": 28,
	            "./utils": 29,
	            "./zipObject": 32
	        }],
	        14: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                e.call(this, a);
	                for (var b = 0; b < this.data.length; b++)a[b] = 255 & a[b]
	            }
	
	            var e = a("./DataReader"), f = a("../utils");
	            f.inherits(d, e), d.prototype.byteAt = function (a) {
	                return this.data[this.zero + a]
	            }, d.prototype.lastIndexOfSignature = function (a) {
	                for (var b = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), e = a.charCodeAt(3), f = this.length - 4; f >= 0; --f)if (this.data[f] === b && this.data[f + 1] === c && this.data[f + 2] === d && this.data[f + 3] === e)return f - this.zero;
	                return -1
	            }, d.prototype.readAndCheckSignature = function (a) {
	                var b = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), e = a.charCodeAt(3), f = this.readData(4);
	                return b === f[0] && c === f[1] && d === f[2] && e === f[3]
	            }, d.prototype.readData = function (a) {
	                if (this.checkOffset(a), 0 === a)return [];
	                var b = this.data.slice(this.zero + this.index, this.zero + this.index + a);
	                return this.index += a, b
	            }, b.exports = d
	        }, {"../utils": 29, "./DataReader": 15}],
	        15: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                this.data = a, this.length = a.length, this.index = 0, this.zero = 0
	            }
	
	            var e = a("../utils");
	            d.prototype = {
	                checkOffset: function (a) {
	                    this.checkIndex(this.index + a)
	                }, checkIndex: function (a) {
	                    if (this.length < this.zero + a || 0 > a)throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?")
	                }, setIndex: function (a) {
	                    this.checkIndex(a), this.index = a
	                }, skip: function (a) {
	                    this.setIndex(this.index + a)
	                }, byteAt: function (a) {
	                }, readInt: function (a) {
	                    var b, c = 0;
	                    for (this.checkOffset(a), b = this.index + a - 1; b >= this.index; b--)c = (c << 8) + this.byteAt(b);
	                    return this.index += a, c
	                }, readString: function (a) {
	                    return e.transformTo("string", this.readData(a))
	                }, readData: function (a) {
	                }, lastIndexOfSignature: function (a) {
	                }, readAndCheckSignature: function (a) {
	                }, readDate: function () {
	                    var a = this.readInt(4);
	                    return new Date(Date.UTC((a >> 25 & 127) + 1980, (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1))
	                }
	            }, b.exports = d
	        }, {"../utils": 29}],
	        16: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                e.call(this, a)
	            }
	
	            var e = a("./Uint8ArrayReader"), f = a("../utils");
	            f.inherits(d, e), d.prototype.readData = function (a) {
	                this.checkOffset(a);
	                var b = this.data.slice(this.zero + this.index, this.zero + this.index + a);
	                return this.index += a, b
	            }, b.exports = d
	        }, {"../utils": 29, "./Uint8ArrayReader": 18}],
	        17: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                e.call(this, a)
	            }
	
	            var e = a("./DataReader"), f = a("../utils");
	            f.inherits(d, e), d.prototype.byteAt = function (a) {
	                return this.data.charCodeAt(this.zero + a)
	            }, d.prototype.lastIndexOfSignature = function (a) {
	                return this.data.lastIndexOf(a) - this.zero
	            }, d.prototype.readAndCheckSignature = function (a) {
	                var b = this.readData(4);
	                return a === b
	            }, d.prototype.readData = function (a) {
	                this.checkOffset(a);
	                var b = this.data.slice(this.zero + this.index, this.zero + this.index + a);
	                return this.index += a, b
	            }, b.exports = d
	        }, {"../utils": 29, "./DataReader": 15}],
	        18: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                e.call(this, a)
	            }
	
	            var e = a("./ArrayReader"), f = a("../utils");
	            f.inherits(d, e), d.prototype.readData = function (a) {
	                if (this.checkOffset(a), 0 === a)return new Uint8Array(0);
	                var b = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
	                return this.index += a, b
	            }, b.exports = d
	        }, {"../utils": 29, "./ArrayReader": 14}],
	        19: [function (a, b, c) {
	            "use strict";
	            var d = a("../utils"), e = a("../support"), f = a("./ArrayReader"), g = a("./StringReader"), h = a("./NodeBufferReader"), i = a("./Uint8ArrayReader");
	            b.exports = function (a) {
	                var b = d.getTypeOf(a);
	                return d.checkSupport(b), "string" !== b || e.uint8array ? "nodebuffer" === b ? new h(a) : e.uint8array ? new i(d.transformTo("uint8array", a)) : new f(d.transformTo("array", a)) : new g(a)
	            }
	        }, {
	            "../support": 27,
	            "../utils": 29,
	            "./ArrayReader": 14,
	            "./NodeBufferReader": 16,
	            "./StringReader": 17,
	            "./Uint8ArrayReader": 18
	        }],
	        20: [function (a, b, c) {
	            "use strict";
	            c.LOCAL_FILE_HEADER = "PK", c.CENTRAL_FILE_HEADER = "PK", c.CENTRAL_DIRECTORY_END = "PK", c.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", c.ZIP64_CENTRAL_DIRECTORY_END = "PK", c.DATA_DESCRIPTOR = "PK\b"
	        }, {}],
	        21: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                e.call(this, "ConvertWorker to " + a), this.destType = a
	            }
	
	            var e = a("./GenericWorker"), f = a("../utils");
	            f.inherits(d, e), d.prototype.processChunk = function (a) {
	                this.push({data: f.transformTo(this.destType, a.data), meta: a.meta})
	            }, b.exports = d
	        }, {"../utils": 29, "./GenericWorker": 25}],
	        22: [function (a, b, c) {
	            "use strict";
	            function d() {
	                e.call(this, "Crc32Probe")
	            }
	
	            var e = a("./GenericWorker"), f = a("../crc32"), g = a("../utils");
	            g.inherits(d, e), d.prototype.processChunk = function (a) {
	                this.streamInfo.crc32 = f(a.data, this.streamInfo.crc32 || 0), this.push(a)
	            }, b.exports = d
	        }, {"../crc32": 4, "../utils": 29, "./GenericWorker": 25}],
	        23: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                f.call(this, "DataLengthProbe for " + a), this.propName = a, this.withStreamInfo(a, 0)
	            }
	
	            var e = a("../utils"), f = a("./GenericWorker");
	            e.inherits(d, f), d.prototype.processChunk = function (a) {
	                if (a) {
	                    var b = this.streamInfo[this.propName] || 0;
	                    this.streamInfo[this.propName] = b + a.data.length
	                }
	                f.prototype.processChunk.call(this, a)
	            }, b.exports = d
	        }, {"../utils": 29, "./GenericWorker": 25}],
	        24: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                f.call(this, "DataWorker");
	                var b = this;
	                this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, a.then(function (a) {
	                    b.dataIsReady = !0, b.data = a, b.max = a && a.length || 0, b.type = e.getTypeOf(a), b.isPaused || b._tickAndRepeat()
	                }, function (a) {
	                    b.error(a)
	                })
	            }
	
	            var e = a("../utils"), f = a("./GenericWorker"), g = 16384;
	            e.inherits(d, f), d.prototype.cleanUp = function () {
	                f.prototype.cleanUp.call(this), this.data = null
	            }, d.prototype.resume = function () {
	                return f.prototype.resume.call(this) ? (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, e.delay(this._tickAndRepeat, [], this)), !0) : !1
	            }, d.prototype._tickAndRepeat = function () {
	                this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (e.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0))
	            }, d.prototype._tick = function () {
	                if (this.isPaused || this.isFinished)return !1;
	                var a = g, b = null, c = Math.min(this.max, this.index + a);
	                if (this.index >= this.max)return this.end();
	                switch (this.type) {
	                    case"string":
	                        b = this.data.substring(this.index, c);
	                        break;
	                    case"uint8array":
	                        b = this.data.subarray(this.index, c);
	                        break;
	                    case"array":
	                    case"nodebuffer":
	                        b = this.data.slice(this.index, c)
	                }
	                return this.index = c, this.push({data: b, meta: {percent: this.max ? this.index / this.max * 100 : 0}})
	            }, b.exports = d
	        }, {"../utils": 29, "./GenericWorker": 25}],
	        25: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
	                    data: [],
	                    end: [],
	                    error: []
	                }, this.previous = null
	            }
	
	            d.prototype = {
	                push: function (a) {
	                    this.emit("data", a)
	                }, end: function () {
	                    if (this.isFinished)return !1;
	                    this.flush();
	                    try {
	                        this.emit("end"), this.cleanUp(), this.isFinished = !0
	                    } catch (a) {
	                        this.emit("error", a)
	                    }
	                    return !0
	                }, error: function (a) {
	                    return this.isFinished ? !1 : (this.isPaused ? this.generatedError = a : (this.isFinished = !0, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), !0)
	                }, on: function (a, b) {
	                    return this._listeners[a].push(b), this
	                }, cleanUp: function () {
	                    this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = []
	                }, emit: function (a, b) {
	                    if (this._listeners[a])for (var c = 0; c < this._listeners[a].length; c++)this._listeners[a][c].call(this, b)
	                }, pipe: function (a) {
	                    return a.registerPrevious(this)
	                }, registerPrevious: function (a) {
	                    if (this.isLocked)throw new Error("The stream '" + this + "' has already been used.");
	                    this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
	                    var b = this;
	                    return a.on("data", function (a) {
	                        b.processChunk(a)
	                    }), a.on("end", function () {
	                        b.end()
	                    }), a.on("error", function (a) {
	                        b.error(a)
	                    }), this
	                }, pause: function () {
	                    return this.isPaused || this.isFinished ? !1 : (this.isPaused = !0, this.previous && this.previous.pause(), !0)
	                }, resume: function () {
	                    if (!this.isPaused || this.isFinished)return !1;
	                    this.isPaused = !1;
	                    var a = !1;
	                    return this.generatedError && (this.error(this.generatedError), a = !0), this.previous && this.previous.resume(), !a
	                }, flush: function () {
	                }, processChunk: function (a) {
	                    this.push(a)
	                }, withStreamInfo: function (a, b) {
	                    return this.extraStreamInfo[a] = b, this.mergeStreamInfo(), this
	                }, mergeStreamInfo: function () {
	                    for (var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a) && (this.streamInfo[a] = this.extraStreamInfo[a])
	                }, lock: function () {
	                    if (this.isLocked)throw new Error("The stream '" + this + "' has already been used.");
	                    this.isLocked = !0, this.previous && this.previous.lock()
	                }, toString: function () {
	                    var a = "Worker " + this.name;
	                    return this.previous ? this.previous + " -> " + a : a
	                }
	            }, b.exports = d
	        }, {}],
	        26: [function (a, b, c) {
	            (function (c) {
	                "use strict";
	                function d(a, b, c) {
	                    switch (a) {
	                        case"blob":
	                            return h.newBlob(h.transformTo("arraybuffer", b), c);
	                        case"base64":
	                            return k.encode(b);
	                        default:
	                            return h.transformTo(a, b)
	                    }
	                }
	
	                function e(a, b) {
	                    var d, e = 0, f = null, g = 0;
	                    for (d = 0; d < b.length; d++)g += b[d].length;
	                    switch (a) {
	                        case"string":
	                            return b.join("");
	                        case"array":
	                            return Array.prototype.concat.apply([], b);
	                        case"uint8array":
	                            for (f = new Uint8Array(g), d = 0; d < b.length; d++)f.set(b[d], e), e += b[d].length;
	                            return f;
	                        case"nodebuffer":
	                            return c.concat(b);
	                        default:
	                            throw new Error("concat : unsupported type '" + a + "'")
	                    }
	                }
	
	                function f(a, b) {
	                    return new m.Promise(function (c, f) {
	                        var g = [], h = a._internalType, i = a._outputType, j = a._mimeType;
	                        a.on("data", function (a, c) {
	                            g.push(a), b && b(c)
	                        }).on("error", function (a) {
	                            g = [], f(a)
	                        }).on("end", function () {
	                            try {
	                                var a = d(i, e(h, g), j);
	                                c(a)
	                            } catch (b) {
	                                f(b)
	                            }
	                            g = []
	                        }).resume()
	                    })
	                }
	
	                function g(a, b, c) {
	                    var d = b;
	                    switch (b) {
	                        case"blob":
	                        case"arraybuffer":
	                            d = "uint8array";
	                            break;
	                        case"base64":
	                            d = "string"
	                    }
	                    try {
	                        this._internalType = d, this._outputType = b, this._mimeType = c, h.checkSupport(d), this._worker = a.pipe(new i(d)), a.lock()
	                    } catch (e) {
	                        this._worker = new j("error"), this._worker.error(e)
	                    }
	                }
	
	                var h = a("../utils"), i = a("./ConvertWorker"), j = a("./GenericWorker"), k = a("../base64"), l = a("../nodejs/NodejsStreamOutputAdapter"), m = a("../external");
	                g.prototype = {
	                    accumulate: function (a) {
	                        return f(this, a)
	                    }, on: function (a, b) {
	                        var c = this;
	                        return "data" === a ? this._worker.on(a, function (a) {
	                            b.call(c, a.data, a.meta)
	                        }) : this._worker.on(a, function () {
	                            h.delay(b, arguments, c)
	                        }), this
	                    }, resume: function () {
	                        return h.delay(this._worker.resume, [], this._worker), this
	                    }, pause: function () {
	                        return this._worker.pause(), this
	                    }, toNodejsStream: function (a) {
	                        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)throw new Error(this._outputType + " is not supported by this method");
	                        return new l(this, {objectMode: "nodebuffer" !== this._outputType}, a)
	                    }
	                }, b.exports = g
	            }).call(this, "undefined" != typeof Buffer ? Buffer : void 0)
	        }, {
	            "../base64": 1,
	            "../external": 6,
	            "../nodejs/NodejsStreamOutputAdapter": 35,
	            "../utils": 29,
	            "./ConvertWorker": 21,
	            "./GenericWorker": 25
	        }],
	        27: [function (a, b, c) {
	            (function (b) {
	                "use strict";
	                if (c.base64 = !0, c.array = !0, c.string = !0, c.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, c.nodebuffer = "undefined" != typeof b, c.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)c.blob = !1; else {
	                    var d = new ArrayBuffer(0);
	                    try {
	                        c.blob = 0 === new Blob([d], {type: "application/zip"}).size
	                    } catch (e) {
	                        try {
	                            var f = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, g = new f;
	                            g.append(d), c.blob = 0 === g.getBlob("application/zip").size
	                        } catch (e) {
	                            c.blob = !1
	                        }
	                    }
	                }
	                c.nodestream = !!a("./nodejs/NodejsStreamOutputAdapter").prototype
	            }).call(this, "undefined" != typeof Buffer ? Buffer : void 0)
	        }, {"./nodejs/NodejsStreamOutputAdapter": 35}],
	        28: [function (a, b, c) {
	            "use strict";
	            function d() {
	                i.call(this, "utf-8 decode"), this.leftOver = null
	            }
	
	            function e() {
	                i.call(this, "utf-8 encode")
	            }
	
	            for (var f = a("./utils"), g = a("./support"), h = a("./nodejsUtils"), i = a("./stream/GenericWorker"), j = new Array(256), k = 0; 256 > k; k++)j[k] = k >= 252 ? 6 : k >= 248 ? 5 : k >= 240 ? 4 : k >= 224 ? 3 : k >= 192 ? 2 : 1;
	            j[254] = j[254] = 1;
	            var l = function (a) {
	                var b, c, d, e, f, h = a.length, i = 0;
	                for (e = 0; h > e; e++)c = a.charCodeAt(e), 55296 === (64512 & c) && h > e + 1 && (d = a.charCodeAt(e + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), e++)), i += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
	                for (b = g.uint8array ? new Uint8Array(i) : new Array(i), f = 0, e = 0; i > f; e++)c = a.charCodeAt(e), 55296 === (64512 & c) && h > e + 1 && (d = a.charCodeAt(e + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), e++)), 128 > c ? b[f++] = c : 2048 > c ? (b[f++] = 192 | c >>> 6, b[f++] = 128 | 63 & c) : 65536 > c ? (b[f++] = 224 | c >>> 12, b[f++] = 128 | c >>> 6 & 63, b[f++] = 128 | 63 & c) : (b[f++] = 240 | c >>> 18, b[f++] = 128 | c >>> 12 & 63, b[f++] = 128 | c >>> 6 & 63, b[f++] = 128 | 63 & c);
	                return b
	            }, m = function (a, b) {
	                var c;
	                for (b = b || a.length, b > a.length && (b = a.length), c = b - 1; c >= 0 && 128 === (192 & a[c]);)c--;
	                return 0 > c ? b : 0 === c ? b : c + j[a[c]] > b ? c : b
	            }, n = function (a) {
	                var b, c, d, e, g = a.length, h = new Array(2 * g);
	                for (c = 0, b = 0; g > b;)if (d = a[b++], 128 > d)h[c++] = d; else if (e = j[d], e > 4)h[c++] = 65533, b += e - 1; else {
	                    for (d &= 2 === e ? 31 : 3 === e ? 15 : 7; e > 1 && g > b;)d = d << 6 | 63 & a[b++], e--;
	                    e > 1 ? h[c++] = 65533 : 65536 > d ? h[c++] = d : (d -= 65536, h[c++] = 55296 | d >> 10 & 1023, h[c++] = 56320 | 1023 & d)
	                }
	                return h.length !== c && (h.subarray ? h = h.subarray(0, c) : h.length = c), f.applyFromCharCode(h)
	            };
	            c.utf8encode = function (a) {
	                return g.nodebuffer ? h.newBuffer(a, "utf-8") : l(a)
	            }, c.utf8decode = function (a) {
	                return g.nodebuffer ? f.transformTo("nodebuffer", a).toString("utf-8") : (a = f.transformTo(g.uint8array ? "uint8array" : "array", a), n(a))
	            }, f.inherits(d, i), d.prototype.processChunk = function (a) {
	                var b = f.transformTo(g.uint8array ? "uint8array" : "array", a.data);
	                if (this.leftOver && this.leftOver.length) {
	                    if (g.uint8array) {
	                        var d = b;
	                        b = new Uint8Array(d.length + this.leftOver.length), b.set(this.leftOver, 0), b.set(d, this.leftOver.length)
	                    } else b = this.leftOver.concat(b);
	                    this.leftOver = null
	                }
	                var e = m(b), h = b;
	                e !== b.length && (g.uint8array ? (h = b.subarray(0, e), this.leftOver = b.subarray(e, b.length)) : (h = b.slice(0, e), this.leftOver = b.slice(e, b.length))), this.push({
	                    data: c.utf8decode(h),
	                    meta: a.meta
	                })
	            }, d.prototype.flush = function () {
	                this.leftOver && this.leftOver.length && (this.push({
	                    data: c.utf8decode(this.leftOver),
	                    meta: {}
	                }), this.leftOver = null)
	            }, c.Utf8DecodeWorker = d, f.inherits(e, i), e.prototype.processChunk = function (a) {
	                this.push({data: c.utf8encode(a.data), meta: a.meta})
	            }, c.Utf8EncodeWorker = e
	        }, {"./nodejsUtils": 12, "./stream/GenericWorker": 25, "./support": 27, "./utils": 29}],
	        29: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                var b = null;
	                return b = i.uint8array ? new Uint8Array(a.length) : new Array(a.length), f(a, b)
	            }
	
	            function e(a) {
	                return a
	            }
	
	            function f(a, b) {
	                for (var c = 0; c < a.length; ++c)b[c] = 255 & a.charCodeAt(c);
	                return b
	            }
	
	            function g(a) {
	                var b = 65536, d = c.getTypeOf(a), e = !0;
	                if ("uint8array" === d ? e = n.applyCanBeUsed.uint8array : "nodebuffer" === d && (e = n.applyCanBeUsed.nodebuffer), e)for (; b > 1;)try {
	                    return n.stringifyByChunk(a, d, b)
	                } catch (f) {
	                    b = Math.floor(b / 2)
	                }
	                return n.stringifyByChar(a)
	            }
	
	            function h(a, b) {
	                for (var c = 0; c < a.length; c++)b[c] = a[c];
	                return b
	            }
	
	            var i = a("./support"), j = a("./base64"), k = a("./nodejsUtils"), l = a("asap"), m = a("./external");
	            c.newBlob = function (a, b) {
	                c.checkSupport("blob");
	                try {
	                    return new Blob([a], {type: b})
	                } catch (d) {
	                    try {
	                        var e = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, f = new e;
	                        return f.append(a), f.getBlob(b)
	                    } catch (d) {
	                        throw new Error("Bug : can't construct the Blob.")
	                    }
	                }
	            };
	            var n = {
	                stringifyByChunk: function (a, b, c) {
	                    var d = [], e = 0, f = a.length;
	                    if (c >= f)return String.fromCharCode.apply(null, a);
	                    for (; f > e;)"array" === b || "nodebuffer" === b ? d.push(String.fromCharCode.apply(null, a.slice(e, Math.min(e + c, f)))) : d.push(String.fromCharCode.apply(null, a.subarray(e, Math.min(e + c, f)))), e += c;
	                    return d.join("")
	                }, stringifyByChar: function (a) {
	                    for (var b = "", c = 0; c < a.length; c++)b += String.fromCharCode(a[c]);
	                    return b
	                }, applyCanBeUsed: {
	                    uint8array: function () {
	                        try {
	                            return i.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length
	                        } catch (a) {
	                            return !1
	                        }
	                    }(), nodebuffer: function () {
	                        try {
	                            return i.nodebuffer && 1 === String.fromCharCode.apply(null, k.newBuffer(1)).length
	                        } catch (a) {
	                            return !1
	                        }
	                    }()
	                }
	            };
	            c.applyFromCharCode = g;
	            var o = {};
	            o.string = {
	                string: e, array: function (a) {
	                    return f(a, new Array(a.length))
	                }, arraybuffer: function (a) {
	                    return o.string.uint8array(a).buffer
	                }, uint8array: function (a) {
	                    return f(a, new Uint8Array(a.length))
	                }, nodebuffer: function (a) {
	                    return f(a, k.newBuffer(a.length))
	                }
	            }, o.array = {
	                string: g, array: e, arraybuffer: function (a) {
	                    return new Uint8Array(a).buffer
	                }, uint8array: function (a) {
	                    return new Uint8Array(a)
	                }, nodebuffer: function (a) {
	                    return k.newBuffer(a)
	                }
	            }, o.arraybuffer = {
	                string: function (a) {
	                    return g(new Uint8Array(a));
	                }, array: function (a) {
	                    return h(new Uint8Array(a), new Array(a.byteLength))
	                }, arraybuffer: e, uint8array: function (a) {
	                    return new Uint8Array(a)
	                }, nodebuffer: function (a) {
	                    return k.newBuffer(new Uint8Array(a))
	                }
	            }, o.uint8array = {
	                string: g, array: function (a) {
	                    return h(a, new Array(a.length))
	                }, arraybuffer: function (a) {
	                    return a.buffer
	                }, uint8array: e, nodebuffer: function (a) {
	                    return k.newBuffer(a)
	                }
	            }, o.nodebuffer = {
	                string: g, array: function (a) {
	                    return h(a, new Array(a.length))
	                }, arraybuffer: function (a) {
	                    return o.nodebuffer.uint8array(a).buffer
	                }, uint8array: function (a) {
	                    return h(a, new Uint8Array(a.length))
	                }, nodebuffer: e
	            }, c.transformTo = function (a, b) {
	                if (b || (b = ""), !a)return b;
	                c.checkSupport(a);
	                var d = c.getTypeOf(b), e = o[d][a](b);
	                return e
	            }, c.getTypeOf = function (a) {
	                return "string" == typeof a ? "string" : "[object Array]" === Object.prototype.toString.call(a) ? "array" : i.nodebuffer && k.isBuffer(a) ? "nodebuffer" : i.uint8array && a instanceof Uint8Array ? "uint8array" : i.arraybuffer && a instanceof ArrayBuffer ? "arraybuffer" : void 0
	            }, c.checkSupport = function (a) {
	                var b = i[a.toLowerCase()];
	                if (!b)throw new Error(a + " is not supported by this platform")
	            }, c.MAX_VALUE_16BITS = 65535, c.MAX_VALUE_32BITS = -1, c.pretty = function (a) {
	                var b, c, d = "";
	                for (c = 0; c < (a || "").length; c++)b = a.charCodeAt(c), d += "\\x" + (16 > b ? "0" : "") + b.toString(16).toUpperCase();
	                return d
	            }, c.delay = function (a, b, c) {
	                l(function () {
	                    a.apply(c || null, b || [])
	                })
	            }, c.inherits = function (a, b) {
	                var c = function () {
	                };
	                c.prototype = b.prototype, a.prototype = new c
	            }, c.extend = function () {
	                var a, b, c = {};
	                for (a = 0; a < arguments.length; a++)for (b in arguments[a])arguments[a].hasOwnProperty(b) && "undefined" == typeof c[b] && (c[b] = arguments[a][b]);
	                return c
	            }, c.prepareContent = function (a, b, e, f, g) {
	                var h = null;
	                return h = i.blob && b instanceof Blob && "undefined" != typeof FileReader ? new m.Promise(function (a, c) {
	                    var d = new FileReader;
	                    d.onload = function (b) {
	                        a(b.target.result)
	                    }, d.onerror = function (a) {
	                        c(a.target.error)
	                    }, d.readAsArrayBuffer(b)
	                }) : m.Promise.resolve(b), h.then(function (b) {
	                    var h = c.getTypeOf(b);
	                    return h ? ("arraybuffer" === h ? b = c.transformTo("uint8array", b) : "string" === h && (g ? b = j.decode(b) : e && f !== !0 && (b = d(b))), b) : m.Promise.reject(new Error("The data of '" + a + "' is in an unsupported format !"))
	                })
	            }
	        }, {"./base64": 1, "./external": 6, "./nodejsUtils": 12, "./support": 27, asap: 33}],
	        30: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                this.files = [], this.loadOptions = a
	            }
	
	            var e = a("./reader/readerFor"), f = a("./utils"), g = a("./signature"), h = a("./zipEntry"), i = (a("./utf8"), a("./support"));
	            d.prototype = {
	                checkSignature: function (a) {
	                    if (!this.reader.readAndCheckSignature(a)) {
	                        this.reader.index -= 4;
	                        var b = this.reader.readString(4);
	                        throw new Error("Corrupted zip or bug : unexpected signature (" + f.pretty(b) + ", expected " + f.pretty(a) + ")")
	                    }
	                }, isSignature: function (a, b) {
	                    var c = this.reader.index;
	                    this.reader.setIndex(a);
	                    var d = this.reader.readString(4), e = d === b;
	                    return this.reader.setIndex(c), e
	                }, readBlockEndOfCentral: function () {
	                    this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
	                    var a = this.reader.readData(this.zipCommentLength), b = i.uint8array ? "uint8array" : "array", c = f.transformTo(b, a);
	                    this.zipComment = this.loadOptions.decodeFileName(c)
	                }, readBlockZip64EndOfCentral: function () {
	                    this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
	                    for (var a, b, c, d = this.zip64EndOfCentralSize - 44, e = 0; d > e;)a = this.reader.readInt(2), b = this.reader.readInt(4), c = this.reader.readData(b), this.zip64ExtensibleData[a] = {
	                        id: a,
	                        length: b,
	                        value: c
	                    }
	                }, readBlockZip64EndOfCentralLocator: function () {
	                    if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1)throw new Error("Multi-volumes zip are not supported")
	                }, readLocalFiles: function () {
	                    var a, b;
	                    for (a = 0; a < this.files.length; a++)b = this.files[a], this.reader.setIndex(b.localHeaderOffset), this.checkSignature(g.LOCAL_FILE_HEADER), b.readLocalPart(this.reader), b.handleUTF8(), b.processAttributes()
	                }, readCentralDir: function () {
	                    var a;
	                    for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a = new h({zip64: this.zip64}, this.loadOptions), a.readCentralPart(this.reader), this.files.push(a);
	                    if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length)
	                }, readEndOfCentral: function () {
	                    var a = this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);
	                    if (0 > a) {
	                        var b = !this.isSignature(0, g.LOCAL_FILE_HEADER);
	                        throw b ? new Error("Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip : can't find end of central directory")
	                    }
	                    this.reader.setIndex(a);
	                    var c = a;
	                    if (this.checkSignature(g.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === f.MAX_VALUE_16BITS || this.diskWithCentralDirStart === f.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === f.MAX_VALUE_16BITS || this.centralDirRecords === f.MAX_VALUE_16BITS || this.centralDirSize === f.MAX_VALUE_32BITS || this.centralDirOffset === f.MAX_VALUE_32BITS) {
	                        if (this.zip64 = !0, a = this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR), 0 > a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
	                        if (this.reader.setIndex(a), this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, g.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
	                        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral()
	                    }
	                    var d = this.centralDirOffset + this.centralDirSize;
	                    this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
	                    var e = c - d;
	                    if (e > 0)this.isSignature(c, g.CENTRAL_FILE_HEADER) || (this.reader.zero = e); else if (0 > e)throw new Error("Corrupted zip: missing " + Math.abs(e) + " bytes.")
	                }, prepareReader: function (a) {
	                    this.reader = e(a)
	                }, load: function (a) {
	                    this.prepareReader(a), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles()
	                }
	            }, b.exports = d
	        }, {
	            "./reader/readerFor": 19,
	            "./signature": 20,
	            "./support": 27,
	            "./utf8": 28,
	            "./utils": 29,
	            "./zipEntry": 31
	        }],
	        31: [function (a, b, c) {
	            "use strict";
	            function d(a, b) {
	                this.options = a, this.loadOptions = b
	            }
	
	            var e = a("./reader/readerFor"), f = a("./utils"), g = a("./compressedObject"), h = a("./crc32"), i = a("./utf8"), j = a("./compressions"), k = a("./support"), l = 0, m = 3, n = function (a) {
	                for (var b in j)if (j.hasOwnProperty(b) && j[b].magic === a)return j[b];
	                return null
	            };
	            d.prototype = {
	                isEncrypted: function () {
	                    return 1 === (1 & this.bitFlag)
	                }, useUTF8: function () {
	                    return 2048 === (2048 & this.bitFlag)
	                }, readLocalPart: function (a) {
	                    var b, c;
	                    if (a.skip(22), this.fileNameLength = a.readInt(2), c = a.readInt(2), this.fileName = a.readData(this.fileNameLength), a.skip(c), -1 === this.compressedSize || -1 === this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");
	                    if (b = n(this.compressionMethod), null === b)throw new Error("Corrupted zip : compression " + f.pretty(this.compressionMethod) + " unknown (inner file : " + f.transformTo("string", this.fileName) + ")");
	                    this.decompressed = new g(this.compressedSize, this.uncompressedSize, this.crc32, b, a.readData(this.compressedSize))
	                }, readCentralPart: function (a) {
	                    this.versionMadeBy = a.readInt(2), a.skip(2), this.bitFlag = a.readInt(2), this.compressionMethod = a.readString(2), this.date = a.readDate(), this.crc32 = a.readInt(4), this.compressedSize = a.readInt(4), this.uncompressedSize = a.readInt(4);
	                    var b = a.readInt(2);
	                    if (this.extraFieldsLength = a.readInt(2), this.fileCommentLength = a.readInt(2), this.diskNumberStart = a.readInt(2), this.internalFileAttributes = a.readInt(2), this.externalFileAttributes = a.readInt(4), this.localHeaderOffset = a.readInt(4), this.isEncrypted())throw new Error("Encrypted zip are not supported");
	                    a.skip(b), this.readExtraFields(a), this.parseZIP64ExtraField(a), this.fileComment = a.readData(this.fileCommentLength)
	                }, processAttributes: function () {
	                    this.unixPermissions = null, this.dosPermissions = null;
	                    var a = this.versionMadeBy >> 8;
	                    this.dir = !!(16 & this.externalFileAttributes), a === l && (this.dosPermissions = 63 & this.externalFileAttributes), a === m && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0)
	                }, parseZIP64ExtraField: function (a) {
	                    if (this.extraFields[1]) {
	                        var b = e(this.extraFields[1].value);
	                        this.uncompressedSize === f.MAX_VALUE_32BITS && (this.uncompressedSize = b.readInt(8)), this.compressedSize === f.MAX_VALUE_32BITS && (this.compressedSize = b.readInt(8)), this.localHeaderOffset === f.MAX_VALUE_32BITS && (this.localHeaderOffset = b.readInt(8)), this.diskNumberStart === f.MAX_VALUE_32BITS && (this.diskNumberStart = b.readInt(4))
	                    }
	                }, readExtraFields: function (a) {
	                    var b, c, d, e = a.index + this.extraFieldsLength;
	                    for (this.extraFields || (this.extraFields = {}); a.index < e;)b = a.readInt(2), c = a.readInt(2), d = a.readData(c), this.extraFields[b] = {
	                        id: b,
	                        length: c,
	                        value: d
	                    }
	                }, handleUTF8: function () {
	                    var a = k.uint8array ? "uint8array" : "array";
	                    if (this.useUTF8())this.fileNameStr = i.utf8decode(this.fileName), this.fileCommentStr = i.utf8decode(this.fileComment); else {
	                        var b = this.findExtraFieldUnicodePath();
	                        if (null !== b)this.fileNameStr = b; else {
	                            var c = f.transformTo(a, this.fileName);
	                            this.fileNameStr = this.loadOptions.decodeFileName(c)
	                        }
	                        var d = this.findExtraFieldUnicodeComment();
	                        if (null !== d)this.fileCommentStr = d; else {
	                            var e = f.transformTo(a, this.fileComment);
	                            this.fileCommentStr = this.loadOptions.decodeFileName(e)
	                        }
	                    }
	                }, findExtraFieldUnicodePath: function () {
	                    var a = this.extraFields[28789];
	                    if (a) {
	                        var b = e(a.value);
	                        return 1 !== b.readInt(1) ? null : h(this.fileName) !== b.readInt(4) ? null : i.utf8decode(b.readData(a.length - 5))
	                    }
	                    return null
	                }, findExtraFieldUnicodeComment: function () {
	                    var a = this.extraFields[25461];
	                    if (a) {
	                        var b = e(a.value);
	                        return 1 !== b.readInt(1) ? null : h(this.fileComment) !== b.readInt(4) ? null : i.utf8decode(b.readData(a.length - 5))
	                    }
	                    return null
	                }
	            }, b.exports = d
	        }, {
	            "./compressedObject": 2,
	            "./compressions": 3,
	            "./crc32": 4,
	            "./reader/readerFor": 19,
	            "./support": 27,
	            "./utf8": 28,
	            "./utils": 29
	        }],
	        32: [function (a, b, c) {
	            "use strict";
	            var d = a("./stream/StreamHelper"), e = a("./stream/DataWorker"), f = a("./utf8"), g = a("./compressedObject"), h = a("./stream/GenericWorker"), i = function (a, b, c) {
	                this.name = a, this.dir = c.dir, this.date = c.date, this.comment = c.comment, this.unixPermissions = c.unixPermissions, this.dosPermissions = c.dosPermissions, this._data = b, this._dataBinary = c.binary, this.options = {
	                    compression: c.compression,
	                    compressionOptions: c.compressionOptions
	                }
	            };
	            i.prototype = {
	                internalStream: function (a) {
	                    var b = a.toLowerCase(), c = "string" === b || "text" === b;
	                    "binarystring" !== b && "text" !== b || (b = "string");
	                    var e = this._decompressWorker(), g = !this._dataBinary;
	                    return g && !c && (e = e.pipe(new f.Utf8EncodeWorker)), !g && c && (e = e.pipe(new f.Utf8DecodeWorker)), new d(e, b, "")
	                }, async: function (a, b) {
	                    return this.internalStream(a).accumulate(b)
	                }, nodeStream: function (a, b) {
	                    return this.internalStream(a || "nodebuffer").toNodejsStream(b)
	                }, _compressWorker: function (a, b) {
	                    if (this._data instanceof g && this._data.compression.magic === a.magic)return this._data.getCompressedWorker();
	                    var c = this._decompressWorker();
	                    return this._dataBinary || (c = c.pipe(new f.Utf8EncodeWorker)), g.createWorkerFrom(c, a, b)
	                }, _decompressWorker: function () {
	                    return this._data instanceof g ? this._data.getContentWorker() : this._data instanceof h ? this._data : new e(this._data)
	                }
	            };
	            for (var j = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], k = function () {
	                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
	            }, l = 0; l < j.length; l++)i.prototype[j[l]] = k;
	            b.exports = i
	        }, {
	            "./compressedObject": 2,
	            "./stream/DataWorker": 24,
	            "./stream/GenericWorker": 25,
	            "./stream/StreamHelper": 26,
	            "./utf8": 28
	        }],
	        33: [function (a, b, c) {
	            "use strict";
	            function d() {
	                if (i.length)throw i.shift()
	            }
	
	            function e(a) {
	                var b;
	                b = h.length ? h.pop() : new f, b.task = a, g(b)
	            }
	
	            function f() {
	                this.task = null
	            }
	
	            var g = a("./raw"), h = [], i = [], j = g.makeRequestCallFromTimer(d);
	            b.exports = e, f.prototype.call = function () {
	                try {
	                    this.task.call()
	                } catch (a) {
	                    e.onerror ? e.onerror(a) : (i.push(a), j())
	                } finally {
	                    this.task = null, h[h.length] = this
	                }
	            }
	        }, {"./raw": 34}],
	        34: [function (a, b, c) {
	            (function (a) {
	                "use strict";
	                function c(a) {
	                    h.length || (g(), i = !0), h[h.length] = a
	                }
	
	                function d() {
	                    for (; j < h.length;) {
	                        var a = j;
	                        if (j += 1, h[a].call(), j > k) {
	                            for (var b = 0, c = h.length - j; c > b; b++)h[b] = h[b + j];
	                            h.length -= j, j = 0
	                        }
	                    }
	                    h.length = 0, j = 0, i = !1
	                }
	
	                function e(a) {
	                    var b = 1, c = new l(a), d = document.createTextNode("");
	                    return c.observe(d, {characterData: !0}), function () {
	                        b = -b, d.data = b
	                    }
	                }
	
	                function f(a) {
	                    return function () {
	                        function b() {
	                            clearTimeout(c), clearInterval(d), a()
	                        }
	
	                        var c = setTimeout(b, 0), d = setInterval(b, 50)
	                    }
	                }
	
	                b.exports = c;
	                var g, h = [], i = !1, j = 0, k = 1024, l = a.MutationObserver || a.WebKitMutationObserver;
	                g = "function" == typeof l ? e(d) : f(d), c.requestFlush = g, c.makeRequestCallFromTimer = f
	            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
	        }, {}],
	        35: [function (a, b, c) {
	        }, {}],
	        36: [function (a, b, c) {
	            function d() {
	                k = !1, h.length ? j = h.concat(j) : l = -1, j.length && e()
	            }
	
	            function e() {
	                if (!k) {
	                    var a = setTimeout(d);
	                    k = !0;
	                    for (var b = j.length; b;) {
	                        for (h = j, j = []; ++l < b;)h && h[l].run();
	                        l = -1, b = j.length
	                    }
	                    h = null, k = !1, clearTimeout(a)
	                }
	            }
	
	            function f(a, b) {
	                this.fun = a, this.array = b
	            }
	
	            function g() {
	            }
	
	            var h, i = b.exports = {}, j = [], k = !1, l = -1;
	            i.nextTick = function (a) {
	                var b = new Array(arguments.length - 1);
	                if (arguments.length > 1)for (var c = 1; c < arguments.length; c++)b[c - 1] = arguments[c];
	                j.push(new f(a, b)), 1 !== j.length || k || setTimeout(e, 0)
	            }, f.prototype.run = function () {
	                this.fun.apply(null, this.array)
	            }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.binding = function (a) {
	                throw new Error("process.binding is not supported")
	            }, i.cwd = function () {
	                return "/"
	            }, i.chdir = function (a) {
	                throw new Error("process.chdir is not supported")
	            }, i.umask = function () {
	                return 0
	            }
	        }, {}],
	        37: [function (b, c, d) {
	            (function (d, e) {
	                (function () {
	                    "use strict";
	                    function f(a) {
	                        return "function" == typeof a || "object" == typeof a && null !== a
	                    }
	
	                    function g(a) {
	                        return "function" == typeof a
	                    }
	
	                    function h(a) {
	                        return "object" == typeof a && null !== a
	                    }
	
	                    function i(a) {
	                        U = a
	                    }
	
	                    function j(a) {
	                        Y = a
	                    }
	
	                    function k() {
	                        return function () {
	                            d.nextTick(p)
	                        }
	                    }
	
	                    function l() {
	                        return function () {
	                            T(p)
	                        }
	                    }
	
	                    function m() {
	                        var a = 0, b = new _(p), c = document.createTextNode("");
	                        return b.observe(c, {characterData: !0}), function () {
	                            c.data = a = ++a % 2
	                        }
	                    }
	
	                    function n() {
	                        var a = new MessageChannel;
	                        return a.port1.onmessage = p, function () {
	                            a.port2.postMessage(0)
	                        }
	                    }
	
	                    function o() {
	                        return function () {
	                            setTimeout(p, 1)
	                        }
	                    }
	
	                    function p() {
	                        for (var a = 0; X > a; a += 2) {
	                            var b = ca[a], c = ca[a + 1];
	                            b(c), ca[a] = void 0, ca[a + 1] = void 0
	                        }
	                        X = 0
	                    }
	
	                    function q() {
	                        try {
	                            var a = b, c = a("vertx");
	                            return T = c.runOnLoop || c.runOnContext, l()
	                        } catch (d) {
	                            return o()
	                        }
	                    }
	
	                    function r() {
	                    }
	
	                    function s() {
	                        return new TypeError("You cannot resolve a promise with itself")
	                    }
	
	                    function t() {
	                        return new TypeError("A promises callback cannot return that CommunityBuye promise.")
	                    }
	
	                    function u(a) {
	                        try {
	                            return a.then
	                        } catch (b) {
	                            return ga.error = b, ga
	                        }
	                    }
	
	                    function v(a, b, c, d) {
	                        try {
	                            a.call(b, c, d)
	                        } catch (e) {
	                            return e
	                        }
	                    }
	
	                    function w(a, b, c) {
	                        Y(function (a) {
	                            var d = !1, e = v(c, b, function (c) {
	                                d || (d = !0, b !== c ? z(a, c) : B(a, c))
	                            }, function (b) {
	                                d || (d = !0, C(a, b))
	                            }, "Settle: " + (a._label || " unknown promise"));
	                            !d && e && (d = !0, C(a, e))
	                        }, a)
	                    }
	
	                    function x(a, b) {
	                        b._state === ea ? B(a, b._result) : b._state === fa ? C(a, b._result) : D(b, void 0, function (b) {
	                            z(a, b)
	                        }, function (b) {
	                            C(a, b)
	                        })
	                    }
	
	                    function y(a, b) {
	                        if (b.constructor === a.constructor)x(a, b); else {
	                            var c = u(b);
	                            c === ga ? C(a, ga.error) : void 0 === c ? B(a, b) : g(c) ? w(a, b, c) : B(a, b)
	                        }
	                    }
	
	                    function z(a, b) {
	                        a === b ? C(a, s()) : f(b) ? y(a, b) : B(a, b)
	                    }
	
	                    function A(a) {
	                        a._onerror && a._onerror(a._result), E(a)
	                    }
	
	                    function B(a, b) {
	                        a._state === da && (a._result = b, a._state = ea, 0 !== a._subscribers.length && Y(E, a))
	                    }
	
	                    function C(a, b) {
	                        a._state === da && (a._state = fa, a._result = b, Y(A, a))
	                    }
	
	                    function D(a, b, c, d) {
	                        var e = a._subscribers, f = e.length;
	                        a._onerror = null, e[f] = b, e[f + ea] = c, e[f + fa] = d, 0 === f && a._state && Y(E, a)
	                    }
	
	                    function E(a) {
	                        var b = a._subscribers, c = a._state;
	                        if (0 !== b.length) {
	                            for (var d, e, f = a._result, g = 0; g < b.length; g += 3)d = b[g], e = b[g + c], d ? H(c, d, e, f) : e(f);
	                            a._subscribers.length = 0
	                        }
	                    }
	
	                    function F() {
	                        this.error = null
	                    }
	
	                    function G(a, b) {
	                        try {
	                            return a(b)
	                        } catch (c) {
	                            return ha.error = c, ha
	                        }
	                    }
	
	                    function H(a, b, c, d) {
	                        var e, f, h, i, j = g(c);
	                        if (j) {
	                            if (e = G(c, d), e === ha ? (i = !0, f = e.error, e = null) : h = !0, b === e)return void C(b, t())
	                        } else e = d, h = !0;
	                        b._state !== da || (j && h ? z(b, e) : i ? C(b, f) : a === ea ? B(b, e) : a === fa && C(b, e))
	                    }
	
	                    function I(a, b) {
	                        try {
	                            b(function (b) {
	                                z(a, b)
	                            }, function (b) {
	                                C(a, b)
	                            })
	                        } catch (c) {
	                            C(a, c)
	                        }
	                    }
	
	                    function J(a, b) {
	                        var c = this;
	                        c._instanceConstructor = a, c.promise = new a(r), c._validateInput(b) ? (c._input = b, c.length = b.length, c._remaining = b.length, c._init(), 0 === c.length ? B(c.promise, c._result) : (c.length = c.length || 0, c._enumerate(), 0 === c._remaining && B(c.promise, c._result))) : C(c.promise, c._validationError())
	                    }
	
	                    function K(a) {
	                        return new ia(this, a).promise
	                    }
	
	                    function L(a) {
	                        function b(a) {
	                            z(e, a)
	                        }
	
	                        function c(a) {
	                            C(e, a)
	                        }
	
	                        var d = this, e = new d(r);
	                        if (!W(a))return C(e, new TypeError("You must pass an array to race.")), e;
	                        for (var f = a.length, g = 0; e._state === da && f > g; g++)D(d.resolve(a[g]), void 0, b, c);
	                        return e
	                    }
	
	                    function M(a) {
	                        var b = this;
	                        if (a && "object" == typeof a && a.constructor === b)return a;
	                        var c = new b(r);
	                        return z(c, a), c
	                    }
	
	                    function N(a) {
	                        var b = this, c = new b(r);
	                        return C(c, a), c
	                    }
	
	                    function O() {
	                        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
	                    }
	
	                    function P() {
	                        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
	                    }
	
	                    function Q(a) {
	                        this._id = na++, this._state = void 0, this._result = void 0, this._subscribers = [], r !== a && (g(a) || O(), this instanceof Q || P(), I(this, a))
	                    }
	
	                    function R() {
	                        var a;
	                        if ("undefined" != typeof e)a = e; else if ("undefined" != typeof self)a = self; else try {
	                            a = Function("return this")()
	                        } catch (b) {
	                            throw new Error("polyfill failed because global object is unavailable in this environment")
	                        }
	                        var c = a.Promise;
	                        c && "[object Promise]" === Object.prototype.toString.call(c.resolve()) && !c.cast || (a.Promise = oa)
	                    }
	
	                    var S;
	                    S = Array.isArray ? Array.isArray : function (a) {
	                        return "[object Array]" === Object.prototype.toString.call(a)
	                    };
	                    var T, U, V, W = S, X = 0, Y = ({}.toString, function (a, b) {
	                        ca[X] = a, ca[X + 1] = b, X += 2, 2 === X && (U ? U(p) : V())
	                    }), Z = "undefined" != typeof window ? window : void 0, $ = Z || {}, _ = $.MutationObserver || $.WebKitMutationObserver, aa = "undefined" != typeof d && "[object process]" === {}.toString.call(d), ba = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, ca = new Array(1e3);
	                    V = aa ? k() : _ ? m() : ba ? n() : void 0 === Z && "function" == typeof b ? q() : o();
	                    var da = void 0, ea = 1, fa = 2, ga = new F, ha = new F;
	                    J.prototype._validateInput = function (a) {
	                        return W(a)
	                    }, J.prototype._validationError = function () {
	                        return new Error("Array Methods must be provided an Array")
	                    }, J.prototype._init = function () {
	                        this._result = new Array(this.length)
	                    };
	                    var ia = J;
	                    J.prototype._enumerate = function () {
	                        for (var a = this, b = a.length, c = a.promise, d = a._input, e = 0; c._state === da && b > e; e++)a._eachEntry(d[e], e)
	                    }, J.prototype._eachEntry = function (a, b) {
	                        var c = this, d = c._instanceConstructor;
	                        h(a) ? a.constructor === d && a._state !== da ? (a._onerror = null, c._settledAt(a._state, b, a._result)) : c._willSettleAt(d.resolve(a), b) : (c._remaining--, c._result[b] = a)
	                    }, J.prototype._settledAt = function (a, b, c) {
	                        var d = this, e = d.promise;
	                        e._state === da && (d._remaining--, a === fa ? C(e, c) : d._result[b] = c), 0 === d._remaining && B(e, d._result)
	                    }, J.prototype._willSettleAt = function (a, b) {
	                        var c = this;
	                        D(a, void 0, function (a) {
	                            c._settledAt(ea, b, a)
	                        }, function (a) {
	                            c._settledAt(fa, b, a)
	                        })
	                    };
	                    var ja = K, ka = L, la = M, ma = N, na = 0, oa = Q;
	                    Q.all = ja, Q.race = ka, Q.resolve = la, Q.reject = ma, Q._setScheduler = i, Q._setAsap = j, Q._asap = Y, Q.prototype = {
	                        constructor: Q,
	                        then: function (a, b) {
	                            var c = this, d = c._state;
	                            if (d === ea && !a || d === fa && !b)return this;
	                            var e = new this.constructor(r), f = c._result;
	                            if (d) {
	                                var g = arguments[d - 1];
	                                Y(function () {
	                                    H(d, e, g, f)
	                                })
	                            } else D(c, e, a, b);
	                            return e
	                        },
	                        "catch": function (a) {
	                            return this.then(null, a)
	                        }
	                    };
	                    var pa = R, qa = {Promise: oa, polyfill: pa};
	                    "function" == typeof a && a.amd ? a(function () {
	                        return qa
	                    }) : "undefined" != typeof c && c.exports ? c.exports = qa : "undefined" != typeof this && (this.ES6Promise = qa), pa()
	                }).call(this)
	            }).call(this, b("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
	        }, {_process: 36}],
	        38: [function (a, b, c) {
	            "use strict";
	            var d = a("./lib/utils/common").assign, e = a("./lib/deflate"), f = a("./lib/inflate"), g = a("./lib/zlib/constants"), h = {};
	            d(h, e, f, g), b.exports = h
	        }, {"./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44}],
	        39: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                if (!(this instanceof d))return new d(a);
	                this.options = i.assign({
	                    level: s,
	                    method: u,
	                    chunkSize: 16384,
	                    windowBits: 15,
	                    memLevel: 8,
	                    strategy: t,
	                    to: ""
	                }, a || {});
	                var b = this.options;
	                b.raw && b.windowBits > 0 ? b.windowBits = -b.windowBits : b.gzip && b.windowBits > 0 && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l, this.strm.avail_out = 0;
	                var c = h.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);
	                if (c !== p)throw new Error(k[c]);
	                if (b.header && h.deflateSetHeader(this.strm, b.header), b.dictionary) {
	                    var e;
	                    if (e = "string" == typeof b.dictionary ? j.string2buf(b.dictionary) : "[object ArrayBuffer]" === m.call(b.dictionary) ? new Uint8Array(b.dictionary) : b.dictionary, c = h.deflateSetDictionary(this.strm, e), c !== p)throw new Error(k[c]);
	                    this._dict_set = !0
	                }
	            }
	
	            function e(a, b) {
	                var c = new d(b);
	                if (c.push(a, !0), c.err)throw c.msg;
	                return c.result
	            }
	
	            function f(a, b) {
	                return b = b || {}, b.raw = !0, e(a, b)
	            }
	
	            function g(a, b) {
	                return b = b || {}, b.gzip = !0, e(a, b)
	            }
	
	            var h = a("./zlib/deflate"), i = a("./utils/common"), j = a("./utils/strings"), k = a("./zlib/messages"), l = a("./zlib/zstream"), m = Object.prototype.toString, n = 0, o = 4, p = 0, q = 1, r = 2, s = -1, t = 0, u = 8;
	            d.prototype.push = function (a, b) {
	                var c, d, e = this.strm, f = this.options.chunkSize;
	                if (this.ended)return !1;
	                d = b === ~~b ? b : b === !0 ? o : n, "string" == typeof a ? e.input = j.string2buf(a) : "[object ArrayBuffer]" === m.call(a) ? e.input = new Uint8Array(a) : e.input = a, e.next_in = 0, e.avail_in = e.input.length;
	                do {
	                    if (0 === e.avail_out && (e.output = new i.Buf8(f), e.next_out = 0, e.avail_out = f), c = h.deflate(e, d), c !== q && c !== p)return this.onEnd(c), this.ended = !0, !1;
	                    0 !== e.avail_out && (0 !== e.avail_in || d !== o && d !== r) || ("string" === this.options.to ? this.onData(j.buf2binstring(i.shrinkBuf(e.output, e.next_out))) : this.onData(i.shrinkBuf(e.output, e.next_out)))
	                } while ((e.avail_in > 0 || 0 === e.avail_out) && c !== q);
	                return d === o ? (c = h.deflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === p) : d === r ? (this.onEnd(p), e.avail_out = 0, !0) : !0
	            }, d.prototype.onData = function (a) {
	                this.chunks.push(a)
	            }, d.prototype.onEnd = function (a) {
	                a === p && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg
	            }, c.Deflate = d, c.deflate = e, c.deflateRaw = f, c.gzip = g
	        }, {
	            "./utils/common": 41,
	            "./utils/strings": 42,
	            "./zlib/deflate": 46,
	            "./zlib/messages": 51,
	            "./zlib/zstream": 53
	        }],
	        40: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                if (!(this instanceof d))return new d(a);
	                this.options = h.assign({chunkSize: 16384, windowBits: 0, to: ""}, a || {});
	                var b = this.options;
	                b.raw && b.windowBits >= 0 && b.windowBits < 16 && (b.windowBits = -b.windowBits, 0 === b.windowBits && (b.windowBits = -15)), !(b.windowBits >= 0 && b.windowBits < 16) || a && a.windowBits || (b.windowBits += 32), b.windowBits > 15 && b.windowBits < 48 && 0 === (15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l, this.strm.avail_out = 0;
	                var c = g.inflateInit2(this.strm, b.windowBits);
	                if (c !== j.Z_OK)throw new Error(k[c]);
	                this.header = new m, g.inflateGetHeader(this.strm, this.header)
	            }
	
	            function e(a, b) {
	                var c = new d(b);
	                if (c.push(a, !0), c.err)throw c.msg;
	                return c.result
	            }
	
	            function f(a, b) {
	                return b = b || {}, b.raw = !0, e(a, b)
	            }
	
	            var g = a("./zlib/inflate"), h = a("./utils/common"), i = a("./utils/strings"), j = a("./zlib/constants"), k = a("./zlib/messages"), l = a("./zlib/zstream"), m = a("./zlib/gzheader"), n = Object.prototype.toString;
	            d.prototype.push = function (a, b) {
	                var c, d, e, f, k, l, m = this.strm, o = this.options.chunkSize, p = this.options.dictionary, q = !1;
	                if (this.ended)return !1;
	                d = b === ~~b ? b : b === !0 ? j.Z_FINISH : j.Z_NO_FLUSH, "string" == typeof a ? m.input = i.binstring2buf(a) : "[object ArrayBuffer]" === n.call(a) ? m.input = new Uint8Array(a) : m.input = a, m.next_in = 0, m.avail_in = m.input.length;
	                do {
	                    if (0 === m.avail_out && (m.output = new h.Buf8(o), m.next_out = 0, m.avail_out = o), c = g.inflate(m, j.Z_NO_FLUSH), c === j.Z_NEED_DICT && p && (l = "string" == typeof p ? i.string2buf(p) : "[object ArrayBuffer]" === n.call(p) ? new Uint8Array(p) : p, c = g.inflateSetDictionary(this.strm, l)), c === j.Z_BUF_ERROR && q === !0 && (c = j.Z_OK, q = !1), c !== j.Z_STREAM_END && c !== j.Z_OK)return this.onEnd(c), this.ended = !0, !1;
	                    m.next_out && (0 !== m.avail_out && c !== j.Z_STREAM_END && (0 !== m.avail_in || d !== j.Z_FINISH && d !== j.Z_SYNC_FLUSH) || ("string" === this.options.to ? (e = i.utf8border(m.output, m.next_out), f = m.next_out - e, k = i.buf2string(m.output, e), m.next_out = f, m.avail_out = o - f, f && h.arraySet(m.output, m.output, e, f, 0), this.onData(k)) : this.onData(h.shrinkBuf(m.output, m.next_out)))), 0 === m.avail_in && 0 === m.avail_out && (q = !0)
	                } while ((m.avail_in > 0 || 0 === m.avail_out) && c !== j.Z_STREAM_END);
	                return c === j.Z_STREAM_END && (d = j.Z_FINISH), d === j.Z_FINISH ? (c = g.inflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === j.Z_OK) : d === j.Z_SYNC_FLUSH ? (this.onEnd(j.Z_OK), m.avail_out = 0, !0) : !0
	            }, d.prototype.onData = function (a) {
	                this.chunks.push(a)
	            }, d.prototype.onEnd = function (a) {
	                a === j.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = h.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg
	            }, c.Inflate = d, c.inflate = e, c.inflateRaw = f, c.ungzip = e
	        }, {
	            "./utils/common": 41,
	            "./utils/strings": 42,
	            "./zlib/constants": 44,
	            "./zlib/gzheader": 47,
	            "./zlib/inflate": 49,
	            "./zlib/messages": 51,
	            "./zlib/zstream": 53
	        }],
	        41: [function (a, b, c) {
	            "use strict";
	            var d = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
	            c.assign = function (a) {
	                for (var b = Array.prototype.slice.call(arguments, 1); b.length;) {
	                    var c = b.shift();
	                    if (c) {
	                        if ("object" != typeof c)throw new TypeError(c + "must be non-object");
	                        for (var d in c)c.hasOwnProperty(d) && (a[d] = c[d])
	                    }
	                }
	                return a
	            }, c.shrinkBuf = function (a, b) {
	                return a.length === b ? a : a.subarray ? a.subarray(0, b) : (a.length = b, a)
	            };
	            var e = {
	                arraySet: function (a, b, c, d, e) {
	                    if (b.subarray && a.subarray)return void a.set(b.subarray(c, c + d), e);
	                    for (var f = 0; d > f; f++)a[e + f] = b[c + f]
	                }, flattenChunks: function (a) {
	                    var b, c, d, e, f, g;
	                    for (d = 0, b = 0, c = a.length; c > b; b++)d += a[b].length;
	                    for (g = new Uint8Array(d), e = 0, b = 0, c = a.length; c > b; b++)f = a[b], g.set(f, e), e += f.length;
	                    return g
	                }
	            }, f = {
	                arraySet: function (a, b, c, d, e) {
	                    for (var f = 0; d > f; f++)a[e + f] = b[c + f]
	                }, flattenChunks: function (a) {
	                    return [].concat.apply([], a)
	                }
	            };
	            c.setTyped = function (a) {
	                a ? (c.Buf8 = Uint8Array, c.Buf16 = Uint16Array, c.Buf32 = Int32Array, c.assign(c, e)) : (c.Buf8 = Array, c.Buf16 = Array, c.Buf32 = Array, c.assign(c, f))
	            }, c.setTyped(d)
	        }, {}],
	        42: [function (a, b, c) {
	            "use strict";
	            function d(a, b) {
	                if (65537 > b && (a.subarray && g || !a.subarray && f))return String.fromCharCode.apply(null, e.shrinkBuf(a, b));
	                for (var c = "", d = 0; b > d; d++)c += String.fromCharCode(a[d]);
	                return c
	            }
	
	            var e = a("./common"), f = !0, g = !0;
	            try {
	                String.fromCharCode.apply(null, [0])
	            } catch (h) {
	                f = !1
	            }
	            try {
	                String.fromCharCode.apply(null, new Uint8Array(1))
	            } catch (h) {
	                g = !1
	            }
	            for (var i = new e.Buf8(256), j = 0; 256 > j; j++)i[j] = j >= 252 ? 6 : j >= 248 ? 5 : j >= 240 ? 4 : j >= 224 ? 3 : j >= 192 ? 2 : 1;
	            i[254] = i[254] = 1, c.string2buf = function (a) {
	                var b, c, d, f, g, h = a.length, i = 0;
	                for (f = 0; h > f; f++)c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), i += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
	                for (b = new e.Buf8(i), g = 0, f = 0; i > g; f++)c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), 128 > c ? b[g++] = c : 2048 > c ? (b[g++] = 192 | c >>> 6, b[g++] = 128 | 63 & c) : 65536 > c ? (b[g++] = 224 | c >>> 12, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c) : (b[g++] = 240 | c >>> 18, b[g++] = 128 | c >>> 12 & 63, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c);
	                return b
	            }, c.buf2binstring = function (a) {
	                return d(a, a.length)
	            }, c.binstring2buf = function (a) {
	                for (var b = new e.Buf8(a.length), c = 0, d = b.length; d > c; c++)b[c] = a.charCodeAt(c);
	                return b
	            }, c.buf2string = function (a, b) {
	                var c, e, f, g, h = b || a.length, j = new Array(2 * h);
	                for (e = 0, c = 0; h > c;)if (f = a[c++], 128 > f)j[e++] = f; else if (g = i[f], g > 4)j[e++] = 65533, c += g - 1; else {
	                    for (f &= 2 === g ? 31 : 3 === g ? 15 : 7; g > 1 && h > c;)f = f << 6 | 63 & a[c++], g--;
	                    g > 1 ? j[e++] = 65533 : 65536 > f ? j[e++] = f : (f -= 65536, j[e++] = 55296 | f >> 10 & 1023, j[e++] = 56320 | 1023 & f)
	                }
	                return d(j, e)
	            }, c.utf8border = function (a, b) {
	                var c;
	                for (b = b || a.length, b > a.length && (b = a.length), c = b - 1; c >= 0 && 128 === (192 & a[c]);)c--;
	                return 0 > c ? b : 0 === c ? b : c + i[a[c]] > b ? c : b
	            }
	        }, {"./common": 41}],
	        43: [function (a, b, c) {
	            "use strict";
	            function d(a, b, c, d) {
	                for (var e = 65535 & a | 0, f = a >>> 16 & 65535 | 0, g = 0; 0 !== c;) {
	                    g = c > 2e3 ? 2e3 : c, c -= g;
	                    do e = e + b[d++] | 0, f = f + e | 0; while (--g);
	                    e %= 65521, f %= 65521
	                }
	                return e | f << 16 | 0
	            }
	
	            b.exports = d
	        }, {}],
	        44: [function (a, b, c) {
	            "use strict";
	            b.exports = {
	                Z_NO_FLUSH: 0,
	                Z_PARTIAL_FLUSH: 1,
	                Z_SYNC_FLUSH: 2,
	                Z_FULL_FLUSH: 3,
	                Z_FINISH: 4,
	                Z_BLOCK: 5,
	                Z_TREES: 6,
	                Z_OK: 0,
	                Z_STREAM_END: 1,
	                Z_NEED_DICT: 2,
	                Z_ERRNO: -1,
	                Z_STREAM_ERROR: -2,
	                Z_DATA_ERROR: -3,
	                Z_BUF_ERROR: -5,
	                Z_NO_COMPRESSION: 0,
	                Z_BEST_SPEED: 1,
	                Z_BEST_COMPRESSION: 9,
	                Z_DEFAULT_COMPRESSION: -1,
	                Z_FILTERED: 1,
	                Z_HUFFMAN_ONLY: 2,
	                Z_RLE: 3,
	                Z_FIXED: 4,
	                Z_DEFAULT_STRATEGY: 0,
	                Z_BINARY: 0,
	                Z_TEXT: 1,
	                Z_UNKNOWN: 2,
	                Z_DEFLATED: 8
	            }
	        }, {}],
	        45: [function (a, b, c) {
	            "use strict";
	            function d() {
	                for (var a, b = [], c = 0; 256 > c; c++) {
	                    a = c;
	                    for (var d = 0; 8 > d; d++)a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
	                    b[c] = a
	                }
	                return b
	            }
	
	            function e(a, b, c, d) {
	                var e = f, g = d + c;
	                a ^= -1;
	                for (var h = d; g > h; h++)a = a >>> 8 ^ e[255 & (a ^ b[h])];
	                return -1 ^ a
	            }
	
	            var f = d();
	            b.exports = e
	        }, {}],
	        46: [function (a, b, c) {
	            "use strict";
	            function d(a, b) {
	                return a.msg = I[b], b
	            }
	
	            function e(a) {
	                return (a << 1) - (a > 4 ? 9 : 0)
	            }
	
	            function f(a) {
	                for (var b = a.length; --b >= 0;)a[b] = 0
	            }
	
	            function g(a) {
	                var b = a.state, c = b.pending;
	                c > a.avail_out && (c = a.avail_out), 0 !== c && (E.arraySet(a.output, b.pending_buf, b.pending_out, c, a.next_out), a.next_out += c, b.pending_out += c, a.total_out += c, a.avail_out -= c, b.pending -= c, 0 === b.pending && (b.pending_out = 0))
	            }
	
	            function h(a, b) {
	                F._tr_flush_block(a, a.block_start >= 0 ? a.block_start : -1, a.strstart - a.block_start, b), a.block_start = a.strstart, g(a.strm)
	            }
	
	            function i(a, b) {
	                a.pending_buf[a.pending++] = b
	            }
	
	            function j(a, b) {
	                a.pending_buf[a.pending++] = b >>> 8 & 255, a.pending_buf[a.pending++] = 255 & b
	            }
	
	            function k(a, b, c, d) {
	                var e = a.avail_in;
	                return e > d && (e = d), 0 === e ? 0 : (a.avail_in -= e, E.arraySet(b, a.input, a.next_in, e, c), 1 === a.state.wrap ? a.adler = G(a.adler, b, e, c) : 2 === a.state.wrap && (a.adler = H(a.adler, b, e, c)), a.next_in += e, a.total_in += e, e)
	            }
	
	            function l(a, b) {
	                var c, d, e = a.max_chain_length, f = a.strstart, g = a.prev_length, h = a.nice_match, i = a.strstart > a.w_size - la ? a.strstart - (a.w_size - la) : 0, j = a.window, k = a.w_mask, l = a.prev, m = a.strstart + ka, n = j[f + g - 1], o = j[f + g];
	                a.prev_length >= a.good_match && (e >>= 2), h > a.lookahead && (h = a.lookahead);
	                do if (c = b, j[c + g] === o && j[c + g - 1] === n && j[c] === j[f] && j[++c] === j[f + 1]) {
	                    f += 2, c++;
	                    do; while (j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && m > f);
	                    if (d = ka - (m - f), f = m - ka, d > g) {
	                        if (a.match_start = b, g = d, d >= h)break;
	                        n = j[f + g - 1], o = j[f + g]
	                    }
	                } while ((b = l[b & k]) > i && 0 !== --e);
	                return g <= a.lookahead ? g : a.lookahead
	            }
	
	            function m(a) {
	                var b, c, d, e, f, g = a.w_size;
	                do {
	                    if (e = a.window_size - a.lookahead - a.strstart, a.strstart >= g + (g - la)) {
	                        E.arraySet(a.window, a.window, g, g, 0), a.match_start -= g, a.strstart -= g, a.block_start -= g, c = a.hash_size, b = c;
	                        do d = a.head[--b], a.head[b] = d >= g ? d - g : 0; while (--c);
	                        c = g, b = c;
	                        do d = a.prev[--b], a.prev[b] = d >= g ? d - g : 0; while (--c);
	                        e += g
	                    }
	                    if (0 === a.strm.avail_in)break;
	                    if (c = k(a.strm, a.window, a.strstart + a.lookahead, e), a.lookahead += c, a.lookahead + a.insert >= ja)for (f = a.strstart - a.insert, a.ins_h = a.window[f], a.ins_h = (a.ins_h << a.hash_shift ^ a.window[f + 1]) & a.hash_mask; a.insert && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[f + ja - 1]) & a.hash_mask, a.prev[f & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = f, f++, a.insert--,
	                        !(a.lookahead + a.insert < ja)););
	                } while (a.lookahead < la && 0 !== a.strm.avail_in)
	            }
	
	            function n(a, b) {
	                var c = 65535;
	                for (c > a.pending_buf_size - 5 && (c = a.pending_buf_size - 5); ;) {
	                    if (a.lookahead <= 1) {
	                        if (m(a), 0 === a.lookahead && b === J)return ua;
	                        if (0 === a.lookahead)break
	                    }
	                    a.strstart += a.lookahead, a.lookahead = 0;
	                    var d = a.block_start + c;
	                    if ((0 === a.strstart || a.strstart >= d) && (a.lookahead = a.strstart - d, a.strstart = d, h(a, !1), 0 === a.strm.avail_out))return ua;
	                    if (a.strstart - a.block_start >= a.w_size - la && (h(a, !1), 0 === a.strm.avail_out))return ua
	                }
	                return a.insert = 0, b === M ? (h(a, !0), 0 === a.strm.avail_out ? wa : xa) : a.strstart > a.block_start && (h(a, !1), 0 === a.strm.avail_out) ? ua : ua
	            }
	
	            function o(a, b) {
	                for (var c, d; ;) {
	                    if (a.lookahead < la) {
	                        if (m(a), a.lookahead < la && b === J)return ua;
	                        if (0 === a.lookahead)break
	                    }
	                    if (c = 0, a.lookahead >= ja && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + ja - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), 0 !== c && a.strstart - c <= a.w_size - la && (a.match_length = l(a, c)), a.match_length >= ja)if (d = F._tr_tally(a, a.strstart - a.match_start, a.match_length - ja), a.lookahead -= a.match_length, a.match_length <= a.max_lazy_match && a.lookahead >= ja) {
	                        a.match_length--;
	                        do a.strstart++, a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + ja - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart; while (0 !== --a.match_length);
	                        a.strstart++
	                    } else a.strstart += a.match_length, a.match_length = 0, a.ins_h = a.window[a.strstart], a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + 1]) & a.hash_mask; else d = F._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++;
	                    if (d && (h(a, !1), 0 === a.strm.avail_out))return ua
	                }
	                return a.insert = a.strstart < ja - 1 ? a.strstart : ja - 1, b === M ? (h(a, !0), 0 === a.strm.avail_out ? wa : xa) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? ua : va
	            }
	
	            function p(a, b) {
	                for (var c, d, e; ;) {
	                    if (a.lookahead < la) {
	                        if (m(a), a.lookahead < la && b === J)return ua;
	                        if (0 === a.lookahead)break
	                    }
	                    if (c = 0, a.lookahead >= ja && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + ja - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), a.prev_length = a.match_length, a.prev_match = a.match_start, a.match_length = ja - 1, 0 !== c && a.prev_length < a.max_lazy_match && a.strstart - c <= a.w_size - la && (a.match_length = l(a, c), a.match_length <= 5 && (a.strategy === U || a.match_length === ja && a.strstart - a.match_start > 4096) && (a.match_length = ja - 1)), a.prev_length >= ja && a.match_length <= a.prev_length) {
	                        e = a.strstart + a.lookahead - ja, d = F._tr_tally(a, a.strstart - 1 - a.prev_match, a.prev_length - ja), a.lookahead -= a.prev_length - 1, a.prev_length -= 2;
	                        do++a.strstart <= e && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + ja - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart); while (0 !== --a.prev_length);
	                        if (a.match_available = 0, a.match_length = ja - 1, a.strstart++, d && (h(a, !1), 0 === a.strm.avail_out))return ua
	                    } else if (a.match_available) {
	                        if (d = F._tr_tally(a, 0, a.window[a.strstart - 1]), d && h(a, !1), a.strstart++, a.lookahead--, 0 === a.strm.avail_out)return ua
	                    } else a.match_available = 1, a.strstart++, a.lookahead--
	                }
	                return a.match_available && (d = F._tr_tally(a, 0, a.window[a.strstart - 1]), a.match_available = 0), a.insert = a.strstart < ja - 1 ? a.strstart : ja - 1, b === M ? (h(a, !0), 0 === a.strm.avail_out ? wa : xa) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? ua : va
	            }
	
	            function q(a, b) {
	                for (var c, d, e, f, g = a.window; ;) {
	                    if (a.lookahead <= ka) {
	                        if (m(a), a.lookahead <= ka && b === J)return ua;
	                        if (0 === a.lookahead)break
	                    }
	                    if (a.match_length = 0, a.lookahead >= ja && a.strstart > 0 && (e = a.strstart - 1, d = g[e], d === g[++e] && d === g[++e] && d === g[++e])) {
	                        f = a.strstart + ka;
	                        do; while (d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && f > e);
	                        a.match_length = ka - (f - e), a.match_length > a.lookahead && (a.match_length = a.lookahead)
	                    }
	                    if (a.match_length >= ja ? (c = F._tr_tally(a, 1, a.match_length - ja), a.lookahead -= a.match_length, a.strstart += a.match_length, a.match_length = 0) : (c = F._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++), c && (h(a, !1), 0 === a.strm.avail_out))return ua
	                }
	                return a.insert = 0, b === M ? (h(a, !0), 0 === a.strm.avail_out ? wa : xa) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? ua : va
	            }
	
	            function r(a, b) {
	                for (var c; ;) {
	                    if (0 === a.lookahead && (m(a), 0 === a.lookahead)) {
	                        if (b === J)return ua;
	                        break
	                    }
	                    if (a.match_length = 0, c = F._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++, c && (h(a, !1), 0 === a.strm.avail_out))return ua
	                }
	                return a.insert = 0, b === M ? (h(a, !0), 0 === a.strm.avail_out ? wa : xa) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? ua : va
	            }
	
	            function s(a, b, c, d, e) {
	                this.good_length = a, this.max_lazy = b, this.nice_length = c, this.max_chain = d, this.func = e
	            }
	
	            function t(a) {
	                a.window_size = 2 * a.w_size, f(a.head), a.max_lazy_match = D[a.level].max_lazy, a.good_match = D[a.level].good_length, a.nice_match = D[a.level].nice_length, a.max_chain_length = D[a.level].max_chain, a.strstart = 0, a.block_start = 0, a.lookahead = 0, a.insert = 0, a.match_length = a.prev_length = ja - 1, a.match_available = 0, a.ins_h = 0
	            }
	
	            function u() {
	                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = $, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new E.Buf16(2 * ha), this.dyn_dtree = new E.Buf16(2 * (2 * fa + 1)), this.bl_tree = new E.Buf16(2 * (2 * ga + 1)), f(this.dyn_ltree), f(this.dyn_dtree), f(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new E.Buf16(ia + 1), this.heap = new E.Buf16(2 * ea + 1), f(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new E.Buf16(2 * ea + 1), f(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
	            }
	
	            function v(a) {
	                var b;
	                return a && a.state ? (a.total_in = a.total_out = 0, a.data_type = Z, b = a.state, b.pending = 0, b.pending_out = 0, b.wrap < 0 && (b.wrap = -b.wrap), b.status = b.wrap ? na : sa, a.adler = 2 === b.wrap ? 0 : 1, b.last_flush = J, F._tr_init(b), O) : d(a, Q)
	            }
	
	            function w(a) {
	                var b = v(a);
	                return b === O && t(a.state), b
	            }
	
	            function x(a, b) {
	                return a && a.state ? 2 !== a.state.wrap ? Q : (a.state.gzhead = b, O) : Q
	            }
	
	            function y(a, b, c, e, f, g) {
	                if (!a)return Q;
	                var h = 1;
	                if (b === T && (b = 6), 0 > e ? (h = 0, e = -e) : e > 15 && (h = 2, e -= 16), 1 > f || f > _ || c !== $ || 8 > e || e > 15 || 0 > b || b > 9 || 0 > g || g > X)return d(a, Q);
	                8 === e && (e = 9);
	                var i = new u;
	                return a.state = i, i.strm = a, i.wrap = h, i.gzhead = null, i.w_bits = e, i.w_size = 1 << i.w_bits, i.w_mask = i.w_size - 1, i.hash_bits = f + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size - 1, i.hash_shift = ~~((i.hash_bits + ja - 1) / ja), i.window = new E.Buf8(2 * i.w_size), i.head = new E.Buf16(i.hash_size), i.prev = new E.Buf16(i.w_size), i.lit_bufsize = 1 << f + 6, i.pending_buf_size = 4 * i.lit_bufsize, i.pending_buf = new E.Buf8(i.pending_buf_size), i.d_buf = i.lit_bufsize >> 1, i.l_buf = 3 * i.lit_bufsize, i.level = b, i.strategy = g, i.method = c, w(a)
	            }
	
	            function z(a, b) {
	                return y(a, b, $, aa, ba, Y)
	            }
	
	            function A(a, b) {
	                var c, h, k, l;
	                if (!a || !a.state || b > N || 0 > b)return a ? d(a, Q) : Q;
	                if (h = a.state, !a.output || !a.input && 0 !== a.avail_in || h.status === ta && b !== M)return d(a, 0 === a.avail_out ? S : Q);
	                if (h.strm = a, c = h.last_flush, h.last_flush = b, h.status === na)if (2 === h.wrap)a.adler = 0, i(h, 31), i(h, 139), i(h, 8), h.gzhead ? (i(h, (h.gzhead.text ? 1 : 0) + (h.gzhead.hcrc ? 2 : 0) + (h.gzhead.extra ? 4 : 0) + (h.gzhead.name ? 8 : 0) + (h.gzhead.comment ? 16 : 0)), i(h, 255 & h.gzhead.time), i(h, h.gzhead.time >> 8 & 255), i(h, h.gzhead.time >> 16 & 255), i(h, h.gzhead.time >> 24 & 255), i(h, 9 === h.level ? 2 : h.strategy >= V || h.level < 2 ? 4 : 0), i(h, 255 & h.gzhead.os), h.gzhead.extra && h.gzhead.extra.length && (i(h, 255 & h.gzhead.extra.length), i(h, h.gzhead.extra.length >> 8 & 255)), h.gzhead.hcrc && (a.adler = H(a.adler, h.pending_buf, h.pending, 0)), h.gzindex = 0, h.status = oa) : (i(h, 0), i(h, 0), i(h, 0), i(h, 0), i(h, 0), i(h, 9 === h.level ? 2 : h.strategy >= V || h.level < 2 ? 4 : 0), i(h, ya), h.status = sa); else {
	                    var m = $ + (h.w_bits - 8 << 4) << 8, n = -1;
	                    n = h.strategy >= V || h.level < 2 ? 0 : h.level < 6 ? 1 : 6 === h.level ? 2 : 3, m |= n << 6, 0 !== h.strstart && (m |= ma), m += 31 - m % 31, h.status = sa, j(h, m), 0 !== h.strstart && (j(h, a.adler >>> 16), j(h, 65535 & a.adler)), a.adler = 1
	                }
	                if (h.status === oa)if (h.gzhead.extra) {
	                    for (k = h.pending; h.gzindex < (65535 & h.gzhead.extra.length) && (h.pending !== h.pending_buf_size || (h.gzhead.hcrc && h.pending > k && (a.adler = H(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending !== h.pending_buf_size));)i(h, 255 & h.gzhead.extra[h.gzindex]), h.gzindex++;
	                    h.gzhead.hcrc && h.pending > k && (a.adler = H(a.adler, h.pending_buf, h.pending - k, k)), h.gzindex === h.gzhead.extra.length && (h.gzindex = 0, h.status = pa)
	                } else h.status = pa;
	                if (h.status === pa)if (h.gzhead.name) {
	                    k = h.pending;
	                    do {
	                        if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > k && (a.adler = H(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending === h.pending_buf_size)) {
	                            l = 1;
	                            break
	                        }
	                        l = h.gzindex < h.gzhead.name.length ? 255 & h.gzhead.name.charCodeAt(h.gzindex++) : 0, i(h, l)
	                    } while (0 !== l);
	                    h.gzhead.hcrc && h.pending > k && (a.adler = H(a.adler, h.pending_buf, h.pending - k, k)), 0 === l && (h.gzindex = 0, h.status = qa)
	                } else h.status = qa;
	                if (h.status === qa)if (h.gzhead.comment) {
	                    k = h.pending;
	                    do {
	                        if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > k && (a.adler = H(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending === h.pending_buf_size)) {
	                            l = 1;
	                            break
	                        }
	                        l = h.gzindex < h.gzhead.comment.length ? 255 & h.gzhead.comment.charCodeAt(h.gzindex++) : 0, i(h, l)
	                    } while (0 !== l);
	                    h.gzhead.hcrc && h.pending > k && (a.adler = H(a.adler, h.pending_buf, h.pending - k, k)), 0 === l && (h.status = ra)
	                } else h.status = ra;
	                if (h.status === ra && (h.gzhead.hcrc ? (h.pending + 2 > h.pending_buf_size && g(a), h.pending + 2 <= h.pending_buf_size && (i(h, 255 & a.adler), i(h, a.adler >> 8 & 255), a.adler = 0, h.status = sa)) : h.status = sa), 0 !== h.pending) {
	                    if (g(a), 0 === a.avail_out)return h.last_flush = -1, O
	                } else if (0 === a.avail_in && e(b) <= e(c) && b !== M)return d(a, S);
	                if (h.status === ta && 0 !== a.avail_in)return d(a, S);
	                if (0 !== a.avail_in || 0 !== h.lookahead || b !== J && h.status !== ta) {
	                    var o = h.strategy === V ? r(h, b) : h.strategy === W ? q(h, b) : D[h.level].func(h, b);
	                    if (o !== wa && o !== xa || (h.status = ta), o === ua || o === wa)return 0 === a.avail_out && (h.last_flush = -1), O;
	                    if (o === va && (b === K ? F._tr_align(h) : b !== N && (F._tr_stored_block(h, 0, 0, !1), b === L && (f(h.head), 0 === h.lookahead && (h.strstart = 0, h.block_start = 0, h.insert = 0))), g(a), 0 === a.avail_out))return h.last_flush = -1, O
	                }
	                return b !== M ? O : h.wrap <= 0 ? P : (2 === h.wrap ? (i(h, 255 & a.adler), i(h, a.adler >> 8 & 255), i(h, a.adler >> 16 & 255), i(h, a.adler >> 24 & 255), i(h, 255 & a.total_in), i(h, a.total_in >> 8 & 255), i(h, a.total_in >> 16 & 255), i(h, a.total_in >> 24 & 255)) : (j(h, a.adler >>> 16), j(h, 65535 & a.adler)), g(a), h.wrap > 0 && (h.wrap = -h.wrap), 0 !== h.pending ? O : P)
	            }
	
	            function B(a) {
	                var b;
	                return a && a.state ? (b = a.state.status, b !== na && b !== oa && b !== pa && b !== qa && b !== ra && b !== sa && b !== ta ? d(a, Q) : (a.state = null, b === sa ? d(a, R) : O)) : Q
	            }
	
	            function C(a, b) {
	                var c, d, e, g, h, i, j, k, l = b.length;
	                if (!a || !a.state)return Q;
	                if (c = a.state, g = c.wrap, 2 === g || 1 === g && c.status !== na || c.lookahead)return Q;
	                for (1 === g && (a.adler = G(a.adler, b, l, 0)), c.wrap = 0, l >= c.w_size && (0 === g && (f(c.head), c.strstart = 0, c.block_start = 0, c.insert = 0), k = new E.Buf8(c.w_size), E.arraySet(k, b, l - c.w_size, c.w_size, 0), b = k, l = c.w_size), h = a.avail_in, i = a.next_in, j = a.input, a.avail_in = l, a.next_in = 0, a.input = b, m(c); c.lookahead >= ja;) {
	                    d = c.strstart, e = c.lookahead - (ja - 1);
	                    do c.ins_h = (c.ins_h << c.hash_shift ^ c.window[d + ja - 1]) & c.hash_mask, c.prev[d & c.w_mask] = c.head[c.ins_h], c.head[c.ins_h] = d, d++; while (--e);
	                    c.strstart = d, c.lookahead = ja - 1, m(c)
	                }
	                return c.strstart += c.lookahead, c.block_start = c.strstart, c.insert = c.lookahead, c.lookahead = 0, c.match_length = c.prev_length = ja - 1, c.match_available = 0, a.next_in = i, a.input = j, a.avail_in = h, c.wrap = g, O
	            }
	
	            var D, E = a("../utils/common"), F = a("./trees"), G = a("./adler32"), H = a("./crc32"), I = a("./messages"), J = 0, K = 1, L = 3, M = 4, N = 5, O = 0, P = 1, Q = -2, R = -3, S = -5, T = -1, U = 1, V = 2, W = 3, X = 4, Y = 0, Z = 2, $ = 8, _ = 9, aa = 15, ba = 8, ca = 29, da = 256, ea = da + 1 + ca, fa = 30, ga = 19, ha = 2 * ea + 1, ia = 15, ja = 3, ka = 258, la = ka + ja + 1, ma = 32, na = 42, oa = 69, pa = 73, qa = 91, ra = 103, sa = 113, ta = 666, ua = 1, va = 2, wa = 3, xa = 4, ya = 3;
	            D = [new s(0, 0, 0, 0, n), new s(4, 4, 8, 4, o), new s(4, 5, 16, 8, o), new s(4, 6, 32, 32, o), new s(4, 4, 16, 16, p), new s(8, 16, 32, 32, p), new s(8, 16, 128, 128, p), new s(8, 32, 128, 256, p), new s(32, 128, 258, 1024, p), new s(32, 258, 258, 4096, p)], c.deflateInit = z, c.deflateInit2 = y, c.deflateReset = w, c.deflateResetKeep = v, c.deflateSetHeader = x, c.deflate = A, c.deflateEnd = B, c.deflateSetDictionary = C, c.deflateInfo = "pako deflate (from Nodeca project)"
	        }, {"../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52}],
	        47: [function (a, b, c) {
	            "use strict";
	            function d() {
	                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
	            }
	
	            b.exports = d
	        }, {}],
	        48: [function (a, b, c) {
	            "use strict";
	            var d = 30, e = 12;
	            b.exports = function (a, b) {
	                var c, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
	                c = a.state, f = a.next_in, B = a.input, g = f + (a.avail_in - 5), h = a.next_out, C = a.output, i = h - (b - a.avail_out), j = h + (a.avail_out - 257), k = c.dmax, l = c.wsize, m = c.whave, n = c.wnext, o = c.window, p = c.hold, q = c.bits, r = c.lencode, s = c.distcode, t = (1 << c.lenbits) - 1, u = (1 << c.distbits) - 1;
	                a:do {
	                    15 > q && (p += B[f++] << q, q += 8, p += B[f++] << q, q += 8), v = r[p & t];
	                    b:for (; ;) {
	                        if (w = v >>> 24, p >>>= w, q -= w, w = v >>> 16 & 255, 0 === w)C[h++] = 65535 & v; else {
	                            if (!(16 & w)) {
	                                if (0 === (64 & w)) {
	                                    v = r[(65535 & v) + (p & (1 << w) - 1)];
	                                    continue b
	                                }
	                                if (32 & w) {
	                                    c.mode = e;
	                                    break a
	                                }
	                                a.msg = "invalid literal/length code", c.mode = d;
	                                break a
	                            }
	                            x = 65535 & v, w &= 15, w && (w > q && (p += B[f++] << q, q += 8), x += p & (1 << w) - 1, p >>>= w, q -= w), 15 > q && (p += B[f++] << q, q += 8, p += B[f++] << q, q += 8), v = s[p & u];
	                            c:for (; ;) {
	                                if (w = v >>> 24, p >>>= w, q -= w, w = v >>> 16 & 255, !(16 & w)) {
	                                    if (0 === (64 & w)) {
	                                        v = s[(65535 & v) + (p & (1 << w) - 1)];
	                                        continue c
	                                    }
	                                    a.msg = "invalid distance code", c.mode = d;
	                                    break a
	                                }
	                                if (y = 65535 & v, w &= 15, w > q && (p += B[f++] << q, q += 8, w > q && (p += B[f++] << q, q += 8)), y += p & (1 << w) - 1, y > k) {
	                                    a.msg = "invalid distance too far back", c.mode = d;
	                                    break a
	                                }
	                                if (p >>>= w, q -= w, w = h - i, y > w) {
	                                    if (w = y - w, w > m && c.sane) {
	                                        a.msg = "invalid distance too far back", c.mode = d;
	                                        break a
	                                    }
	                                    if (z = 0, A = o, 0 === n) {
	                                        if (z += l - w, x > w) {
	                                            x -= w;
	                                            do C[h++] = o[z++]; while (--w);
	                                            z = h - y, A = C
	                                        }
	                                    } else if (w > n) {
	                                        if (z += l + n - w, w -= n, x > w) {
	                                            x -= w;
	                                            do C[h++] = o[z++]; while (--w);
	                                            if (z = 0, x > n) {
	                                                w = n, x -= w;
	                                                do C[h++] = o[z++]; while (--w);
	                                                z = h - y, A = C
	                                            }
	                                        }
	                                    } else if (z += n - w, x > w) {
	                                        x -= w;
	                                        do C[h++] = o[z++]; while (--w);
	                                        z = h - y, A = C
	                                    }
	                                    for (; x > 2;)C[h++] = A[z++], C[h++] = A[z++], C[h++] = A[z++], x -= 3;
	                                    x && (C[h++] = A[z++], x > 1 && (C[h++] = A[z++]))
	                                } else {
	                                    z = h - y;
	                                    do C[h++] = C[z++], C[h++] = C[z++], C[h++] = C[z++], x -= 3; while (x > 2);
	                                    x && (C[h++] = C[z++], x > 1 && (C[h++] = C[z++]))
	                                }
	                                break
	                            }
	                        }
	                        break
	                    }
	                } while (g > f && j > h);
	                x = q >> 3, f -= x, q -= x << 3, p &= (1 << q) - 1, a.next_in = f, a.next_out = h, a.avail_in = g > f ? 5 + (g - f) : 5 - (f - g), a.avail_out = j > h ? 257 + (j - h) : 257 - (h - j), c.hold = p, c.bits = q
	            }
	        }, {}],
	        49: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                return (a >>> 24 & 255) + (a >>> 8 & 65280) + ((65280 & a) << 8) + ((255 & a) << 24)
	            }
	
	            function e() {
	                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
	            }
	
	            function f(a) {
	                var b;
	                return a && a.state ? (b = a.state, a.total_in = a.total_out = b.total = 0, a.msg = "", b.wrap && (a.adler = 1 & b.wrap), b.mode = L, b.last = 0, b.havedict = 0, b.dmax = 32768, b.head = null, b.hold = 0, b.bits = 0, b.lencode = b.lendyn = new s.Buf32(pa), b.distcode = b.distdyn = new s.Buf32(qa), b.sane = 1, b.back = -1, D) : G
	            }
	
	            function g(a) {
	                var b;
	                return a && a.state ? (b = a.state, b.wsize = 0, b.whave = 0, b.wnext = 0, f(a)) : G
	            }
	
	            function h(a, b) {
	                var c, d;
	                return a && a.state ? (d = a.state, 0 > b ? (c = 0, b = -b) : (c = (b >> 4) + 1, 48 > b && (b &= 15)), b && (8 > b || b > 15) ? G : (null !== d.window && d.wbits !== b && (d.window = null), d.wrap = c, d.wbits = b, g(a))) : G
	            }
	
	            function i(a, b) {
	                var c, d;
	                return a ? (d = new e, a.state = d, d.window = null, c = h(a, b), c !== D && (a.state = null), c) : G
	            }
	
	            function j(a) {
	                return i(a, sa)
	            }
	
	            function k(a) {
	                if (ta) {
	                    var b;
	                    for (q = new s.Buf32(512), r = new s.Buf32(32), b = 0; 144 > b;)a.lens[b++] = 8;
	                    for (; 256 > b;)a.lens[b++] = 9;
	                    for (; 280 > b;)a.lens[b++] = 7;
	                    for (; 288 > b;)a.lens[b++] = 8;
	                    for (w(y, a.lens, 0, 288, q, 0, a.work, {bits: 9}), b = 0; 32 > b;)a.lens[b++] = 5;
	                    w(z, a.lens, 0, 32, r, 0, a.work, {bits: 5}), ta = !1
	                }
	                a.lencode = q, a.lenbits = 9, a.distcode = r, a.distbits = 5
	            }
	
	            function l(a, b, c, d) {
	                var e, f = a.state;
	                return null === f.window && (f.wsize = 1 << f.wbits, f.wnext = 0, f.whave = 0, f.window = new s.Buf8(f.wsize)), d >= f.wsize ? (s.arraySet(f.window, b, c - f.wsize, f.wsize, 0), f.wnext = 0, f.whave = f.wsize) : (e = f.wsize - f.wnext, e > d && (e = d), s.arraySet(f.window, b, c - d, e, f.wnext), d -= e, d ? (s.arraySet(f.window, b, c - d, d, 0), f.wnext = d, f.whave = f.wsize) : (f.wnext += e, f.wnext === f.wsize && (f.wnext = 0), f.whave < f.wsize && (f.whave += e))), 0
	            }
	
	            function m(a, b) {
	                var c, e, f, g, h, i, j, m, n, o, p, q, r, pa, qa, ra, sa, ta, ua, va, wa, xa, ya, za, Aa = 0, Ba = new s.Buf8(4), Ca = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	                if (!a || !a.state || !a.output || !a.input && 0 !== a.avail_in)return G;
	                c = a.state, c.mode === W && (c.mode = X), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, o = i, p = j, xa = D;
	                a:for (; ;)switch (c.mode) {
	                    case L:
	                        if (0 === c.wrap) {
	                            c.mode = X;
	                            break
	                        }
	                        for (; 16 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        if (2 & c.wrap && 35615 === m) {
	                            c.check = 0, Ba[0] = 255 & m, Ba[1] = m >>> 8 & 255, c.check = u(c.check, Ba, 2, 0), m = 0, n = 0, c.mode = M;
	                            break
	                        }
	                        if (c.flags = 0, c.head && (c.head.done = !1), !(1 & c.wrap) || (((255 & m) << 8) + (m >> 8)) % 31) {
	                            a.msg = "incorrect header check", c.mode = ma;
	                            break
	                        }
	                        if ((15 & m) !== K) {
	                            a.msg = "unknown compression method", c.mode = ma;
	                            break
	                        }
	                        if (m >>>= 4, n -= 4, wa = (15 & m) + 8, 0 === c.wbits)c.wbits = wa; else if (wa > c.wbits) {
	                            a.msg = "invalid window size", c.mode = ma;
	                            break
	                        }
	                        c.dmax = 1 << wa, a.adler = c.check = 1, c.mode = 512 & m ? U : W, m = 0, n = 0;
	                        break;
	                    case M:
	                        for (; 16 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        if (c.flags = m, (255 & c.flags) !== K) {
	                            a.msg = "unknown compression method", c.mode = ma;
	                            break
	                        }
	                        if (57344 & c.flags) {
	                            a.msg = "unknown header flags set", c.mode = ma;
	                            break
	                        }
	                        c.head && (c.head.text = m >> 8 & 1), 512 & c.flags && (Ba[0] = 255 & m, Ba[1] = m >>> 8 & 255, c.check = u(c.check, Ba, 2, 0)), m = 0, n = 0, c.mode = N;
	                    case N:
	                        for (; 32 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        c.head && (c.head.time = m), 512 & c.flags && (Ba[0] = 255 & m, Ba[1] = m >>> 8 & 255, Ba[2] = m >>> 16 & 255, Ba[3] = m >>> 24 & 255, c.check = u(c.check, Ba, 4, 0)), m = 0, n = 0, c.mode = O;
	                    case O:
	                        for (; 16 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        c.head && (c.head.xflags = 255 & m, c.head.os = m >> 8), 512 & c.flags && (Ba[0] = 255 & m, Ba[1] = m >>> 8 & 255, c.check = u(c.check, Ba, 2, 0)), m = 0, n = 0, c.mode = P;
	                    case P:
	                        if (1024 & c.flags) {
	                            for (; 16 > n;) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            c.length = m, c.head && (c.head.extra_len = m), 512 & c.flags && (Ba[0] = 255 & m, Ba[1] = m >>> 8 & 255, c.check = u(c.check, Ba, 2, 0)), m = 0, n = 0
	                        } else c.head && (c.head.extra = null);
	                        c.mode = Q;
	                    case Q:
	                        if (1024 & c.flags && (q = c.length, q > i && (q = i), q && (c.head && (wa = c.head.extra_len - c.length, c.head.extra || (c.head.extra = new Array(c.head.extra_len)), s.arraySet(c.head.extra, e, g, q, wa)), 512 & c.flags && (c.check = u(c.check, e, q, g)), i -= q, g += q, c.length -= q), c.length))break a;
	                        c.length = 0, c.mode = R;
	                    case R:
	                        if (2048 & c.flags) {
	                            if (0 === i)break a;
	                            q = 0;
	                            do wa = e[g + q++], c.head && wa && c.length < 65536 && (c.head.name += String.fromCharCode(wa)); while (wa && i > q);
	                            if (512 & c.flags && (c.check = u(c.check, e, q, g)), i -= q, g += q, wa)break a
	                        } else c.head && (c.head.name = null);
	                        c.length = 0, c.mode = S;
	                    case S:
	                        if (4096 & c.flags) {
	                            if (0 === i)break a;
	                            q = 0;
	                            do wa = e[g + q++], c.head && wa && c.length < 65536 && (c.head.comment += String.fromCharCode(wa)); while (wa && i > q);
	                            if (512 & c.flags && (c.check = u(c.check, e, q, g)), i -= q, g += q, wa)break a
	                        } else c.head && (c.head.comment = null);
	                        c.mode = T;
	                    case T:
	                        if (512 & c.flags) {
	                            for (; 16 > n;) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            if (m !== (65535 & c.check)) {
	                                a.msg = "header crc mismatch", c.mode = ma;
	                                break
	                            }
	                            m = 0, n = 0
	                        }
	                        c.head && (c.head.hcrc = c.flags >> 9 & 1, c.head.done = !0), a.adler = c.check = 0, c.mode = W;
	                        break;
	                    case U:
	                        for (; 32 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        a.adler = c.check = d(m), m = 0, n = 0, c.mode = V;
	                    case V:
	                        if (0 === c.havedict)return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, F;
	                        a.adler = c.check = 1, c.mode = W;
	                    case W:
	                        if (b === B || b === C)break a;
	                    case X:
	                        if (c.last) {
	                            m >>>= 7 & n, n -= 7 & n, c.mode = ja;
	                            break
	                        }
	                        for (; 3 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        switch (c.last = 1 & m, m >>>= 1, n -= 1, 3 & m) {
	                            case 0:
	                                c.mode = Y;
	                                break;
	                            case 1:
	                                if (k(c), c.mode = ca, b === C) {
	                                    m >>>= 2, n -= 2;
	                                    break a
	                                }
	                                break;
	                            case 2:
	                                c.mode = _;
	                                break;
	                            case 3:
	                                a.msg = "invalid block type", c.mode = ma
	                        }
	                        m >>>= 2, n -= 2;
	                        break;
	                    case Y:
	                        for (m >>>= 7 & n, n -= 7 & n; 32 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        if ((65535 & m) !== (m >>> 16 ^ 65535)) {
	                            a.msg = "invalid stored block lengths", c.mode = ma;
	                            break
	                        }
	                        if (c.length = 65535 & m, m = 0, n = 0, c.mode = Z, b === C)break a;
	                    case Z:
	                        c.mode = $;
	                    case $:
	                        if (q = c.length) {
	                            if (q > i && (q = i), q > j && (q = j), 0 === q)break a;
	                            s.arraySet(f, e, g, q, h), i -= q, g += q, j -= q, h += q, c.length -= q;
	                            break
	                        }
	                        c.mode = W;
	                        break;
	                    case _:
	                        for (; 14 > n;) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        if (c.nlen = (31 & m) + 257, m >>>= 5, n -= 5, c.ndist = (31 & m) + 1, m >>>= 5, n -= 5, c.ncode = (15 & m) + 4, m >>>= 4, n -= 4, c.nlen > 286 || c.ndist > 30) {
	                            a.msg = "too many length or distance symbols", c.mode = ma;
	                            break
	                        }
	                        c.have = 0, c.mode = aa;
	                    case aa:
	                        for (; c.have < c.ncode;) {
	                            for (; 3 > n;) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            c.lens[Ca[c.have++]] = 7 & m, m >>>= 3, n -= 3
	                        }
	                        for (; c.have < 19;)c.lens[Ca[c.have++]] = 0;
	                        if (c.lencode = c.lendyn, c.lenbits = 7, ya = {bits: c.lenbits}, xa = w(x, c.lens, 0, 19, c.lencode, 0, c.work, ya), c.lenbits = ya.bits, xa) {
	                            a.msg = "invalid code lengths set", c.mode = ma;
	                            break
	                        }
	                        c.have = 0, c.mode = ba;
	                    case ba:
	                        for (; c.have < c.nlen + c.ndist;) {
	                            for (; Aa = c.lencode[m & (1 << c.lenbits) - 1], qa = Aa >>> 24, ra = Aa >>> 16 & 255, sa = 65535 & Aa, !(n >= qa);) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            if (16 > sa)m >>>= qa, n -= qa, c.lens[c.have++] = sa; else {
	                                if (16 === sa) {
	                                    for (za = qa + 2; za > n;) {
	                                        if (0 === i)break a;
	                                        i--, m += e[g++] << n, n += 8
	                                    }
	                                    if (m >>>= qa, n -= qa, 0 === c.have) {
	                                        a.msg = "invalid bit length repeat", c.mode = ma;
	                                        break
	                                    }
	                                    wa = c.lens[c.have - 1], q = 3 + (3 & m), m >>>= 2, n -= 2
	                                } else if (17 === sa) {
	                                    for (za = qa + 3; za > n;) {
	                                        if (0 === i)break a;
	                                        i--, m += e[g++] << n, n += 8
	                                    }
	                                    m >>>= qa, n -= qa, wa = 0, q = 3 + (7 & m), m >>>= 3, n -= 3
	                                } else {
	                                    for (za = qa + 7; za > n;) {
	                                        if (0 === i)break a;
	                                        i--, m += e[g++] << n, n += 8
	                                    }
	                                    m >>>= qa, n -= qa, wa = 0, q = 11 + (127 & m), m >>>= 7, n -= 7
	                                }
	                                if (c.have + q > c.nlen + c.ndist) {
	                                    a.msg = "invalid bit length repeat", c.mode = ma;
	                                    break
	                                }
	                                for (; q--;)c.lens[c.have++] = wa
	                            }
	                        }
	                        if (c.mode === ma)break;
	                        if (0 === c.lens[256]) {
	                            a.msg = "invalid code -- missing end-of-block", c.mode = ma;
	                            break
	                        }
	                        if (c.lenbits = 9, ya = {bits: c.lenbits}, xa = w(y, c.lens, 0, c.nlen, c.lencode, 0, c.work, ya), c.lenbits = ya.bits, xa) {
	                            a.msg = "invalid literal/lengths set", c.mode = ma;
	                            break
	                        }
	                        if (c.distbits = 6, c.distcode = c.distdyn, ya = {bits: c.distbits}, xa = w(z, c.lens, c.nlen, c.ndist, c.distcode, 0, c.work, ya), c.distbits = ya.bits, xa) {
	                            a.msg = "invalid distances set", c.mode = ma;
	                            break
	                        }
	                        if (c.mode = ca, b === C)break a;
	                    case ca:
	                        c.mode = da;
	                    case da:
	                        if (i >= 6 && j >= 258) {
	                            a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, v(a, p), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, c.mode === W && (c.back = -1);
	                            break
	                        }
	                        for (c.back = 0; Aa = c.lencode[m & (1 << c.lenbits) - 1], qa = Aa >>> 24, ra = Aa >>> 16 & 255, sa = 65535 & Aa, !(n >= qa);) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        if (ra && 0 === (240 & ra)) {
	                            for (ta = qa, ua = ra, va = sa; Aa = c.lencode[va + ((m & (1 << ta + ua) - 1) >> ta)], qa = Aa >>> 24, ra = Aa >>> 16 & 255, sa = 65535 & Aa, !(n >= ta + qa);) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            m >>>= ta, n -= ta, c.back += ta
	                        }
	                        if (m >>>= qa, n -= qa, c.back += qa, c.length = sa, 0 === ra) {
	                            c.mode = ia;
	                            break
	                        }
	                        if (32 & ra) {
	                            c.back = -1, c.mode = W;
	                            break
	                        }
	                        if (64 & ra) {
	                            a.msg = "invalid literal/length code", c.mode = ma;
	                            break
	                        }
	                        c.extra = 15 & ra, c.mode = ea;
	                    case ea:
	                        if (c.extra) {
	                            for (za = c.extra; za > n;) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            c.length += m & (1 << c.extra) - 1, m >>>= c.extra, n -= c.extra, c.back += c.extra
	                        }
	                        c.was = c.length, c.mode = fa;
	                    case fa:
	                        for (; Aa = c.distcode[m & (1 << c.distbits) - 1], qa = Aa >>> 24, ra = Aa >>> 16 & 255, sa = 65535 & Aa, !(n >= qa);) {
	                            if (0 === i)break a;
	                            i--, m += e[g++] << n, n += 8
	                        }
	                        if (0 === (240 & ra)) {
	                            for (ta = qa, ua = ra, va = sa; Aa = c.distcode[va + ((m & (1 << ta + ua) - 1) >> ta)], qa = Aa >>> 24, ra = Aa >>> 16 & 255, sa = 65535 & Aa, !(n >= ta + qa);) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            m >>>= ta, n -= ta, c.back += ta
	                        }
	                        if (m >>>= qa, n -= qa, c.back += qa, 64 & ra) {
	                            a.msg = "invalid distance code", c.mode = ma;
	                            break
	                        }
	                        c.offset = sa, c.extra = 15 & ra, c.mode = ga;
	                    case ga:
	                        if (c.extra) {
	                            for (za = c.extra; za > n;) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            c.offset += m & (1 << c.extra) - 1, m >>>= c.extra, n -= c.extra, c.back += c.extra
	                        }
	                        if (c.offset > c.dmax) {
	                            a.msg = "invalid distance too far back", c.mode = ma;
	                            break
	                        }
	                        c.mode = ha;
	                    case ha:
	                        if (0 === j)break a;
	                        if (q = p - j, c.offset > q) {
	                            if (q = c.offset - q, q > c.whave && c.sane) {
	                                a.msg = "invalid distance too far back", c.mode = ma;
	                                break
	                            }
	                            q > c.wnext ? (q -= c.wnext, r = c.wsize - q) : r = c.wnext - q, q > c.length && (q = c.length), pa = c.window
	                        } else pa = f, r = h - c.offset, q = c.length;
	                        q > j && (q = j), j -= q, c.length -= q;
	                        do f[h++] = pa[r++]; while (--q);
	                        0 === c.length && (c.mode = da);
	                        break;
	                    case ia:
	                        if (0 === j)break a;
	                        f[h++] = c.length, j--, c.mode = da;
	                        break;
	                    case ja:
	                        if (c.wrap) {
	                            for (; 32 > n;) {
	                                if (0 === i)break a;
	                                i--, m |= e[g++] << n, n += 8
	                            }
	                            if (p -= j, a.total_out += p, c.total += p, p && (a.adler = c.check = c.flags ? u(c.check, f, p, h - p) : t(c.check, f, p, h - p)), p = j, (c.flags ? m : d(m)) !== c.check) {
	                                a.msg = "incorrect data check", c.mode = ma;
	                                break
	                            }
	                            m = 0, n = 0
	                        }
	                        c.mode = ka;
	                    case ka:
	                        if (c.wrap && c.flags) {
	                            for (; 32 > n;) {
	                                if (0 === i)break a;
	                                i--, m += e[g++] << n, n += 8
	                            }
	                            if (m !== (4294967295 & c.total)) {
	                                a.msg = "incorrect length check", c.mode = ma;
	                                break
	                            }
	                            m = 0, n = 0
	                        }
	                        c.mode = la;
	                    case la:
	                        xa = E;
	                        break a;
	                    case ma:
	                        xa = H;
	                        break a;
	                    case na:
	                        return I;
	                    case oa:
	                    default:
	                        return G
	                }
	                return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, (c.wsize || p !== a.avail_out && c.mode < ma && (c.mode < ja || b !== A)) && l(a, a.output, a.next_out, p - a.avail_out) ? (c.mode = na, I) : (o -= a.avail_in, p -= a.avail_out, a.total_in += o, a.total_out += p, c.total += p, c.wrap && p && (a.adler = c.check = c.flags ? u(c.check, f, p, a.next_out - p) : t(c.check, f, p, a.next_out - p)), a.data_type = c.bits + (c.last ? 64 : 0) + (c.mode === W ? 128 : 0) + (c.mode === ca || c.mode === Z ? 256 : 0), (0 === o && 0 === p || b === A) && xa === D && (xa = J), xa)
	            }
	
	            function n(a) {
	                if (!a || !a.state)return G;
	                var b = a.state;
	                return b.window && (b.window = null), a.state = null, D
	            }
	
	            function o(a, b) {
	                var c;
	                return a && a.state ? (c = a.state, 0 === (2 & c.wrap) ? G : (c.head = b, b.done = !1, D)) : G
	            }
	
	            function p(a, b) {
	                var c, d, e, f = b.length;
	                return a && a.state ? (c = a.state, 0 !== c.wrap && c.mode !== V ? G : c.mode === V && (d = 1, d = t(d, b, f, 0), d !== c.check) ? H : (e = l(a, b, f, f)) ? (c.mode = na, I) : (c.havedict = 1, D)) : G
	            }
	
	            var q, r, s = a("../utils/common"), t = a("./adler32"), u = a("./crc32"), v = a("./inffast"), w = a("./inftrees"), x = 0, y = 1, z = 2, A = 4, B = 5, C = 6, D = 0, E = 1, F = 2, G = -2, H = -3, I = -4, J = -5, K = 8, L = 1, M = 2, N = 3, O = 4, P = 5, Q = 6, R = 7, S = 8, T = 9, U = 10, V = 11, W = 12, X = 13, Y = 14, Z = 15, $ = 16, _ = 17, aa = 18, ba = 19, ca = 20, da = 21, ea = 22, fa = 23, ga = 24, ha = 25, ia = 26, ja = 27, ka = 28, la = 29, ma = 30, na = 31, oa = 32, pa = 852, qa = 592, ra = 15, sa = ra, ta = !0;
	            c.inflateReset = g, c.inflateReset2 = h, c.inflateResetKeep = f, c.inflateInit = j, c.inflateInit2 = i, c.inflate = m, c.inflateEnd = n, c.inflateGetHeader = o, c.inflateSetDictionary = p, c.inflateInfo = "pako inflate (from Nodeca project)"
	        }, {"../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50}],
	        50: [function (a, b, c) {
	            "use strict";
	            var d = a("../utils/common"), e = 15, f = 852, g = 592, h = 0, i = 1, j = 2, k = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], m = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], n = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
	            b.exports = function (a, b, c, o, p, q, r, s) {
	                var t, u, v, w, x, y, z, A, B, C = s.bits, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = null, O = 0, P = new d.Buf16(e + 1), Q = new d.Buf16(e + 1), R = null, S = 0;
	                for (D = 0; e >= D; D++)P[D] = 0;
	                for (E = 0; o > E; E++)P[b[c + E]]++;
	                for (H = C, G = e; G >= 1 && 0 === P[G]; G--);
	                if (H > G && (H = G), 0 === G)return p[q++] = 20971520, p[q++] = 20971520, s.bits = 1, 0;
	                for (F = 1; G > F && 0 === P[F]; F++);
	                for (F > H && (H = F), K = 1, D = 1; e >= D; D++)if (K <<= 1, K -= P[D], 0 > K)return -1;
	                if (K > 0 && (a === h || 1 !== G))return -1;
	                for (Q[1] = 0, D = 1; e > D; D++)Q[D + 1] = Q[D] + P[D];
	                for (E = 0; o > E; E++)0 !== b[c + E] && (r[Q[b[c + E]]++] = E);
	                if (a === h ? (N = R = r, y = 19) : a === i ? (N = k, O -= 257, R = l, S -= 257, y = 256) : (N = m, R = n, y = -1), M = 0, E = 0, D = F, x = q, I = H, J = 0, v = -1, L = 1 << H, w = L - 1, a === i && L > f || a === j && L > g)return 1;
	                for (var T = 0; ;) {
	                    T++, z = D - J, r[E] < y ? (A = 0, B = r[E]) : r[E] > y ? (A = R[S + r[E]], B = N[O + r[E]]) : (A = 96, B = 0), t = 1 << D - J, u = 1 << I, F = u;
	                    do u -= t, p[x + (M >> J) + u] = z << 24 | A << 16 | B | 0; while (0 !== u);
	                    for (t = 1 << D - 1; M & t;)t >>= 1;
	                    if (0 !== t ? (M &= t - 1, M += t) : M = 0, E++, 0 === --P[D]) {
	                        if (D === G)break;
	                        D = b[c + r[E]]
	                    }
	                    if (D > H && (M & w) !== v) {
	                        for (0 === J && (J = H), x += F, I = D - J, K = 1 << I; G > I + J && (K -= P[I + J], !(0 >= K));)I++, K <<= 1;
	                        if (L += 1 << I, a === i && L > f || a === j && L > g)return 1;
	                        v = M & w, p[v] = H << 24 | I << 16 | x - q | 0
	                    }
	                }
	                return 0 !== M && (p[x + M] = D - J << 24 | 64 << 16 | 0), s.bits = H, 0
	            }
	        }, {"../utils/common": 41}],
	        51: [function (a, b, c) {
	            "use strict";
	            b.exports = {
	                2: "need dictionary",
	                1: "stream end",
	                0: "",
	                "-1": "file error",
	                "-2": "stream error",
	                "-3": "data error",
	                "-4": "insufficient memory",
	                "-5": "buffer error",
	                "-6": "incompatible version"
	            }
	        }, {}],
	        52: [function (a, b, c) {
	            "use strict";
	            function d(a) {
	                for (var b = a.length; --b >= 0;)a[b] = 0
	            }
	
	            function e(a, b, c, d, e) {
	                this.static_tree = a, this.extra_bits = b, this.extra_base = c, this.elems = d, this.max_length = e, this.has_stree = a && a.length
	            }
	
	            function f(a, b) {
	                this.dyn_tree = a, this.max_code = 0, this.stat_desc = b
	            }
	
	            function g(a) {
	                return 256 > a ? ia[a] : ia[256 + (a >>> 7)]
	            }
	
	            function h(a, b) {
	                a.pending_buf[a.pending++] = 255 & b, a.pending_buf[a.pending++] = b >>> 8 & 255
	            }
	
	            function i(a, b, c) {
	                a.bi_valid > X - c ? (a.bi_buf |= b << a.bi_valid & 65535, h(a, a.bi_buf), a.bi_buf = b >> X - a.bi_valid, a.bi_valid += c - X) : (a.bi_buf |= b << a.bi_valid & 65535, a.bi_valid += c)
	            }
	
	            function j(a, b, c) {
	                i(a, c[2 * b], c[2 * b + 1])
	            }
	
	            function k(a, b) {
	                var c = 0;
	                do c |= 1 & a, a >>>= 1, c <<= 1; while (--b > 0);
	                return c >>> 1
	            }
	
	            function l(a) {
	                16 === a.bi_valid ? (h(a, a.bi_buf), a.bi_buf = 0, a.bi_valid = 0) : a.bi_valid >= 8 && (a.pending_buf[a.pending++] = 255 & a.bi_buf, a.bi_buf >>= 8, a.bi_valid -= 8)
	            }
	
	            function m(a, b) {
	                var c, d, e, f, g, h, i = b.dyn_tree, j = b.max_code, k = b.stat_desc.static_tree, l = b.stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base, o = b.stat_desc.max_length, p = 0;
	                for (f = 0; W >= f; f++)a.bl_count[f] = 0;
	                for (i[2 * a.heap[a.heap_max] + 1] = 0, c = a.heap_max + 1; V > c; c++)d = a.heap[c], f = i[2 * i[2 * d + 1] + 1] + 1, f > o && (f = o, p++), i[2 * d + 1] = f, d > j || (a.bl_count[f]++, g = 0, d >= n && (g = m[d - n]), h = i[2 * d], a.opt_len += h * (f + g), l && (a.static_len += h * (k[2 * d + 1] + g)));
	                if (0 !== p) {
	                    do {
	                        for (f = o - 1; 0 === a.bl_count[f];)f--;
	                        a.bl_count[f]--, a.bl_count[f + 1] += 2, a.bl_count[o]--, p -= 2
	                    } while (p > 0);
	                    for (f = o; 0 !== f; f--)for (d = a.bl_count[f]; 0 !== d;)e = a.heap[--c], e > j || (i[2 * e + 1] !== f && (a.opt_len += (f - i[2 * e + 1]) * i[2 * e], i[2 * e + 1] = f), d--)
	                }
	            }
	
	            function n(a, b, c) {
	                var d, e, f = new Array(W + 1), g = 0;
	                for (d = 1; W >= d; d++)f[d] = g = g + c[d - 1] << 1;
	                for (e = 0; b >= e; e++) {
	                    var h = a[2 * e + 1];
	                    0 !== h && (a[2 * e] = k(f[h]++, h))
	                }
	            }
	
	            function o() {
	                var a, b, c, d, f, g = new Array(W + 1);
	                for (c = 0, d = 0; Q - 1 > d; d++)for (ka[d] = c, a = 0; a < 1 << ba[d]; a++)ja[c++] = d;
	                for (ja[c - 1] = d, f = 0, d = 0; 16 > d; d++)for (la[d] = f, a = 0; a < 1 << ca[d]; a++)ia[f++] = d;
	                for (f >>= 7; T > d; d++)for (la[d] = f << 7, a = 0; a < 1 << ca[d] - 7; a++)ia[256 + f++] = d;
	                for (b = 0; W >= b; b++)g[b] = 0;
	                for (a = 0; 143 >= a;)ga[2 * a + 1] = 8, a++, g[8]++;
	                for (; 255 >= a;)ga[2 * a + 1] = 9, a++, g[9]++;
	                for (; 279 >= a;)ga[2 * a + 1] = 7, a++, g[7]++;
	                for (; 287 >= a;)ga[2 * a + 1] = 8, a++, g[8]++;
	                for (n(ga, S + 1, g), a = 0; T > a; a++)ha[2 * a + 1] = 5, ha[2 * a] = k(a, 5);
	                ma = new e(ga, ba, R + 1, S, W), na = new e(ha, ca, 0, T, W), oa = new e(new Array(0), da, 0, U, Y)
	            }
	
	            function p(a) {
	                var b;
	                for (b = 0; S > b; b++)a.dyn_ltree[2 * b] = 0;
	                for (b = 0; T > b; b++)a.dyn_dtree[2 * b] = 0;
	                for (b = 0; U > b; b++)a.bl_tree[2 * b] = 0;
	                a.dyn_ltree[2 * Z] = 1, a.opt_len = a.static_len = 0, a.last_lit = a.matches = 0
	            }
	
	            function q(a) {
	                a.bi_valid > 8 ? h(a, a.bi_buf) : a.bi_valid > 0 && (a.pending_buf[a.pending++] = a.bi_buf), a.bi_buf = 0, a.bi_valid = 0
	            }
	
	            function r(a, b, c, d) {
	                q(a), d && (h(a, c), h(a, ~c)), G.arraySet(a.pending_buf, a.window, b, c, a.pending), a.pending += c
	            }
	
	            function s(a, b, c, d) {
	                var e = 2 * b, f = 2 * c;
	                return a[e] < a[f] || a[e] === a[f] && d[b] <= d[c]
	            }
	
	            function t(a, b, c) {
	                for (var d = a.heap[c], e = c << 1; e <= a.heap_len && (e < a.heap_len && s(b, a.heap[e + 1], a.heap[e], a.depth) && e++, !s(b, d, a.heap[e], a.depth));)a.heap[c] = a.heap[e], c = e, e <<= 1;
	                a.heap[c] = d
	            }
	
	            function u(a, b, c) {
	                var d, e, f, h, k = 0;
	                if (0 !== a.last_lit)do d = a.pending_buf[a.d_buf + 2 * k] << 8 | a.pending_buf[a.d_buf + 2 * k + 1], e = a.pending_buf[a.l_buf + k], k++, 0 === d ? j(a, e, b) : (f = ja[e], j(a, f + R + 1, b), h = ba[f], 0 !== h && (e -= ka[f], i(a, e, h)), d--, f = g(d), j(a, f, c), h = ca[f], 0 !== h && (d -= la[f], i(a, d, h))); while (k < a.last_lit);
	                j(a, Z, b)
	            }
	
	            function v(a, b) {
	                var c, d, e, f = b.dyn_tree, g = b.stat_desc.static_tree, h = b.stat_desc.has_stree, i = b.stat_desc.elems, j = -1;
	                for (a.heap_len = 0, a.heap_max = V, c = 0; i > c; c++)0 !== f[2 * c] ? (a.heap[++a.heap_len] = j = c, a.depth[c] = 0) : f[2 * c + 1] = 0;
	                for (; a.heap_len < 2;)e = a.heap[++a.heap_len] = 2 > j ? ++j : 0, f[2 * e] = 1, a.depth[e] = 0, a.opt_len--, h && (a.static_len -= g[2 * e + 1]);
	                for (b.max_code = j, c = a.heap_len >> 1; c >= 1; c--)t(a, f, c);
	                e = i;
	                do c = a.heap[1], a.heap[1] = a.heap[a.heap_len--], t(a, f, 1), d = a.heap[1], a.heap[--a.heap_max] = c, a.heap[--a.heap_max] = d, f[2 * e] = f[2 * c] + f[2 * d], a.depth[e] = (a.depth[c] >= a.depth[d] ? a.depth[c] : a.depth[d]) + 1, f[2 * c + 1] = f[2 * d + 1] = e, a.heap[1] = e++, t(a, f, 1); while (a.heap_len >= 2);
	                a.heap[--a.heap_max] = a.heap[1], m(a, b), n(f, j, a.bl_count)
	            }
	
	            function w(a, b, c) {
	                var d, e, f = -1, g = b[1], h = 0, i = 7, j = 4;
	                for (0 === g && (i = 138, j = 3), b[2 * (c + 1) + 1] = 65535, d = 0; c >= d; d++)e = g, g = b[2 * (d + 1) + 1],
	                ++h < i && e === g || (j > h ? a.bl_tree[2 * e] += h : 0 !== e ? (e !== f && a.bl_tree[2 * e]++, a.bl_tree[2 * $]++) : 10 >= h ? a.bl_tree[2 * _]++ : a.bl_tree[2 * aa]++, h = 0, f = e, 0 === g ? (i = 138, j = 3) : e === g ? (i = 6, j = 3) : (i = 7, j = 4))
	            }
	
	            function x(a, b, c) {
	                var d, e, f = -1, g = b[1], h = 0, k = 7, l = 4;
	                for (0 === g && (k = 138, l = 3), d = 0; c >= d; d++)if (e = g, g = b[2 * (d + 1) + 1], !(++h < k && e === g)) {
	                    if (l > h) {
	                        do j(a, e, a.bl_tree); while (0 !== --h)
	                    } else 0 !== e ? (e !== f && (j(a, e, a.bl_tree), h--), j(a, $, a.bl_tree), i(a, h - 3, 2)) : 10 >= h ? (j(a, _, a.bl_tree), i(a, h - 3, 3)) : (j(a, aa, a.bl_tree), i(a, h - 11, 7));
	                    h = 0, f = e, 0 === g ? (k = 138, l = 3) : e === g ? (k = 6, l = 3) : (k = 7, l = 4)
	                }
	            }
	
	            function y(a) {
	                var b;
	                for (w(a, a.dyn_ltree, a.l_desc.max_code), w(a, a.dyn_dtree, a.d_desc.max_code), v(a, a.bl_desc), b = U - 1; b >= 3 && 0 === a.bl_tree[2 * ea[b] + 1]; b--);
	                return a.opt_len += 3 * (b + 1) + 5 + 5 + 4, b
	            }
	
	            function z(a, b, c, d) {
	                var e;
	                for (i(a, b - 257, 5), i(a, c - 1, 5), i(a, d - 4, 4), e = 0; d > e; e++)i(a, a.bl_tree[2 * ea[e] + 1], 3);
	                x(a, a.dyn_ltree, b - 1), x(a, a.dyn_dtree, c - 1)
	            }
	
	            function A(a) {
	                var b, c = 4093624447;
	                for (b = 0; 31 >= b; b++, c >>>= 1)if (1 & c && 0 !== a.dyn_ltree[2 * b])return I;
	                if (0 !== a.dyn_ltree[18] || 0 !== a.dyn_ltree[20] || 0 !== a.dyn_ltree[26])return J;
	                for (b = 32; R > b; b++)if (0 !== a.dyn_ltree[2 * b])return J;
	                return I
	            }
	
	            function B(a) {
	                pa || (o(), pa = !0), a.l_desc = new f(a.dyn_ltree, ma), a.d_desc = new f(a.dyn_dtree, na), a.bl_desc = new f(a.bl_tree, oa), a.bi_buf = 0, a.bi_valid = 0, p(a)
	            }
	
	            function C(a, b, c, d) {
	                i(a, (L << 1) + (d ? 1 : 0), 3), r(a, b, c, !0)
	            }
	
	            function D(a) {
	                i(a, M << 1, 3), j(a, Z, ga), l(a)
	            }
	
	            function E(a, b, c, d) {
	                var e, f, g = 0;
	                a.level > 0 ? (a.strm.data_type === K && (a.strm.data_type = A(a)), v(a, a.l_desc), v(a, a.d_desc), g = y(a), e = a.opt_len + 3 + 7 >>> 3, f = a.static_len + 3 + 7 >>> 3, e >= f && (e = f)) : e = f = c + 5, e >= c + 4 && -1 !== b ? C(a, b, c, d) : a.strategy === H || f === e ? (i(a, (M << 1) + (d ? 1 : 0), 3), u(a, ga, ha)) : (i(a, (N << 1) + (d ? 1 : 0), 3), z(a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, g + 1), u(a, a.dyn_ltree, a.dyn_dtree)), p(a), d && q(a)
	            }
	
	            function F(a, b, c) {
	                return a.pending_buf[a.d_buf + 2 * a.last_lit] = b >>> 8 & 255, a.pending_buf[a.d_buf + 2 * a.last_lit + 1] = 255 & b, a.pending_buf[a.l_buf + a.last_lit] = 255 & c, a.last_lit++, 0 === b ? a.dyn_ltree[2 * c]++ : (a.matches++, b--, a.dyn_ltree[2 * (ja[c] + R + 1)]++, a.dyn_dtree[2 * g(b)]++), a.last_lit === a.lit_bufsize - 1
	            }
	
	            var G = a("../utils/common"), H = 4, I = 0, J = 1, K = 2, L = 0, M = 1, N = 2, O = 3, P = 258, Q = 29, R = 256, S = R + 1 + Q, T = 30, U = 19, V = 2 * S + 1, W = 15, X = 16, Y = 7, Z = 256, $ = 16, _ = 17, aa = 18, ba = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], ca = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], da = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ea = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], fa = 512, ga = new Array(2 * (S + 2));
	            d(ga);
	            var ha = new Array(2 * T);
	            d(ha);
	            var ia = new Array(fa);
	            d(ia);
	            var ja = new Array(P - O + 1);
	            d(ja);
	            var ka = new Array(Q);
	            d(ka);
	            var la = new Array(T);
	            d(la);
	            var ma, na, oa, pa = !1;
	            c._tr_init = B, c._tr_stored_block = C, c._tr_flush_block = E, c._tr_tally = F, c._tr_align = D
	        }, {"../utils/common": 41}],
	        53: [function (a, b, c) {
	            "use strict";
	            function d() {
	                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
	            }
	
	            b.exports = d
	        }, {}]
	    }, {}, [10])(10)
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    
	    var compoundFileObjectType = {
	        Unknown: 0,
	        Storage: 1,
	        Stream: 2,
	        RootStorage: 5
	    };
	    var nodeColor = {
	        Red: 0,
	        Black: 1
	    };
	    var headerSignature = 0xE11AB1A1E011CFD0;
	    var endOfChain = -2;
	    var sectorSize = 0x200;
	    var minisectorSize = 0x40;
	    var directoryEntrySize = 0x80;
	    var maxRegSect = -6;
	    var freeSect = -1;
	    var rootName = "Root Entry";
	    var noStream = -1;
	    var compoundFileHeaderSize = 0x200;
	    var maxDifatArrayLength = 109;
	    var BufferHelper = __webpack_require__(4)._BufferHelper;
	
	    function makeSectors(input) {
	        var sectors = {StartSectorIndex: 0, SectorCount: 0};
	        var result = [];
	        for (var i = 0; i < input.length; i++) {
	            var isNew = (sectors.SectorCount === 0);
	            if (isNew) {
	                sectors.StartSectorIndex = input[i];
	                sectors.SectorCount = 1;
	            } else {
	                var isContinuous = (input[i] === (sectors.SectorCount + sectors.StartSectorIndex));
	                if (isContinuous) {
	                    sectors.SectorCount += 1;
	                } else {
	                    result.push(sectors);
	                    sectors.SectorCount = 0;
	                    i--;
	                }
	            }
	        }
	       
	        result.push(sectors);
	        return result;
	    }
	
	    var DirectoryEntry = function () {
	        this._name = new Array(0x20);
	        this._nameLength = 0;
	        this._type = 5;
	        this._leftSiblingID = noStream;
	        this._rightSiblingID = noStream;
	        this._childID = noStream;
	        this._startSector = freeSect;
	        this._streamSize = 0;
	        this._bytes = [];
	    };
	    DirectoryEntry.prototype = {
	        getName: function () {
	            var name = '';
	            this._name.forEach(function (n) {
	                var i = n.indexOf('\0');
	                if (i !== -1) {
	                    name += n.substring(0, i);
	                } else {
	                    name += n;
	                }
	            });
	            while (name.length > 0) {
	                if (name[name.length - 1] === 0x0000) {
	                    name.substring(0, name.length - 2);
	                } else {
	                    break;
	                }
	            }
	            return name;
	        },
	        setName: function (value) {
	            for (var i = 0; i < this._name.length && i < value.length; i++) {
	                this._name[i] = value[i];
	            }
	            this._nameLength = Math.min(this._name.length * 2, (value.length + 1) * 2);
	        },
	        read: function (reader) {
	            this._name = reader.readChars(this._name.length);
	            this._nameLength = reader.readInt16();
	            switch (this.getName()) {
	                case "R":
	                    this.setName(rootName);
	                    break;
	                case "Book":
	                    this.setName("Workbook");
	                    break;
	                default:
	                    break;
	            }
	            this._type = reader.readByte()[0];
	            reader.readByte();//this._nodeColor =
	            this._leftSiblingID = reader.readInt32();
	            this._rightSiblingID = reader.readInt32();
	            this._childID = reader.readInt32();
	            reader.readInt32();//this._CLSID1 =
	            reader.readInt32();// this._CLSID2 =
	            reader.readInt32();//this._CLSID3 =
	            reader.readInt32();// this._CLSID4 =
	            reader.readInt32();//this._stateBits =
	            reader.readInt64();//this._creationTime =
	            reader.readInt64();//this._modifiedTime =
	            this._startSector = reader.readInt32();
	            this._streamSize = reader.readInt32();
	            reader.readInt32();//this._streamSize2 =
	        }
	    };
	    var CompoundFileHeader = function () {
	    };
	    CompoundFileHeader.prototype = {
	        _headerSignature: headerSignature,
	        _revisionNo: 0x003E,
	        _versionNo: 0x0003,
	        _byteOrder: 0xFFFE,
	        _sectorShift: 9,
	        _miniSectorShift: 6,
	        _reserved1: 0,
	        _reserved2: 0,
	        _directorySectorCount: 0,
	        _fatSectorCount: 0,
	        _firstDirectorySector: 0,
	        _transactionSignature: 0,
	        _miniStreamCufoffSize: 0x00001000,
	        _firstMiniFatSector: endOfChain,
	        _miniFatSectorCount: 0,
	        _firstDifatSector: endOfChain,
	        _difatSectorCount: 0,
	        _difatArray: [],
	        sectorSize: function () {
	            return Math.pow(2, this._sectorShift);
	        },
	        minisectorSize: function () {
	            return Math.pow(2, this._miniSectorShift);
	        },
	        read: function (reader) {
	            this._headerSignature = reader.readUInt64();
	            reader.readInt32();//this._CLSID1
	            reader.readInt32();//this._CLSID2
	            reader.readInt32();//this._CLSID3
	            reader.readInt32();//this._CLSID4
	            this._revisionNo = reader.readUInt16();
	            this._versionNo = reader.readUInt16();
	            if (this._versionNo > 3) {
	                return false;
	            }
	            this._byteOrder = reader.readUInt16();
	            this._sectorShift = reader.readInt16();
	            this._miniSectorShift = reader.readInt32();
	            this._reserved1 = reader.readInt32();
	            this._reserved2 = reader.readInt16();
	            this._directorySectorCount = reader.readInt16();
	            this._fatSectorCount = reader.readInt32();
	            this._firstDirectorySector = reader.readInt32();
	            this._transactionSignature = reader.readInt32();
	            this._miniStreamCufoffSize = reader.readInt32();
	            this._firstMiniFatSector = reader.readInt32();
	            this._miniFatSectorCount = reader.readInt32();
	            this._firstDifatSector = reader.readInt32();
	            this._difatSectorCount = reader.readInt32();
	
	            var fatCount = Math.min(this._fatSectorCount, maxDifatArrayLength);
	            this._difatArray = [];
	            for (var i = 0; i < fatCount; i++) {
	                this._difatArray[i] = reader.readInt32();
	            }
	        }
	    };
	    var FileAllocationTable = function () {
	        this._innerList = [];
	    };
	    FileAllocationTable.prototype = {
	        length: function () {
	            return this._innerList.length;
	        },
	        getList: function () {
	            return this._innerList;
	        },
	        getSectorList: function (startIndex) {
	            var result = [];
	            var index = startIndex;
	            while (index <= maxRegSect || index > freeSect) {
	                result.push(index);
	                index = this._innerList[index];
	            }
	            return result;
	        },
	
	        addRange: function (collection) {
	            var self = this;
	            if (collection && collection.length) {
	                collection.forEach(function (c) {
	                    self._innerList.push(c);
	                });
	            }
	        },
	
	        read: function (reader, count) {
	            for (var i = 0; i < count; i++) {
	                this._innerList.push(reader.readInt32());
	            }
	        }
	    };
	    var DirectoryEntryCollection = function () {
	        this._directoryEntries = [];
	    };
	    DirectoryEntryCollection.prototype = {
	        add: function (directoryEntry) {
	            if (directoryEntry.getName() === rootName) {
	                this._directoryEntries.splice(0, 0, directoryEntry);
	            } else {
	                this._directoryEntries.push(directoryEntry);
	            }
	        },
	        clear: function () {
	            this._directoryEntries = [];
	        },
	        length: function () {
	            return this._directoryEntries.length;
	        },
	        entries: function () {
	            return this._directoryEntries;
	        },
	        read: function (reader, count) {
	            for (var i = 0; i < count; i++) {
	                var property = new DirectoryEntry();
	                property.read(reader);
	                this._directoryEntries.push(property);
	            }
	        }
	    };
	
	    var CompoundFile = function (isReadOnly) {
	        this._pos = 0;
	        this._header = new CompoundFileHeader();
	        this._directoryEntries = new DirectoryEntryCollection();
	        this._difatList = new FileAllocationTable();
	        this._fatList = new FileAllocationTable();
	        this._miniFatList = new FileAllocationTable();
	        var rootEntry = new DirectoryEntry();
	        rootEntry.setName(rootName);
	        rootEntry._type = compoundFileObjectType.Stream;
	        rootEntry._nodeColor = nodeColor.Black;
	        rootEntry._childID = noStream;
	        if (!isReadOnly) {
	            rootEntry._creationTime = new Date().getTime();
	            rootEntry._modifiedTime = new Date().getTime();
	        }
	        rootEntry._leftSiblingID = noStream;
	        rootEntry._rightSiblingID = noStream;
	        rootEntry._childID = noStream;
	        rootEntry._type = compoundFileObjectType.RootStorage;
	        rootEntry._startSector = endOfChain;
	        rootEntry._streamSize = 0;
	        rootEntry.Bytes = null;
	        this._directoryEntries.add(rootEntry);
	    };
	    CompoundFile.prototype = {
	        _getStream: function (name, parentName) {
	            if (arguments.length === 1) {
	                parentName = rootName;
	            }
	
	            var parentId = -1;
	            for (var i = 0; i < this._directoryEntries.length(); i++) {
	                var de = this._directoryEntries.entries()[i];
	                if (de.getName() === parentName && (de._type === compoundFileObjectType.Storage || de._type === compoundFileObjectType.RootStorage)) {
	                    parentId = i;
	                    break;
	                }
	            }
	            if (parentId === -1) {
	                return null;
	            }
	
	            if (this._directoryEntries.entries()[parentId]._childID === noStream) {
	                return null;
	            }
	
	            var ids = [];
	           
	            ids.push(this._directoryEntries.entries()[parentId]._childID);
	           
	            this._getSiblingDirectoryEntryIds(this._directoryEntries.entries()[parentId]._childID, ids);
	            for (i = 0; i < ids.length; i++) {
	                de = this._directoryEntries.entries()[ids[i]];
	                if (de.getName() === name && de._type === compoundFileObjectType.Stream) {
	                    return de._bytes;
	                }
	            }
	            return null;
	        },
	        _getSiblingDirectoryEntryIds: function (id, ids) {
	            if (this._directoryEntries.entries()[id]._leftSiblingID !== noStream) {
	                ids.push(this._directoryEntries.entries()[id]._leftSiblingID);
	                this._getSiblingDirectoryEntryIds(this._directoryEntries.entries()[id]._leftSiblingID, ids);
	            }
	            if (this._directoryEntries.entries()[id]._rightSiblingID !== noStream) {
	                ids.push(this._directoryEntries.entries()[id]._rightSiblingID);
	                this._getSiblingDirectoryEntryIds(this._directoryEntries.entries()[id]._rightSiblingID, ids);
	            }
	        },
	        _read: function (view) {
	            this.view = view;
	            var reader = this._reader();
	            this._readHeader(reader);
	            this._readFatList(reader);
	            this._readDirectoryEntries(reader);
	        },
	        _readHeader: function (reader) {
	            this._header.read(reader);
	            sectorSize = this._header.sectorSize();
	            minisectorSize = this._header.minisectorSize();
	        },
	        _readFatList: function (reader) {
	            this._difatList.addRange(this._header._difatArray);
	            var remainFatSectorCount = this._header._fatSectorCount - (this._header._difatArray ? this._header._difatArray.length : 0);
	            var difatSector = this._header._firstDifatSector;
	            var countInSector = (sectorSize - 4) / 4;
	            while (remainFatSectorCount > 0) {
	                this._moveToSector(difatSector, reader);
	                this._difatList.read(reader, Math.min(countInSector, remainFatSectorCount));
	                remainFatSectorCount -= Math.min(countInSector, remainFatSectorCount);
	                if (remainFatSectorCount > 0) {
	                    difatSector = reader.readInt32();
	                }
	            }
	
	           
	            for (var i = 0; i < this._difatList.length(); i++) {
	                this._moveToSector(this._difatList.getList()[i], reader);
	                this._fatList.read(reader, sectorSize / 4);
	            }
	
	           
	            var miniFats = this._fatList.getSectorList(this._header._firstMiniFatSector);
	            for (i = 0; i < miniFats.length; i++) {
	                this._moveToSector(miniFats[i], reader);
	                this._miniFatList.read(reader, sectorSize / 4);
	            }
	        },
	
	        _readDirectoryEntries: function (reader) {
	            this._directoryEntries.clear();
	
	           
	            var firstSector = this._header._firstDirectorySector;
	            var sectors = this._fatList.getSectorList(firstSector);
	            for (var i = 0; i < sectors.length; i++) {
	                this._moveToSector(sectors[i], reader);
	                this._directoryEntries.read(reader, sectorSize / directoryEntrySize);
	            }
	
	            var rootEntity = this._directoryEntries.entries()[0];
	            if (rootEntity.getName() === rootName.replace(" ", "")) {
	                rootEntity.setName(rootName);
	            }
	
	            if (rootEntity.getName() !== rootName) {
	                return;
	            }
	           
	            for (i = 1; i < this._directoryEntries.length(); i++) {
	                var de = this._directoryEntries.entries()[i];
	                if (de._type === compoundFileObjectType.Stream) {
	                    de._bytes = this._getDirectoryEntryBytes(de, reader);
	                }
	            }
	        },
	        _getDirectoryEntryBytes: function (directoryEntry, reader) {
	            if (directoryEntry === null) {
	                return null;
	            }
	            if (directoryEntry._streamSize < this._header._miniStreamCufoffSize) {
	                return this._getMiniSectorBytes(directoryEntry._startSector, directoryEntry._streamSize, reader);
	            }
	            return this._getSectorBytes(directoryEntry._startSector, directoryEntry._streamSize, reader);
	        },
	        _getMiniSectorBytes: function (startSector, streamSize, reader) {
	            var result = [];
	            var sectors = this._miniFatList.getSectorList(startSector);
	            for (var i = 0; i < sectors.length; i++) {
	                this._moveToMiniSector(sectors[i], reader);
	                var count = minisectorSize;
	                if (i === sectors.length - 1 && streamSize % minisectorSize !== 0) {
	                    count = streamSize % minisectorSize;
	                }
	
	                var bytes = reader.readBytes(count);
		
	                for (var j = 0; j < bytes.length; j++) {
	                    result.push(bytes[j]);
	                }
	            }
	            return result;
	        },
	        _moveToSector: function (index) {
	            this._pos = compoundFileHeaderSize + this._header.sectorSize() * index;
	        },
	        _moveToMiniSector: function (index) {
	            var miniSectorCountInNormalSector = sectorSize / minisectorSize;
	            var normalSectorIndex = Math.floor(index / miniSectorCountInNormalSector);
	            var normalSectors = this._fatList.getSectorList(this._directoryEntries.entries()[0]._startSector);
	            this._moveToSector(normalSectors[normalSectorIndex]);
	            this._pos += (index % miniSectorCountInNormalSector) * minisectorSize;
	        },
	
	        _getSectorBytes: function (startSector, streamSize, reader) {
	            var blocks = this._fatList.getSectorList(startSector);
	            var continuousSector = makeSectors(blocks);
	            var result = [];
	            for (var i = 0; i < continuousSector.length; i++) {
	                this._moveToSector(continuousSector[i].StartSectorIndex);
	                var count = sectorSize * continuousSector[i].SectorCount;
	                if (i === continuousSector.length - 1 && streamSize % sectorSize !== 0) {
	                    count -= sectorSize - streamSize % sectorSize;
	                }
	                count = Math.min(count, (this.view.length - this._pos));
	                var bytes = reader.readBytes(count);
	                for (var j = 0; j < bytes.length; j++) {
	                    result.push(bytes[j]);
	                }
	            }
	            return result;
	        },
	        _reader: function () {
	            var self = this;
	            var reverse = function (arr) {
	               
	                var result = [];
	                for (var i = 0; i < arr.length; i++) {
	                    result[i] = arr[arr.length - i - 1];
	                }
	                return result;
	            };
	            var readUInt = function (n) {
	                var sign = 0;
	                reverse(BufferHelper._slice(self.view, self._pos, self._pos + n)).forEach(function (i) {
	                    sign = sign * 256 + i;
	                });
	                self._pos += n;
	                return sign;
	            };
	            var readInt = function (n) {
	                var sign = 0;
	
	                reverse(BufferHelper._slice(self.view, self._pos, self._pos + n)).forEach(function (i) {
	                    sign = (sign << 8) + i;
	                });
	                self._pos += n;
	                return sign;
	            };
	            var _readBytes = function (n) {
	
	                var subView = BufferHelper._slice(self.view, self._pos, self._pos + n);
	                self._pos += n;
	                return subView;
	            };
	            return {
	                readUInt64: function () {
	                    return readUInt(8);
	                },
	                readInt64: function () {
	                    return readInt(8);
	                },
	                readInt32: function () {
	                    return readInt(4);
	                },
	                readUInt32: function () {
	                    return readUInt(4);
	                },
	                readInt16: function () {
	                    return readInt(2);
	                },
	                readUInt16: function () {
	                    return readInt(2);
	                },
	                readByte: function () {
	                    return _readBytes(1);
	                },
	                readBytes: function (count) {
	                    return _readBytes(count);
	                },
	                readChars: function (count) {
	                    var chars = [];
	                    for (var i = 0; i < count; i++) {
	                        var bytes = _readBytes(2);
	                        chars.push(String.fromCharCode.apply(null, bytes));
	                    }
	                    return chars;
	                }
	            };
	        }
	    };
	
	    module.exports = CompoundFile;
	
	}());

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function () {
	    'use strict';
	
	    var keyword_null = null, keyword_undefined = void 0, const_object = 'object', const_string = 'string';
	    function isNullOrUndefined(obj) {
	        return obj === null || obj === undefined;
	    }
	
	    exports._isNullOrUndefined = isNullOrUndefined;
	
	    var StringEx = (function () {
	        function StringEx() {
	        }
	
	        StringEx._isNullOrEmpty = function (obj) {
	            return !obj || obj === '';
	        };
	        StringEx._isNullOrWhiteSpace = function (obj) {
	            return !obj || obj === ' ';
	        };
	        return StringEx;
	    })();
	    exports._StringEx = StringEx;
	
	    var Range = (function () {
	        function Range(row, col, rowCount, colCount) {
	            this.row = row;
	            this.col = col;
	            this.rowCount = rowCount;
	            this.colCount = colCount;
	        }
	
	        return Range;
	    })();
	    exports._Range = Range;
	
	    function isRangeWholeRow(range) {
	        return range.col === -1 || range.colCount === -1;
	    }
	
	    function isRangeWholeColumn(range) {
	        return range.row === -1 || range.rowCount === -1;
	    }
	
	    exports.isRangeWholeRow = isRangeWholeRow;
	    exports.isRangeWholeColumn = isRangeWholeColumn;
	
	    var isLetter = function (c) {
	        var cc = c.charCodeAt(0);
	        cc |= 0x20;
	       
	        return (cc >= 96 && cc <= 122);
	    };
	
	    var IndexHelper = (function () {
	        function IndexHelper() {
	        }
	
	        IndexHelper._getRowIndexInNumber = function (s) {
	            if (StringEx._isNullOrEmpty(s)) {
	                return 0;
	            }
	            var row = 0, n = 0;
	            while (n < s.length && isNaN(parseInt(s[n], 10))) {
	                n++;
	            }
	
	            if (n < s.length) {
	                row = parseInt(s.substring(n));
	            }
	            return row - 1;
	        };
	        IndexHelper._getColumnIndexInNumber = function (s) {
	            var column = 0, len = s.length;
	            for (var i = 0; i < len; i++) {
	                var c = s[i], charCode = c.charCodeAt();
	                var value = charCode - 97;
	                if (value > 25) {
	                    break;
	                }
	                if (value < 0) {
	                    value = charCode - 65;
	                }
	                if (value < 0) {
	                    break;
	                }
	                column = 26 * column + value + 1;
	            }
	            column--;
	            return column;
	        };
	        IndexHelper._getColumnIndexInA1Letter = function (coord) {
	            if (coord < 0) {
	                return '';
	            }
	            var result = IndexHelper._columnsInA1Letter[coord];
	            if (result) {
	                return result;
	            }
	            var key = coord;
	            var sb = '';
	            var position = sb.length;
	            for (coord += 1; coord > 0; coord = Math.floor((coord - 1) / 26)) {
	                var temp1 = sb.substring(0, position);
	                var temp2 = sb.substring(position);
	                sb = temp1 + String.fromCharCode((65 + (coord - 1) % 26)) + temp2;
	            }
	            result = sb.toString();
	            IndexHelper._columnsInA1Letter[key] = result;
	            return result;
	        };
	        IndexHelper._columnsInA1Letter = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
	        IndexHelper._getSheetName = function (sheetName) {
	            var validSheetName = function (name) {
	                return !(/^\d+$/.test(name) ||
	                    name.indexOf(' ') > -1 ||
	                    name.indexOf("'") > -1 ||
	                    name.indexOf('%') > -1 ||
	                    name.indexOf('"') > -1 ||
	                    name.indexOf('(') > -1 || name.indexOf(')') > -1 ||
	                    name.indexOf('\uff08') > -1 || name.indexOf('\uff09') > -1);
	            };
	            if (!validSheetName(sheetName)) {
	                return '\'' + sheetName + '\'';
	            }
	            return sheetName;
	        };
	        return IndexHelper;
	    })();
	    exports._IndexHelper = IndexHelper;
	
	    var ParsedSharedFormulaStruct = (function () {
	        function ParsedSharedFormulaStruct() {
	            var self = this;
	            self.sharedFormulaType = 0;
	            self.index = 0;
	            self.length = 0;
	            self.column1 = 0;
	            self.column2 = 0;
	            self.row1 = 0;
	            self.row2 = 0;
	            self.firstSign = keyword_null;
	            self.secondSign = keyword_null;
	            self.formatString = keyword_null;
	        }
	
	        return ParsedSharedFormulaStruct;
	    })();
	
	    var CalcHelper = (function () {
	        function CalcHelper() {
	        }
	
	        CalcHelper._readString = function (formula, startIndex, startSign, endSign, throwError) {
	            var len = formula.length;
	            var startSignCount = (startSign === endSign) ? 0 : 1;
	            var text = '';
	            for (var index = startIndex + 1; index < len; index++) {
	                var currentChar = formula.charAt(index);
	                if (currentChar === startSign) {
	                    startSignCount++;
	                }
	                if (currentChar === endSign) {
	                    startSignCount--;
	                    if (startSign === endSign && index + 2 < len && formula.charAt(index + 1) === startSign) {
	                        text += startSign;
	                        index++;
	                    } else if (startSignCount !== 0) {
	                        text += currentChar;
	                    } else {
	                        return { result: text, endIndex: index };
	                    }
	                } else {
	                    text += currentChar;
	                }
	            }
	            if (throwError) {
	                throw new Error();
	            }
	        };
	        CalcHelper._readString2 = function (formula, startIndex, startSign, endSign, escapeSign, throwError) {
	            var len = formula.length;
	            var startSignCount = 0;
	            var text = '';
	            for (var index = startIndex; index < len; index++) {
	                var currentChar = formula.charAt(index);
	                if (currentChar === escapeSign) {
	                    text += currentChar;
	                    index++;
	                    currentChar = formula.charAt(index);
	                }
	                if (currentChar === startSign) {
	                    text += currentChar;
	                    startSignCount++;
	                } else if (currentChar === endSign) {
	                    startSignCount--;
	                    if (startSignCount !== 0) {
	                        text += currentChar;
	                    } else {
	                        return { result: text, endIndex: index };
	                    }
	                } else {
	                    text += currentChar;
	                }
	            }
	            if (throwError) {
	                throw new Error();
	            }
	        };
	        CalcHelper._getSharedFormula = function (sharedFormula, columnOffset, rowOffset) {
	            if (!sharedFormula.parsedSharedFormulaStructs) {
	                CalcHelper._parseSharedFormulaStruct(sharedFormula, columnOffset, rowOffset, 0);
	            }
	            if (sharedFormula.parsedSharedFormulaStructs) {
	                var result = '';
	                var baseFormula = sharedFormula.baseFormula;
	                if (!sharedFormula.parsedSharedFormulaStructs || sharedFormula.parsedSharedFormulaStructs.length === 0) {
	                    result = baseFormula;
	                } else {
	                    for (var i = 0, len = sharedFormula.parsedSharedFormulaStructs.length; i < len; i++) {
	                        var item = sharedFormula.parsedSharedFormulaStructs[i];
	                        if (item.sharedFormulaType === 0) {
	                            var colIndex = item.column1 + columnOffset;
	                            if (colIndex >= CalcHelper._maxColumnCount) {
	                                colIndex = item.column1;
	                            }
	                            var rowIndex = item.row1 + rowOffset;
	                            if (rowIndex >= CalcHelper._maxRowCount) {
	                                rowIndex = item.row1;
	                            }
	                            var tempStr = item.formatString.replace('{0}', IndexHelper._getColumnIndexInA1Letter(colIndex));
	                            tempStr = tempStr.replace('{1}', rowIndex.toString());
	                            result = result.concat(tempStr);
	                        } else if (item.sharedFormulaType === 1) {
	                            var colIndex1 = item.column1 + columnOffset;
	                            if (colIndex1 >= CalcHelper._maxColumnCount) {
	                                colIndex1 = item.column1;
	                            }
	                            var colIndex2 = item.column2 + columnOffset;
	                            if (colIndex2 >= CalcHelper._maxColumnCount) {
	                                colIndex2 = item.column2;
	                            }
	                            tempStr = item.formatString.replace('{0}', IndexHelper._getColumnIndexInA1Letter(colIndex1));
	                            tempStr = tempStr.replace('{1}', IndexHelper._getColumnIndexInA1Letter(colIndex2));
	                            result = result.concat(tempStr);
	                        } else if (item.sharedFormulaType === 2) {
	                            rowIndex = item.row1 + rowOffset;
	                            if (rowIndex >= CalcHelper._maxRowCount) {
	                                rowIndex = item.row1;
	                            }
	                            var rowIndex2 = item.row2 + rowOffset;
	                            if (rowIndex2 >= CalcHelper._maxRowCount) {
	                                rowIndex2 = item.row2;
	                            }
	                            tempStr = item.formatString.replace('{0}', rowIndex.toString());
	                            tempStr = tempStr.replace('{1}', rowIndex2.toString());
	                            result = result.concat(tempStr);
	                        }
	                    }
	                }
	                return result;
	            }
	            return '';
	        };
	        CalcHelper._parseSharedFormulaStruct = function (sharedFormula, columnOffset, rowOffset, index) {
	            if (index >= sharedFormula.baseFormula.length) {
	                return;
	            }
	            var lastIndex = index;
	            while (index < sharedFormula.baseFormula.length) {
	                var result = false;
	                var m = sharedFormula.baseFormula.substring(index).match(CalcHelper._cellRefRegex);
	                if (m !== keyword_null) {
	                    var isReference = true;
	                    var nextCharIndex = m.index + m[0].length + index;
	                    if (nextCharIndex < sharedFormula.baseFormula.length) {
	                        var nextChar = sharedFormula.baseFormula[nextCharIndex];
	                        if (isLetter(nextChar)
	                            || nextChar === '_'
	                            || nextChar === '\\'
	                            || nextChar === '?'
	                            || nextChar === '.'
	                            || nextChar === '"'
	                            || nextChar === '(') {
	                            isReference = false;
	                        }
	                    }
	                    if (isReference) {
	                        result = true;
	
	                       
	                        if (!sharedFormula.parsedSharedFormulaStructs) {
	                            sharedFormula.parsedSharedFormulaStructs = [];
	                        }
	                        var sb = '';
	
	                        var column = m[2];
	                        var row = m[4];
	
	                        var psf = new ParsedSharedFormulaStruct();
	                        psf.sharedFormulaType = 0;
	                        psf.index = m.index;
	                        psf.length = m[0].length;
	                        psf.column1 = IndexHelper._getColumnIndexInNumber(column);
	                        psf.row1 = parseInt(row);
	                        psf.firstSign = m[1];
	                        psf.secondSign = m[3];
	
	                        sb = sb.concat(sharedFormula.baseFormula.substring(lastIndex, m.index + index));
	                        var oldValue = m[0];
	                        if (psf.index > 0 && sharedFormula.baseFormula[psf.index + index - 1] === '_') {
	                            sb = sb.concat(oldValue);
	                        } else if (psf.firstSign === psf.secondSign && psf.firstSign === '') {
	                            oldValue = oldValue.replace(column, '{0}');
	                            oldValue = oldValue.replace(row, '{1}');
	                            sb = sb.concat(oldValue);
	                        } else if (psf.firstSign === '$' && psf.secondSign === '') {
	                            oldValue = oldValue.replace(row, '{1}');
	                            sb = sb.concat(oldValue);
	                        } else if (psf.secondSign === '$' && psf.firstSign === '') {
	                            oldValue = oldValue.replace(column, '{0}');
	                            sb = sb.concat(oldValue);
	                        } else {
	                            sb = sb.concat(oldValue);
	                        }
	                        psf.formatString = sb;
	                        sharedFormula.parsedSharedFormulaStructs.push(psf);
	                    }
	                } else if (columnOffset === 0) {
	                    m = sharedFormula.baseFormula.substring(index).match(CalcHelper._cellRefRegex2);
	                    if (m !== keyword_null) {
	                        result = true;
	                        if (!sharedFormula.parsedSharedFormulaStructs) {
	                            sharedFormula.parsedSharedFormulaStructs = [];
	                        }
	                        sb = '';
	
	                        var row1 = m[2];
	                        var row2 = m[4];
	                        psf = new ParsedSharedFormulaStruct();
	                        psf.sharedFormulaType = 2;
	                        psf.index = m.index;
	                        psf.length = m[0].length;
	                        psf.row1 = parseInt(row1);
	                        psf.row2 = parseInt(row2);
	                        psf.firstSign = m[1];
	                        psf.secondSign = m[3];
	                        sb = sb.concat(sharedFormula.baseFormula.substring(lastIndex, m.index + index));
	                        oldValue = sharedFormula.baseFormula.substring(m.index + index, m.index + index + m[0].length);
	                        if (psf.index > 0 && sharedFormula.baseFormula[psf.index + index - 1] === '_') {
	                            sb = sb.concat(oldValue);
	                        } else if (psf.firstSign === psf.secondSign && psf.firstSign === '') {
	                            sb = sb.concat('{0}:{1}');
	                        } else {
	                            sb = sb.concat(oldValue);
	                        }
	                        psf.formatString = sb;
	                        sharedFormula.parsedSharedFormulaStructs.push(psf);
	                    }
	                } else if (rowOffset === 0) {
	                    m = sharedFormula.baseFormula.substring(index).match(CalcHelper._cellRefRegex3);
	                    if (m !== keyword_null) {
	                        result = true;
	                        if (!sharedFormula.parsedSharedFormulaStructs) {
	                            sharedFormula.parsedSharedFormulaStructs = [];
	                        }
	                        sb = '';
	
	                        var column1 = m[2];
	                        var column2 = m[4];
	                        psf = new ParsedSharedFormulaStruct();
	                        psf.sharedFormulaType = 1;
	                        psf.index = m.indexOf(m[0]);
	                        psf.length = m[0].length;
	                        psf.column1 = IndexHelper._getColumnIndexInNumber(column1);
	                        psf.column2 = IndexHelper._getColumnIndexInNumber(column2);
	                        psf.firstSign = m[1];
	                        psf.secondSign = m[3];
	                        sb = sb.concat(sharedFormula.baseFormula.substring(lastIndex, m.index + index));
	                        oldValue = sharedFormula.baseFormula.substring(m.index + index, m.index + index + m[0].length);
	                        if (psf.index > 0 && sharedFormula.baseFormula[psf.index + index - 1] === '_') {
	                            sb = sb.concat(oldValue);
	                        } else if (psf.firstSign === psf.secondSign && psf.firstSign === '') {
	                            sb = sb.concat('{0}:{1}');
	                        } else {
	                            sb = sb.concat(oldValue);
	                        }
	
	                        psf.formatString = sb;
	                        sharedFormula.parsedSharedFormulaStructs.push(psf);
	                    }
	                }
	                if (m) {
	                    index = index + m.index + m[0].length;
	                    if (result) {
	                        lastIndex = index;
	                    }
	                } else {
	                    psf = new ParsedSharedFormulaStruct();
	                    psf.formatString = sharedFormula.baseFormula.substring(lastIndex);
	                    if (!sharedFormula.parsedSharedFormulaStructs) {
	                        sharedFormula.parsedSharedFormulaStructs = [];
	                    }
	                    sharedFormula.parsedSharedFormulaStructs.push(psf);
	                    break;
	                }
	            }
	
	            if (isNullOrUndefined(sharedFormula.parsedSharedFormulaStructs)) {
	                sharedFormula.parsedSharedFormulaStructs = [];
	            }
	            return result;
	        };
	        CalcHelper._contains = function (range, row, col) {
	            return (range.row === -1 || (range.row <= row && row < range.row + range.rowCount)) && (range.col === -1 || (range.col <= col && col < range.col + range.colCount));
	        };
	        CalcHelper._cellRefRegex = /(\$?)([A-Z]+)(\$?)(\d+)/;
	        CalcHelper._cellRefRegex2 = /(\$?)(\d+):(\$?)(\d+)/;
	        CalcHelper._cellRefRegex3 = /(\$?)([A-Z]+):(\$?)([A-Z]+)/;
	        CalcHelper._maxRowCount = 1048576;
	        CalcHelper._maxColumnCount = 16384;
	        CalcHelper._LatinUnicodeCategory = {
	            UppercaseLetter: 0x00,
	            LowercaseLetter: 0x01,
	            DecimalDigitNumber: 0x08,
	            OtherNumber: 0x0a,
	            SpaceSeparator: 0x0b,
	            Control: 0x0e,
	            ConnectorPunctuation: 0x12,
	            DashPunctuation: 0x13,
	            OpenPunctuation: 0x14,
	            ClosePunctuation: 0x15,
	            InitialQuotePunctuation: 0x16,
	            FinalQuotePunctuation: 0x17,
	            OtherPunctuation: 0x18,
	            MathSymbol: 0x19,
	            currencySymbol: 0x1a,
	            ModifierSymbol: 0x1b,
	            OtherSymbol: 0x1c
	        };
	        CalcHelper._CategoryForLatin1 = [
	            0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	            0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	            0xb, 0x18, 0x18, 0x18, 0x1a, 0x18, 0x18, 0x18, 0x14, 0x15, 0x18, 0x19, 0x18, 0x13, 0x18, 0x18,
	            0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x18, 0x18, 0x19, 0x19, 0x19, 0x18,
	            0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x18, 0x15, 0x1b, 0x12,
	            0x1b, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	            0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x14, 0x19, 0x15, 0x19, 0xe,
	            0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	            0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	            0xb, 0x18, 0x1a, 0x1a, 0x1a, 0x1a, 0x1c, 0x1c, 0x1b, 0x1c, 0x1, 0x16, 0x19, 0x13, 0x1c, 0x1b,
	            0x1c, 0x19, 0xa, 0xa, 0x1b, 0x1, 0x1c, 0x18, 0x1b, 0xa, 0x1, 0x17, 0xa, 0xa, 0xa, 0x18,
	            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
	            0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	            0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x19, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1
	        ];
	        return CalcHelper;
	    })();
	    exports._CalcHelper = CalcHelper;
	
	    function cloneBorder(border) {
	        var retValue = {};
	        if (!isNullOrUndefined(border.color)) {
	            retValue.color = border.color;
	        }
	        if (!isNullOrUndefined(border.style)) {
	            retValue.style = border.style;
	        }
	        if (!isNullOrUndefined(border.level)) {
	            retValue.level = border.level;
	        }
	        return retValue;
	    }
	
	    var StyleHelper = (function () {
	        function StyleHelper() {
	        }
	
	        StyleHelper._findName = function (namedStylesNamesIndexImp, name) {
	            return namedStylesNamesIndexImp && namedStylesNamesIndexImp[name];
	        };
	        StyleHelper._getByName = function (arr, name) {
	            if (!arr) {
	                return null;
	            }
	            for (var i = 0, len = arr.length; i < len; i++) {
	                var item = arr[i];
	                if (item && item.name === name) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        StyleHelper._addToNamedStyles = function (namedStyles, namedStylesNamesIndexImp, style) {
	            if (!style) {
	                return;
	            }
	            var name = style.name;
	            var oldStyleIndex = StyleHelper._findName(namedStylesNamesIndexImp, style.name);
	            if (!isNullOrUndefined(oldStyleIndex)) {
	                namedStyles[oldStyleIndex] = style;
	            } else {
	                namedStyles.push(style);
	                namedStylesNamesIndexImp[name] = namedStyles.length - 1;
	            }
	        };
	        StyleHelper._isEmptyStyleInfo = function (style) {
	            if (!style) {
	                return true;
	            }
	            var result = style.name === undefined
	                && style.locked === undefined
	                && style.tabStop === undefined
	                && style.themeFont === undefined
	                && style.font === undefined
	                && style.hAlign === undefined
	                && style.vAlign === undefined
	                && style.textIndent === undefined
	                && style.wordWrap === undefined
	                && style.shrinkToFit === undefined
	                && style.borderLeft === undefined
	                && style.borderTop === undefined
	                && style.borderRight === undefined
	                && style.borderBottom === undefined
	                && style.backColor === undefined
	                && style.foreColor === undefined
	                && style.textDecoration === undefined;
	            if (!result) {
	                return false;
	            }
	           
	            var formatterString = style.formatter;
	            if (typeof formatterString === const_string && formatterString.toUpperCase() !== 'GENERAL') {
	                return false;
	            }
	            return true;
	        };
	        StyleHelper._composeStyle = function (style, parentStyle) {
	            if (!parentStyle || StyleHelper._isEmptyStyleInfo(parentStyle)) {
	                return;
	            }
	            if (style.backColor === keyword_undefined && parentStyle.backColor) {
	                style.backColor = parentStyle.backColor;
	            }
	            if (style.foreColor === keyword_undefined && parentStyle.foreColor) {
	                style.foreColor = parentStyle.foreColor;
	            }
	            if (style.hAlign === keyword_undefined && parentStyle.hAlign) {
	                style.hAlign = parentStyle.hAlign;
	            }
	            if (style.vAlign === keyword_undefined && parentStyle.vAlign) {
	                style.vAlign = parentStyle.vAlign;
	            }
	            if (style.themeFont === keyword_undefined && style.font === keyword_undefined) {
	                style.themeFont = parentStyle.themeFont;
	                style.font = parentStyle.font;
	            } else if (style.themeFont !== keyword_undefined && style.font === keyword_undefined) {
	                style.font = parentStyle.font;
	            }
	            if (style.formatter === keyword_undefined && parentStyle.formatter) {
	                style.formatter = parentStyle.formatter;
	            }
	            if (style.borderLeft === keyword_undefined && parentStyle.borderLeft) {
	                style.borderLeft = cloneBorder(parentStyle.borderLeft);
	            }
	            if (style.borderTop === keyword_undefined && parentStyle.borderTop) {
	                style.borderTop = cloneBorder(parentStyle.borderTop);
	            }
	            if (style.borderRight === keyword_undefined && parentStyle.borderRight) {
	                style.borderRight = cloneBorder(parentStyle.borderRight);
	            }
	            if (style.borderBottom === keyword_undefined && parentStyle.borderBottom) {
	                style.borderBottom = cloneBorder(parentStyle.borderBottom);
	            }
	            if (style.locked === keyword_undefined && parentStyle.locked) {
	                style.locked = parentStyle.locked;
	            }
	            if (style.textIndent === keyword_undefined && parentStyle.textIndent) {
	                style.textIndent = parentStyle.textIndent;
	            }
	            if (style.wordWrap === keyword_undefined && parentStyle.wordWrap) {
	                style.wordWrap = parentStyle.wordWrap;
	            }
	            if (style.shrinkToFit === keyword_undefined && parentStyle.shrinkToFit) {
	                style.shrinkToFit = parentStyle.shrinkToFit;
	            }
	            if (style.textDecoration === keyword_undefined && parentStyle.textDecoration) {
	                style.textDecoration = parentStyle.textDecoration;
	            }
	        };
	        StyleHelper._setActualStyle = function (namedStyles, style) {
	            if (!style || namedStyles.length <= 0) {
	                return keyword_null;
	            }
	            var tempStyle = style;
	            while (tempStyle.parentName) {
	                tempStyle = StyleHelper._getByName(namedStyles, tempStyle.parentName);
	                if (!tempStyle) {
	                    break;
	                }
	                StyleHelper._composeStyle(style, tempStyle);
	            }
	        };
	
	
	        return StyleHelper;
	    })();
	    exports._StyleHelper = StyleHelper;
	
	    var BufferHelper = (function () {
	        function BufferHelper() {
	           
	        }
	
	        BufferHelper._clamp = function (val, length) {
	            var valTemp = (val | 0) || 0;
	            return valTemp < 0 ? Math.max(valTemp + length, 0) : Math.min(valTemp, length);
	        };
	
	        BufferHelper._slice = function (buffer, from, to) {
	            if (!buffer.slice) {
	                var length = buffer.byteLength, clamp = BufferHelper._clamp;
	                var begin = clamp(from, length);
	                var end = length;
	
	                if (to !== void 0) {
	                    end = clamp(to, length);
	                }
	                var bufferConstructor = buffer.constructor;
	                if (begin > end) {
	                    return new bufferConstructor(0);
	                }
	                var num = end - begin;
	                if (buffer instanceof ArrayBuffer) {
	                    var target = new ArrayBuffer(num);
	                    var targetArray = new Uint8Array(target);
	                    var sourceArray = new Uint8Array(buffer, begin, num);
	                    targetArray.set(sourceArray);
	                    return target;
	                } else {
	                   
	                    var cloned = new bufferConstructor(num);
	                    for (var i = 0; i < num; i++) {
	                        cloned[i] = buffer[begin + i];
	                    }
	                    return cloned;
	                }
	            }
	            return buffer.slice(from, to);
	        };
	        return BufferHelper;
	    })();
	    exports._BufferHelper = BufferHelper;
	
	    var exp1 = /&/g;
	    var exp2 = /</g;
	    var exp3 = />/g;
	    var exp4 = /"/g;
	    var exp5 = /'/g;
	
	    var exp11 = /&amp;/g;
	    var exp12 = /&gt;/g;
	    var exp13 = /&lt;/g;
	    var exp14 = /&quot;/g;
	    var exp15 = /&apos;/g;
	
	    var specialCharacterMatchPattern = /_x00[0-1][0-9A-Fa-f]_/;
	
	    var Util = (function () {
	        function Util() {
	        }
	
	        Util._firstOrDefault = function (list, condition, defaultValue) {
	            if (!list || list.length === 0) {
	                return defaultValue;
	            }
	            if (!condition) {
	                return list[0];
	            }
	            for (var i = 0, len = list.length; i < len; i++) {
	                if (condition(list[i])) {
	                    return list[i];
	                }
	            }
	            return defaultValue;
	        };
	        Util._indexOf = function (list, item) {
	            if (!list) {
	                return -1;
	            }
	            for (var i = 0, len = list.length; i < len; i++) {
	                var listItem = list[i];
	                if ((listItem.equals && listItem.equals(item)) || (listItem === item)) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	        Util._indexOfJSON = function (list, item) {
	            if (!list) {
	                return -1;
	            }
	            for (var i = 0, len = list.length; i < len; i++) {
	                var listItem = list[i];
	                if ((Util._isJSONEqual(listItem, item)) || (listItem === item)) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	        Util._isJSONEqual = function (item1, item2) {
	            return JSON.stringify(item1) === JSON.stringify(item2);
	        };
	        Util._xmlEncode = function (string) {
	            if (typeof string === const_string) {
	                return string.replace(exp1, '&amp;')
	                    .replace(exp2, '&lt;')
	                    .replace(exp3, '&gt;')
	                    .replace(exp4, '&quot;')
	                    .replace(exp5, '&apos;');
	            }
	            if (!isNullOrUndefined(string)) {
	                return '' + string;
	            }
	            return string;
	        };
	        var expCharReferenceInDecimalForm = /&#(\d+);/g;
	        var expCharReferenceInHexForm = /&#x([0-9A-F]+);/gi;
	        function getReplaceFunction(radix) {
	            return function (match , p1 ) {  
	                return String.fromCharCode(parseInt(p1, radix));
	            };
	        }
	        Util._xmlDecode = function (string) {
	            if (typeof string === const_string) {
	               
	               
	               
	                if (string.indexOf('&#') !== -1) {
	                    string = string.replace(expCharReferenceInDecimalForm, getReplaceFunction(10))
	                        .replace(expCharReferenceInHexForm, getReplaceFunction(16));
	                }
	               
	                return string.replace(exp11, '&')
	                    .replace(exp12, '>')
	                    .replace(exp13, '<')
	                    .replace(exp14, '"')
	                    .replace(exp15, "'");
	            }
	            if (!isNullOrUndefined(string)) {
	                return '' + string;
	            }
	            return string;
	        };
	        Util._joinPath = function (base, relative) {
	            var baseItems = base.split('/'),
	                relativeItems = relative.split('/');
	
	            baseItems.pop();
	
	            while (relativeItems.length > 0) {
	                var first = relativeItems[0];
	                if (first === '..') {
	                    relativeItems.shift();
	                    baseItems.pop();
	                } else if (first === '.') {
	                    relativeItems.shift();
	                } else {
	                    break;
	                }
	            }
	
	            return baseItems.concat(relativeItems).join('/');
	        };
	        Util._parsePath = function (path) {
	            var dir, fileName;
	
	            if (!StringEx._isNullOrEmpty(path)) {
	                var parts = path.split('/');
	
	                fileName = parts.pop();
	                dir = parts.join('/');
	            }
	
	            return { dir: dir || '', fileName: fileName || '' };
	        };
	        var isEqualObject = function (obj1, obj2, compareObjectFieldFunc) {
	            function isEqualArray(arr1, arr2) {
	                if (!arr1 && !arr2) {
	                    return true;
	                }
	                if (!arr1 || !arr2 || arr1.length !== arr2.length) {
	                    return false;
	                }
	                var find = false;
	                for (var i = 0; i < arr1.length; i++) {
	                    for (var j = 0; j < arr2.length; j++) {
	                        if (typeof arr1[i] === const_object) {
	                            if (typeof arr2[j] === const_object) {
	                                find = isEqualObject(arr1[i], arr2[j]);
	                                if (find) {
	                                    break;
	                                }
	                            }
	                        } else if (arr1[i] === arr2[j]) {
	                            find = true;
	                            break;
	                        }
	                    }
	                    if (!find) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	
	            if (!obj1 && !obj2) {
	                return true;
	            } else if (!obj1 || !obj2) {
	                return false;
	            }
	            if (!compareObjectFieldFunc) {
	                compareObjectFieldFunc = isEqualObject;
	            }
	            var propCache = {}, prop;
	            for (prop in obj1) {
	                if (obj1.hasOwnProperty(prop)) {
	                    var propValue = obj1[prop];
	                    if (Array.isArray(propValue)) {
	                        if (!isEqualArray(propValue, obj2[prop])) {
	                            return false;
	                        }
	                    } else if (typeof propValue === const_object) {
	                        if (!compareObjectFieldFunc(propValue, obj2[prop])) {
	                            return false;
	                        }
	                    } else if (propValue !== obj2[prop]) {
	                        return false;
	                    }
	                    propCache[prop] = true;
	                }
	            }
	            for (prop in obj2) {
	                if (obj2.hasOwnProperty(prop) && !propCache[prop]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        Util._isEqualObject = isEqualObject;
	        Util._isExternalRange = function (formula, currentSheetName, sheetNames) {
	            if (formula && typeof formula === const_string) {
	                for (var i = 0; i < sheetNames.length; i++) {
	                    var sheetName = sheetNames[i];
	                    if (sheetName === currentSheetName) {
	                        continue;
	                    }
	                    if (formula.indexOf(sheetName + '!') > -1 || formula.indexOf("'" + sheetName + "'!") > -1) {
	                        return true;
	                    }
	                }
	            }
	            return false;
	        };
	        Util._replaceAll = function (target, substr, replacement) {
	            return target.split(substr).join(replacement);
	        };
	        Util._createURI = function () {
	            return '{xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx}'.replace(/[xy]/g, function (c) {
	                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
	                return v.toString(16);
	            });
	        };
	       
	       
	       
	       
	       
	        Util._decodeSpecialCharacterFromXML = function (text) {
	            if (!isNullOrUndefined(text) && text.match(specialCharacterMatchPattern) !== keyword_null) {
	                var decodeSpecialCharacterPattern = /(_x005[fF])?_x00([0-1][0-9A-Fa-f])_/g;
	                return text.replace(decodeSpecialCharacterPattern, function (match, childMath1, childMath2) {
	                    var result = 0;
	                    if (childMath2) {
	                        result = parseInt(childMath2, 16);
	                    }
	                    if (childMath1) {  
	                        return '_x00' + childMath2 + '_';
	                    }
	                    return String.fromCharCode(result);
	                });
	            }
	            return text;
	        };
	        Util._encodeSpecialCharacterToXML = function (text, ignoreWrapText) {
	            if (isNullOrUndefined(text) || text === "") {
	                return text;
	            }
	            if (text.match(specialCharacterMatchPattern) !== keyword_null) {
	                var encodeSpecialCharacterPattern = /(_x00[0-1][0-9A-Fa-f]_)/g;
	                text = text.replace(encodeSpecialCharacterPattern, function (match) {
	                    return '_x005F' + match;
	                });
	            }
	            var specialCharTableValue = ['_x0000_', '_x0001_', '_x0002_', '_x0003_', '_x0004_', '_x0005_', '_x0006_', '_x0007_',
	                '_x0008_', '_x0009_', '_x000A_', '_x000B_', '_x000C_', '_x000D_', '_x000E_', '_x000F_', '_x0010_', '_x0011_',
	                '_x0012_', '_x0013_', '_x0014_', '_x0015_', '_x0016_', '_x0017_', '_x0018_', '_x0019_', '_x001A_', '_x001B_',
	                '_x001C_', '_x001D_', '_x001E_', '_x001F_'];
	            var sb = [];
	            for (var i = 0; i < text.length; i++) {
	                var charCode = text.charCodeAt(i), c = text[i];
	               
	                if (charCode > 0x1F || (charCode === 0x0A  && ignoreWrapText)) {
	                    sb.push(c);
	                } else {
	                    sb.push(specialCharTableValue[charCode]);
	                }
	            }
	            return sb.join('');
	        };
	        return Util;
	    })();
	    exports._Util = Util;
	
	    exports._getSheetDefaults = function () {
	        return {
	            colHeaderRowHeight: 20,
	            rowHeaderColWidth: 40,
	            rowHeight: 20,
	            colWidth: 62
	        };
	    };
	
	    
	    function getRoot() {
	        var root;
	        try {
	            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	                return typeof obj;
	            } : function (obj) {
	                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
	            };
	           
	            var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global && global.Object === Object && global;
	           
	            var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self && self.Object === Object && self;
	           
	            root = freeGlobal || freeSelf || Function('return this')();
	        } catch (e) {
	           
	        }
	        return root;
	    }
	
	    exports._getRoot = getRoot;
	    exports._getCulture = function () {
	        var root = getRoot();
	        return root && root.gcCultureInfo;
	    };
	}());
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    
	    var CompoundFile = __webpack_require__(3);
	    var AesEngine = __webpack_require__(6);
	    var BufferHelper = __webpack_require__(4)._BufferHelper;
	
	    function hasPassword(fileData) {
	        var sign0 = 0;
	        var sign1 = 0;
	        var reverse = function (arr) {
	            var result = [];
	            for (var i = 0; i < arr.length; i++) {
	                result[i] = arr[arr.length - i - 1];
	            }
	            return result;
	        };
	        reverse(new Uint8Array(BufferHelper._slice(fileData, 0, 4))).forEach(function (i) {// eslint-disable-line
	            sign0 = sign0 * 256 + i;
	        });
	        reverse(new Uint8Array(BufferHelper._slice(fileData, 4, 8))).forEach(function (i) {// eslint-disable-line
	            sign1 = sign1 * 256 + i;
	        });
	        if (sign0.toString(16).toUpperCase() === 'E011CFD0' && sign1.toString(16).toUpperCase() === 'E11AB1A1') {
	            try {
	                var encryptedStgResult = readEncryptedStgStream(fileData);
	                return encryptedStgResult.success && encryptedStgResult.encryptionInfoStream && encryptedStgResult.encryptPagStream;
	            } catch (err) {
	                return false;
	            }
	
	        }
	        return false;
	
	
	    }
	
	    function readEncryptedStgStream(fileData) {
	        var result = {success: false, encryptionInfoStream: null, encryptPagStream: null};
	        var compoundFile = new CompoundFile();
	        var view = new Uint8Array(fileData);//eslint-disable-line
	        compoundFile._read(view);
	        var encryptionInfoStreamBytes = compoundFile._getStream("EncryptionInfo");
	        var encryptPagStreamBytes = compoundFile._getStream("EncryptedPackage");
	        if (encryptionInfoStreamBytes === null || encryptPagStreamBytes === null) {
	            return result;
	        }
	        result.success = true;
	        result.encryptionInfoStream = encryptionInfoStreamBytes;
	        result.encryptPagStream = encryptPagStreamBytes;
	        return result;
	    }
	
	    function decryptData(fileData, password) {
	        var result = {success: false};
	
	        var encryptedStgResult = readEncryptedStgStream(fileData);
	        if (!encryptedStgResult.success) {
	            return result;
	        }
	        var encryptionInfoStream = encryptedStgResult.encryptionInfoStream;
	        var encryptPagStream = encryptedStgResult.encryptPagStream;
	        if (encryptionInfoStream !== null && encryptPagStream !== null) {
	            var aes = new AesEngine();
	            if (aes._progressStream(encryptionInfoStream)) {
	                if (aes._isAgileEncrypt) {
	                    if (aes._agileVerifyPassWord(password)) {
	                        result = aes._agileDecryptStream(encryptPagStream);
	                    }
	                } else {
	                    aes.key = aes._createKey(password, aes.salt, aes.hashAlgorithm);
	                    aes._initAesEngine(aes.keySize, aes.key);
	                    if (aes._verifyPassword()) {
	                        result = aes._decryptStream(encryptPagStream);
	                    }
	                }
	            }
	
	        }
	        return result;
	    }
	
	    function base64toBlob(base64Data, contentType) {
	        var sliceSize = 1024;
	        var byteCharacters = atob(base64Data);
	        var bytesLength = byteCharacters.length;
	        var slicesCount = Math.ceil(bytesLength / sliceSize);
	        var byteArrays = new Array(slicesCount);
	        for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
	            var begin = sliceIndex * sliceSize;
	            var end = Math.min(begin + sliceSize, bytesLength);
	            var bytes = new Array(end - begin);
	            for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
	                bytes[i] = byteCharacters[offset].charCodeAt(0);
	            }
	            byteArrays[sliceIndex] = new Uint8Array(bytes);//eslint-disable-line
	        }
	        return new Blob(byteArrays, {type: contentType});
	    }
	
	    var XlsxEncryptionHelper = {
	        _decrypt: function (fileData, password) {
	            var valid = hasPassword(fileData);
	            if (valid) {
	                var isEncryptedOffice12 = decryptData(fileData, password);
	                if (isEncryptedOffice12 && isEncryptedOffice12.success) {
	                    return isEncryptedOffice12.data;
	                }
	                return null;
	            }
	            return fileData;
	        },
	
	        _encrypt: function (arrayBuffer, password) {
	            var aes = new AesEngine();
	            var encStreamInfo = aes._createEncryptInfo(password);
	            var encStreamPackage = aes._encryptPackageStream(arrayBuffer);
	            if (encStreamInfo !== null && encStreamPackage !== null) {
	                var result = aes._stgOpenXmlStreamWrite(encStreamInfo, encStreamPackage);
	                if (result.success) {
	                    return result.data;
	                }
	            }
	        },
	
	        _arrayBufferToBlob: function (arrayBuffer) {
	            return base64toBlob(btoa(String.fromCharCode.apply(null, arrayBuffer)), 'application/zip');
	        },
	
	        _hasPassword: hasPassword
	    };
	
	    module.exports = XlsxEncryptionHelper;
	
	}());

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var Sha = __webpack_require__(9);
	    var aesjs = __webpack_require__(10);
	    var nodeHelper = __webpack_require__(11);
	    var Sha1 = __webpack_require__(17);
	    var getAsArray = nodeHelper._getAsArray;
	    var util = __webpack_require__(4);
	    var BufferHelper = util._BufferHelper;
	    var getRoot = util._getRoot;
	    var seekOrigin = {
	        Begin: 0,
	        Current: 1,
	        End: 2
	    };
	
	
	    function base64ToBytes(base64) {
	        var root = getRoot();
	        var binary_string = root && root.atob && root.atob(base64);
	        var len = binary_string ? binary_string.length : 0;
	        var bytes = new Uint8Array(len);//eslint-disable-line
	        for (var i = 0; i < len; i++) {
	            bytes[i] = binary_string.charCodeAt(i);
	        }
	        return bytes;
	    }
	
	    function arrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
	        var j = destinationIndex;
	        for (var i = sourceIndex; i < sourceIndex + length; i++) {
	            destinationArray[j] = sourceArray[i];
	            j++;
	        }
	    }
	
	    function stringToByteArray(str) {
	       
	        var bytes = [];
	        var bytesv2 = [];
	
	        for (var i = 0; i < str.length; ++i) {
	            var code = str.charCodeAt(i);
	
	            bytes = bytes.concat([code]);
	
	            bytesv2 = bytesv2.concat([code & 0xff, (parseInt(code / 256)) >>> 0]);
	        }
	        return bytesv2;
	    }
	
	    function getBytesFromInt(i, x) {
	        var bytes = [];
	        do {
	            bytes[--i] = x & (255);
	            x = x >> 8;
	        } while (i);
	        return bytes.reverse();
	    }
	
	    function getBytesFromString(str) {
	        var bytes = [];
	        var charCode;
	
	        for (var i = 0; i < str.length; ++i) {
	            charCode = str.charCodeAt(i);
	            bytes.push(charCode & 0xFF);
	            bytes.push((charCode & 0xFF00) >> 8);
	        }
	        return bytes;
	    }
	
	    function hashByte(b1, b2, hashAlgorithm) {
	        var sha = Sha;
	        switch (hashAlgorithm) {
	            case "SHA1":
	                sha = Sha1;
	                break;
	        }
	        var t = [];
	        for (var i = 0; i < b1.length; i++) {
	            t.push(b1[i]);
	        }
	        return sha.hash(t.concat(b2));
	    }
	
	    function createKey(password, salt, hashAlgorithm) {
	        var pwd = stringToByteArray(password);
	
	        var tmp = hashByte(salt, pwd, hashAlgorithm);
	        for (var i = 0; i < 50000; i++) {
	            var tmpI = getBytesFromInt(4, i);
	            tmp = hashByte(tmpI, tmp, hashAlgorithm);
	        }
	        tmp = hashByte(tmp, getBytesFromInt(4, 0), hashAlgorithm);
	
	        var XorBuff = [];
	        for (i = 0; i < 64; i++) {
	            XorBuff[i] = 0x36;
	        }
	
	        for (i = 0; i < tmp.length; i++) {
	            XorBuff[i] ^= tmp[i];
	        }
	
	        tmp = Sha1.hash(XorBuff);
	
	        var _key = [];
	        arrayCopy(tmp, 0, _key, 0, 16);
	        return _key;
	    }
	
	    function reader(view) {
	        var readUInt = function (n) {
	            var sign = 0;
	            BufferHelper._slice(view, view._pos, view._pos + n).reverse().forEach(function (i) {
	                sign = sign * 256 + i;
	            });
	            view._pos += n;
	            return sign;
	        };
	        var readInt = function (n) {
	            var sign = 0;
	            BufferHelper._slice(view, view._pos, view._pos + n).reverse().forEach(function (i) {
	                sign = ((sign << 8) + i);
	            });
	            view._pos += n;
	            return sign;
	        };
	        var _readBytes = function (n) {
	            var subView = BufferHelper._slice(view, view._pos, view._pos + n);
	            view._pos += n;
	            return subView;
	        };
	
	        return {
	            readUInt64: function () {
	                return readUInt(8);
	            },
	            readInt64: function () {
	                return readInt(8);
	            },
	            readInt32: function () {
	                return readInt(4);
	            },
	            readUInt32: function () {
	                return readUInt(4);
	            },
	            readInt16: function () {
	                return readInt(2);
	            },
	            readUInt16: function () {
	                return readInt(2);
	            },
	            readByte: function () {
	                return _readBytes(1);
	            },
	            readBytes: function (count) {
	                return _readBytes(count);
	            },
	            readChars: function (count) {
	                var bytes = _readBytes(count);
	                var chars = [];
	                bytes.forEach(function (byte) {
	                    chars.push(String.fromCharCode(byte));
	                });
	                return chars;
	            },
	            seek: function (offset, origin) {
	                if (origin === seekOrigin.Begin) {
	                    view._pos = offset;
	                } else if (origin === seekOrigin.Current) {
	                    view._pos += offset;
	                } else if (origin === seekOrigin.End) {
	                    view._pos = view.length + offset;
	                }
	            }
	        };
	    }
	
	    function writer(view) {
	        var write = function (n, value) {
	            var result = getBytesFromInt(n, value);
	            var pos = view._pos;
	            for (var i = 0; i < result.length; i++) {
	                view[i + pos] = result[i];
	            }
	            view._pos = pos + n;
	        };
	        return {
	            writeBytes: function (value) {
	                var pos = view._pos;
	                for (var i = 0; i < value.length; i++) {
	                    view[i + pos] = value[i];
	                }
	                view._pos = pos + value.length;
	            },
	            writeByte: function (value) {
	                this.writeBytes([value]);
	            },
	            writeUshort: function (value) {
	                return write(2, value);
	            },
	            writeShort: function (value) {
	                return write(2, value);
	            },
	            writeInt: function (value) {
	                return write(4, value);
	            },
	            writeUint: function (value) {
	                return write(4, value);
	            },
	            writeLong: function (value) {
	                return write(8, value);
	            },
	            seek: function (offset, origin) {
	                if (origin === seekOrigin.Begin) {
	                    view._pos = offset;
	                } else if (origin === seekOrigin.Current) {
	                    view._pos += offset;
	                } else if (origin === seekOrigin.End) {
	                    view._pos = view.length + offset;
	                }
	            },
	            getView: function () {
	                return view;
	            }
	        };
	    }
	
	    function create2DArray(d1, d2, defaultValue) {
	        var result = [];
	        for (var i = 0; i < d1; i++) {
	            result[i] = result[i] || [];
	            for (var j = 0; j < d2; j++) {
	                if (defaultValue) {
	                    result[i][j] = defaultValue;
	                } else {
	                    result[i][j] = 0;
	                }
	
	            }
	        }
	        return result;
	    }
	
	    function buildSbox() {
	        return [ 
	            [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
	            [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
	            [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
	            [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
	            [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
	            [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
	            [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
	            [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
	            [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
	            [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
	            [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
	            [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
	            [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
	            [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
	            [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
	            [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]];
	    }
	
	    function buildInvSbox() {
	        return [
	            [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb],
	            [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb],
	            [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e],
	            [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25],
	            [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92],
	            [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84],
	            [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06],
	            [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b],
	            [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73],
	            [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e],
	            [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b],
	            [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4],
	            [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f],
	            [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef],
	            [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61],
	            [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]
	        ];
	
	    }
	
	    function buildRcon() {
	        return [
	            [0x00, 0x00, 0x00, 0x00],
	            [0x01, 0x00, 0x00, 0x00],
	            [0x02, 0x00, 0x00, 0x00],
	            [0x04, 0x00, 0x00, 0x00],
	            [0x08, 0x00, 0x00, 0x00],
	            [0x10, 0x00, 0x00, 0x00],
	            [0x20, 0x00, 0x00, 0x00],
	            [0x40, 0x00, 0x00, 0x00],
	            [0x80, 0x00, 0x00, 0x00],
	            [0x1b, 0x00, 0x00, 0x00],
	            [0x36, 0x00, 0x00, 0x00]];
	    }
	
	    function keyExpansion(nb, nr, nk, key, rcon, sbox) {
	        var w = create2DArray(nb * (nr + 1), 4, 0); 
	
	        for (var row = 0; row < nk; ++row) {
	            w[row][0] = key[4 * row];
	            w[row][1] = key[4 * row + 1];
	            w[row][2] = key[4 * row + 2];
	            w[row][3] = key[4 * row + 3];
	        }
	
	        var temp = [];
	
	        for (row = nk; row < nb * (nr + 1); ++row) {
	            temp[0] = w[row - 1][0];
	            temp[1] = w[row - 1][1];
	            temp[2] = w[row - 1][2];
	            temp[3] = w[row - 1][3];
	
	            if (row % nk === 0) {
	                temp = subWord(rotWord(temp), sbox);
	                temp[0] = (temp[0] ^ rcon[parseInt(row / nk)][0]) % 256;
	                temp[1] = (temp[1] ^ rcon[parseInt(row / nk)][1]) % 256;
	                temp[2] = (temp[2] ^ rcon[parseInt(row / nk)][2]) % 256;
	                temp[3] = (temp[3] ^ rcon[parseInt(row / nk)][3]) % 256;
	            } else if (nk > 6 && (row % nk === 4)) {
	                temp = subWord(temp);
	            }
	            w[row][0] = (w[row - nk][0] ^ temp[0]) % 256;
	            w[row][1] = (w[row - nk][1] ^ temp[1]) % 256;
	            w[row][2] = (w[row - nk][2] ^ temp[2]) % 256;
	            w[row][3] = (w[row - nk][3] ^ temp[3]) % 256;
	        }
	        return w;
	    }
	
	    function subWord(word, sbox) {
	        var result = [];
	        result[0] = sbox[word[0] >> 4][word[0] & 0x0f];
	        result[1] = sbox[word[1] >> 4][word[1] & 0x0f];
	        result[2] = sbox[word[2] >> 4][word[2] & 0x0f];
	        result[3] = sbox[word[3] >> 4][word[3] & 0x0f];
	        return result;
	    }
	
	    function rotWord(word) {
	        var result = [];
	        result[0] = word[1];
	        result[1] = word[2];
	        result[2] = word[3];
	        result[3] = word[0];
	        return result;
	    }
	
	    function gfmultby01(b) {
	        return b;
	    }
	
	    function gfmultby02(b) {
	        if (b < 0x80) {
	            return (b << 1) % 256;
	        }
	        return ((b << 1) ^ (0x1b)) % 256;
	    }
	
	    function gfmultby03(b) {
	        return (gfmultby02(b) ^ b) % 256;
	    }
	
	    function gfmultby09(b) {
	        return (gfmultby02(gfmultby02(gfmultby02(b))) ^ b) % 256;
	    }
	
	    function gfmultby0b(b) {
	        return (gfmultby02(gfmultby02(gfmultby02(b))) ^ gfmultby02(b) ^ b) % 256;
	    }
	
	    function gfmultby0d(b) {
	        return (gfmultby02(gfmultby02(gfmultby02(b))) ^ gfmultby02(gfmultby02(b)) ^ (b)) % 256;
	    }
	
	    function gfmultby0e(b) {
	        return (gfmultby02(gfmultby02(gfmultby02(b))) ^ gfmultby02(gfmultby02(b)) ^ gfmultby02(b)) % 256;
	    }
	
	    function stgGenerateRootEntry(customSectID) {
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var rootWriter = writer(view);
	        rootWriter.writeBytes(stringToByteArray("Root Entry"));
	        rootWriter.seek(0x40, seekOrigin.Begin);
	        rootWriter.writeShort(0x16);
	        rootWriter.writeByte(5);    
	        rootWriter.writeByte(0);    
	        rootWriter.writeInt(-1);    
	        rootWriter.writeInt(-1);    
	        rootWriter.writeInt(1);     
	
	        rootWriter.seek(0x64, seekOrigin.Begin);
	        rootWriter.writeInt(0);     
	        rootWriter.writeInt(0);     
	        rootWriter.writeInt(0);     
	        rootWriter.writeInt(0);     
	        rootWriter.writeInt(customSectID);     
	        rootWriter.writeInt(0x340);
	
	        return rootWriter.getView();
	    }
	
	    function stgGenerateEncryptionInfo() {
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var enInfoWriter = writer(view);
	        enInfoWriter.writeBytes(stringToByteArray("EncryptionInfo"));
	        enInfoWriter.seek(0x40, seekOrigin.Begin);
	        enInfoWriter.writeShort(0x1E); 
	        enInfoWriter.writeByte(2);     
	        enInfoWriter.writeByte(1);     
	        enInfoWriter.writeInt(0x03);   
	        enInfoWriter.writeInt(0x02);   
	        enInfoWriter.writeInt(-1);     
	
	        enInfoWriter.seek(0x64, seekOrigin.Begin);
	        enInfoWriter.writeInt(0);      
	        enInfoWriter.writeInt(0);      
	        enInfoWriter.writeInt(0);      
	        enInfoWriter.writeInt(0);      
	        enInfoWriter.writeInt(0);      
	        enInfoWriter.writeInt(0xF8);  
	
	        return enInfoWriter.getView();
	    }
	
	    function stgGenerateEncryptedPackage(propertyCount, size) {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var enPackageWriter = writer(view);
	        enPackageWriter.writeBytes(stringToByteArray("EncryptedPackage"));
	        enPackageWriter.seek(0x40, seekOrigin.Begin);
	        enPackageWriter.writeShort(0x22); 
	        enPackageWriter.writeByte(2);     
	        enPackageWriter.writeByte(0);     
	        enPackageWriter.writeInt(-1);     
	        enPackageWriter.writeInt(-1);     
	        enPackageWriter.writeInt(-1);     
	
	        enPackageWriter.seek(0x64, seekOrigin.Begin);
	        enPackageWriter.writeInt(0);      
	        enPackageWriter.writeInt(0);      
	        enPackageWriter.writeInt(0);      
	        enPackageWriter.writeInt(0);      
	        enPackageWriter.writeInt(propertyCount);      
	        enPackageWriter.writeInt(size);   
	
	        return enPackageWriter.getView();
	    }
	
	    function stgGenerateDataSpaces() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var dataSpaceWriter = writer(view);
	        dataSpaceWriter.writeShort(0x06);     
	        dataSpaceWriter.writeBytes(stringToByteArray("DataSpaces"));
	        dataSpaceWriter.seek(0x40, seekOrigin.Begin);
	        dataSpaceWriter.writeShort(0x18); 
	        dataSpaceWriter.writeByte(1);     
	        dataSpaceWriter.writeByte(0);     
	        dataSpaceWriter.writeInt(-1);     
	        dataSpaceWriter.writeInt(-1);     
	        dataSpaceWriter.writeInt(5);      
	
	        dataSpaceWriter.seek(0x64, seekOrigin.Begin);
	        dataSpaceWriter.writeInt(0);      
	        dataSpaceWriter.writeInt(0);      
	        dataSpaceWriter.writeInt(0);      
	        dataSpaceWriter.writeInt(0);      
	        dataSpaceWriter.writeInt(0);      
	        dataSpaceWriter.writeInt(0);   
	
	        return dataSpaceWriter.getView();
	    }
	
	    function stgGenerateVersion() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var versionWriter = writer(view);
	        versionWriter.writeBytes(stringToByteArray("Version"));
	        versionWriter.seek(0x40, seekOrigin.Begin);
	        versionWriter.writeShort(0x10); 
	        versionWriter.writeByte(2);     
	        versionWriter.writeByte(1);     
	        versionWriter.writeInt(-1);     
	        versionWriter.writeInt(-1);     
	        versionWriter.writeInt(-1);      
	
	        versionWriter.seek(0x64, seekOrigin.Begin);
	        versionWriter.writeInt(0);      
	        versionWriter.writeInt(0);      
	        versionWriter.writeInt(0);      
	        versionWriter.writeInt(0);      
	        versionWriter.writeInt(4);      
	        versionWriter.writeInt(76);     
	
	        return versionWriter.getView();
	    }
	
	    function stgGenerateDataSpaceMap() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var dataSpaceMapWriter = writer(view);
	        dataSpaceMapWriter.writeBytes(stringToByteArray("DataSpaceMap"));
	        dataSpaceMapWriter.seek(0x40, seekOrigin.Begin);
	        dataSpaceMapWriter.writeShort(0x1A); 
	        dataSpaceMapWriter.writeByte(2);     
	        dataSpaceMapWriter.writeByte(1);     
	        dataSpaceMapWriter.writeInt(0x04);   
	        dataSpaceMapWriter.writeInt(0x06);   
	        dataSpaceMapWriter.writeInt(-1);     
	
	        dataSpaceMapWriter.seek(0x64, seekOrigin.Begin);
	        dataSpaceMapWriter.writeInt(0);      
	        dataSpaceMapWriter.writeInt(0);      
	        dataSpaceMapWriter.writeInt(0);      
	        dataSpaceMapWriter.writeInt(0);      
	        dataSpaceMapWriter.writeInt(6);      
	        dataSpaceMapWriter.writeInt(112);    
	
	        return dataSpaceMapWriter.getView();
	    }
	
	    function stgGenerateDataSpaceInfo() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var dataSpaceInfoWriter = writer(view);
	        dataSpaceInfoWriter.writeBytes(stringToByteArray("DataSpaceInfo"));
	        dataSpaceInfoWriter.seek(0x40, seekOrigin.Begin);
	        dataSpaceInfoWriter.writeShort(0x1C); 
	        dataSpaceInfoWriter.writeByte(1);     
	        dataSpaceInfoWriter.writeByte(1);     
	        dataSpaceInfoWriter.writeInt(-1);     
	        dataSpaceInfoWriter.writeInt(8);      
	        dataSpaceInfoWriter.writeInt(7);      
	
	        dataSpaceInfoWriter.seek(0x64, seekOrigin.Begin);
	        dataSpaceInfoWriter.writeInt(0);      
	        dataSpaceInfoWriter.writeInt(0);      
	        dataSpaceInfoWriter.writeInt(0);      
	        dataSpaceInfoWriter.writeInt(0);      
	        dataSpaceInfoWriter.writeInt(0);      
	        dataSpaceInfoWriter.writeInt(0);      
	
	        return dataSpaceInfoWriter.getView();
	    }
	
	    function stgGenerateStrongEncryptionDataSpace() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var senDataSpaceWriter = writer(view);
	        senDataSpaceWriter.writeBytes(stringToByteArray("StrongEncryptionDataSpace"));
	        senDataSpaceWriter.seek(0x40, seekOrigin.Begin);
	        senDataSpaceWriter.writeShort(0x34); 
	        senDataSpaceWriter.writeByte(2);     
	        senDataSpaceWriter.writeByte(1);     
	        senDataSpaceWriter.writeInt(-1);     
	        senDataSpaceWriter.writeInt(-1);      
	        senDataSpaceWriter.writeInt(-1);      
	
	        senDataSpaceWriter.seek(0x64, seekOrigin.Begin);
	        senDataSpaceWriter.writeInt(0);      
	        senDataSpaceWriter.writeInt(0);      
	        senDataSpaceWriter.writeInt(0);      
	        senDataSpaceWriter.writeInt(0);      
	        senDataSpaceWriter.writeInt(8);      
	        senDataSpaceWriter.writeInt(64);      
	
	        return senDataSpaceWriter.getView();
	    }
	
	    function stgGenerateTransformInfo() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var transformInfoWriter = writer(view);
	        transformInfoWriter.writeBytes(stringToByteArray("TransformInfo"));
	        transformInfoWriter.seek(0x40, seekOrigin.Begin);
	        transformInfoWriter.writeShort(0x1C); 
	        transformInfoWriter.writeByte(1);     
	        transformInfoWriter.writeByte(0);     
	        transformInfoWriter.writeInt(-1);     
	        transformInfoWriter.writeInt(-1);     
	        transformInfoWriter.writeInt(9);      
	
	        transformInfoWriter.seek(0x64, seekOrigin.Begin);
	        transformInfoWriter.writeInt(0);      
	        transformInfoWriter.writeInt(0);      
	        transformInfoWriter.writeInt(0);      
	        transformInfoWriter.writeInt(0);      
	        transformInfoWriter.writeInt(0);      
	        transformInfoWriter.writeInt(0);      
	
	        return transformInfoWriter.getView();
	    }
	
	    function stgGenerateStrongEncryptionTransform() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var seTransformWriter = writer(view);
	        seTransformWriter.writeBytes(stringToByteArray("StrongEncryptionTransform"));
	        seTransformWriter.seek(0x40, seekOrigin.Begin);
	        seTransformWriter.writeShort(0x34); 
	        seTransformWriter.writeByte(1);     
	        seTransformWriter.writeByte(1);     
	        seTransformWriter.writeInt(-1);     
	        seTransformWriter.writeInt(-1);     
	        seTransformWriter.writeInt(0x0A);   
	
	        seTransformWriter.seek(0x64, seekOrigin.Begin);
	        seTransformWriter.writeInt(0);      
	        seTransformWriter.writeInt(0);      
	        seTransformWriter.writeInt(0);      
	        seTransformWriter.writeInt(0);      
	        seTransformWriter.writeInt(0);      
	        seTransformWriter.writeInt(0);      
	
	        return seTransformWriter.getView();
	    }
	
	    function stgGeneratePrimary() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var primaryWriter = writer(view);
	        primaryWriter.writeShort(0x06);
	        primaryWriter.writeBytes(stringToByteArray("Primary"));
	        primaryWriter.seek(0x40, seekOrigin.Begin);
	        primaryWriter.writeShort(0x12);        
	        primaryWriter.writeByte(2);     
	        primaryWriter.writeByte(1);      
	        primaryWriter.writeInt(-1);      
	        primaryWriter.writeInt(-1);      
	        primaryWriter.writeInt(-1);      
	
	        primaryWriter.seek(0x64, seekOrigin.Begin);
	        primaryWriter.writeInt(0);      
	        primaryWriter.writeInt(0);      
	        primaryWriter.writeInt(0);      
	        primaryWriter.writeInt(0);      
	        primaryWriter.writeInt(9);      
	        primaryWriter.writeInt(208);    
	
	
	        return primaryWriter.getView();
	    }
	
	    function stgGenerateNoneDir() {
	
	        var view = [];
	        for (var i = 0; i < 128; i++) {
	            view[i] = 0;
	        }
	        view._pos = 0;
	        var noneWriter = writer(view);
	        noneWriter.seek(0x40, seekOrigin.Begin);
	        noneWriter.writeShort(0x00);
	        noneWriter.writeShort(0x00);
	        noneWriter.writeInt(-1);
	        noneWriter.writeInt(-1);
	        noneWriter.writeInt(-1);
	
	        return noneWriter.getView();
	    }
	
	    function stgGenerateDirectoryEntry(propertyCount, customSectID, size) {
	        var view = [];
	        view._pos = 0;
	        var dirEntryStream = writer(view);
	        if (size < 0) {
	            size = 0;
	        }
	       
	       
	        var rootEntry = stgGenerateRootEntry(customSectID);
	        dirEntryStream.writeBytes(rootEntry);
	
	       
	       
	        var encryptionInfoEntry = stgGenerateEncryptionInfo();
	        dirEntryStream.writeBytes(encryptionInfoEntry);
	
	       
	       
	        var enPackageEntry = stgGenerateEncryptedPackage(propertyCount, size);
	        dirEntryStream.writeBytes(enPackageEntry);
	
	       
	        var dataSpace = stgGenerateDataSpaces();
	        dirEntryStream.writeBytes(dataSpace);
	
	       
	        var version = stgGenerateVersion();
	        dirEntryStream.writeBytes(version);
	
	       
	        var dataSpaceMap = stgGenerateDataSpaceMap();
	        dirEntryStream.writeBytes(dataSpaceMap);
	
	       
	        var dataSpaceInfo = stgGenerateDataSpaceInfo();
	        dirEntryStream.writeBytes(dataSpaceInfo);
	
	       
	        var sedataSpace = stgGenerateStrongEncryptionDataSpace();
	        dirEntryStream.writeBytes(sedataSpace);
	
	       
	        var transformInfo = stgGenerateTransformInfo();
	        dirEntryStream.writeBytes(transformInfo);
	
	       
	        var seTransform = stgGenerateStrongEncryptionTransform();
	        dirEntryStream.writeBytes(seTransform);
	
	       
	        var primary = stgGeneratePrimary();
	        dirEntryStream.writeBytes(primary);
	
	       
	        var none = stgGenerateNoneDir();
	        dirEntryStream.writeBytes(none);
	
	
	        return dirEntryStream.getView();
	    }
	
	    function stgGenerateVersionStream() {
	        var view = [];
	        view._pos = 0;
	        var versionWrite = writer(view);
	        versionWrite.writeInt(0x3c); 
	        versionWrite.writeBytes(stringToByteArray("Microsoft.Container.DataSpaces"));
	        versionWrite.writeInt(0x01); 
	        versionWrite.writeInt(0x01); 
	        versionWrite.writeInt(0x01); 
	        return versionWrite.getView();
	    }
	
	    function stgGenarateDataSpaceMapStream() {
	        var view = [];
	        view._pos = 0;
	        var dataSpaceMapWrite = writer(view);
	        dataSpaceMapWrite.writeUint(0x08);      
	        dataSpaceMapWrite.writeUint(0x01);      
	       
	        dataSpaceMapWrite.writeUint(0x68);      
	        dataSpaceMapWrite.writeUint(0x01);      
	       
	        dataSpaceMapWrite.writeUint(0x00);      
	        dataSpaceMapWrite.writeUint(0x20);      
	        dataSpaceMapWrite.writeBytes(stringToByteArray("EncryptedPackage"));
	        dataSpaceMapWrite.writeUint(0x32);      
	        dataSpaceMapWrite.writeBytes(stringToByteArray("StrongEncryptionDataSpace"));
	        dataSpaceMapWrite.writeShort(0x00);
	        return dataSpaceMapWrite.getView();
	    }
	
	    function stgGenarateStrongEncryptionDataSpaceStream() {
	        var view = [];
	        view._pos = 0;
	        var sEptDataSpaceWrite = writer(view);
	        sEptDataSpaceWrite.writeUint(0x08);   
	        sEptDataSpaceWrite.writeUint(0x01);   
	        sEptDataSpaceWrite.writeUint(0x32);   
	        sEptDataSpaceWrite.writeBytes(stringToByteArray("StrongEncryptionTransform"));//StrongEncryptionDataSpace
	        sEptDataSpaceWrite.writeShort(0x00);
	        return sEptDataSpaceWrite.getView();
	    }
	
	    function stgGenaratePrimaryStream() {
	        var view = [];
	        view._pos = 0;
	        var primaryWrite = writer(view);
	        primaryWrite.writeUint(0x6C);        
	        primaryWrite.writeUint(0x01);         
	       
	        primaryWrite.writeInt(0x4C);          
	        primaryWrite.writeBytes(stringToByteArray("{FF9A3F03-56EF-4613-BDD5-5A41C1D07246}"));
	        primaryWrite.writeInt(0x4E);          
	        primaryWrite.writeBytes(stringToByteArray("Microsoft.Container.EncryptionTransform"));
	        primaryWrite.writeShort(0x00);          
	
	        primaryWrite.writeInt(0x01);         
	        primaryWrite.writeInt(0x01);         
	        primaryWrite.writeInt(0x01);         
	
	       
	        primaryWrite.writeInt(0x07);         
	        primaryWrite.writeBytes(stringToByteArray("AES128"));
	        primaryWrite.writeByte(0);           
	
	       
	        primaryWrite.writeInt(0x10);
	        primaryWrite.writeInt(0x00);
	        primaryWrite.writeInt(0x04);
	
	
	        return primaryWrite.getView();
	    }
	
	    function stgGenerateCustomFileStream(encStreamInfo, ssatList) {
	        var view = [];
	        view._pos = 0;
	        var customFile = writer(view);
	
	        var miniPropertyCount = 0;
	
	       
	       
	        var encStream = new Array(0x100);
	        if (encStreamInfo !== null) {
	            arrayCopy(encStreamInfo, 0, encStream, 0, encStreamInfo.length);
	        }
	        customFile.writeBytes(encStream);
	        var encStreamBlockCount = parseInt(encStream.length / 64);
	        if (encStream.length % 64 > 0) {
	            encStreamBlockCount++;
	        }
	
	        for (var i = 1; i < encStreamBlockCount; i++) {
	            ssatList.push(i);
	        }
	
	        ssatList.push(-2);
	        miniPropertyCount += encStreamBlockCount;
	
	       
	       
	        var versionStream = new Array(0x80);
	        var version = stgGenerateVersionStream();
	        arrayCopy(version, 0, versionStream, 0, version.length);
	        customFile.writeBytes(versionStream);
	        var versionBlockCount = parseInt(versionStream.length / 64);
	        if (versionStream.length % 64 > 0) {
	            versionBlockCount++;
	        }
	
	        for (i = 1; i < versionBlockCount; i++) {
	            ssatList.push(i + miniPropertyCount);
	        }
	
	        ssatList.push(-2);
	        miniPropertyCount += versionBlockCount;
	
	       
	       
	        var dataSpaceMap = new Array(0x80);
	        var datasm = stgGenarateDataSpaceMapStream();
	        arrayCopy(datasm, 0, dataSpaceMap, 0, datasm.length);
	        customFile.writeBytes(dataSpaceMap);
	        var dataSpaceMapBlockCount = parseInt(dataSpaceMap.length / 64);
	        if (dataSpaceMap.length % 64 > 0) {
	            dataSpaceMapBlockCount++;
	        }
	
	        for (i = 1; i < dataSpaceMapBlockCount; i++) {
	            ssatList.push(i + miniPropertyCount);
	        }
	        ssatList.push(-2);
	        miniPropertyCount += dataSpaceMapBlockCount;
	
	       
	       
	        var seDataSpace = stgGenarateStrongEncryptionDataSpaceStream();
	        customFile.writeBytes(seDataSpace);
	
	        var seDataSpaceBlockCount = parseInt(seDataSpace.length / 64);
	        if (seDataSpace.length % 64 > 0) {
	            seDataSpaceBlockCount++;
	        }
	
	        for (i = 1; i < seDataSpaceBlockCount; i++) {
	            ssatList.push(i + miniPropertyCount);
	        }
	        ssatList.push(-2);
	        miniPropertyCount += seDataSpaceBlockCount;
	
	       
	       
	        var primaryStream = new Array(0x1C0);
	        var primary = stgGenaratePrimaryStream();
	        arrayCopy(primary, 0, primaryStream, 0, primary.length);
	        customFile.writeBytes(primaryStream);
	
	        var primaryBlockCount = parseInt(primary.length / 64);
	        if (primary.length % 64 > 0) {
	            primaryBlockCount++;
	        }
	
	        for (i = 1; i < primaryBlockCount; i++) {
	            ssatList.push(i + miniPropertyCount);
	        }
	
	        ssatList.push(-2);
	
	        if (ssatList.length < 128) {
	            for (i = ssatList.length; i < 128; i++) {
	                ssatList.push(-1);
	            }
	        }
	        customFile.seek(0, seekOrigin.Begin);
	
	        return customFile.getView();
	    }
	
	    function addRoundKey(round, state, w) {
	        for (var r = 0; r < 4; ++r) {
	            for (var c = 0; c < 4; ++c) {
	                state[r][c] = (state[r][c] ^ w[(round * 4) + c][r]) % 256;
	            }
	        }
	        return state;
	    }
	
	    function shiftRows(state, nb) {
	        var temp = create2DArray(4, 4, 0);
	        for (var r = 0; r < 4; ++r) {
	           
	            for (var c = 0; c < 4; ++c) {
	                temp[r][c] = state[r][c];
	            }
	        }
	
	        for (r = 1; r < 4; ++r) {
	           
	
	            for (c = 0; c < 4; ++c) {
	                state[r][c] = temp[r][(c + r) % nb];
	            }
	        }
	        return state;
	    }
	
	    function mixColumns(state) {
	        var temp = create2DArray(4, 4, 0);
	        for (var r = 0; r < 4; ++r) {
	
	            for (var c = 0; c < 4; ++c) {
	                temp[r][c] = state[r][c];
	            }
	        }
	
	        for (c = 0; c < 4; ++c) {
	            state[0][c] = (gfmultby02(temp[0][c]) ^ gfmultby03(temp[1][c]) ^ gfmultby01(temp[2][c]) ^ gfmultby01(temp[3][c])) % 256;
	            state[1][c] = (gfmultby01(temp[0][c]) ^ gfmultby02(temp[1][c]) ^ gfmultby03(temp[2][c]) ^ gfmultby01(temp[3][c])) % 256;
	            state[2][c] = (gfmultby01(temp[0][c]) ^ gfmultby01(temp[1][c]) ^ gfmultby02(temp[2][c]) ^ gfmultby03(temp[3][c])) % 256;
	            state[3][c] = (gfmultby03(temp[0][c]) ^ gfmultby01(temp[1][c]) ^ gfmultby01(temp[2][c]) ^ gfmultby02(temp[3][c])) % 256;
	        }
	        return state;
	    }
	
	    function subBytes(state, sbox) {
	        for (var r = 0; r < 4; ++r) {
	            for (var c = 0; c < 4; ++c) {
	                state[r][c] = sbox[(state[r][c] >> 4)][(state[r][c] & 0x0f)];
	            }
	        }
	        return state;
	    }
	
	    var AesEngine = function () {
	        this.salt = new Array(16) ;
	        this.pwdVerifier = new Array(16);
	        this.pwdVerifierHash = new Array(32);
	        this.blockLen = 16;
	        this._isAgileEncrypt = false;
	        this.hashAlgorithm = "SHA1";
	        this.cipherChaining = "ChainingModeCBC";
	        this.cipherAlgorithm = "AES";
	        this.iterator = 100000;
	        this.blockSize = 16;
	        this.keyBits = 128;
	        this.saltSize = 16;
	        this.hashSize = 20;
	        this.encryptedKeyValueBlockKey = [0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6];
	        this.encryptedVerifierHashInputBlockKey = [0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79];
	        this.encryptedVerifierHashValueBlockKey = [0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e];
	
	    };
	    var keyType = {
	        Bits128: 'Bits128',
	        Bits192: 'Bits192',
	        Bits256: 'Bits256'
	    };
	    AesEngine.prototype = {
	        _progressStream: function (view) {
	            view._pos = 0;
	            var read = reader(view);
	            var vMajor = read.readInt16();
	            var vMinor = read.readInt16();
	            if ((vMajor === 0x0003 || vMajor === 0x0004) && vMinor === 0x0002) {
	                read.seek(0x08, seekOrigin.Begin);
	                var length = read.readUInt32() + 12;  
	                read.seek(0x1C, seekOrigin.Begin);
	                var key = read.readInt32();
	                if (key === 128) {
	                    this.keySize = keyType.Bits128;
	                } else if (key === 192) {
	                    this.keySize = keyType.Bits192;
	                } else if (key === 256) {
	                    this.keySize = keyType.Bits256;
	                }
	                read.seek(length, seekOrigin.Begin);
	                var saltSize = read.readInt32();
	
	                length += 4;
	                read.seek(length, seekOrigin.Begin);
	                this.salt = read.readBytes(saltSize);
	
	                length += saltSize;
	                read.seek(length, seekOrigin.Begin);
	                this.pwdVerifier = read.readBytes(saltSize);
	
	                length += saltSize;
	                read.seek(length, seekOrigin.Begin);
	                read.readInt32();//verifierHashSize
	
	                length += 4;
	                read.seek(length, seekOrigin.Begin);
	                this.pwdVerifierHash = read.readBytes(saltSize * 2);
	
	                return true;
	            } else if (vMajor === 0x0004 && vMinor === 0x0004) {
	                var reserved = read.readUInt32();
	                if (reserved === 0x40) {
	                    var buffer = read.readBytes(view.length - 8);
	
	                    if (buffer !== null) {
	                        var obj = parseXmlToObject(String.fromCharCode.apply(null, buffer));
	                        var encryption = {};
	                        var rootNode = obj['encryption'];
	                        var keyEncryptors = [];
	                        var keyDataNode = rootNode['keyData'];
	                        var keyData = {};
	                        keyData.SaltSize = keyDataNode._attr["saltSize"] ? keyDataNode._attr["saltSize"] : 16;
	                        keyData.BlockSize = keyDataNode._attr["blockSize"] ? keyDataNode._attr["blockSize"] : 16;
	                        keyData.KeyBits = keyDataNode._attr["keyBits"] ? keyDataNode._attr["keyBits"] : 128;
	                        keyData.HashSize = keyDataNode._attr["hashSize"] ? keyDataNode._attr["hashSize"] : 20;
	                        keyData.CipherAlgorithm = keyDataNode._attr["cipherAlgorithm"] ? keyDataNode._attr["cipherAlgorithm"] : "AES";
	                        keyData.CipherChaining = keyDataNode._attr["cipherChaining"] ? keyDataNode._attr["cipherChaining"] : 'ChainingModeCBC';
	                        keyData.HashAlgorithm = keyDataNode._attr["hashAlgorithm"] ? keyDataNode._attr["hashAlgorithm"] : "SHA1";
	                        keyData.SaltValue = base64ToBytes(keyDataNode._attr["saltValue"]);
	                        encryption.KeyData = keyData;
	
	                        var dataIntegrityNode = rootNode['dataIntegrity'];
	                        var dataIntegrity = {};
	                        dataIntegrity.EncryptedHmacKey = dataIntegrityNode._attr["encryptedHmacKey"];
	                        dataIntegrity.EncryptedHmacValue = dataIntegrityNode._attr["encryptedHmacValue"];
	                        encryption.DataIntegrity = dataIntegrity;
	
	                        var keyEncryptorsNode = rootNode['keyEncryptors'];
	                        var keyEncrptor = {};
	                        keyEncrptor.Uri = keyEncryptorsNode._attr["uri"] ? keyEncryptorsNode._attr["uri"] : "http://schemas.microsoft.com/office/2006/keyEncryptor/password";
	                        keyEncrptor.Any = {};
	                        var keyEncryptorNode = getAsArray(keyEncryptorsNode['keyEncryptor']);
	                        if (keyEncryptorNode && keyEncryptorNode.length) {
	                            keyEncryptorNode.forEach(function (node) {
	                                var encryptedKeyNode = node['p:encryptedKey'];
	                                keyEncrptor.Any.SpinCount = encryptedKeyNode._attr["spinCount"] ? encryptedKeyNode._attr["spinCount"] : 100000;
	                                keyEncrptor.Any.SaltSize = encryptedKeyNode._attr["saltSize"] ? encryptedKeyNode._attr["saltSize"] : 16;
	                                keyEncrptor.Any.BlockSize = encryptedKeyNode._attr["blockSize"] ? encryptedKeyNode._attr["blockSize"] : 16;
	                                keyEncrptor.Any.KeyBits = encryptedKeyNode._attr["keyBits"] ? encryptedKeyNode._attr["keyBits"] : 128;
	                                keyEncrptor.Any.HashSize = encryptedKeyNode._attr["hashSize"] ? encryptedKeyNode._attr["hashSize"] : 20;
	                                keyEncrptor.Any.CipherAlgorithm = encryptedKeyNode._attr["cipherAlgorithm"] ? encryptedKeyNode._attr["cipherAlgorithm"] : "AES";
	                                keyEncrptor.Any.CipherChaining = encryptedKeyNode._attr["cipherChaining"] ? encryptedKeyNode._attr["cipherChaining"] : "ChainingModeCBC";
	                                keyEncrptor.Any.HashAlgorithm = encryptedKeyNode._attr["hashAlgorithm"] ? encryptedKeyNode._attr["hashAlgorithm"] : "SHA1";
	                                keyEncrptor.Any.SaltValue = base64ToBytes(encryptedKeyNode._attr["saltValue"]);
	                                keyEncrptor.Any.EncryptedVerifierHashInput = base64ToBytes(encryptedKeyNode._attr["encryptedVerifierHashInput"]);
	                                keyEncrptor.Any.EncryptedVerifierHashValue = base64ToBytes(encryptedKeyNode._attr["encryptedVerifierHashValue"]);
	                                keyEncrptor.Any.EncryptedKeyValue = base64ToBytes(encryptedKeyNode._attr["encryptedKeyValue"]);
	
	                                keyEncryptors.push(keyEncrptor);
	                                encryption.KeyEncryptors = keyEncryptors;
	                            });
	                        }
	
	                        var passKeyEncrypt = encryption.KeyEncryptors[0].Any;
	
	                        this.iterator = parseInt(passKeyEncrypt.SpinCount);
	                        this.blockSize = passKeyEncrypt.BlockSize;
	                        this.saltSize = passKeyEncrypt.SaltSize;
	                        this.hashSize = passKeyEncrypt.HashSize;
	                        this.keyBits = passKeyEncrypt.KeyBits;
	
	                        this.hashAlgorithm = passKeyEncrypt.HashAlgorithm;
	                        this.cipherAlgorithm = passKeyEncrypt.CipherAlgorithm;
	                        this.cipherChaining = passKeyEncrypt.CipherChaining;
	
	                        this.encryptedKeyValue = passKeyEncrypt.EncryptedKeyValue;
	                        this.encryptedVerifierHashInput = passKeyEncrypt.EncryptedVerifierHashInput;
	                        this.encryptedVerifierHashValue = passKeyEncrypt.EncryptedVerifierHashValue;
	                        this.salt = passKeyEncrypt.SaltValue;
	                        this.saltForIV = encryption.KeyData.SaltValue;
	                        this._isAgileEncrypt = true;
	                        return this.cipherAlgorithm === "AES";
	                    }
	                }
	            }
	            return false;
	        },
	        _agileVerifyPassWord: function (passWord) {
	            this.userPassWord = passWord;
	            var iv = this._agileInitializationVector(this.salt, null, this.blockSize);
	
	           
	            var encryptionKey = this._agileEncryptionKeyCreateKey(passWord, this.encryptedVerifierHashInputBlockKey, this.salt);
	            var tmp = this._agileDecrypt(this.saltSize, encryptionKey, this.encryptedVerifierHashInput, iv);
	            tmp = Sha.hash(tmp);
	            var hashInput = new Array(this.saltSize);
	            arrayCopy(tmp, 0, hashInput, 0, this.saltSize);
	
	           
	            encryptionKey = this._agileEncryptionKeyCreateKey(passWord, this.encryptedVerifierHashValueBlockKey, this.salt);
	            var hashValue = this._agileEncrypt(hashInput, encryptionKey, iv);
	
	           
	            var length = this.encryptedVerifierHashValue.length;
	            if (length > hashValue.length) {
	                length = hashValue.length;
	            }
	            for (var i = 0; i < length; i++) {
	                if (hashValue[i] !== this.encryptedVerifierHashValue[i]) {
	                    return false;
	                }
	            }
	
	            return true;
	        },
	        _agileEncrypt: function (unEncryptedBytes, encryptionKey, initVectorBytes) {
	            var aesCbc = new aesjs.ModeOfOperation.cbc(encryptionKey, initVectorBytes);
	            return aesCbc.encrypt(unEncryptedBytes);
	        },
	
	        _agileDecrypt: function (unEncryptedLength, encryptionKey, encryptedBytes, iv) {
	            var decryptedBytes = null;
	            var aseBuffer = [];
	            var subAseBuffer;
	            var blockStartIndex = 0;
	            var blockUnit = 4096;
	            var blockCount = parseInt(encryptedBytes.length / blockUnit);
	            var uIv;
	            for (var i = 0; i < blockCount; i++) {
	                if (!iv) {
	                    uIv = this._agileInitializationVector(this.saltForIV, getBytesFromInt(4, i), this.blockSize);
	                } else {
	                    uIv = iv;
	                }
	                var aesCbc = new aesjs.ModeOfOperation.cbc(encryptionKey, uIv);
	                subAseBuffer = aesCbc.decrypt(BufferHelper._slice(encryptedBytes, blockStartIndex, blockStartIndex + blockUnit));
	
	                arrayCopy(subAseBuffer, 0, aseBuffer, blockStartIndex, blockUnit);
	                blockStartIndex += blockUnit;
	            }
	            var byteLeft = encryptedBytes.length % blockUnit;
	            if (byteLeft > 0) {
	                if (!iv) {
	                    uIv = this._agileInitializationVector(this.saltForIV, getBytesFromInt(4, blockCount), this.blockSize);
	                } else {
	                    uIv = iv;
	                }
	                aesCbc = new aesjs.ModeOfOperation.cbc(encryptionKey, uIv);
	                subAseBuffer = aesCbc.decrypt(BufferHelper._slice(encryptedBytes, blockStartIndex, blockStartIndex + byteLeft));
	                arrayCopy(subAseBuffer, 0, aseBuffer, blockStartIndex, byteLeft);
	            }
	            decryptedBytes = new Array(unEncryptedLength);
	            arrayCopy(aseBuffer, 0, decryptedBytes, 0, unEncryptedLength);
	            return decryptedBytes;
	        },
	        _agileInitializationVector: function (keySalt, blockKey, ivSize) {
	            var tmp = keySalt;
	            if (blockKey !== null) {
	                tmp = hashByte(tmp, blockKey, this.hashAlgorithm);
	            }
	            ivSize = +ivSize;//convert to num, ie don't support string number as Uint8Array constructor parameter.
	            var iv = new Uint8Array(ivSize);
	            var ivLength = tmp.length;
	
	            arrayCopy(tmp, 0, iv, 0, Math.min(ivSize, ivLength));
	            for (var i = ivLength; i < ivSize; i++) {
	                iv[i] = 0x36;
	            }
	            return iv;
	        },
	        _agileEncryptionKeyCreateKey: function (passWord, blockKey, saltValue) {
	            var pwd = getBytesFromString(passWord);
	            var tmp = hashByte(saltValue, pwd, this.hashAlgorithm);
	            for (var i = 0; i < this.iterator; i++) {
	                var tmpI = getBytesFromInt(4, i);
	                tmp = hashByte(tmpI, tmp, this.hashAlgorithm);
	            }
	            tmp = hashByte(tmp, blockKey, this.hashAlgorithm);
	            var keyBytes = this.keyBits / 8;
	
	            var encryptionKey = [];
	            var keyLength = tmp.length;
	
	            var minValue = Math.min(keyLength, keyBytes);
	            for (var k = 0; k < minValue; k++) {
	                encryptionKey[k] = tmp[k];
	            }
	            for (i = keyLength; i < keyBytes; i++) {
	                encryptionKey[i] = 54;
	            }
	            return encryptionKey;
	        },
	        _agileDecryptStream: function (view) {
	            var result = { success: false };
	            if (view === null) {
	                return result;
	            }
	            view._pos = 0;
	            var read = reader(view);
	            var length = read.readUInt64();       
	            var encryptedBytes = read.readBytes(view.length - 8);
	            this._agileIntermediateKeyCreateKey(this.userPassWord);
	            var decryptedBytes = this._agileDecrypt(length, this.key, encryptedBytes, null);
	            if (decryptedBytes !== null) {
	                result.data = decryptedBytes;
	                result.success = true;
	            }
	            return result;
	        },
	        _agileIntermediateKeyCreateKey: function (passWord) {
	            var encryptionKey = this._agileEncryptionKeyCreateKey(passWord, this.encryptedKeyValueBlockKey, this.salt);
	            var iv = this._agileInitializationVector(this.salt, null, this.blockSize);
	            var keyBytes = this.keyBits / 8;
	            this.key = this._agileDecrypt(keyBytes, encryptionKey, this.encryptedKeyValue, iv);
	        },
	        _decryptStream: function (inStream) {
	            if (!inStream) {
	                return false;
	            }
	            inStream._pos = 0;
	            var read = reader(inStream);
	
	            var length = read.readInt64();       
	            var encsuffer = read.readBytes(inStream.length - 8);
	            var biffBuffer = null;
	            var aesCbc = new aesjs.ModeOfOperation.ecb(this.key);
	            var aseBuffer = aesCbc.decrypt(encsuffer);
	            var buf = new Array(length);
	            if (aseBuffer) {
	                arrayCopy(aseBuffer, 0, buf, 0, buf.length);
	            } else {
	                arrayCopy(biffBuffer, 0, buf, 0, buf.length);
	            }
	            return { success: true, data: buf };
	        },
	        _createKey: createKey,
	        _createEncryptInfo: function (password) {
	            if (!password || password.length > 256) {
	                return;
	            }
	            var view = [];
	            view._pos = 0;
	            var write = writer(view);
	
	           
	            write.writeUshort(0x0003); 
	            write.writeUshort(0x0002); 
	           
	            write.writeInt(0x24);      
	           
	            write.writeUint(0xA4);   
	           
	            write.writeInt(0x24);      
	            write.writeInt(0x00);      
	            write.writeInt(0x660E);    
	            write.writeInt(0x8004);    
	            write.writeUint(0x80);     
	            write.writeInt(0x18);      
	            write.writeLong(0x00);     
	           
	            var providerName = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
	            write.writeBytes(stringToByteArray(providerName));
	            write.writeShort(0x00);
	           
	            write.writeInt(0x10);      
	            this._generalEncryptHead(password);
	            if (this._verifyPassword()) {
	                write.writeBytes(this.salt);           
	                write.writeBytes(this.pwdVerifier);    
	                write.writeUint(0x14);     
	                write.writeBytes(this.pwdVerifierHash);
	            }
	            write.seek(0, seekOrigin.Begin);
	
	            return write.getView();
	        },
	        _generalEncryptHead: function (password) {
	            var tempSalt = [];
	            var verifier = [];
	            for (var i = 0; i < this.blockLen; i++) {
	                tempSalt[i] = parseInt(Math.random() * 255);
	                verifier[i] = parseInt(Math.random() * 255);
	            }
	            this.salt = tempSalt;
	            this.key = createKey(password, this.salt, this.hashAlgorithm);
	            this._initAesEngine(keyType.Bits128, this.key);
	            var verifierHash = Sha1.hash(verifier);
	
	            this.pwdVerifier = this._cipher(verifier);
	            this.pwdVerifierHash = this._cipher(verifierHash);
	
	            return true;
	        },
	        _initAesEngine: function (keySize, keyBytes) {
	            this.Nb = 4;    
	            if (keySize === keyType.Bits128) {
	                this.Nk = 4;  
	                this.Nr = 10; 
	            } else if (keySize === keyType.Bits192) {
	                this.Nk = 6;  
	                this.Nr = 12;
	            } else if (keySize === keyType.Bits256) {
	                this.Nk = 8;  
	                this.Nr = 14;
	            }
	            this.key = [].concat(keyBytes);
	            this.Sbox = buildSbox();
	            this.iSbox = buildInvSbox();
	            this.Rcon = buildRcon();
	            this.w = keyExpansion(this.Nb, this.Nr, this.Nk, this.key, this.Rcon, this.Sbox);
	        },
	
	
	        _cipher: function (input) {
	            var outputLen = input.length;
	            var rem = input.length % this.blockLen;
	            if (rem !== 0) {
	                outputLen += this.blockLen - rem;
	            }
	
	
	            var output = [];
	            arrayCopy(input, 0, output, 0, input.length);
	
	            var tmpInput = [];
	            var tmpOutput = [];
	            for (var i = 0; i < outputLen; i += this.blockLen) {
	                arrayCopy(output, i, tmpInput, 0, this.blockLen);
	                this._cipherInternal(tmpInput, tmpOutput);
	                arrayCopy(tmpOutput, 0, output, i, this.blockLen);
	            }
	            return output;
	        },
	        _cipherInternal: function (input, output) {
	            this.State = create2DArray(4, this.Nb); 
	            for (var i = 0; i < (4 * this.Nb); ++i) {
	                this.State[i % 4][parseInt(i / 4)] = input[i];
	            }
	
	            this.State = addRoundKey(0, this.State, this.w);
	
	            for (var round = 1; round <= (this.Nr - 1); ++round) {
	                this.State = subBytes(this.State, this.Sbox);
	                this.State = shiftRows(this.State, this.Nb);
	                this.State = mixColumns(this.State);
	                this.State = addRoundKey(round, this.State, this.w);
	            } 
	            this.State = subBytes(this.State, this.Sbox);
	            this.State = shiftRows(this.State, this.Nb);
	            this.State = addRoundKey(this.Nr, this.State, this.w);
	
	           
	            for (i = 0; i < (4 * this.Nb); ++i) {
	                output[i] = this.State[i % 4][parseInt(i / 4)];
	            }
	        },
	
	        _verifyPassword: function () {
	            var sha = Sha1;
	
	            var pwdVerifierDec = this._invCipher(this.pwdVerifier);
	            var pwdVerifierHashDec = this._invCipher(this.pwdVerifierHash);
	
	            pwdVerifierDec = sha.hash(pwdVerifierDec);
	
	            for (var i = 0; i < pwdVerifierDec.length; i++) {
	                if (pwdVerifierDec[i] !== pwdVerifierHashDec[i]) {
	                    return false;
	                }
	            }
	            return true;
	        },
	        _invCipher: function (input) {
	            if (input === null) {
	                return null;
	            }
	            var outputLength = input.length;
	            if (input.length % this.blockLen !== 0) {
	                return;
	            }
	            if (outputLength > input.length) {
	                return;
	            }
	
	            var output = [];
	            var tmpInput = [];
	            var tmpOutput = [];
	            for (var i = 0; i < input.length; i += this.blockLen) {
	                arrayCopy(input, i, tmpInput, 0, this.blockLen);
	                this._invCipherInternal(tmpInput, tmpOutput);
	                var len = i + this.blockLen - outputLength;
	                arrayCopy(tmpOutput, 0, output, i, len > 0 ? this.blockLen - len : this.blockLen);
	            }
	            return output;
	        },
	        _invCipherInternal: function (input, output) {
	            this.State = create2DArray(4, this.Nb); 
	            for (var i = 0; i < (4 * this.Nb); ++i) {
	                this.State[i % 4][parseInt(i / 4)] = input[i];
	            }
	
	            this.State = addRoundKey(this.Nr, this.State, this.w);
	
	            for (var round = this.Nr - 1; round >= 1; --round) { 
	
	                this._invShiftRows();
	                this._invSubBytes();
	                this.State = addRoundKey(round, this.State, this.w);
	                this._invMixColumns();
	            } 
	
	            this._invShiftRows();
	            this._invSubBytes();
	            this.State = addRoundKey(0, this.State, this.w);
	
	           
	            for (i = 0; i < (4 * this.Nb); ++i) {
	                output[i] = this.State[i % 4][parseInt(i / 4)];
	            }
	        },
	        _invShiftRows: function () {
	            var temp = create2DArray(4, 4);
	            for (var r = 0; r < 4; ++r) {
	                for (var c = 0; c < 4; ++c) {
	                    temp[r][c] = this.State[r][c];
	                }
	            }
	            for (r = 1; r < 4; ++r) {
	                for (c = 0; c < 4; ++c) {
	                    this.State[r][(c + r) % this.Nb] = temp[r][c];
	                }
	            }
	        },
	        _invSubBytes: function () {
	            for (var r = 0; r < 4; ++r) {
	                for (var c = 0; c < 4; ++c) {
	                    this.State[r][c] = this.iSbox[(this.State[r][c] >> 4)][(this.State[r][c] & 0x0f)];
	                }
	            }
	        },
	        _invMixColumns: function () {
	            var temp = create2DArray(4, 4);
	            for (var r = 0; r < 4; ++r) {
	                for (var c = 0; c < 4; ++c) {
	                    temp[r][c] = this.State[r][c];
	                }
	            }
	            for (c = 0; c < 4; ++c) {
	                this.State[0][c] = (gfmultby0e(temp[0][c]) ^ gfmultby0b(temp[1][c]) ^ gfmultby0d(temp[2][c]) ^ gfmultby09(temp[3][c])) % 256;
	                this.State[1][c] = (gfmultby09(temp[0][c]) ^ gfmultby0e(temp[1][c]) ^ gfmultby0b(temp[2][c]) ^ gfmultby0d(temp[3][c])) % 256;
	                this.State[2][c] = (gfmultby0d(temp[0][c]) ^ gfmultby09(temp[1][c]) ^ gfmultby0e(temp[2][c]) ^ gfmultby0b(temp[3][c])) % 256;
	                this.State[3][c] = (gfmultby0b(temp[0][c]) ^ gfmultby0d(temp[1][c]) ^ gfmultby09(temp[2][c]) ^ gfmultby0e(temp[3][c])) % 256;
	            }
	        },
	        _encryptPackageStream: function (inStream) {
	            var view = new Uint8Array(inStream);// eslint-disable-line
	            view._pos = 0;
	            var read = reader(view);
	            var length = view.length;
	            var input = read.readBytes(length);
	            var encBuffer = this._cipher(input);
	            var encTotal = [];
	            arrayCopy(getBytesFromInt(8, length), 0, encTotal, 0, 8);
	            arrayCopy(encBuffer, 0, encTotal, 8, encBuffer.length);
	            read.seek(0, seekOrigin.Begin);
	            return encTotal;
	        },
	
	        _stgOpenXmlStreamWrite: function (encStreamInfo, encstreamPackage) {
	            var view = [];
	            view._pos = 0;
	            var write = writer(view);
	            var i = 0;
	           
	            var dirctoryBlockCount = 3;
	           
	            var customFileBlockCount = 2;
	           
	            var ssatBolckCount = 1;
	           
	            var msatList = [];
	           
	            var satList = [];
	           
	            var ssaList = [];
	
	           
	
	           
	           
	
	           
	            var size = Math.max(encstreamPackage.length, 4096);
	
	           
	            var streamBlockCount = parseInt(encstreamPackage.length / 0x200);
	            if (encstreamPackage.length % 0x200 > 0) {
	                streamBlockCount++;
	            }
	
	
	           
	            var propertyBlockCount = dirctoryBlockCount + customFileBlockCount + ssatBolckCount;
	
	           
	            var blockIndexArraySize = (streamBlockCount + propertyBlockCount) * 4;
	
	           
	            var satBlocksNeeded = parseInt(blockIndexArraySize / 0x200);
	            if (blockIndexArraySize % 0x200 > 0) {
	                satBlocksNeeded++;
	            }
	           
	            var msatBlocksNeeded = 0;
	           
	            var blocksChanged = true;
	            while (blocksChanged) {
	                var newSatBlocksNeeded = 0;
	                var newMSatBlocksNeeded = 0;
	               
	                blocksChanged = false;
	                blockIndexArraySize = (streamBlockCount + propertyBlockCount + satBlocksNeeded + msatBlocksNeeded) * 4;
	                newSatBlocksNeeded = parseInt(blockIndexArraySize / 0x200);
	                if (blockIndexArraySize % 0x200 > 0) {
	                    newSatBlocksNeeded++;
	                }
	
	
	                if (newSatBlocksNeeded > satBlocksNeeded) {
	                    satBlocksNeeded = newSatBlocksNeeded;
	                    blocksChanged = true;
	                    continue;
	                }
	
	               
	                if (satBlocksNeeded > 109) {
	                    var batArrayListRemainingSize = (satBlocksNeeded - 109) * 4;
	                    newMSatBlocksNeeded = parseInt(batArrayListRemainingSize / 0x200);
	
	                    var batArrayListRemainingSizeRemainder = batArrayListRemainingSize % 0x200;
	                    if (batArrayListRemainingSizeRemainder > 0) {
	                        newMSatBlocksNeeded++;
	                    }
	                    if (batArrayListRemainingSizeRemainder + (4 * newMSatBlocksNeeded) > 0x200) {
	                        newMSatBlocksNeeded++;
	                    }
	                    if (newMSatBlocksNeeded > msatBlocksNeeded) {
	                        msatBlocksNeeded = newMSatBlocksNeeded;
	                        blocksChanged = true;
	                    }
	                }
	            }
	           
	            if (msatBlocksNeeded > 0) {
	                var count = msatBlocksNeeded * 128 + 109;
	                var msatIndex = 0;
	                for (i = 0; i < count; i++) {
	                    if (i < satBlocksNeeded) {
	                        var xbatIndexCount = i - 109;
	                        if (xbatIndexCount > 0 && xbatIndexCount % 0x80 === 0) {
	                            msatList.push(++msatIndex);
	                        }
	                        msatList.push(i + msatBlocksNeeded);
	                    } else {
	                        msatList.push(-1);
	                    }
	                }
	            } else {
	                for (i = 0; i < 109; i++) {
	                    if (i < satBlocksNeeded) {
	                        msatList.push(i);
	                    } else {
	                        msatList.push(-1);
	                    }
	
	                }
	            }
	
	            var blockCount = 0;
	            if (satBlocksNeeded > 0) {
	                for (i = 1; i <= msatBlocksNeeded; i++) {
	                    satList.push(-4);  
	                }
	                blockCount = msatBlocksNeeded;
	                for (i = 1; i <= satBlocksNeeded; i++) {
	                    satList.push(-3); 
	                }
	                blockCount += satBlocksNeeded;
	                for (i = 1; i < ssatBolckCount; i++) {
	                    satList.push(i);
	                }
	                satList.push(-2);
	                blockCount += ssatBolckCount;
	                for (i = 1; i < dirctoryBlockCount; i++) {
	                    satList.push(i + blockCount);
	                }
	                satList.push(-2);
	                blockCount += dirctoryBlockCount;
	                for (i = 1; i < customFileBlockCount; i++) {
	                    satList.push(i + blockCount);
	                }
	                satList.push(-2);
	                blockCount += customFileBlockCount;
	                for (i = 1; i < streamBlockCount; i++) {
	                    satList.push(i + blockCount);
	                }
	                satList.push(-2);
	            }
	
	           
	
	            write.writeInt(0xE011CFD0);
	            write.writeInt(0xE11AB1A1);
	            write.writeLong(0x00);             
	            write.writeLong(0x00);
	            write.writeShort(0x003E);
	            write.writeShort(0x0003);
	            write.writeShort(-2);
	            write.writeShort(9);
	            write.writeInt(6);
	            write.writeInt(0);
	            write.writeInt(0);
	
	           
	            write.writeInt(satBlocksNeeded);
	
	           
	            write.writeInt(msatBlocksNeeded + satBlocksNeeded + ssatBolckCount);
	
	            write.writeInt(0);
	            write.writeInt(0x00001000);
	
	           
	            write.writeInt(satBlocksNeeded + msatBlocksNeeded);
	
	           
	            write.writeInt(ssatBolckCount);
	
	           
	            if (msatBlocksNeeded > 0) {
	                write.writeInt(0);
	                write.writeInt(msatBlocksNeeded);
	            } else {
	                write.writeInt(-2);
	                write.writeInt(0);
	            }
	
	           
	            msatList.forEach(function (value) {
	                write.writeInt(value);
	            });
	            for (var j = 0; j < satBlocksNeeded * 128; j++) {
	                if (j < satList.length) {
	                    write.writeInt(satList[j]);
	                } else {
	                    write.writeInt(-1);
	                }
	            }
	           
	            var customFileStream = stgGenerateCustomFileStream(encStreamInfo, ssaList);
	            ssaList.forEach(function (value) {
	                write.writeInt(value);
	            });
	           
	            var dirctoryEntry = stgGenerateDirectoryEntry(blockCount, blockCount - customFileBlockCount, size);
	
	           
	            write.writeBytes(dirctoryEntry);
	
	           
	            write.writeBytes(customFileStream);
	
	           
	            write.writeBytes(encstreamPackage);
	            return { success: true, data: write.getView() };
	        }
	
	    };
	
	    module.exports = AesEngine;
	
	}());

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var XmlReader = __webpack_require__(8);
	    
	    function parseXmlToObject(xmlString) {
	        if (!xmlString) {
	            return;
	        }
	        var reader = new XmlReader(), obj = {};
	        reader.reset();
	        reader.setXml(xmlString);
	        while (reader.read()) {
	            if (reader.elementType === 2 ) {
	                continue;
	            }
	            var tempObj = {};
	            tempObj._attr = {};
	            obj[reader.name()] = tempObj;
	            while (reader.moveToNextAttribute()) {
	                tempObj._attr[reader.readAttributeNameAsString()] = reader.readContentAsString();
	            }
	            if (reader.elementType === 3 ) {
	                continue;
	            }
	            parse(reader, tempObj);
	        }
	        return obj;
	    }
	    
	    function parse(reader, obj) {
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1 ) {
	                var tempObj = {}, name = reader.name();
	                if (obj[name]) {
	                    if (!Array.isArray(obj[name])) {
	                        obj[name] = [obj[name]];
	                    }
	                    obj[name].push(tempObj);
	                } else {
	                    obj[name] = tempObj;
	                }
	                tempObj._attr = {};
	                while (reader.moveToNextAttribute()) {
	                    tempObj._attr[reader.readAttributeNameAsString()] = reader.readContentAsString();
	                }
	                if (reader.elementType === 3 ) {
	                    continue;
	                }
	                var elementContent = reader.readElementContentAsString();
	                if ((reader.elementType & 1 ) === 1  && elementContent !== '' && reader._elementContentStart > reader._nameIndex) {
	                    if (tempObj._attr['xml:space'] === 'preserve') {
	                        elementContent = reader.readElementContentAsString(true);
	                    }
	                    tempObj[name] = elementContent;
	                }
	                parse(reader, tempObj);
	            }
	        }
	    }
	    
	    function convertObjectToXml(object, rootName) {
	        var xml = '<' + rootName;
	    
	        var attr = object._attr;
	        if (attr) {
	            for (var a in attr) {
	                if (attr.hasOwnProperty(a)) {
	                    xml += ' ' + a + '="' + attr[a] + '"';
	                }
	            }
	        }
	        xml += '>';
	    
	        for (var p in object) {
	            if (object.hasOwnProperty(p) && attr !== object[p]) {
	                if (typeof object[p] === 'object') {
	                    xml += convertObjectToXml(object[p], p);
	                } else {
	                    xml += object[p];
	                }
	            }
	        }
	        xml += '</' + rootName + '>';
	    
	        return xml;
	    }
	    exports._parseXmlToObject = parseXmlToObject;
	    exports._convertObjectToXml = convertObjectToXml;
	
	}());

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    
	
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	    var xmlEncode = __webpack_require__(4)._Util._xmlEncode;
	    var CDATA_START = '<![CDATA[', CDATA_END = ']]>';
	
	    var XmlReader = (function () {
	        function XmlReader() {
	            this._elementCursorIndex = -1;
	            this._attributeCursorIndex = 0;
	            this._lastCharPosition = 0;
	            this._elementEndIndex = 0;
	            this.buffer = '';
	            this.elementType = 2 ;
	            this.depth = 0;
	            this._nameIndex = 0;
	            this._nameLength = 0;
	            this._attributeNameIndex = 0;
	            this._attributeNameLength = 0;
	            this._attributeContentStart = 0;
	            this._attributeContentEnd = 0;
	            this._elementContentStart = 0;
	            this._elementContentEnd = 0;
	            this.xmlIndex = 0;
	            this.xml = '';
	            this._hasCDATA = false;
	            this.reset();
	        }
	
	        XmlReader.prototype.reset = function () {
	            var self = this;
	            self._elementCursorIndex = -1;
	            self._attributeCursorIndex = 0;
	            self._lastCharPosition = 0;
	            self._elementEndIndex = 0;
	            self.buffer = '';
	            self.elementType = 2 ;
	            self.depth = 0;
	            self._nameIndex = 0;
	            self._nameLength = 0;
	            self._attributeNameIndex = 0;
	            self._attributeNameLength = 0;
	            self._attributeContentStart = 0;
	            self._attributeContentEnd = 0;
	            self._elementContentStart = 0;
	            self._elementContentEnd = 0;
	            self.xmlIndex = 0;
	            self.xml = '';
	            self._hasCDATA = false;
	        };
	        XmlReader.prototype.setXml = function (xmlString) {
	            this.xml = xmlString;
	        };
	        XmlReader.prototype.name = function () {
	            var self = this;
	            return self.buffer.slice(self._nameIndex, self._nameIndex + self._nameLength);
	        };
	        XmlReader.prototype.nodeType = function () {
	            if (this.elementType === 2 ) {
	                return 15 ;
	            }
	            return 1 ;
	        };
	        XmlReader.prototype.fillBuffer = function () {
	            var self = this;
	            var bufferLength = self.buffer.length;
	            if (bufferLength === 0) {
	                self.buffer = self.xml;
	                self._elementCursorIndex = 0;
	                self._elementContentStart = 0;
	                self._lastCharPosition = self.buffer.length;
	                return true;
	            }
	            return false;
	        };
	        XmlReader.prototype.read = function () {
	            var self = this;
	            self._attributeCursorIndex = Number.MAX_VALUE;
	            while (true) {
	                self._elementCursorIndex++;
	                if (self._elementCursorIndex >= self._lastCharPosition && !self.fillBuffer()) {
	                    return false;
	                }
	                var c = self.buffer[self._elementCursorIndex];
	                if (c === '\x3c') {
	                    break;
	                }
	            }
	            var eleParts = [
	                'elementStarting', 'elementStart', 'elementNameEnd', 'elementEnd', 'elementContent',
	                '_elementContentStart', 'endElementStart'], elePartsLen = eleParts.length, partIndex = 0, jump = false;
	            while (partIndex < elePartsLen) {
	                switch (eleParts[partIndex]) {
	                    case 'elementStarting': 
	                        jump = false;
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x2f' ) {
	                                partIndex = 6;
	                                jump = true;
	                                break;
	                            } else if (c === '\x3f' ) {
	                                self.elementType = 3 ;
	                                while (true) {
	                                    self._elementCursorIndex++;
	                                    c = self.buffer[self._elementCursorIndex];
	                                    if (c === '\x3e' ) {
	                                        return true;
	                                    }
	                                }
	                            } else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                self._nameIndex = self._elementCursorIndex;
	                                break;
	                            }
	                        }
	                        if (jump) {
	                            continue;
	                        }
	                    case 'elementStart': 
	                        jump = false;
	                        if (self.elementType === 1 ) {
	                            self.depth++;
	                        }
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3e') {
	                                self._nameLength = self._elementCursorIndex - self._nameIndex;
	                                partIndex = 3;
	                                jump = true;
	                                break;
	                            } else if (c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09' || c === '\x2f') {
	                                self._nameLength = self._elementCursorIndex - self._nameIndex;
	                                self._attributeCursorIndex = self._elementCursorIndex;
	                                break;
	                            }
	                        }
	                        if (jump) {
	                            continue;
	                        }
	                    case 'elementNameEnd': 
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3e') {
	                                break;
	                            }
	                        }
	                        var index = self._elementCursorIndex;
	                        while (true) {
	                            index--;
	                            c = self.buffer[index];
	                            if (c === '\x2f') {
	                                self._elementEndIndex = index;
	                                self.elementType = 3 ;
	                                return true;
	                            } else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                               
	                                self._elementEndIndex = index;
	                                self.elementType = 1 ;
	                                partIndex = 4;
	                                break;
	                            }
	                        }
	                        continue;
	                    case 'elementEnd': 
	                        index = self._elementCursorIndex;
	                        while (true) {
	                            index--;
	                            c = self.buffer[index];
	                            if (c === '\x2f') {
	                                self.elementType = 3 ;
	                                return true;
	                            } else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                self.elementType = 1 ;
	                                break;
	                            }
	                        }
	                    case 'elementContent': 
	                        var elementContentStartSet = false;
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3c') {
	                                self._elementCursorIndex--;
	                               
	                                if (elementContentStartSet) {
	                                    self._elementContentEnd = self._elementCursorIndex + 1;
	                                }
	                                return true;
	                            }
	                           
	                           
	                           
	                            self._elementContentStart = self._elementCursorIndex;
	                            elementContentStartSet = true;
	                            if (c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                break;
	                            }
	                        }
	                    case '_elementContentStart': 
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3c') {
	                                self._elementContentEnd = self._elementCursorIndex;
	                                self._elementCursorIndex--;
	                                return true;
	                            }
	                        }
	                    case 'endElementStart':
	                        if (self.elementType === 2  || self.elementType === 3 ) {
	                            self.depth--;
	                        }
	                        self.elementType = 2 ;
	                        self._nameIndex = self._elementCursorIndex + 1;
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3e') {
	                                self._nameLength = self._elementCursorIndex - self._nameIndex;
	                                return true;
	                            }
	                        }
	                }
	            }
	        };
	        XmlReader.prototype.fastRead = function () {
	            var self = this;
	            self._attributeCursorIndex = Number.MAX_VALUE;
	            self._hasCDATA = false;
	            while (true) {
	                self._elementCursorIndex++;
	                if (self._elementCursorIndex >= self._lastCharPosition && !self.fillBuffer()) {
	                    return false;
	                }
	                var c = self.buffer[self._elementCursorIndex];
	                if (c === '\x3c') {
	                    break;
	                }
	            }
	            var eleParts = [
	                'elementStarting', 'elementStart', 'elementNameEnd', 'elementEnd', 'elementContent',
	                '_elementContentStart', 'endElementStart'];
	            var partIndex = 0, jump = false;
	            while (partIndex < eleParts.length) {
	                switch (eleParts[partIndex]) {
	                    case 'elementStarting': 
	                        jump = false;
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x2f') {
	                                partIndex = 6;
	                                jump = true;
	                                break;
	                            } else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                self._nameIndex = self._elementCursorIndex;
	                                break;
	                            }
	                        }
	                        if (jump) {
	                            continue;
	                        }
	                    case 'elementStart': 
	                        jump = false;
	                        if (self.elementType === 1 ) {
	                            self.depth++;
	                        }
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3e') {
	                                self._nameLength = self._elementCursorIndex - self._nameIndex;
	                                partIndex = 3;
	                                jump = true;
	                                break;
	                            } else if (c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09') {
	                                self._nameLength = self._elementCursorIndex - self._nameIndex;
	                                self._attributeCursorIndex = self._elementCursorIndex;
	                                break;
	                            }
	                        }
	                        if (jump) {
	                            continue;
	                        }
	                    case 'elementNameEnd': 
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3e') {
	                                break;
	                            }
	                        }
	                        var index = self._elementCursorIndex;
	                        while (true) {
	                            index--;
	                            c = self.buffer[index];
	                            if (c === '\x2f') {
	                                self._elementEndIndex = index;
	                                self.elementType = 3 ;
	                                return true;
	                            } else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                self._elementEndIndex = index;
	                                self.elementType = 1 ;
	                                partIndex = 4;
	                                break;
	                            }
	                        }
	                        continue;
	                    case 'elementEnd': 
	                        index = self._elementCursorIndex;
	                        while (true) {
	                            index--;
	                            c = self.buffer[index];
	                            if (c === '\x2f') {
	                                self.elementType = 3 ;
	                                return true;
	                            } else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                self.elementType = 1 ;
	                                break;
	                            }
	                        }
	                    case 'elementContent': 
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                           
	                           
	                           
	                            if (self.buffer.substr(self._elementCursorIndex, 9) === CDATA_START) {
	                                var findCDataEnd = self.buffer.indexOf(CDATA_END, self._elementCursorIndex);
	                               
	                                self._elementContentStart = self._elementCursorIndex;
	                               
	                                self._elementContentEnd = findCDataEnd + CDATA_END.length;
	                               
	                                self._elementCursorIndex = self._elementContentEnd - 1;
	                               
	                                self._hasCDATA = true;
	                                return true;
	                            } else if (c === '\x3c') {
	                                self._elementCursorIndex--;
	                                return true;
	                            } else if (c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                                self._elementContentStart = self._elementCursorIndex;
	                                break;
	                            }
	                        }
	                    case '_elementContentStart': 
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3c') {
	                                self._elementContentEnd = self._elementCursorIndex;
	                                self._elementCursorIndex--;
	                                return true;
	                            }
	                        }
	                    case 'endElementStart':
	                        if (self.elementType === 2  || self.elementType === 3 ) {
	                            self.depth--;
	                        }
	                        self.elementType = 2 ;
	                        while (true) {
	                            self._elementCursorIndex++;
	                            c = self.buffer[self._elementCursorIndex];
	                            if (c === '\x3e') {
	                                return true;
	                            }
	                        }
	                }
	            }
	        };
	        XmlReader.prototype.moveToNextAttribute = function () {
	            var self = this;
	            while (true) {
	                if (self._attributeCursorIndex >= self._elementEndIndex - 1) {
	                    return false;
	                }
	                self._attributeCursorIndex++;
	                var c = self.buffer[self._attributeCursorIndex];
	                if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
	                    self._attributeNameIndex = self._attributeCursorIndex;
	                    break;
	                }
	            }
	
	            while (true) {
	                self._attributeCursorIndex++;
	                c = self.buffer[self._attributeCursorIndex];
	                if (c === '\x3d' || c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09') {
	                    self._attributeNameLength = self._attributeCursorIndex - self._attributeNameIndex;
	                    break;
	                }
	            }
	
	            var mark = '\x22'; 
	            while (true) {
	                self._attributeCursorIndex++;
	                c = self.buffer[self._attributeCursorIndex];
	                if (c === '\x22' || c === '\x27') {
	                    mark = c;
	                    self._attributeContentStart = self._attributeCursorIndex + 1;
	                    break;
	                }
	            }
	
	            while (true) {
	                self._attributeCursorIndex++;
	                c = self.buffer[self._attributeCursorIndex];
	                if (c === mark) {
	                    self._attributeContentEnd = self._attributeCursorIndex;
	                    return true;
	                }
	            }
	        };
	        XmlReader.prototype.readContentAsString = function () {
	            var self = this;
	            return self.buffer.slice(self._attributeContentStart, self._attributeContentEnd);
	        };
	        XmlReader.prototype.readContentAsBoolean = function (defaultValue) {
	            var self = this;
	           
	           
	           
	            var c = self.buffer[self._attributeContentStart];
	            if (c === '1' || c === 't') {
	                return true;
	            } else if (c === '0' || c === 'f') {
	                return false;
	            }
	            return defaultValue;
	        };
	        XmlReader.prototype.readContentAsInt = function (defaultValue) {
	            var self = this;
	            var content = parseInt(self.buffer.slice(self._attributeContentStart, self._attributeContentEnd));
	            if (!isNaN(content)) {
	                return content;
	            }
	            return defaultValue;
	        };
	        XmlReader.prototype.readContentAsDouble = function (defaultValue) {
	            var self = this;
	            var content = parseFloat(self.buffer.slice(self._attributeContentStart, self._attributeContentEnd));
	            if (!isNaN(content)) {
	                return content;
	            }
	            return defaultValue;
	        };
	        XmlReader.prototype.readElementContentAsString = function (keepSpace) {
	            var self = this,
	                start = self._elementContentStart;
	
	           
	           
	           
	            if (this._elementContentStart <= this._nameIndex) {
	                return '';
	            }
	            if (keepSpace) {
	                var buffer = self.buffer,
	                    c = buffer[start - 1];
	
	                while (c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09') {
	                    start--;
	                    c = buffer[start - 1];
	                }
	            }
	           
	           
	           
	            var content = self.buffer.slice(start, self._elementContentEnd);
	            if (self._hasCDATA) {
	                content = xmlEncode(content.replace(CDATA_START, '').replace(CDATA_END, ''));
	                self._hasCDATA = false;
	            }
	            return content;
	        };
	        XmlReader.prototype.readElementContentAsInt = function (defaultValue) {
	            var self = this;
	            var content = parseInt(self.buffer.slice(self._elementContentStart, self._elementContentEnd));
	            if (!isNaN(content)) {
	                return content;
	            }
	            return defaultValue;
	        };
	        XmlReader.prototype.readElementContentAsDouble = function (defaultValue) {
	            var self = this;
	            var content = parseFloat(self.buffer.slice(self._elementContentStart, self._elementContentEnd));
	            if (!isNaN(content)) {
	                return content;
	            }
	            return defaultValue;
	        };
	        XmlReader.prototype.readElementContentAsBoolean = function (defaultValue) {
	            var self = this;
	            var c = self.buffer[self._elementContentStart];
	            if (c === '1' || c === 't') {
	                return true;
	            } else if (c === '0' || c === 'f') {
	                return false;
	            }
	            return defaultValue;
	        };
	
	        XmlReader.prototype.readAttributeNameAsString = function () {
	            var self = this;
	            return self.buffer.slice(self._attributeNameIndex, self._attributeNameIndex + self._attributeNameLength);
	        };
	        XmlReader.prototype.readFullElement = function () {
	            var self = this;
	            if (self.elementType === 2 ) {
	                return '';
	            }
	            var elementStartCursor = self._nameIndex - 1;
	            if (self.elementType === 3 ) {
	                return self.buffer.slice(elementStartCursor, self._elementEndIndex + 2);
	            }
	            var depth = self.depth;
	            if (self.elementType === 1 ) {
	                while (self.read()) {
	                    if (self.depth <= depth) {
	                        break;
	                    }
	                }
	                return self.buffer.slice(elementStartCursor, self._nameIndex + self._nameLength + 1);
	            }
	            return '';
	        };
	        return XmlReader;
	    })();
	    module.exports = XmlReader;
	
	}());

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	(function (root) {
	    'use strict';
	    var Sha512 = {};
	    var EXTRA = [-2147483648, 8388608, 32768, 128];
	    var SHIFT = [24, 16, 8, 0];
	    var K = [0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD,
	        0xB5C0FBCF, 0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC,
	        0x3956C25B, 0xF348B538, 0x59F111F1, 0xB605D019,
	        0x923F82A4, 0xAF194F9B, 0xAB1C5ED5, 0xDA6D8118,
	        0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,
	        0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2,
	        0x72BE5D74, 0xF27B896F, 0x80DEB1FE, 0x3B1696B1,
	        0x9BDC06A7, 0x25C71235, 0xC19BF174, 0xCF692694,
	        0xE49B69C1, 0x9EF14AD2, 0xEFBE4786, 0x384F25E3,
	        0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,
	        0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483,
	        0x5CB0A9DC, 0xBD41FBD4, 0x76F988DA, 0x831153B5,
	        0x983E5152, 0xEE66DFAB, 0xA831C66D, 0x2DB43210,
	        0xB00327C8, 0x98FB213F, 0xBF597FC7, 0xBEEF0EE4,
	        0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,
	        0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70,
	        0x27B70A85, 0x46D22FFC, 0x2E1B2138, 0x5C26C926,
	        0x4D2C6DFC, 0x5AC42AED, 0x53380D13, 0x9D95B3DF,
	        0x650A7354, 0x8BAF63DE, 0x766A0ABB, 0x3C77B2A8,
	        0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,
	        0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001,
	        0xC24B8B70, 0xD0F89791, 0xC76C51A3, 0x0654BE30,
	        0xD192E819, 0xD6EF5218, 0xD6990624, 0x5565A910,
	        0xF40E3585, 0x5771202A, 0x106AA070, 0x32BBD1B8,
	        0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,
	        0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8,
	        0x391C0CB3, 0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB,
	        0x5B9CCA4F, 0x7763E373, 0x682E6FF3, 0xD6B2B8A3,
	        0x748F82EE, 0x5DEFB2FC, 0x78A5636F, 0x43172F60,
	        0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,
	        0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9,
	        0xBEF9A3F7, 0xB2C67915, 0xC67178F2, 0xE372532B,
	        0xCA273ECE, 0xEA26619C, 0xD186B8C7, 0x21C0C207,
	        0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F, 0xEE6ED178,
	        0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,
	        0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B,
	        0x28DB77F5, 0x23047D84, 0x32CAAB7B, 0x40C72493,
	        0x3C9EBE0A, 0x15C9BEBC, 0x431D67C4, 0x9C100D4C,
	        0x4CC5D4BE, 0xCB3E42B6, 0x597F299C, 0xFC657E2A,
	        0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817];
	
	    var blocks = [];
	
	
	    var sha512 = function (message) {
	
	        var h0h, h0l, h1h, h1l, h2h, h2l, h3h, h3l,
	            h4h, h4l, h5h, h5l, h6h, h6l, h7h, h7l, block, end = false,
	            i, j, index = 0, start = 0, bytes = 0, length = message.length,
	            s0h, s0l, s1h, s1l, c1, c2, c3, c4,
	            abh, abl, dah, dal, cdh, cdl, bch, bcl,
	            majh, majl, t1h, t1l, t2h, t2l, chh, chl;
	
	
	        h0h = 0x6A09E667;
	        h0l = 0xF3BCC908;
	        h1h = 0xBB67AE85;
	        h1l = 0x84CAA73B;
	        h2h = 0x3C6EF372;
	        h2l = 0xFE94F82B;
	        h3h = 0xA54FF53A;
	        h3l = 0x5F1D36F1;
	        h4h = 0x510E527F;
	        h4l = 0xADE682D1;
	        h5h = 0x9B05688C;
	        h5l = 0x2B3E6C1F;
	        h6h = 0x1F83D9AB;
	        h6l = 0xFB41BD6B;
	        h7h = 0x5BE0CD19;
	        h7l = 0x137E2179;
	
	        block = 0;
	        do {
	            blocks[0] = block;
	            blocks[1] = blocks[2] = blocks[3] = blocks[4] =
	                blocks[5] = blocks[6] = blocks[7] = blocks[8] =
	                    blocks[9] = blocks[10] = blocks[11] = blocks[12] =
	                        blocks[13] = blocks[14] = blocks[15] = blocks[16] =
	                            blocks[17] = blocks[18] = blocks[19] = blocks[20] =
	                                blocks[21] = blocks[22] = blocks[23] = blocks[24] =
	                                    blocks[25] = blocks[26] = blocks[27] = blocks[28] =
	                                        blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
	
	            for (i = start; index < length && i < 128; ++index) {
	                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
	            }
	
	            bytes += i - start;
	            start = i - 128;
	            if (index === length) {
	                blocks[i >> 2] |= EXTRA[i & 3];
	                ++index;
	            }
	            block = blocks[32];
	            if (index > length && i < 112) {
	                blocks[31] = bytes << 3;
	                end = true;
	            }
	
	            for (j = 32; j < 160; j += 2) {
	                t1h = blocks[j - 30];
	                t1l = blocks[j - 29];
	                s0h = ((t1h >>> 1) | (t1l << 31)) ^ ((t1h >>> 8) | (t1l << 24)) ^ (t1h >>> 7);
	                s0l = ((t1l >>> 1) | (t1h << 31)) ^ ((t1l >>> 8) | (t1h << 24)) ^ ((t1l >>> 7) | t1h << 25);
	
	                t1h = blocks[j - 4];
	                t1l = blocks[j - 3];
	                s1h = ((t1h >>> 19) | (t1l << 13)) ^ ((t1l >>> 29) | (t1h << 3)) ^ (t1h >>> 6);
	                s1l = ((t1l >>> 19) | (t1h << 13)) ^ ((t1h >>> 29) | (t1l << 3)) ^ ((t1l >>> 6) | t1h << 26);
	
	                t1h = blocks[j - 32];
	                t1l = blocks[j - 31];
	                t2h = blocks[j - 14];
	                t2l = blocks[j - 13];
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (s0l & 0xFFFF) + (s1l & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (s0h & 0xFFFF) + (s1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
	
	                blocks[j] = (c4 << 16) | (c3 & 0xFFFF);
	                blocks[j + 1] = (c2 << 16) | (c1 & 0xFFFF);
	            }
	
	            var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
	            bch = bh & ch;
	            bcl = bl & cl;
	            for (j = 0; j < 160; j += 8) {
	                s0h = ((ah >>> 28) | (al << 4)) ^ ((al >>> 2) | (ah << 30)) ^ ((al >>> 7) | (ah << 25));
	                s0l = ((al >>> 28) | (ah << 4)) ^ ((ah >>> 2) | (al << 30)) ^ ((ah >>> 7) | (al << 25));
	
	                s1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((el >>> 9) | (eh << 23));
	                s1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((eh >>> 9) | (el << 23));
	
	                abh = ah & bh;
	                abl = al & bl;
	                majh = abh ^ (ah & ch) ^ bch;
	                majl = abl ^ (al & cl) ^ bcl;
	
	                chh = (eh & fh) ^ (~eh & gh);
	                chl = (el & fl) ^ (~el & gl);
	
	                t1h = blocks[j];
	                t1l = blocks[j + 1];
	                t2h = K[j];
	                t2l = K[j + 1];
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (hl & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
	
	                t1h = (c4 << 16) | (c3 & 0xFFFF);
	                t1l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
	                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
	                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
	                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
	
	                t2h = (c4 << 16) | (c3 & 0xFFFF);
	                t2l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (dl & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (dh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                hh = (c4 << 16) | (c3 & 0xFFFF);
	                hl = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                dh = (c4 << 16) | (c3 & 0xFFFF);
	                dl = (c2 << 16) | (c1 & 0xFFFF);
	
	                s0h = ((dh >>> 28) | (dl << 4)) ^ ((dl >>> 2) | (dh << 30)) ^ ((dl >>> 7) | (dh << 25));
	                s0l = ((dl >>> 28) | (dh << 4)) ^ ((dh >>> 2) | (dl << 30)) ^ ((dh >>> 7) | (dl << 25));
	
	                s1h = ((hh >>> 14) | (hl << 18)) ^ ((hh >>> 18) | (hl << 14)) ^ ((hl >>> 9) | (hh << 23));
	                s1l = ((hl >>> 14) | (hh << 18)) ^ ((hl >>> 18) | (hh << 14)) ^ ((hh >>> 9) | (hl << 23));
	
	                dah = dh & ah;
	                dal = dl & al;
	                majh = dah ^ (dh & bh) ^ abh;
	                majl = dal ^ (dl & bl) ^ abl;
	
	                chh = (hh & eh) ^ (~hh & fh);
	                chl = (hl & el) ^ (~hl & fl);
	
	                t1h = blocks[j + 2];
	                t1l = blocks[j + 3];
	                t2h = K[j + 2];
	                t2l = K[j + 3];
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (gl & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
	
	                t1h = (c4 << 16) | (c3 & 0xFFFF);
	                t1l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
	                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
	                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
	                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
	
	                t2h = (c4 << 16) | (c3 & 0xFFFF);
	                t2l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (cl & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (ch & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                gh = (c4 << 16) | (c3 & 0xFFFF);
	                gl = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                ch = (c4 << 16) | (c3 & 0xFFFF);
	                cl = (c2 << 16) | (c1 & 0xFFFF);
	
	                s0h = ((ch >>> 28) | (cl << 4)) ^ ((cl >>> 2) | (ch << 30)) ^ ((cl >>> 7) | (ch << 25));
	                s0l = ((cl >>> 28) | (ch << 4)) ^ ((ch >>> 2) | (cl << 30)) ^ ((ch >>> 7) | (cl << 25));
	
	                s1h = ((gh >>> 14) | (gl << 18)) ^ ((gh >>> 18) | (gl << 14)) ^ ((gl >>> 9) | (gh << 23));
	                s1l = ((gl >>> 14) | (gh << 18)) ^ ((gl >>> 18) | (gh << 14)) ^ ((gh >>> 9) | (gl << 23));
	
	                cdh = ch & dh;
	                cdl = cl & dl;
	                majh = cdh ^ (ch & ah) ^ dah;
	                majl = cdl ^ (cl & al) ^ dal;
	
	                chh = (gh & hh) ^ (~gh & eh);
	                chl = (gl & hl) ^ (~gl & el);
	
	                t1h = blocks[j + 4];
	                t1l = blocks[j + 5];
	                t2h = K[j + 4];
	                t2l = K[j + 5];
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (fl & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
	
	                t1h = (c4 << 16) | (c3 & 0xFFFF);
	                t1l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
	                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
	                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
	                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
	
	                t2h = (c4 << 16) | (c3 & 0xFFFF);
	                t2l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (bl & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (bh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                fh = (c4 << 16) | (c3 & 0xFFFF);
	                fl = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                bh = (c4 << 16) | (c3 & 0xFFFF);
	                bl = (c2 << 16) | (c1 & 0xFFFF);
	
	                s0h = ((bh >>> 28) | (bl << 4)) ^ ((bl >>> 2) | (bh << 30)) ^ ((bl >>> 7) | (bh << 25));
	                s0l = ((bl >>> 28) | (bh << 4)) ^ ((bh >>> 2) | (bl << 30)) ^ ((bh >>> 7) | (bl << 25));
	
	                s1h = ((fh >>> 14) | (fl << 18)) ^ ((fh >>> 18) | (fl << 14)) ^ ((fl >>> 9) | (fh << 23));
	                s1l = ((fl >>> 14) | (fh << 18)) ^ ((fl >>> 18) | (fh << 14)) ^ ((fh >>> 9) | (fl << 23));
	
	                bch = bh & ch;
	                bcl = bl & cl;
	                majh = bch ^ (bh & dh) ^ cdh;
	                majl = bcl ^ (bl & dl) ^ cdl;
	
	                chh = (fh & gh) ^ (~fh & hh);
	                chl = (fl & gl) ^ (~fl & hl);
	
	                t1h = blocks[j + 6];
	                t1l = blocks[j + 7];
	                t2h = K[j + 6];
	                t2l = K[j + 7];
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (el & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
	
	                t1h = (c4 << 16) | (c3 & 0xFFFF);
	                t1l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
	                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
	                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
	                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
	
	                t2h = (c4 << 16) | (c3 & 0xFFFF);
	                t2l = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (al & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (ah & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                eh = (c4 << 16) | (c3 & 0xFFFF);
	                el = (c2 << 16) | (c1 & 0xFFFF);
	
	                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
	                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
	                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
	                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
	
	                ah = (c4 << 16) | (c3 & 0xFFFF);
	                al = (c2 << 16) | (c1 & 0xFFFF);
	            }
	
	            c1 = (h0l & 0xFFFF) + (al & 0xFFFF);
	            c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
	            c3 = (h0h & 0xFFFF) + (ah & 0xFFFF) + (c2 >>> 16);
	            c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
	
	            h0h = (c4 << 16) | (c3 & 0xFFFF);
	            h0l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h1l & 0xFFFF) + (bl & 0xFFFF);
	            c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
	            c3 = (h1h & 0xFFFF) + (bh & 0xFFFF) + (c2 >>> 16);
	            c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
	
	            h1h = (c4 << 16) | (c3 & 0xFFFF);
	            h1l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h2l & 0xFFFF) + (cl & 0xFFFF);
	            c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
	            c3 = (h2h & 0xFFFF) + (ch & 0xFFFF) + (c2 >>> 16);
	            c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
	
	            h2h = (c4 << 16) | (c3 & 0xFFFF);
	            h2l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h3l & 0xFFFF) + (dl & 0xFFFF);
	            c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
	            c3 = (h3h & 0xFFFF) + (dh & 0xFFFF) + (c2 >>> 16);
	            c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
	
	            h3h = (c4 << 16) | (c3 & 0xFFFF);
	            h3l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h4l & 0xFFFF) + (el & 0xFFFF);
	            c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
	            c3 = (h4h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
	            c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
	
	            h4h = (c4 << 16) | (c3 & 0xFFFF);
	            h4l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h5l & 0xFFFF) + (fl & 0xFFFF);
	            c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
	            c3 = (h5h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
	            c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
	
	            h5h = (c4 << 16) | (c3 & 0xFFFF);
	            h5l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h6l & 0xFFFF) + (gl & 0xFFFF);
	            c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
	            c3 = (h6h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
	            c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
	
	            h6h = (c4 << 16) | (c3 & 0xFFFF);
	            h6l = (c2 << 16) | (c1 & 0xFFFF);
	
	            c1 = (h7l & 0xFFFF) + (hl & 0xFFFF);
	            c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
	            c3 = (h7h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
	            c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
	
	            h7h = (c4 << 16) | (c3 & 0xFFFF);
	            h7l = (c2 << 16) | (c1 & 0xFFFF);
	        } while (!end);
	        return [16 * ((h0h >> 28) & 0x0F) + ((h0h >> 24) & 0x0F),
	            16 * ((h0h >> 20) & 0x0F) + ((h0h >> 16) & 0x0F),
	            16 * ((h0h >> 12) & 0x0F) + ((h0h >> 8) & 0x0F),
	            16 * ((h0h >> 4) & 0x0F) + (h0h & 0x0F),
	            16 * ((h0l >> 28) & 0x0F) + ((h0l >> 24) & 0x0F),
	            16 * ((h0l >> 20) & 0x0F) + ((h0l >> 16) & 0x0F),
	            16 * ((h0l >> 12) & 0x0F) + ((h0l >> 8) & 0x0F),
	            16 * ((h0l >> 4) & 0x0F) + (h0l & 0x0F),
	            16 * ((h1h >> 28) & 0x0F) + ((h1h >> 24) & 0x0F),
	            16 * ((h1h >> 20) & 0x0F) + ((h1h >> 16) & 0x0F),
	            16 * ((h1h >> 12) & 0x0F) + ((h1h >> 8) & 0x0F),
	            16 * ((h1h >> 4) & 0x0F) + (h1h & 0x0F),
	            16 * ((h1l >> 28) & 0x0F) + ((h1l >> 24) & 0x0F),
	            16 * ((h1l >> 20) & 0x0F) + ((h1l >> 16) & 0x0F),
	            16 * ((h1l >> 12) & 0x0F) + ((h1l >> 8) & 0x0F),
	            16 * ((h1l >> 4) & 0x0F) + (h1l & 0x0F),
	            16 * ((h2h >> 28) & 0x0F) + ((h2h >> 24) & 0x0F),
	            16 * ((h2h >> 20) & 0x0F) + ((h2h >> 16) & 0x0F),
	            16 * ((h2h >> 12) & 0x0F) + ((h2h >> 8) & 0x0F),
	            16 * ((h2h >> 4) & 0x0F) + (h2h & 0x0F),
	            16 * ((h2l >> 28) & 0x0F) + ((h2l >> 24) & 0x0F),
	            16 * ((h2l >> 20) & 0x0F) + ((h2l >> 16) & 0x0F),
	            16 * ((h2l >> 12) & 0x0F) + ((h2l >> 8) & 0x0F),
	            16 * ((h2l >> 4) & 0x0F) + (h2l & 0x0F),
	            16 * ((h3h >> 28) & 0x0F) + ((h3h >> 24) & 0x0F),
	            16 * ((h3h >> 20) & 0x0F) + ((h3h >> 16) & 0x0F),
	            16 * ((h3h >> 12) & 0x0F) + ((h3h >> 8) & 0x0F),
	            16 * ((h3h >> 4) & 0x0F) + (h3h & 0x0F),
	            16 * ((h3l >> 28) & 0x0F) + ((h3l >> 24) & 0x0F),
	            16 * ((h3l >> 20) & 0x0F) + ((h3l >> 16) & 0x0F),
	            16 * ((h3l >> 12) & 0x0F) + ((h3l >> 8) & 0x0F),
	            16 * ((h3l >> 4) & 0x0F) + (h3l & 0x0F),
	            16 * ((h4h >> 28) & 0x0F) + ((h4h >> 24) & 0x0F),
	            16 * ((h4h >> 20) & 0x0F) + ((h4h >> 16) & 0x0F),
	            16 * ((h4h >> 12) & 0x0F) + ((h4h >> 8) & 0x0F),
	            16 * ((h4h >> 4) & 0x0F) + (h4h & 0x0F),
	            16 * ((h4l >> 28) & 0x0F) + ((h4l >> 24) & 0x0F),
	            16 * ((h4l >> 20) & 0x0F) + ((h4l >> 16) & 0x0F),
	            16 * ((h4l >> 12) & 0x0F) + ((h4l >> 8) & 0x0F),
	            16 * ((h4l >> 4) & 0x0F) + (h4l & 0x0F),
	            16 * ((h5h >> 28) & 0x0F) + ((h5h >> 24) & 0x0F),
	            16 * ((h5h >> 20) & 0x0F) + ((h5h >> 16) & 0x0F),
	            16 * ((h5h >> 12) & 0x0F) + ((h5h >> 8) & 0x0F),
	            16 * ((h5h >> 4) & 0x0F) + (h5h & 0x0F),
	            16 * ((h5l >> 28) & 0x0F) + ((h5l >> 24) & 0x0F),
	            16 * ((h5l >> 20) & 0x0F) + ((h5l >> 16) & 0x0F),
	            16 * ((h5l >> 12) & 0x0F) + ((h5l >> 8) & 0x0F),
	            16 * ((h5l >> 4) & 0x0F) + (h5l & 0x0F),
	            16 * ((h6h >> 28) & 0x0F) + ((h6h >> 24) & 0x0F),
	            16 * ((h6h >> 20) & 0x0F) + ((h6h >> 16) & 0x0F),
	            16 * ((h6h >> 12) & 0x0F) + ((h6h >> 8) & 0x0F),
	            16 * ((h6h >> 4) & 0x0F) + (h6h & 0x0F),
	            16 * ((h6l >> 28) & 0x0F) + ((h6l >> 24) & 0x0F),
	            16 * ((h6l >> 20) & 0x0F) + ((h6l >> 16) & 0x0F),
	            16 * ((h6l >> 12) & 0x0F) + ((h6l >> 8) & 0x0F),
	            16 * ((h6l >> 4) & 0x0F) + (h6l & 0x0F),
	            16 * ((h7h >> 28) & 0x0F) + ((h7h >> 24) & 0x0F),
	            16 * ((h7h >> 20) & 0x0F) + ((h7h >> 16) & 0x0F),
	            16 * ((h7h >> 12) & 0x0F) + ((h7h >> 8) & 0x0F),
	            16 * ((h7h >> 4) & 0x0F) + (h7h & 0x0F),
	            16 * ((h7l >> 28) & 0x0F) + ((h7l >> 24) & 0x0F),
	            16 * ((h7l >> 20) & 0x0F) + ((h7l >> 16) & 0x0F),
	            16 * ((h7l >> 12) & 0x0F) + ((h7l >> 8) & 0x0F),
	            16 * ((h7l >> 4) & 0x0F) + (h7l & 0x0F)];
	    };
	
	
	    root.sha512 = sha512;
	    Sha512.hash = sha512;
	    module.exports = Sha512;
	}(this));

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	
	"use strict";
	
	(function () {
	
	    var createBuffer = null, copyBuffer = null;
	
	    var slowCreateBuffer = function (arg) {
	
	       
	        if (typeof arg === 'number') {
	            var result = [];
	            for (var i = 0; i < arg; i++) {
	                result.push(0);
	            }
	            return result;
	
	        }
	       
	        for (i = 0; i < arg.length; i++) {
	            if (arg[i] < 0 || arg[i] >= 256 || typeof arg[i] !== 'number') {
	                throw new Error('invalid byte (' + arg[i] + ':' + i + ')');
	            }
	        }
	
	       
	        if (arg.slice) {
	            return arg.slice(0);
	        }
	
	       
	        result = [];
	        for (i = 0; i < arg.length; i++) {
	            result.push(arg[i]);
	        }
	        return result;
	
	    };
	
	    createBuffer = slowCreateBuffer;
	
	    copyBuffer = function (sourceBuffer, targetBuffer, targetStart, sourceStart, sourceEnd) {
	        if (targetStart === null) {
	            targetStart = 0;
	        }
	        if (sourceStart === null) {
	            sourceStart = 0;
	        }
	        if (sourceEnd === null) {
	            sourceEnd = sourceBuffer.length;
	        }
	        for (var i = sourceStart; i < sourceEnd; i++) {
	            targetBuffer[targetStart++] = sourceBuffer[i];
	        }
	    };
	
	   
	    var numberOfRounds = {16: 10, 24: 12, 32: 14};
	
	   
	    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
	
	   
	    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
	    var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
	
	   
	    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
	    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
	    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
	    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
	
	   
	    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
	    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
	    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
	    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
	
	   
	    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
	    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
	    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
	    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
	
	
	    function convertToInt32(bytes) {
	        var result = [];
	        for (var i = 0; i < bytes.length; i += 4) {
	            result.push(
	                (bytes[i] << 24) |
	                (bytes[i + 1] << 16) |
	                (bytes[i + 2] << 8) |
	                bytes[i + 3]
	            );
	        }
	        return result;
	    }
	
	
	    var AES = function (key) {
	        if (!(this instanceof AES)) {
	            throw Error('AES must be instanitated with `new`');
	        }
	
	        this.key = createBuffer(key);
	        this._prepare();
	    };
	
	
	    AES.prototype._prepare = function () {
	
	        var rounds = numberOfRounds[this.key.length];
	        if (rounds === null) {
	            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
	        }
	
	       
	        this._Ke = [];
	
	       
	        this._Kd = [];
	
	        for (var i = 0; i <= rounds; i++) {
	            this._Ke.push([0, 0, 0, 0]);
	            this._Kd.push([0, 0, 0, 0]);
	        }
	
	        var roundKeyCount = (rounds + 1) * 4;
	        var KC = this.key.length / 4;
	
	       
	        var tk = convertToInt32(this.key);
	
	       
	        var index;
	        for (i = 0; i < KC; i++) {
	            index = i >> 2;
	            this._Ke[index][i % 4] = tk[i];
	            this._Kd[rounds - index][i % 4] = tk[i];
	        }
	
	       
	        var rconpointer = 0;
	        var t = KC, tt;
	        while (t < roundKeyCount) {
	            tt = tk[KC - 1];
	            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
	            (S[(tt >> 8) & 0xFF] << 16) ^
	            (S[tt & 0xFF] << 8) ^
	            S[(tt >> 24) & 0xFF] ^
	            (rcon[rconpointer] << 24));
	            rconpointer += 1;
	
	           
	            if (KC !== 8) {
	                for (i = 1; i < KC; i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	
	               
	            } else {
	                for (i = 1; i < (KC / 2); i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	                tt = tk[(KC / 2) - 1];
	
	                tk[KC / 2] ^= (S[tt & 0xFF] ^
	                (S[(tt >> 8) & 0xFF] << 8) ^
	                (S[(tt >> 16) & 0xFF] << 16) ^
	                (S[(tt >> 24) & 0xFF] << 24));
	
	                for (i = (KC / 2) + 1; i < KC; i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	            }
	
	           
	            i = 0;
	            var r, c;
	            while (i < KC && t < roundKeyCount) {
	                r = t >> 2;
	                c = t % 4;
	                this._Ke[r][c] = tk[i];
	                this._Kd[rounds - r][c] = tk[i++];
	                t++;
	            }
	        }
	
	       
	        for (r = 1; r < rounds; r++) {
	            for (c = 0; c < 4; c++) {
	                tt = this._Kd[r][c];
	                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
	                U2[(tt >> 16) & 0xFF] ^
	                U3[(tt >> 8) & 0xFF] ^
	                U4[tt & 0xFF]);
	            }
	        }
	    };
	
	    AES.prototype.encrypt = function (plaintext) {
	        if (plaintext.length !== 16) {
	            throw new Error('invalid plaintext size (must be 16 bytes)');
	        }
	
	        var rounds = this._Ke.length - 1;
	        var a = [0, 0, 0, 0];
	
	       
	        var t = convertToInt32(plaintext);
	        for (var i = 0; i < 4; i++) {
	            t[i] ^= this._Ke[0][i];
	        }
	
	       
	        for (var r = 1; r < rounds; r++) {
	            for (i = 0; i < 4; i++) {
	                a[i] = (T1[(t[i] >> 24) & 0xff] ^
	                T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
	                T3[(t[(i + 2) % 4] >> 8) & 0xff] ^
	                T4[t[(i + 3) % 4] & 0xff] ^
	                this._Ke[r][i]);
	            }
	            t = a.slice(0);
	        }
	
	       
	        var result = createBuffer(16), tt;
	        for (i = 0; i < 4; i++) {
	            tt = this._Ke[rounds][i];
	            result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
	            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
	            result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
	            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
	        }
	
	        return result;
	    };
	
	    AES.prototype.decrypt = function (ciphertext) {
	        if (ciphertext.length !== 16) {
	            throw new Error('invalid ciphertext size (must be 16 bytes)');
	        }
	
	        var rounds = this._Kd.length - 1;
	        var a = [0, 0, 0, 0];
	
	       
	        var t = convertToInt32(ciphertext);
	        for (var i = 0; i < 4; i++) {
	            t[i] ^= this._Kd[0][i];
	        }
	
	       
	        for (var r = 1; r < rounds; r++) {
	            for (i = 0; i < 4; i++) {
	                a[i] = (T5[(t[i] >> 24) & 0xff] ^
	                T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
	                T7[(t[(i + 2) % 4] >> 8) & 0xff] ^
	                T8[t[(i + 1) % 4] & 0xff] ^
	                this._Kd[r][i]);
	            }
	            t = a.slice(0);
	        }
	
	       
	        var result = createBuffer(16), tt;
	        for (i = 0; i < 4; i++) {
	            tt = this._Kd[rounds][i];
	            result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
	            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
	            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
	            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
	        }
	
	        return result;
	    };
	
	
	    
	    var ModeOfOperationECB = function (key) {
	        if (!(this instanceof ModeOfOperationECB)) {
	            throw Error('AES must be instanitated with `new`');
	        }
	
	        this.description = "Electronic Code Block";
	        this.name = "ecb";
	
	        this._aes = new AES(key);
	    };
	
	    ModeOfOperationECB.prototype.encrypt = function (plaintext) {
	        if ((plaintext.length % 16) !== 0) {
	            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
	        }
	
	        var ciphertext = createBuffer(plaintext.length);
	        var block = createBuffer(16);
	
	        for (var i = 0; i < plaintext.length; i += 16) {
	            copyBuffer(plaintext, block, 0, i, i + 16);
	            block = this._aes.encrypt(block);
	            copyBuffer(block, ciphertext, i, 0, 16);
	        }
	
	        return ciphertext;
	    };
	
	    ModeOfOperationECB.prototype.decrypt = function (ciphertext) {
	        if ((ciphertext.length % 16) !== 0) {
	            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
	        }
	
	        var plaintext = createBuffer(ciphertext.length);
	        var block = createBuffer(16);
	
	        for (var i = 0; i < ciphertext.length; i += 16) {
	            copyBuffer(ciphertext, block, 0, i, i + 16);
	            block = this._aes.decrypt(block);
	            copyBuffer(block, plaintext, i, 0, 16);
	        }
	
	        return plaintext;
	    };
	
	
	    
	    var ModeOfOperationCBC = function (key, iv) {
	        if (!(this instanceof ModeOfOperationCBC)) {
	            throw Error('AES must be instanitated with `new`');
	        }
	
	        this.description = "Cipher Block Chaining";
	        this.name = "cbc";
	
	        if (!iv) {
	            iv = createBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	
	        } else if (iv.length !== 16) {
	            throw new Error('invalid initialation vector size (must be 16 bytes)');
	        }
	
	        this._lastCipherblock = createBuffer(iv);
	
	        this._aes = new AES(key);
	    };
	
	    ModeOfOperationCBC.prototype.encrypt = function (plaintext) {
	        if ((plaintext.length % 16) !== 0) {
	            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
	        }
	
	        var ciphertext = createBuffer(plaintext.length);
	        var block = createBuffer(16);
	
	        for (var i = 0; i < plaintext.length; i += 16) {
	            copyBuffer(plaintext, block, 0, i, i + 16);
	
	            for (var j = 0; j < 16; j++) {
	                block[j] ^= this._lastCipherblock[j];
	            }
	
	            this._lastCipherblock = this._aes.encrypt(block);
	            copyBuffer(this._lastCipherblock, ciphertext, i, 0, 16);
	        }
	
	        return ciphertext;
	    };
	
	    ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {
	        if ((ciphertext.length % 16) !== 0) {
	            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
	        }
	
	        var plaintext = createBuffer(ciphertext.length);
	        var block = createBuffer(16);
	
	        for (var i = 0; i < ciphertext.length; i += 16) {
	            copyBuffer(ciphertext, block, 0, i, i + 16);
	            block = this._aes.decrypt(block);
	
	            for (var j = 0; j < 16; j++) {
	                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
	            }
	
	            copyBuffer(ciphertext, this._lastCipherblock, 0, i, i + 16);
	        }
	
	        return plaintext;
	    };
	   
	    var ModeOfOperation = {
	        ecb: ModeOfOperationECB,
	        cbc: ModeOfOperationCBC
	    };
	   
	    var aesjs = {
	        AES: AES,
	        ModeOfOperation: ModeOfOperation,
	        util: {
	            _slowCreateBuffer: slowCreateBuffer
	        }
	    };
	    module.exports = aesjs;
	
	
	})();


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excelStyle = __webpack_require__(12);
	    
	    var UnitHelper = excelStyle.UnitHelper;
	    var emuToPixles = UnitHelper.emuToPixles;
	    
	    var XmlNodeHelper = (function () {
	        function XmlNodeHelper() {
	        }
	    
	        XmlNodeHelper._getAttrValueOrDefaultOfBooleanType = function (attr, defaultValue) {
	            if (attr === '1') {
	                return true;
	            } else if (attr === '0') {
	                return false;
	            }
	            return defaultValue;
	        };
	        XmlNodeHelper._getAttrValueOrDefaultOfDoubleType = function (attr, defaultValue) {
	            if (attr) {
	                var result = parseFloat(attr);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            return defaultValue;
	        };
	        XmlNodeHelper._getAttributeValueOrDefaultOfIntType = function (attr, defaultValue) {
	            if (attr) {
	                var result = parseInt(attr);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            return defaultValue;
	        };
	        XmlNodeHelper._getAsArray = function (obj) {
	            if (!Array.isArray(obj)) {
	                obj = obj ? [obj] : [];
	            }
	            return obj;
	        };
	    
	        XmlNodeHelper._getValueFromObject = function (obj, key, subKey) {
	            subKey = subKey || key;
	            return obj[key] && obj[key][subKey];
	        };
	    
	        XmlNodeHelper._readXY = function (off, target) {
	            if (off) {
	                target.x = emuToPixles(parseInt(off._attr.x));
	                target.y = emuToPixles(parseInt(off._attr.y));
	            }
	        };
	    
	        XmlNodeHelper._readSize = function (ext, target) {
	            if (ext) {
	                target.width = emuToPixles(parseInt(ext._attr.cx));
	                target.height = emuToPixles(parseInt(ext._attr.cy));
	            }
	        };
	    
	        XmlNodeHelper._readAnchorPoint = function (item) {
	            if (item) {
	                return {
	                    col: parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:col')),
	                    colOffset: emuToPixles(parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:colOff'))),
	                    row: parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:row')),
	                    rowOffset: emuToPixles(parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:rowOff')))
	                };
	            }
	        };
	    
	        return XmlNodeHelper;
	    })();
	    
	    module.exports = XmlNodeHelper;
	
	}());

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var builtInResource = __webpack_require__(13);
	    var Tuple = __webpack_require__(14);
	    var StringEx = common._StringEx;
	
	    var keyword_null = null, keyword_undefined = void 0;
	    var isNullOrUndefined = common._isNullOrUndefined;
	
	    var THEME_HEADINGS = "Headings";
	    var THEME_BODY = "Body";
	    var DEFAULT_FONT_FAMILY = "Calibri";
	    var BOLD = 'bold', ITALIC = 'italic';
	
	   
	   
	   
	   
	   
	   
	
	    (function (FontSchemeCategory) {
	        FontSchemeCategory[FontSchemeCategory['none'] = 0x00] = 'none';
	        FontSchemeCategory[FontSchemeCategory['major'] = 0x01] = 'major';
	        FontSchemeCategory[FontSchemeCategory['minor'] = 0x02] = 'minor';
	        FontSchemeCategory[FontSchemeCategory['ninched'] = 0xFF] = 'ninched';
	    })(exports.FontSchemeCategory || (exports.FontSchemeCategory = {}));
	
	   
	   
	   
	   
	   
	   
	   
	   
	
	    (function (ExcelVerticalAlignment) {
	        ExcelVerticalAlignment[ExcelVerticalAlignment['top'] = 0] = 'top';
	        ExcelVerticalAlignment[ExcelVerticalAlignment['center'] = 1] = 'center';
	        ExcelVerticalAlignment[ExcelVerticalAlignment['bottom'] = 2] = 'bottom';
	        ExcelVerticalAlignment[ExcelVerticalAlignment['justify'] = 3] = 'justify';
	        ExcelVerticalAlignment[ExcelVerticalAlignment['distributed'] = 4] = 'distributed';
	    })(exports.ExcelVerticalAlignment || (exports.ExcelVerticalAlignment = {}));
	
	    (function (ExcelHorizontalAlignment) {
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['general'] = 0] = 'general';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['left'] = 1] = 'left';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['center'] = 2] = 'center';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['right'] = 3] = 'right';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['fill'] = 4] = 'fill';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['justify'] = 5] = 'justify';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['centerContinuous'] = 6] = 'centerContinuous';
	        ExcelHorizontalAlignment[ExcelHorizontalAlignment['distributed'] = 7] = 'distributed';
	    })(exports.ExcelHorizontalAlignment || (exports.ExcelHorizontalAlignment = {}));
	
	    (function (TextDirection) {
	        TextDirection[TextDirection['accordingToContext'] = 0] = 'accordingToContext';
	        TextDirection[TextDirection['leftToRight'] = 1] = 'leftToRight';
	        TextDirection[TextDirection['rightToLeft'] = 2] = 'rightToLeft';
	    })(exports.TextDirection || (exports.TextDirection = {}));
	
	    (function (UnderLineStyle) {
	        UnderLineStyle[UnderLineStyle['none'] = 0] = 'none';
	        UnderLineStyle[UnderLineStyle['single'] = 1] = 'single';
	        UnderLineStyle[UnderLineStyle['double'] = 2] = 'double';
	        UnderLineStyle[UnderLineStyle['singleaccounting'] = 3] = 'singleaccounting';
	        UnderLineStyle[UnderLineStyle['doubleaccounting'] = 4] = 'doubleaccounting';
	    })(exports.UnderLineStyle || (exports.UnderLineStyle = {}));
	
	    (function (VerticalAlignRun) {
	        VerticalAlignRun[VerticalAlignRun['baseLine'] = 0] = 'baseLine';
	        VerticalAlignRun[VerticalAlignRun['superscript'] = 1] = 'superscript';
	        VerticalAlignRun[VerticalAlignRun['subscript'] = 2] = 'subscript';
	    })(exports.VerticalAlignRun || (exports.VerticalAlignRun = {}));
	
	    (function (ExcelBorderStyle) {
	        ExcelBorderStyle[ExcelBorderStyle['none'] = 0] = 'none';
	        ExcelBorderStyle[ExcelBorderStyle['thin'] = 1] = 'thin';
	        ExcelBorderStyle[ExcelBorderStyle['medium'] = 2] = 'medium';
	        ExcelBorderStyle[ExcelBorderStyle['dashed'] = 3] = 'dashed';
	        ExcelBorderStyle[ExcelBorderStyle['dotted'] = 4] = 'dotted';
	        ExcelBorderStyle[ExcelBorderStyle['thick'] = 5] = 'thick';
	        ExcelBorderStyle[ExcelBorderStyle['double'] = 6] = 'double';
	        ExcelBorderStyle[ExcelBorderStyle['hair'] = 7] = 'hair';
	        ExcelBorderStyle[ExcelBorderStyle['mediumDashed'] = 8] = 'mediumDashed';
	        ExcelBorderStyle[ExcelBorderStyle['dashDot'] = 9] = 'dashDot';
	        ExcelBorderStyle[ExcelBorderStyle['mediumDashDot'] = 10] = 'mediumDashDot';
	        ExcelBorderStyle[ExcelBorderStyle['dashDotDot'] = 11] = 'dashDotDot';
	        ExcelBorderStyle[ExcelBorderStyle['mediumDashDotDot'] = 12] = 'mediumDashDotDot';
	        ExcelBorderStyle[ExcelBorderStyle['slantDashDot'] = 13] = 'slantDashDot';
	    })(exports.ExcelBorderStyle || (exports.ExcelBorderStyle = {}));
	
	    (function (FillPatternType) {
	        FillPatternType[FillPatternType['none'] = 0] = 'none';
	        FillPatternType[FillPatternType['solid'] = 1] = 'solid';
	        FillPatternType[FillPatternType['mediumGray'] = 2] = 'mediumGray';
	        FillPatternType[FillPatternType['darkGray'] = 3] = 'darkGray';
	        FillPatternType[FillPatternType['lightGray'] = 4] = 'lightGray';
	        FillPatternType[FillPatternType['darkHorizontal'] = 5] = 'darkHorizontal';
	        FillPatternType[FillPatternType['darkVertical'] = 6] = 'darkVertical';
	        FillPatternType[FillPatternType['darkDown'] = 7] = 'darkDown';
	        FillPatternType[FillPatternType['darkUp'] = 8] = 'darkUp';
	        FillPatternType[FillPatternType['darkGrid'] = 9] = 'darkGrid';
	        FillPatternType[FillPatternType['lightTrellis'] = 10] = 'lightTrellis';
	        FillPatternType[FillPatternType['darkTrellis'] = 11] = 'darkTrellis';
	        FillPatternType[FillPatternType['lightHorizontal'] = 12] = 'lightHorizontal';
	        FillPatternType[FillPatternType['lightVertical'] = 13] = 'lightVertical';
	        FillPatternType[FillPatternType['lightDown'] = 14] = 'lightDown';
	        FillPatternType[FillPatternType['lightUp'] = 15] = 'lightUp';
	        FillPatternType[FillPatternType['lightGrid'] = 16] = 'lightGrid';
	        FillPatternType[FillPatternType['gray125'] = 17] = 'gray125';
	        FillPatternType[FillPatternType['gray0625'] = 18] = 'gray0625';
	    })(exports.FillPatternType || (exports.FillPatternType = {}));
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	    var ExcelColor = (function () {
	        function ExcelColor(colorType, color, tint) {
	            var self = this;
	            if (colorType === 3  && color > 11 && color !== 0xF1 && color !== 0xF2 && color !== 0xF3 && color !== 0xF4 && color !== 0xFF) {
	                throw new Error('themeColorIndexError');
	            }
	            if (tint > 1.0 || tint < -1.0) {
	                throw new Error('colorTintError');
	            }
	            if (colorType === 1  && color === 32767) {
	                self._isAutoColor = true;
	            }
	            self._colorType = colorType || 2;
	            self._color = color || 0;
	            self._tint = tint || 0;
	        }
	
	        ExcelColor.prototype.colorType = function () {
	            return this._colorType;
	        };
	        ExcelColor.prototype.value = function () {
	            return this._color;
	        };
	        ExcelColor.prototype.tint = function () {
	            return this._tint;
	        };
	        ExcelColor.prototype.isAutoColor = function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                return self._isAutoColor;
	            }
	            if (typeof value === 'boolean' && value !== self._isAutoColor) {
	                self._isAutoColor = value;
	            }
	        };
	        ExcelColor.prototype.isIndexedColor = function () {
	            return this._colorType === 1 ;
	        };
	        ExcelColor.prototype.isRGBColor = function () {
	            return this._colorType === 2 ;
	        };
	        ExcelColor.prototype.isThemeColor = function () {
	            return this._colorType === 3 ;
	        };
	        ExcelColor.prototype.equals = function (other) {
	            if (this === other) {
	                return true;
	            }
	            if (!other) {
	                return false;
	            }
	            return this._colorType === other.colorType() &&
	                this.value() === other.value() &&
	                this.tint() === other.tint() &&
	                this.isAutoColor() === other.isAutoColor();
	        };
	        ExcelColor.EmptyColor = new ExcelColor();
	        return ExcelColor;
	    })();
	    exports.ExcelColor = ExcelColor;
	
	    var ExcelBorderSide = (function () {
	        function ExcelBorderSide(color, lineStyle) {
	            this.color = color || null;
	            this.lineStyle = lineStyle || 0;
	        }
	
	        ExcelBorderSide.prototype.equals = function (other) {
	            var self = this;
	            if (self === other) {
	                return true;
	            }
	            if (!other) {
	                return false;
	            }
	            if (!self.color) {
	                if (other.color) {
	                    return false;
	                }
	                return self.lineStyle === other.lineStyle;
	            }
	            return self.color.equals(other.color) && self.lineStyle === other.lineStyle;
	        };
	        return ExcelBorderSide;
	    })();
	    exports.ExcelBorderSide = ExcelBorderSide;
	
	    var ExcelBorder = (function () {
	        function ExcelBorder() {
	            var self = this;
	            self.left = new ExcelBorderSide();
	            self.top = new ExcelBorderSide();
	            self.right = new ExcelBorderSide();
	            self.bottom = new ExcelBorderSide();
	            self.diagonalUp = new ExcelBorderSide();
	            self.diagonalDown = new ExcelBorderSide();
	        }
	
	        ExcelBorder.prototype.clone = function () {
	            var self = this, border = new ExcelBorder();
	            border.left = new ExcelBorderSide(self.left.color, self.left.lineStyle);
	            border.right = new ExcelBorderSide(self.right.color, self.right.lineStyle);
	            border.top = new ExcelBorderSide(self.top.color, self.top.lineStyle);
	            border.bottom = new ExcelBorderSide(self.bottom.color, self.bottom.lineStyle);
	            border.diagonalUp = new ExcelBorderSide(self.diagonalUp.color, self.diagonalUp.lineStyle);
	            border.diagonalDown = new ExcelBorderSide(self.diagonalDown.color, self.diagonalDown.lineStyle);
	            return border;
	        };
	        ExcelBorder.prototype.equals = function (other) {
	            var self = this;
	            if (self === other) {
	                return true;
	            }
	            if (!other) {
	                return false;
	            }
	            return self.left.equals(other.left) &&
	                self.right.equals(other.right) &&
	                self.top.equals(other.top) &&
	                self.bottom.equals(other.bottom) &&
	                self.diagonalUp.equals(other.diagonalUp) &&
	                self.diagonalDown.equals(other.diagonalDown);
	        };
	        return ExcelBorder;
	    })();
	    exports.ExcelBorder = ExcelBorder;
	
	    var ExcelFont = (function () {
	        function ExcelFont(name, fontColor, fontFamily) {
	            var self = this;
	            if (typeof fontColor !== 'undefined') {
	                self.fontColor = fontColor;
	            } else {
	                self.fontColor = null;
	            }
	            if (typeof name !== 'undefined') {
	                self.fontName = name;
	            } else {
	                self.fontName = null;
	            }
	            if (typeof fontFamily !== 'undefined') {
	                self.fontFamily = fontFamily;
	            } else {
	                self.fontFamily = 0 ;
	            }
	            self.isAutoColor = false;
	            self.isBold = false;
	            self.isItalic = false;
	            self.isOutlineStyle = false;
	            self.isShadowStyle = false;
	            self.isStrikeOut = false;
	            self.fontScheme = 0 ;
	            self.fontSize = 11;
	            self.charSetIndex = 0;
	            self.underLineStyle = 0 ;
	            self.verticalAlignRun = 0 ;
	            self._default = null;
	        }
	
	        ExcelFont.prototype.equals = function (right) {
	            var self = this;
	            if (self === right) {
	                return true;
	            }
	            if (!right) {
	                return false;
	            }
	            var result = self.isBold === right.isBold &&
	                self.isItalic === right.isItalic &&
	                this.isOutlineStyle === right.isOutlineStyle &&
	                this.isShadowStyle === right.isShadowStyle &&
	                this.isStrikeOut === right.isStrikeOut &&
	                this.fontName === right.fontName &&
	                this.fontFamily === right.fontFamily &&
	                this.fontSize === right.fontSize &&
	                this.charSetIndex === right.charSetIndex &&
	                this.underLineStyle === right.underLineStyle &&
	                this.verticalAlignRun === right.verticalAlignRun &&
	                this.fontScheme === right.fontScheme;
	            if (!result) {
	                return false;
	            }
	            if (!self.fontColor && !right.fontColor) {
	                return true;
	            } else if (!self.fontColor && right.fontColor) {
	                return false;
	            } else if (self.fontColor && !right.fontColor) {
	                return false;
	            }
	            return self.fontColor.equals(right.fontColor);
	        };
	        ExcelFont.prototype.clone = function () {
	            var self = this;
	            var font = new ExcelFont(self.fontName, self.fontColor, self.fontFamily);
	            font.isAutoColor = self.isAutoColor;
	            font.isBold = self.isBold;
	            font.isItalic = self.isItalic;
	            font.isOutlineStyle = self.isOutlineStyle;
	            font.isShadowStyle = self.isShadowStyle;
	            font.isStrikeOut = self.isStrikeOut;
	            font.fontScheme = self.fontScheme;
	            font.fontSize = self.fontSize;
	            font.charSetIndex = self.charSetIndex;
	            font.underLineStyle = self.underLineStyle;
	            font.verticalAlignRun = self.verticalAlignRun;
	            return font;
	        };
	        ExcelFont.prototype.Default = function () {
	            var self = this;
	            if (!self._default) {
	                self._default = new ExcelFont();
	                self._default.fontSize = 11;
	                self._default.fontFamily = 2 ;
	                self._default.fontColor = new ExcelColor(1 , 0, 0);
	                self._default.fontName = 'Calibri';
	                self._default.charSetIndex = 0;
	            }
	            return self._default;
	        };
	        return ExcelFont;
	    })();
	    exports.ExcelFont = ExcelFont;
	
	    var ExcelNumerFormat = (function () {
	        function ExcelNumerFormat(id, code) {
	            this.numberFormatId = id;
	            this.numberFormatCode = code;
	        }
	
	        ExcelNumerFormat.prototype.equals = function (other) {
	            var self = this;
	            if (self === other) {
	                return true;
	            }
	            if (!other) {
	                return false;
	            }
	            return self.numberFormatId === other.numberFormatId && self.numberFormatCode === other.numberFormatCode;
	        };
	        return ExcelNumerFormat;
	    })();
	    exports.ExcelNumerFormat = ExcelNumerFormat;
	
	    var ExtendedFormat = (function () {
	        function ExtendedFormat() {
	            var self = this;
	            self.font = (new ExcelFont()).Default();
	            self.border = new ExcelBorder();
	            self.applyAlignment = keyword_undefined;
	            self.applyBorder = keyword_undefined;
	            self.applyFill = keyword_undefined;
	            self.applyFont = keyword_undefined;
	            self.applyNumberFormat = keyword_undefined;
	            self.applyProtection = keyword_undefined;
	            self.quotePrefix = keyword_undefined;
	
	            self.patternBackgroundColor = keyword_undefined;
	            self.patternColor = keyword_undefined;
	            self.fillPattern = 0 ;
	
	            self.numberFormatIndex = 0;
	            self.numberFormat = keyword_undefined;
	
	            self.isStyleFormat = false;
	            self.parentFormatID = keyword_undefined;
	
	            self.horizontalAlign = 0 ;
	            self.verticalAlign = 0 ;
	            self.isLocked = false;
	            self.rotation = 0;
	            self.isWordWrap = false;
	            self.isJustfyLastLine = false;
	            self.isShrinkToFit = false;
	            self.isFirstSymbolApostrophe = false;
	            self.readingOrder = 0 ;
	            self.isHidden = false;
	            self.indent = 0;
	            self.isVerticalText = false;
	        }
	
	        ExtendedFormat.Default = function () {
	            var extendedFormat = new ExtendedFormat();
	            extendedFormat.numberFormatIndex = 0;
	            extendedFormat.isLocked = true;
	            extendedFormat.verticalAlign = 2 ;
	            extendedFormat.horizontalAlign = 0 ;
	            return extendedFormat;
	        };
	        ExtendedFormat.prototype.copyFrom = function (source) {
	            var self = this;
	            self.applyAlignment = source.applyAlignment;
	            self.applyBorder = source.applyBorder;
	            self.applyFill = source.applyFill;
	            self.applyFont = source.applyFont;
	            self.applyNumberFormat = source.applyNumberFormat;
	            self.applyProtection = source.applyProtection;
	
	            self.patternBackgroundColor = source.patternBackgroundColor;
	            self.patternColor = source.patternColor;
	            self.fillPattern = source.fillPattern;
	
	            self.border = source.border !== null ? source.border.clone() : null;
	            self.font = source.font !== null ? source.font.clone() : null;
	
	            self.numberFormatIndex = source.numberFormatIndex;
	            self.numberFormat = source.numberFormat;
	
	            self.isStyleFormat = source.isStyleFormat;
	            self.parentFormatID = source.parentFormatID;
	
	            self.horizontalAlign = source.horizontalAlign;
	            self.verticalAlign = source.verticalAlign;
	            self.isLocked = source.isLocked;
	            self.rotation = source.rotation;
	            self.isWordWrap = source.isWordWrap;
	            self.isJustfyLastLine = source.isJustfyLastLine;
	            self.isShrinkToFit = source.isShrinkToFit;
	            self.isFirstSymbolApostrophe = source.isFirstSymbolApostrophe;
	            self.readingOrder = source.readingOrder;
	            self.isHidden = source.isHidden;
	            self.indent = source.indent;
	            self.quotePrefix = source.quotePrefix;
	        };
	        ExtendedFormat.prototype.clone = function () {
	            var s = new ExtendedFormat();
	            s.copyFrom(this);
	            return s;
	        };
	        ExtendedFormat.prototype.equals = function (excelStyle) {
	            var self = this;
	            if (self === excelStyle) {
	                return true;
	            }
	            if (!excelStyle) {
	                return false;
	            }
	            var result = self.fillPattern === excelStyle.fillPattern &&
	                self.numberFormatIndex === excelStyle.numberFormatIndex &&
	                self.horizontalAlign === excelStyle.horizontalAlign &&
	                self.verticalAlign === excelStyle.verticalAlign &&
	                self.isLocked === excelStyle.isLocked &&
	                self.rotation === excelStyle.rotation &&
	                self.isWordWrap === excelStyle.isWordWrap &&
	                self.isJustfyLastLine === excelStyle.isJustfyLastLine &&
	                self.isShrinkToFit === excelStyle.isShrinkToFit &&
	                self.isFirstSymbolApostrophe === excelStyle.isFirstSymbolApostrophe &&
	                self.readingOrder === excelStyle.readingOrder &&
	                self.isHidden === excelStyle.isHidden &&
	                self.indent === excelStyle.indent &&
	                self.applyAlignment === excelStyle.applyAlignment &&
	                self.applyBorder === excelStyle.applyBorder &&
	                self.applyFill === excelStyle.applyFill &&
	                self.applyFont === excelStyle.applyFont &&
	                self.applyNumberFormat === excelStyle.applyNumberFormat &&
	                self.applyProtection === excelStyle.applyProtection &&
	                self.parentFormatID === excelStyle.parentFormatID &&
	                self.quotePrefix === excelStyle.quotePrefix &&
	                self.border.equals(excelStyle.border);
	            if (!self.font) {
	                if (excelStyle.font) {
	                    return false;
	                }
	            } else {
	                result = (result && self.font.equals(excelStyle.font));
	            }
	            if (!self.numberFormat && excelStyle.numberFormat) {
	                return false;
	            }
	            if (self.numberFormat) {
	                result = (result && self.numberFormat.equals(excelStyle.numberFormat));
	            }
	            if (!self.patternColor && excelStyle.patternColor) {
	                return false;
	            }
	            if (!self.patternBackgroundColor && excelStyle.patternBackgroundColor) {
	                return false;
	            }
	
	            if (self.patternBackgroundColor) {
	                result = (result && self.patternBackgroundColor.equals(excelStyle.patternBackgroundColor));
	            }
	            if (self.patternColor) {
	                result = (result && self.patternColor.equals(excelStyle.patternColor));
	            }
	            return result;
	        };
	        return ExtendedFormat;
	    })();
	    exports.ExtendedFormat = ExtendedFormat;
	
	    var ExcelStyle = (function () {
	        function ExcelStyle() {
	            this._format = null;
	            this.builtInStyle = 0 ;
	            this.category = 0;
	            this.isCustomBuiltin = false;
	            this.name = null;
	            this.outLineLevel = 0;
	        }
	
	        ExcelStyle.prototype.format = function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                if (self._format === null) {
	                    self._format = new ExtendedFormat();
	                }
	                return self._format;
	            }
	            self._format = value;
	        };
	        ExcelStyle.prototype.copy = function () {
	            var self = this, result = new ExcelStyle();
	            result.builtInStyle = self.builtInStyle;
	            result.outLineLevel = self.outLineLevel;
	            result.isCustomBuiltin = self.isCustomBuiltin;
	            result.category = self.category;
	            result.name = self.name;
	            result.format(self.format().clone());
	            return result;
	        };
	        ExcelStyle.prototype.isBuiltInStyle = function () {
	            return true;
	        };
	        ExcelStyle.prototype.getBuiltInStyleCategory = function () {
	            var self = this;
	            if (!self.isBuiltInStyle()) {
	                return 0;
	            }
	                        switch (self.builtInStyle) {
	                case 26                     :
	                case 27                     :
	                case 28                     :
	                case 29                     :
	                case 30                     :
	                case 31                     :
	                case 32                     :
	                case 33                     :
	                case 34                     :
	                case 35                     :
	                case 36                     :
	                case 37                     :
	                case 38                     :
	                case 39                     :
	                case 40                     :
	                case 41                     :
	                case 42                     :
	                case 43                     :
	               
	               
	                case 44                     :
	                case 45                     :
	                case 46                     :
	                case 47                     :
	                case 48                     :
	                case 2                     :
	                case 1                     :
	                    return 4;
	                case 24                     :
	                    return 1;
	                case 19                     :
	                    return 2;
	                case 20                     :
	                    return 2;
	                case 3                     :
	                case 6                     :
	                case 4                     :
	                case 7                     :
	                    return 5;
	                case 49                     :
	                    return 2;
	                case 23                     :
	                    return 1;
	                case 13                     :
	                case 14                     :
	                case 15                     :
	                case 16                     :
	                    return 3;
	                case 17                     :
	                    return 2;
	                case 21                     :
	                    return 2;
	                case 25                     :
	                    return 1;
	                case 0                     :
	                    return 1;
	                case 10                     :
	                case 18                     :
	                    return 2;
	                case 5                     :
	                    return 5;
	                case 12                     :
	                case 22                     :
	                    return 3;
	                case 11                     :
	                    return 2;
	                default:
	                    return 0;
	            }
	                    };
	        return ExcelStyle;
	    })();
	    exports.ExcelStyle = ExcelStyle;
	
	    var CustomExcelStyle = (function () {
	        function CustomExcelStyle() {
	            this._format = null;
	            this.name = null;
	        }
	
	        CustomExcelStyle.prototype.format = function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                if (self._format === null) {
	                    self._format = new ExtendedFormat();
	                }
	                return self._format;
	            }
	            self._format = value;
	            return this;
	        };
	        CustomExcelStyle.prototype.copy = function () {
	            var result = new CustomExcelStyle();
	            result.name = this.name;
	            result.format(this.format().clone());
	            return result;
	        };
	        CustomExcelStyle.prototype.isBuiltInStyle = function () {
	            return false;
	        };
	        return CustomExcelStyle;
	    })();
	    exports.CustomExcelStyle = CustomExcelStyle;
	
	    var BuiltInExcelStyles = (function () {
	        function BuiltInExcelStyles() {
	        }
	
	        BuiltInExcelStyles.initBuiltInExcelStyleCollections = function () {
	            BuiltInExcelStyles.builtInStyles.length = 0;
	            var dataString = builtInResource.BuiltInStylesResource;
	            if (dataString) {
	                var XmlReader = __webpack_require__(8);
	                var reader = new XmlReader();
	                reader.reset();
	                reader.setXml(dataString);
	                var fonts = [], fills = [], borders = [], styleXfs = [], numberFormats = {};
	                while (reader.read()) {
	                    if (reader.depth !== 1 || reader.elementType === 2 ) {
	                        continue;
	                    }
	                    var styleReader = __webpack_require__(15);
	                    switch (reader.name()) {
	                        case 'numFmts':
	                            styleReader._readNumberFormats(reader, numberFormats);
	                            break;
	                        case 'fonts':
	                            styleReader._readFonts(reader, fonts);
	                            break;
	                        case 'fills':
	                            styleReader._readFills(reader, fills);
	                            break;
	                        case 'borders':
	                            styleReader._readBorders(reader, borders);
	                            break;
	                        case 'cellStyleXfs':
	                            styleReader._readXFs(reader, styleXfs, fonts, borders, numberFormats, fills, true);
	                            break;
	                        case 'cellStyles':
	                            var depth = reader.depth;
	                            while (reader.read()) {
	                                if (reader.depth <= depth) {
	                                    return;
	                                }
	                                if (reader.nodeType() === 1  && reader.name() === 'cellStyle') {
	                                    var name = keyword_undefined, xfId = 0, builtinId = 0;
	                                    while (reader.moveToNextAttribute()) {
	                                        switch (reader.readAttributeNameAsString()) {
	                                            case 'name':
	                                                name = reader.readContentAsString();
	                                                break;
	                                            case 'xfId':
	                                                xfId = reader.readContentAsInt(0);
	                                                break;
	                                            case 'builtinId':
	                                                builtinId = reader.readContentAsInt(0);
	                                                break;
	                                            default:
	                                                break;
	                                        }
	                                    }
	                                    var cellFormat = styleXfs[xfId];
	                                    cellFormat.isStyleFormat = true;
	                                    var style = new ExcelStyle();
	                                    style.name = name;
	                                    style.format(cellFormat.clone());
	                                    if (!style.format().numberFormat && numberFormats[style.format().numberFormatIndex]) {
	                                        style.format().numberFormat = numberFormats[style.format().numberFormatIndex];
	                                        style.format().numberFormatIndex = 0;
	                                    }
	                                    style.isCustomBuiltin = false;
	                                    style.builtInStyle = builtinId;
	                                    style.category = style.getBuiltInStyleCategory();
	                                    BuiltInExcelStyles.builtInStyles.push(style);
	                                }
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                }
	            }
	        };
	        BuiltInExcelStyles.getBuiltInStyles = function () {
	            var builtLen = BuiltInExcelStyles.builtInStyles.length;
	            if (builtLen !== 47) {
	                BuiltInExcelStyles.initBuiltInExcelStyleCollections();
	            }
	            var result = [];
	            builtLen = BuiltInExcelStyles.builtInStyles.length;
	            for (var i = 0; i < builtLen; i++) {
	                result.push(BuiltInExcelStyles.builtInStyles[i].copy());
	            }
	            return result;
	        };
	        BuiltInExcelStyles.getNormalStyle = function () {
	            var format = new ExtendedFormat();
	            format.font = new ExcelFont();
	            format.font.fontColor = new ExcelColor(3 , 1);
	            format.font.fontSize = 11;
	            format.font.fontName = 'Calibri';
	            var ret = new ExcelStyle();
	            ret.format(format);
	            ret.name = 'Normal';
	            ret.builtInStyle = 0 ;
	            return ret;
	        };
	        BuiltInExcelStyles.builtInStyles = [];
	        return BuiltInExcelStyles;
	    })();
	    exports.BuiltInExcelStyles = BuiltInExcelStyles;
	
	    var ExtendedNumberFormatHelper = (function () {
	        function ExtendedNumberFormatHelper() {
	        }
	
	        ExtendedNumberFormatHelper.builtInNumberFomrat = function () {
	            if (!ExtendedNumberFormatHelper._builtInNumberFomrat) {
	                ExtendedNumberFormatHelper._builtInNumberFomrat = { count: 0 };
	            }
	            if (ExtendedNumberFormatHelper._builtInNumberFomrat.count === 0) {
	                ExtendedNumberFormatHelper.initBuintNumberFormat();
	            }
	            return ExtendedNumberFormatHelper._builtInNumberFomrat;
	        };
	        ExtendedNumberFormatHelper.languageIndepedentNumberFormat = function () {
	            if (!ExtendedNumberFormatHelper._languageIndepedentNumberFormat) {
	                ExtendedNumberFormatHelper._languageIndepedentNumberFormat = { count: 0 };
	            }
	            if (ExtendedNumberFormatHelper._languageIndepedentNumberFormat.count === 0) {
	                ExtendedNumberFormatHelper.initLanguageIndepedentNumberFormat();
	            }
	            return ExtendedNumberFormatHelper._languageIndepedentNumberFormat;
	        };
	        ExtendedNumberFormatHelper.formatCodeTable = function () {
	            if (!ExtendedNumberFormatHelper._formatCodeTable) {
	                ExtendedNumberFormatHelper._formatCodeTable = [];
	            }
	            return ExtendedNumberFormatHelper._formatCodeTable;
	        };
	        ExtendedNumberFormatHelper.customNumberFormat = function () {
	            if (!ExtendedNumberFormatHelper._customNumberFormat) {
	                ExtendedNumberFormatHelper._customNumberFormat = { count: 0 };
	            }
	            return ExtendedNumberFormatHelper._customNumberFormat;
	        };
	        ExtendedNumberFormatHelper.initBuintNumberFormat = function () {
	            var _builtInNumberFormat = ExtendedNumberFormatHelper._builtInNumberFomrat;
	            _builtInNumberFormat[0] = 'General';
	            _builtInNumberFormat[1] = '0';
	            _builtInNumberFormat[2] = '0.00';
	            _builtInNumberFormat[3] = '#,##0';
	            _builtInNumberFormat[4] = '#,##0.00';
	            _builtInNumberFormat[9] = '0%';
	            _builtInNumberFormat[10] = '0.00%';
	            _builtInNumberFormat[11] = '0.00E+00';
	            _builtInNumberFormat[12] = '# ?/?';
	            _builtInNumberFormat[13] = '# ??/??';
	            _builtInNumberFormat[14] = 'm/d/yyyy';
	            _builtInNumberFormat[15] = 'd-mmm-yy';
	            _builtInNumberFormat[16] = 'd-mmm';
	            _builtInNumberFormat[17] = 'mmm-yy';
	            _builtInNumberFormat[18] = 'h:mm AM/PM';
	            _builtInNumberFormat[19] = 'h:mm:ss AM/PM';
	            _builtInNumberFormat[20] = 'h:mm';
	            _builtInNumberFormat[21] = 'h:mm:ss';
	            _builtInNumberFormat[22] = 'm/d/yyyy h:mm';
	            _builtInNumberFormat[37] = '#,##0 ;(#,##0)';
	            _builtInNumberFormat[38] = '#,##0 ;[Red](#,##0)';
	            _builtInNumberFormat[39] = '#,##0.00;(#,##0.00)';
	            _builtInNumberFormat[40] = '#,##0.00;[Red](#,##0.00)';
	            _builtInNumberFormat[45] = 'mm:ss';
	            _builtInNumberFormat[46] = '[h]:mm:ss';
	            _builtInNumberFormat[47] = 'mm:ss.0';
	            _builtInNumberFormat[48] = '##0.0E+0';
	            _builtInNumberFormat[49] = '@';
	            _builtInNumberFormat.count = 49;
	            if (common._getCulture()) {
	                var cultureStr = common._getCulture();
	                if (cultureStr === "zh-cn") {
	                    _builtInNumberFormat[14] = 'yyyy/m/d';
	                    _builtInNumberFormat[17] = 'mmm-yy';
	                    _builtInNumberFormat[22] = 'yyyy/m/d h:mm';
	                    _builtInNumberFormat[27] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[28] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[29] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[30] = 'm-d-yy';
	                    _builtInNumberFormat[31] = 'yyyy\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[32] = 'h\"\u65f6\"mm\"\u5206\"';
	                    _builtInNumberFormat[33] = 'h\"\u65f6\"mm\"\u5206\"ss\"\u79d2\"';
	                    _builtInNumberFormat[34] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"';
	                    _builtInNumberFormat[35] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"ss\"\u79d2\"';
	                    _builtInNumberFormat[36] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[50] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[51] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[52] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[53] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[54] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[55] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"';
	                    _builtInNumberFormat[56] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"ss\"\u79d2\"';
	                    _builtInNumberFormat[57] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[58] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat.count = 58;
	                } else if (cultureStr === "ja-jp") {
	                    _builtInNumberFormat[14] = 'yyyy/m/d';
	                    _builtInNumberFormat[15] = 'dd-mmm-yy';
	                    _builtInNumberFormat[16] = 'dd-mmm';
	                    _builtInNumberFormat[17] = 'mmm-yy';
	                    _builtInNumberFormat[22] = 'yyyy/mm/dd h:mm';
	                    _builtInNumberFormat[27] = '[$-411]ge.m.d';
	                    _builtInNumberFormat[28] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"';
	                    _builtInNumberFormat[29] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"';
	                    _builtInNumberFormat[30] = 'm/d/yy';
	                    _builtInNumberFormat[31] = 'yyyy\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[32] = 'h\"\u6642\"mm\"\u5206\"';
	                    _builtInNumberFormat[33] = 'h\"\u6642\"mm\"\u5206\"ss\"\u79d2\"';
	                    _builtInNumberFormat[34] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[35] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[36] = '[$-411]ge.m.d';
	                    _builtInNumberFormat[50] = '[$-411]ge.m.d';
	                    _builtInNumberFormat[51] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[52] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[53] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[54] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[55] = 'yyyy\"\u5e74\"m\"\u6708\"';
	                    _builtInNumberFormat[56] = 'm\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat[57] = '[$-411]ge.m.d';
	                    _builtInNumberFormat[58] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
	                    _builtInNumberFormat.count = 58;
	                }
	            }
	        };
	        ExtendedNumberFormatHelper.initLanguageIndepedentNumberFormat = function () {
	            var _languageIndepedentNumberFormat = ExtendedNumberFormatHelper._languageIndepedentNumberFormat;
	            _languageIndepedentNumberFormat[27] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[28] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[29] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[30] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[31] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[32] = 'h:mm:ss';
	            _languageIndepedentNumberFormat[33] = 'h:mm:ss';
	            _languageIndepedentNumberFormat[34] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[35] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[36] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[50] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[51] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[52] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[53] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[54] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[55] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[56] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[57] = 'm/d/yyyy';
	            _languageIndepedentNumberFormat[58] = 'm/d/yyyy';
	        };
	        ExtendedNumberFormatHelper.getFormatCode = function (format) {
	            var builtInNumberFomrat = ExtendedNumberFormatHelper.builtInNumberFomrat(),
	                customNumberFormat = ExtendedNumberFormatHelper.customNumberFormat(),
	                languageIndepedentNumberFormat = ExtendedNumberFormatHelper.languageIndepedentNumberFormat(),
	                numberFormatIndex = format.numberFormatIndex;
	            if (format.numberFormat) {
	                var numberFormat = format.numberFormat, numberFormatId = numberFormat.numberFormatId,
	                    numberFormatCode = numberFormat.numberFormatCode;
	                if (builtInNumberFomrat[numberFormatId] && builtInNumberFomrat[numberFormatId] !== numberFormatCode) {
	                    builtInNumberFomrat[numberFormatId] = numberFormatCode;
	                    return numberFormatCode;
	                }
	
	                if (!customNumberFormat[numberFormatCode]) {
	                    customNumberFormat[numberFormatCode] = numberFormatId;
	                    customNumberFormat.count++;
	                }
	                return numberFormatCode;
	            }
	
	            if (builtInNumberFomrat[numberFormatIndex]) {
	                return builtInNumberFomrat[numberFormatIndex];
	            } else if (languageIndepedentNumberFormat[numberFormatIndex]) {
	                return languageIndepedentNumberFormat[numberFormatIndex];
	            }
	            return 'General';
	        };
	
	        ExtendedNumberFormatHelper.getFormatId = function (excelFormatCode) {
	            var formatIDCache = ExtendedNumberFormatHelper._getFormatIDCache();
	            if (formatIDCache[excelFormatCode]) {
	                return formatIDCache[excelFormatCode];
	            }
	            var result;
	            var builtInNumberFormat = ExtendedNumberFormatHelper.builtInNumberFomrat();
	            if (builtInNumberFormat) {
	                for (var id in builtInNumberFormat) {
	                    if (builtInNumberFormat[id] === excelFormatCode) {
	                        result = {
	                            isBuiltIn: true,
	                            id: parseInt(id)
	                        };
	                        formatIDCache[excelFormatCode] = result;
	                        return result;
	                    }
	                }
	            }
	            var customNumberFormat = ExtendedNumberFormatHelper.customNumberFormat();
	            if (customNumberFormat && customNumberFormat[excelFormatCode]) {
	                result = {
	                    isBuiltIn: false,
	                    id: customNumberFormat[excelFormatCode]
	                };
	                formatIDCache[excelFormatCode] = result;
	                return result;
	            }
	            var key = 0;
	            if (customNumberFormat.count > 0) {
	                var maxId = 0;
	                for (var code in customNumberFormat) {
	                    if (customNumberFormat[code] > maxId) {
	                        maxId = customNumberFormat[code];
	                    }
	                }
	                key = maxId;
	            }
	            key = Math.max(ExtendedNumberFormatHelper._startKey++, key) + 1;
	            customNumberFormat[excelFormatCode] = key;
	            result = {
	                isBuiltIn: false,
	                id: key
	            };
	            return result;
	        };
	        ExtendedNumberFormatHelper._getFormatIDCache = function () {
	            if (!ExtendedNumberFormatHelper._formatIDCache) {
	                ExtendedNumberFormatHelper._formatIDCache = {};
	            }
	            return ExtendedNumberFormatHelper._formatIDCache;
	        };
	        ExtendedNumberFormatHelper._builtInNumberFomrat = { count: 0 };
	        ExtendedNumberFormatHelper._languageIndepedentNumberFormat = { count: 0 };
	        ExtendedNumberFormatHelper._customNumberFormat = { count: 0 };
	
	        ExtendedNumberFormatHelper._startKey = 170;
	        return ExtendedNumberFormatHelper;
	    })();
	    exports.ExtendedNumberFormatHelper = ExtendedNumberFormatHelper;
	
	    var UnitHelper = (function () {
	        function UnitHelper() {
	        }
	
	        function roundToDecimal(value, digits) {
	            var mult = Math.pow(10, digits);
	
	            return Math.round(value * mult) / mult;
	        }
	
	        UnitHelper.pointToPixel = function (point) {
	            return roundToDecimal(point * 96 / 72, 2);
	        };
	        UnitHelper.pixelToPoint = function (pixel) {
	            return pixel * 72 / 96;
	        };
	       
	       
	        UnitHelper.emuToPixles = function (emu) {
	            return roundToDecimal(emu * 96 / 914400, 2);
	        };
	
	       
	       
	        UnitHelper.pixelToEMU = function (px) {
	            return Math.round(px * 914400 / 96);
	        };
	        UnitHelper.getMaxiumDigitWidth = function (font) {
	            var charArray = '0123456789';
	            var maxWidth = 0;
	            var size = 0;
	            var maxDigitWidthCache = UnitHelper._getMaxiumDigitWidthCache();
	            if (maxDigitWidthCache[font]) {
	                return maxDigitWidthCache[font];
	            }
	            for (var i = 0; i < charArray.length; i++) {
	                size = UnitHelper.measureText(charArray.charAt(i), font);
	                if (size > maxWidth) {
	                    maxWidth = size;
	                }
	            }
	            if (maxWidth > 0) {
	                maxDigitWidthCache[font] = maxWidth;
	                return maxWidth;
	            }
	            maxDigitWidthCache[font] = 7;
	            return maxDigitWidthCache[font];
	        };
	        UnitHelper._getMaxiumDigitWidthCache = function () {
	            if (!UnitHelper._maxiumDigitWidthCache) {
	                UnitHelper._maxiumDigitWidthCache = {};
	            }
	            return UnitHelper._maxiumDigitWidthCache;
	        };
	        UnitHelper.measureText = function (text, font) {
	            function getCanvas() {
	                if (!UnitHelper._canvas) {
	                    UnitHelper._canvas = document.createElement('canvas');
	                }
	                return UnitHelper._canvas;
	            }
	            try {
	                var canvas = getCanvas();
	                var ctx = canvas.getContext('2d');
	                ctx.font = font;
	                return ctx.measureText(text).width;
	            } catch (e) {
	               
	               
	               
	               
	               
	               
	                return 8;
	            }
	        };
	        return UnitHelper;
	    })();
	    exports.UnitHelper = UnitHelper;
	
	    var _Color = (function () {
	        function _Color(a, r, g, b) {
	            var self = this;
	            self.a = a;
	            self.r = r;
	            self.g = g;
	            self.b = b;
	        }
	
	        _Color.prototype.toString = function () {
	            var self = this;
	            if (self.a === 255) {
	                return '#' + self.getColorUnitString(self.r) + self.getColorUnitString(self.g) + self.getColorUnitString(self.b);
	            }
	            return 'rgba(' + self.r + ',' + self.g + ',' + self.b + ',' + self.a + ')';
	        };
	        _Color.prototype.getColorUnitString = function (unit) {
	            var s = unit.toString(16);
	            if (s.length === 1) {
	                s = '0' + s;
	            }
	            return s;
	        };
	        _Color.hueToRGB = function (n1, n2, hue) {
	            if (hue < 0) {
	                hue += 240;
	            }
	            if (hue > 240) {
	                hue -= 240;
	            }
	            if (hue < 40) {
	                return (n1 + ((((n2 - n1) * hue) + 20) / 40));
	            }
	            if (hue < 120) {
	                return n2;
	            }
	            if (hue < 160) {
	                return (n1 + ((((n2 - n1) * (160 - hue)) + 20) / 40));
	            }
	            return n1;
	        };
	        _Color.fromHLS = function (hue, luminosity, saturation) {
	            var r, g, b;
	            if (saturation === 0) {
	                r = g = b = parseInt(((luminosity * 0xff) / 240), 10);
	            } else {
	                var n1, n2;
	                if (luminosity <= 120) {
	                    n2 = ((luminosity * (240 + saturation)) + 120) / 240;
	                } else {
	                    n2 = (luminosity + saturation) - (((luminosity * saturation) + 120) / 240);
	                }
	                n1 = (2 * luminosity) - n2;
	                r = parseInt((((_Color.hueToRGB(n1, n2, hue + 80) * 0xff) + 120) / 240), 10);
	                g = parseInt((((_Color.hueToRGB(n1, n2, hue) * 0xff) + 120) / 240), 10);
	                b = parseInt((((_Color.hueToRGB(n1, n2, hue - 80) * 0xff) + 120) / 240), 10);
	            }
	            return new _Color(0xff, r, g, b);
	        };
	        return _Color;
	    })();
	    exports._Color = _Color;
	
	    var HLSColor = (function () {
	        function HLSColor(rgbColor) {
	            var self = this;
	            var r = rgbColor.r, g = rgbColor.g, b = rgbColor.b;
	            var maxUnit = Math.max(Math.max(r, g), b);
	            var minUnit = Math.min(Math.min(r, g), b);
	            var sum = maxUnit + minUnit;
	            self.luminosity = parseInt((((sum * 240) + 0xff) / 510).toString(), 10);
	            var diff = maxUnit - minUnit;
	            if (diff === 0) {
	                self.saturation = 0;
	                self.hue = 160;
	            } else {
	                if (self.luminosity <= 120) {
	                    self.saturation = parseInt((((diff * 240) + (sum / 2)) / sum).toString(), 10);
	                } else {
	                    self.saturation = parseInt((((diff * 240) + ((510 - sum) / 2)) / (510 - sum)).toString(), 10);
	                }
	                var partR = (((maxUnit - r) * 40) + (diff / 2)) / diff;
	                var partG = (((maxUnit - g) * 40) + (diff / 2)) / diff;
	                var partB = (((maxUnit - b) * 40) + (diff / 2)) / diff;
	                if (r === maxUnit) {
	                    self.hue = parseInt((partB - partG).toString(), 10);
	                } else if (g === maxUnit) {
	                    self.hue = parseInt(((80 + partR) - partB).toString(), 10);
	                } else {
	                    self.hue = parseInt(((160 + partG) - partR).toString(), 10);
	                }
	                if (self.hue < 0) {
	                    self.hue += 240;
	                }
	                if (self.hue > 240) {
	                    self.hue -= 240;
	                }
	            }
	        }
	
	        HLSColor.prototype.toColor = function () {
	            return _Color.fromHLS(this.hue, this.luminosity, this.saturation);
	        };
	        return HLSColor;
	    })();
	
	    var ColorHelper = (function () {
	        function ColorHelper() {
	        }
	
	        ColorHelper.getThemeColorName = function (color) {
	            if (!color || color.colorType() !== 3 ) {
	                return null;
	            }
	           
	           
	           
	           
	           
	           
	           
	           
	            var tint = Math.round(color.tint() * 100);
	            if (color.value() === 0 || color.value() === 0xF3) {
	                return 'Background 1 ' + tint;
	            }
	            if (color.value() === 1 || color.value() === 0XF1) {
	                return 'Text 1 ' + tint;
	            }
	            if (color.value() === 2 || color.value() === 0xF4) {
	                return 'Background 2 ' + tint;
	            }
	            if (color.value() === 3 || color.value() === 0xF2) {
	                return 'Text 2 ' + tint;
	            }
	            if (color.value() === 4) {
	                return 'Accent 1 ' + tint;
	            }
	            if (color.value() === 5) {
	                return 'Accent 2 ' + tint;
	            }
	            if (color.value() === 6) {
	                return 'Accent 3 ' + tint;
	            }
	            if (color.value() === 7) {
	                return 'Accent 4 ' + tint;
	            }
	            if (color.value() === 8) {
	                return 'Accent 5 ' + tint;
	            }
	            if (color.value() === 9) {
	                return 'Accent 6 ' + tint;
	            }
	            return null;
	        };
	        ColorHelper.getThemeColorIndex = function (themeColor, isChartTheme) {
	            if (themeColor.substring(0, 12) === 'Background 1') {
	                if (isChartTheme) {
	                    return 0xF3;
	                }
	                return 0;
	            }
	            if (themeColor.substring(0, 6) === 'Text 1') {
	                if (isChartTheme) {
	                    return 0xF1;
	                }
	                return 1;
	            }
	            if (themeColor.substring(0, 12) === 'Background 2') {
	                if (isChartTheme) {
	                    return 0xF4;
	                }
	                return 2;
	            }
	            if (themeColor.substring(0, 6) === 'Text 2') {
	                if (isChartTheme) {
	                    return 0xF2;
	                }
	                return 3;
	            }
	            if (themeColor.substring(0, 8) === 'Accent 1') {
	                return 4;
	            }
	            if (themeColor.substring(0, 8) === 'Accent 2') {
	                return 5;
	            }
	            if (themeColor.substring(0, 8) === 'Accent 3') {
	                return 6;
	            }
	            if (themeColor.substring(0, 8) === 'Accent 4') {
	                return 7;
	            }
	            if (themeColor.substring(0, 8) === 'Accent 5') {
	                return 8;
	            }
	            if (themeColor.substring(0, 8) === 'Accent 6') {
	                return 9;
	            }
	        };
	        ColorHelper._getThemeColorCache = function () {
	            if (!ColorHelper._themeColorCache) {
	                ColorHelper._themeColorCache = {};
	            }
	            return ColorHelper._themeColorCache;
	        };
	        ColorHelper.getExcelThemeColor = function (themeColor) {
	            if (!StringEx._isNullOrEmpty(themeColor)) {
	                var themeColorCache = ColorHelper._getThemeColorCache();
	                if (themeColorCache[themeColor]) {
	                    return themeColorCache[themeColor];
	                }
	                var tint = 0;
	                var themeColorParts = themeColor.split(' ');
	                if (themeColorParts.length >= 3) {
	                    tint = parseFloat(themeColorParts[2]);
	                    if (!isNaN(tint)) {
	                        tint = tint / 100;
	                    }
	                }
	                var result = new ExcelColor(3 , ColorHelper.getThemeColorIndex(themeColor), tint);
	                themeColorCache[themeColor] = result;
	                return result;
	            }
	            return ExcelColor.EmptyColor;
	        };
	        ColorHelper.toRGBColor = function (excelColor) {
	            if (!excelColor) {
	                return null;
	            }
	            return ColorHelper.getRGBColor(excelColor).toString();
	        };
	        ColorHelper.colorFromIndex = function (index, alpha) {
	            if (index === 32767) {
	                return new _Color(0, 0, 0, 0);
	            }
	            if (index < 0 || index >= ColorHelper.palette.length) {
	                return new _Color(0, 255, 255, 255);
	            }
	            if (!ColorHelper.useCustomPalette) {
	                var value = ColorHelper.palette[index];
	
	                var r = ((value >> 16) & 0xFF);
	                var g = ((value >> 8) & 0xFF);
	                var b = (value & 0xFF);
	                return new _Color(alpha, r, g, b);
	            }
	            if (ColorHelper.customPalette[index] !== keyword_undefined) {
	                return ColorHelper.customPalette[index];
	            }
	            if (index === 64) {
	                return new _Color(255, 0, 0, 0);
	            } else if (index === 65) {
	                return new _Color(255, 255, 255, 255);
	            }
	            return new _Color(0, 255, 255, 255);
	        };
	        ColorHelper.updateTint = function (baseColor, tint) {
	            if (tint === 0.0) {
	                return baseColor;
	            }
	
	            var color = new HLSColor(baseColor);
	            if (tint > 0) {
	                var num1 = 240 - color.luminosity;
	                var num2 = num1 * tint;
	                return _Color.fromHLS(color.hue, color.luminosity + num2, color.saturation);
	            }
	            num2 = color.luminosity * (-tint);
	            return _Color.fromHLS(color.hue, color.luminosity - num2, color.saturation);
	        };
	        ColorHelper.getRGBColor = function (excelColor) {
	            if (excelColor === null || excelColor === keyword_undefined) {
	                return new _Color(0, 255, 255, 255);
	            }
	            if (excelColor.isAutoColor()) {
	                return new _Color(255, 0, 0, 0);
	            }
	            if (excelColor.isIndexedColor()) {
	                var color = ColorHelper.colorFromIndex(excelColor.value() | 0, 255, null);
	                return ColorHelper.updateTint(color, excelColor.tint());
	            }
	            if (excelColor.isRGBColor()) {
	                var value = ((excelColor.value() & 0xFFFFFF) + 0xFF000000);
	                color = ColorHelper.fromArgb(value);
	                return ColorHelper.updateTint(color, excelColor.tint());
	            }
	            if (excelColor.isThemeColor()) {
	                return ColorHelper.getThemeColorName(excelColor);
	            }
	            return new _Color(0, 255, 255, 255);
	        };
	        ColorHelper.fromArgb = function (value) {
	            return new _Color(((value >> 24) & 0xFF), ((value >> 16) & 0xFF), ((value >> 8) & 0xFF), (value & 0xFF));
	        };
	        ColorHelper.getRGBAColorData = function (excelColor) {
	            var color = ColorHelper.fromArgb(excelColor.value());
	            return {
	                rgb: color.getColorUnitString(color.r) + color.getColorUnitString(color.g) + color.getColorUnitString(color.b),
	                alpha: color.a
	            };
	        };
	        ColorHelper._getHtmlColorCache = function () {
	            if (!ColorHelper._htmlColorCache) {
	                ColorHelper._htmlColorCache = {};
	            }
	            return ColorHelper._htmlColorCache;
	        };
	        ColorHelper.fromHtmlColor = function (value) {
	            if (!value) {
	                return;
	            }
	            if (typeof value !== 'string') {
	                return value;
	            }
	            var htmlColorCache = ColorHelper._getHtmlColorCache();
	            if (htmlColorCache[value]) {
	                return htmlColorCache[value];
	            }
	            var value2 = value.toLowerCase(), result;
	            if (value2.substring(0, 1) === '#') {
	               
	                if (value2.length === 7) {
	                   
	                    value2 = '#ff' + value2.substring(1);
	                } else if (value2.length === 4) {
	                   
	                   
	                   
	                   
	                    value2 = '#ff' + value2[1] + value2[1] + value2[2] + value2[2] + value2[3] + value2[3];
	                }
	                result = parseInt(value2.substring(1, value2.length), 16);
	            } else if (value2.substring(0, 4) === 'rgb(') {
	                var leftBracket = value2.indexOf('('), rightBracket = value2.indexOf(')');
	                var colors = value2.substring(leftBracket + 1, rightBracket).split(',');
	                result = 255 * Math.pow(16, 6) + parseInt(colors[0]) * Math.pow(16, 4) + parseInt(colors[1]) * Math.pow(16, 2) + parseInt(colors[2]);
	            } else if (value2.substring(0, 5) === 'rgba(') {
	                leftBracket = value2.indexOf('(');
	                rightBracket = value2.indexOf(')');
	                colors = value2.substring(leftBracket + 1, rightBracket).split(',');
	               
	               
	                result = parseInt(parseFloat(colors[3]) * 255) * Math.pow(16, 6) + parseInt(colors[0]) * Math.pow(16, 4) + parseInt(colors[1]) * Math.pow(16, 2) + parseInt(colors[2]);
	            } else if (ColorHelper._preSetColors[value2]) {
	                result = ColorHelper._preSetColors[value2];
	            } else {
	                result = parseInt(value2);
	            }
	            htmlColorCache[value] = result;
	            return result;
	        };
	        ColorHelper.isThemeColor = function (value) {
	            if (!value || typeof value !== 'string') {
	                return false;
	            }
	            value = value.toLowerCase();
	            var fl = value[0];
	            switch (fl) {
	                case 'b':
	                    return value.indexOf('background ') === 0;
	                case 't':
	                    return value.indexOf('text ') === 0;
	                case 'a':
	                    return value.indexOf('accent ') === 0;
	                case 'h':
	                    return value.indexOf('hyperlink ') === 0;
	                case 'f':
	                    return value.indexOf('fhyperlink ') === 0;
	                default:
	                    return false;
	            }
	        };
	        ColorHelper.mixTranslucentColor = function (baseColor, color) {
	            if (color.a === 255) {
	                return color;
	            }
	            if (color.a === 0) {
	                return baseColor;
	            }
	            var colorA = Math.round(((255 - baseColor.a) * color.a) / 255);
	            var r = ColorHelper.getMaxInt(baseColor.a, color.a, baseColor.r, color.r, colorA + baseColor.a);
	            var g = ColorHelper.getMaxInt(baseColor.a, color.a, baseColor.g, color.g, colorA + baseColor.a);
	            var b = ColorHelper.getMaxInt(baseColor.a, color.a, baseColor.b, color.b, colorA + baseColor.a);
	            return new _Color(Math.round(colorA + baseColor.a), r, g, b);
	        };
	        ColorHelper.getMaxInt = function (baseColorAlpha, colorAlpha, baseColorValue, colorValue, resultColorAlpha) {
	            if (resultColorAlpha === 0) {
	                return 0;
	            }
	            return ((colorAlpha * colorValue) + (255 - colorAlpha) * baseColorAlpha * baseColorValue / 255.0) / resultColorAlpha;
	        };
	        ColorHelper.toExcelColor = function (color, expectValue) {
	            if (expectValue === keyword_undefined) {
	                expectValue = 0xffffff;
	            }
	            if (!color) {
	                return null;
	            }
	            if (ColorHelper.isThemeColor(color)) {
	                return ColorHelper.getExcelThemeColor(color);
	            }
	            var color1 = ColorHelper.fromHtmlColor(color);
	            if (color1 !== expectValue) {
	                return ColorHelper.fromColorToExcelColor(ColorHelper.fromArgb(color1));
	            }
	            return null;
	        };
	        ColorHelper.toExcelIndexedColor = function (excelColor) {
	            if (excelColor) {
	                var colorIndex = ColorHelper.getPaletteColorIndex(excelColor, 63);
	                return new ExcelColor(1 , colorIndex);
	            }
	            return null;
	        };
	        ColorHelper.fromColorToExcelColor = function (color) {
	            color = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), color);
	           
	            if (color.a !== 255) {
	                var bgColor = ColorHelper._whiteBGColor;
	               
	                var r = (bgColor.r - color.a) + ((color.a / 255) * color.r);
	                var g = (bgColor.g - color.a) + ((color.a / 255) * color.g);
	                var b = (bgColor.b - color.a) + ((color.a / 255) * color.b);
	                color = new _Color(255, r, g, b);
	            }
	            var color1 = color.a * Math.pow(16, 6) + color.r * Math.pow(16, 4) + color.g * Math.pow(16, 2) + color.b;
	            return new ExcelColor(2 , color1, 0.0);
	        };
	        ColorHelper.getClosestColorIndex = function (color, startIndex) {
	            if (startIndex === keyword_undefined) {
	                startIndex = 64;
	            }
	            var bestMatchIndex = -1, bestDistance = Number.MAX_VALUE;
	            for (var i = Math.min(ColorHelper.palette.length - 1, startIndex); i >= 0; i--) {
	                var item = ColorHelper.palette[i];
	                var r = (item & 0x00FF0000) >> 16;
	                var g = (item & 0x0000FF00) >> 8;
	                var b = item & 0xFF;
	                var distance = Math.abs((r - color.r) * 0.30) + Math.abs((g - color.g) * 0.59) + Math.abs((b - color.b) * 0.11);
	                if (distance < bestDistance) {
	                    bestDistance = distance;
	                    bestMatchIndex = i;
	                }
	            }
	            return bestMatchIndex;
	        };
	        ColorHelper.getPaletteColorIndex = function (excelColor, startIndex) {
	            if (startIndex === keyword_undefined) {
	                startIndex = 64;
	            }
	            if (excelColor.isThemeColor()) {
	                return ColorHelper.getClosestColorIndex(ColorHelper.getRGBColor(new ExcelColor(3 , excelColor.value(), 0)));
	            }
	            return ColorHelper.getClosestColorIndex(ColorHelper.getRGBColor(excelColor), startIndex);
	        };
	        ColorHelper.toColorSchemeIndex = function (val) {
	            if (val === 'ACCENT1') {
	                return 4 ;
	            }
	            if (val === 'ACCENT2') {
	                return 5 ;
	            }
	            if (val === 'ACCENT3') {
	                return 6 ;
	            }
	            if (val === 'ACCENT4') {
	                return 7 ;
	            }
	            if (val === 'ACCENT5') {
	                return 8 ;
	            }
	            if (val === 'ACCENT6') {
	                return 9 ;
	            }
	            if (val === 'DK1') {
	                return 1 ;
	            }
	            if (val === 'DK2') {
	                return 3 ;
	            }
	            if (val === 'LT1') {
	                return 0 ;
	            }
	            if (val === 'LT2') {
	                return 2 ;
	            }
	            if (val === 'HLIK') {
	                return 10 ;
	            }
	            if (val === 'FOLHLINK') {
	                return 11 ;
	            }
	            if (val === 'PHCLR') {
	                return 240 ;
	            }
	            if (val === 'BG1') {
	                return 243 ;
	            }
	            if (val === 'BG2') {
	                return 244 ;
	            }
	            if (val === 'TX1') {
	                return 241 ;
	            }
	            if (val === 'TX2') {
	                return 242 ;
	            }
	            return 255 ;
	        };
	
	        ColorHelper.scRgbTosRgb = function (val) {
	            if (val <= 0.0) {
	                return 0;
	            }
	            if (val <= 0.0031308) {
	                return ((255 * val) * 12.92) + 0.5;
	            }
	            if (val < 1.0) {
	                return (255 * ((1.055 * (Math.pow(val, 0.41666666666666669))) - 0.055)) + 0.5;
	            }
	            return 0xff;
	        };
	        ColorHelper.convertHLSToRGB = function (hue, luminance, saturation) {
	            var num1 = 0, num2 = 0, num3 = 0;
	            if (saturation === 0.0) {
	                num1 = ((luminance * 255.0) / 255.0) | 0;
	                num2 = num1;
	                num3 = num1;
	            } else {
	                var num5;
	                if (luminance <= 127.0) {
	                    num5 = ((luminance * (255.0 + saturation)) + 127.0) / 255.0;
	                } else {
	                    num5 = (luminance + saturation) - (((luminance * saturation) + 127.0) / 255.0);
	                }
	                var num4 = (2.0 * luminance) - num5;
	
	                num1 = parseInt((((ColorHelper.hueToRGB(num4, num5, hue + 85.0) * 255.0) + 127.0) / 255.0).toString());
	                num2 = parseInt((((ColorHelper.hueToRGB(num4, num5, hue) * 255.0) + 127.0) / 255.0).toString());
	                num3 = parseInt((((ColorHelper.hueToRGB(num4, num5, hue - 85.0) * 255.0) + 127.0) / 255.0).toString());
	            }
	            num1 = num1 > 0 ? num1 : 0;
	            num2 = num2 > 0 ? num2 : 0;
	            num3 = num3 > 0 ? num3 : 0;
	            num1 = num1 < 0xFF ? num1 : 0xFF;
	            num2 = num2 < 0xFF ? num2 : 0xFF;
	            num3 = num3 > 0xFF ? num3 : 0xFF;
	
	            return new _Color(0, num1, num2, num3);
	        };
	        ColorHelper.hueToRGB = function (n1, n2, hue) {
	            if (hue < 0.0) {
	                hue += 255.0;
	            }
	            if (hue > 255.0) {
	                hue -= 255.0;
	            }
	            if (hue < 42.0) {
	                return (n1 + ((((n2 - n1) * hue) + 21.0) / 42.0));
	            }
	            if (hue < 127.0) {
	                return n2;
	            }
	            if (hue < 170.0) {
	                return (n1 + ((((n2 - n1) * (170.0 - hue)) + 21.0) / 42.0));
	            }
	            return n1;
	        };
	        ColorHelper.fromPresetColorVal = function (preSetValue) {
	            var value = ColorHelper._preSetColors[preSetValue];
	            if (value !== keyword_undefined) {
	                return ColorHelper.fromArgb(value);
	            }
	            return null;
	        };
	        ColorHelper.useCustomPalette = false;
	        ColorHelper.customPalette = null;
	        ColorHelper.palette = [
	            0xFF000000, 0xFFFFFFFF, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFFFF00FF,
	            0xFF00FFFF, 0xFF000000, 0xFFFFFFFF, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFFFF00FF, 0xFF00FFFF,
	            0xFF800000, 0xFF008000, 0xFF000080, 0xFF808000, 0xFF800080, 0xFF008080, 0xFFC0C0C0, 0xFF808080, 0xFF9999FF,
	            0xFF993366, 0xFFFFFFCC, 0xFFCCFFFF, 0xFF660066, 0xFFFF8080, 0xFF0066CC, 0xFFCCCCFF, 0xFF000080, 0xFFFF00FF,
	            0xFFFFFF00, 0xFF00FFFF, 0xFF800080, 0xFF800000, 0xFF008080, 0xFF0000FF, 0xFF00CCFF, 0xFFCCFFFF, 0xFFCCFFCC,
	            0xFFFFFF99, 0xFF99CCFF, 0xFFFF99CC, 0xFFCC99FF, 0xFFFFCC99, 0xFF3366FF, 0xFF33CCCC, 0xFF99CC00, 0xFFFFCC00,
	            0xFFFF9900, 0xFFFF6600, 0xFF666699, 0xFF969696, 0xFF003366, 0xFF339966, 0xFF003300, 0xFF333300, 0xFF993300,
	            0xFF993366, 0xFF333399, 0xFF333333, 0xFF000000
	        ];
	        ColorHelper._whiteBGColor = new _Color(255, 255, 255, 255);// this color is used for convert rgba color to rgb color when export to excel.
	
	        ColorHelper._preSetColors = {
	            'aliceblue': 0xfff0f8ff,
	            'antiquewhite': 0xfffaebd7,
	            'aqua': 0xff00ffff,
	            'aquamarine': 0xff7fffd4,
	            'azure': 0xfff0ffff,
	            'beige': 0xfff5f5dc,
	            'bisque': 0xffffe4c4,
	            'black': 0xff000000,
	            'blanchedalmond': 0xffffebcd,
	            'blue': 0xff0000ff,
	            'blueviolet': 0xff8a2be2,
	            'brown': 0xffa52a2a,
	            'burlywood': 0xffdeb887,
	            'cadetblue': 0xff5f9ea0,
	            'chartreuse': 0xff7fff00,
	            'chocolate': 0xffd2691e,
	            'coral': 0xffff7f50,
	            'cornflowerblue': 0xff6495ed,
	            'cornsilk': 0xfffff8dc,
	            'crimson': 0xffdc143c,
	            'cyan': 0xff00ffff,
	            'darkblue': 0xff00008b,
	            'darkcyan': 0xff008b8b,
	            'darkgoldenrod': 0xffb8860b,
	            'darkgray': 0xffa9a9a9,
	            'darkgreen': 0xff006400,
	            'darkkhaki': 0xffbdb76b,
	            'darkmagenta': 0xff8b008b,
	            'darkolivegreen': 0xff556b2f,
	            'darkorange': 0xffff8c00,
	            'darkorchid': 0xff9932cc,
	            'darkred': 0xff8b0000,
	            'darksalmon': 0xffe9967a,
	            'darkseagreen': 0xff8fbc8f,
	            'darkslateblue': 0xff483d8b,
	            'darkslategray': 0xff2f4f4f,
	            'darkturquoise': 0xff00ced1,
	            'darkviolet': 0xff9400d3,
	            'deeppink': 0xffff1493,
	            'deepskyblue': 0xff00bfff,
	            'dimgray': 0xff696969,
	            'dodgerblue': 0xff1e90ff,
	            'feldspar': 0xffd19275,
	            'firebrick': 0xffb22222,
	            'floralwhite': 0xfffffaf0,
	            'forestgreen': 0xff228b22,
	            'fuchsia': 0xffff00ff,
	            'gainsboro': 0xffdcdcdc,
	            'ghostwhite': 0xfff8f8ff,
	            'gold': 0xffffd700,
	            'goldenrod': 0xffdaa520,
	            'gray': 0xff808080,
	            'green': 0xff008000,
	            'greenyellow': 0xffadff2f,
	            'honeydew': 0xfff0fff0,
	            'hotpink': 0xffff69b4,
	            'indianred ': 0xffcd5c5c,
	            'indigo ': 0xff4b0082,
	            'ivory': 0xfffffff0,
	            'khaki': 0xfff0e68c,
	            'lavender': 0xffe6e6fa,
	            'lavenderblush': 0xfffff0f5,
	            'lawngreen': 0xff7cfc00,
	            'lemonchiffon': 0xfffffacd,
	            'lightblue': 0xffadd8e6,
	            'lightcoral': 0xfff08080,
	            'lightcyan': 0xffe0ffff,
	            'lightgoldenrodyellow': 0xfffafad2,
	            'lightgrey': 0xffd3d3d3,
	            'lightgreen': 0xff90ee90,
	            'lightpink': 0xffffb6c1,
	            'lightsalmon': 0xffffa07a,
	            'lightseagreen': 0xff20b2aa,
	            'lightskyblue': 0xff87cefa,
	            'lightslateblue': 0xff8470ff,
	            'lightslategray': 0xff778899,
	            'lightsteelblue': 0xffb0c4de,
	            'lightyellow': 0xffffffe0,
	            'lime': 0xff00ff00,
	            'limegreen': 0xff32cd32,
	            'linen': 0xfffaf0e6,
	            'magenta': 0xffff00ff,
	            'maroon': 0xff800000,
	            'mediumaquamarine': 0xff66cdaa,
	            'mediumblue': 0xff0000cd,
	            'mediumorchid': 0xffba55d3,
	            'mediumpurple': 0xff9370d8,
	            'mediumseagreen': 0xff3cb371,
	            'mediumslateblue': 0xff7b68ee,
	            'mediumspringgreen': 0xff00fa9a,
	            'mediumturquoise': 0xff48d1cc,
	            'mediumvioletred': 0xffc71585,
	            'midnightblue': 0xff191970,
	            'mintcream': 0xfff5fffa,
	            'mistyrose': 0xffffe4e1,
	            'moccasin': 0xffffe4b5,
	            'navajowhite': 0xffffdead,
	            'navy': 0xff000080,
	            'oldlace': 0xfffdf5e6,
	            'olive': 0xff808000,
	            'olivedrab': 0xff6b8e23,
	            'orange': 0xffffa500,
	            'orangered': 0xffff4500,
	            'orchid': 0xffda70d6,
	            'palegoldenrod': 0xffeee8aa,
	            'palegreen': 0xff98fb98,
	            'paleturquoise': 0xffafeeee,
	            'palevioletred': 0xffd87093,
	            'papayawhip': 0xffffefd5,
	            'peachpuff': 0xffffdab9,
	            'peru': 0xffcd853f,
	            'pink': 0xffffc0cb,
	            'plum': 0xffdda0dd,
	            'powderblue': 0xffb0e0e6,
	            'purple': 0xff800080,
	            'red': 0xffff0000,
	            'rosybrown': 0xffbc8f8f,
	            'royalblue': 0xff4169e1,
	            'saddlebrown': 0xff8b4513,
	            'salmon': 0xfffa8072,
	            'sandybrown': 0xfff4a460,
	            'seagreen': 0xff2e8b57,
	            'seashell': 0xfffff5ee,
	            'sienna': 0xffa0522d,
	            'silver': 0xffc0c0c0,
	            'skyblue': 0xff87ceeb,
	            'slateblue': 0xff6a5acd,
	            'slategray': 0xff708090,
	            'snow': 0xfffffafa,
	            'springgreen': 0xff00ff7f,
	            'steelblue': 0xff4682b4,
	            'tan': 0xffd2b48c,
	            'teal': 0xff008080,
	            'thistle': 0xffd8bfd8,
	            'tomato': 0xffff6347,
	            'turquoise': 0xff40e0d0,
	            'violet': 0xffee82ee,
	            'violetred': 0xffd02090,
	            'wheat': 0xfff5deb3,
	            'white': 0xffffffff,
	            'whitesmoke': 0xfff5f5f5,
	            'yellow': 0xffffff00,
	            'yellowgreen': 0xff9acd32,
	            'transparent': 0x00ffffff
	        };
	        return ColorHelper;
	    })();
	    exports.ColorHelper = ColorHelper;
	
	    var ConverterHelper = (function () {
	        function ConverterHelper() {
	        }
	
	        ConverterHelper.getFontName = function (fontFamily) {
	            if (!fontFamily) {
	                return null;
	            }
	            var fontName = fontFamily, listSeparator = ',';
	            if (fontName.indexOf(listSeparator) !== -1) {
	                fontName = fontName.split(listSeparator)[0];
	            }
	            if (fontName) {
	                var index = fontName.length - 1;
	                while (index >= 0) {
	                    if (fontName[index] !== '/') {
	                        index--;
	                    } else {
	                        break;
	                    }
	                }
	                if (index >= 0) {
	                    fontName = fontName.substring(index);
	                }
	                if (fontName && fontName.substring(0, 2) === '/#') {
	                    fontName = fontName.substring(2);
	                }
	               
	                if (fontName[0] === '"' && fontName[fontName.length - 1] === '"') {
	                    fontName = fontName.substring(1, fontName.length - 1);
	                }
	            }
	            return fontName;
	        };
	        ConverterHelper.setStyleInfoFont = function (font, styleInfo, headingFont, bodyFont) {
	            var fontstr, fontFamily = font.fontName;
	            if (!fontFamily) {
	                fontFamily = DEFAULT_FONT_FAMILY;
	            }
	            var fontSize = '';
	            if (font.fontSize > 0) {
	                fontSize = Math.round(UnitHelper.pointToPixel(font.fontSize) * 10) / 10 + 'px';
	            }
	            var italic = '';
	            if (font.isItalic) {
	                italic = 'italic';
	            } else {
	                italic = 'normal';
	            }
	
	            var fontWeight = '';
	            if (font.isBold) {
	                fontWeight = 'bold';
	            } else {
	                fontWeight = 'normal';
	            }
	
	            var foreColor = '';
	            if (font.fontColor) {
	                if (font.fontColor.isThemeColor()) {
	                    foreColor = ColorHelper.getThemeColorName(font.fontColor);
	                } else {
	                    foreColor = ColorHelper.toRGBColor(font.fontColor);
	                }
	            }
	            if (foreColor) {
	                styleInfo.foreColor = foreColor;
	            } else {
	               
	               
	               
	                styleInfo.foreColor = null;
	            }
	            if (font.isStrikeOut) {
	                styleInfo.textDecoration = 0x02;
	            }
	            if (font.underLineStyle !== keyword_undefined && font.underLineStyle !== 0 ) {
	                var underLineStyle = 0x01;
	                if (font.underLineStyle === 2) {
	                    underLineStyle = 0x08;
	                }
	                if (styleInfo.textDecoration === keyword_undefined) {
	                    styleInfo.textDecoration = underLineStyle;
	                } else {
	                    styleInfo.textDecoration = styleInfo.textDecoration | underLineStyle;
	                }
	            }
	            if (font.fontScheme === 1 ) {
	                styleInfo.themeFont = THEME_HEADINGS;
	                if (headingFont) {
	                    fontFamily = headingFont;
	                }
	            } else if (font.fontScheme === 2 ) {
	                styleInfo.themeFont = THEME_BODY;
	                if (bodyFont) {
	                    fontFamily = bodyFont;
	                }
	            }
	            fontstr = italic + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily;
	            if (fontstr) {
	                styleInfo.font = fontstr;
	            }
	        };
	        ConverterHelper._getFontParseCache = function () {
	            if (!ConverterHelper._fontParseCache) {
	                ConverterHelper._fontParseCache = {};
	            }
	            return ConverterHelper._fontParseCache;
	        };
	        ConverterHelper.fromHtmlFont = function (font) {
	            if (StringEx._isNullOrEmpty(font)) {
	                return;
	            }
	            var result = {}, fontCache = ConverterHelper._getFontParseCache();
	            if (fontCache[font]) {
	                return fontCache[font];
	            }
	            var t = ConverterHelper.splitFontString(font);
	            if (t.length === 0) {
	                return;
	            }
	            var n = 0, fontStyleSetted = false, fontVariantSetted = false, fontWeightSetted = false;
	            while (n < t.length) {
	                var fontSet = t[n].toLowerCase();
	                if (fontSet === 'normal') {
	                   
	                } else if (!fontStyleSetted && (fontSet === 'italic' || fontSet === 'oblique' || fontSet === 'inherit')) {
	                    fontStyleSetted = true;
	                    if (fontSet === 'oblique') {
	                        fontSet = ITALIC;
	                    }
	                    result.fontStyle = fontSet;
	                } else if (!fontVariantSetted && (fontSet === 'small-caps')) {
	                    fontVariantSetted = true;
	                    result.fontVariant = fontSet;
	                } else if (!fontWeightSetted &&
	                    (
	                        fontSet === 'bold' ||
	                        fontSet === 'bolder' ||
	                        fontSet === 'lighter' ||
	                        fontSet === '100' ||
	                        fontSet === '200' ||
	                        fontSet === '300' ||
	                        fontSet === '400' ||
	                        fontSet === '500' ||
	                        fontSet === '600' ||
	                        fontSet === '700' ||
	                        fontSet === '800' ||
	                        fontSet === '900' ||
	                        fontSet === 'inherit'
	                    )) {
	                    fontWeightSetted = true;
	                    if (fontSet === 'bolder' || parseInt(fontSet) >= 700) {
	                        result.fontWeight = BOLD;
	                    } else if (fontSet === 'lighter') {
	                        result.fontWeight = 'ExtraLight';
	                    } else {
	                        result.fontWeight = fontSet;
	                    }
	                } else if (fontSet.substring(0, 1) === '/') {
	                    n++;
	                    break;
	                } else if (fontSet === 'xx-small' || fontSet === 'x-small' || fontSet === 'small' || fontSet === 'medium' ||
	                    fontSet === 'large' || fontSet === 'x-large' || fontSet === 'xx-large' ||
	                    fontSet.indexOf('px') !== -1 || fontSet.indexOf('pt') !== -1) {
	                    break;
	                }
	                n++;
	                if (fontStyleSetted && fontVariantSetted && fontWeightSetted) {
	                    break;
	                }
	            }
	            if (n < t.length) {
	                var fontSize = t[n].toLowerCase();
	                if (fontSize === 'xx-small' || fontSize === 'x-small' || fontSize === 'small' || fontSize === 'medium' || fontSize === 'large' || fontSize === 'x-large' || fontSize === 'xx-large') {
	                    var d = 10;
	                    if (fontSize === 'xx-small' || fontSize === 'x-small') {
	                        d = 6;
	                    } else if (fontSize === 'small') {
	                        d = 8;
	                    } else if (fontSize === 'medium') {
	                        d = 10;
	                    } else if (fontSize === 'large') {
	                        d = 14;
	                    } else if (fontSize === 'x-large') {
	                        d = 18;
	                    } else if (fontSize === 'xx-large') {
	                        d = 22;
	                    }
	                    result.fontSize = d;
	                } else {
	                    var size;
	                    if (fontSize.indexOf('px') !== -1) {
	                        size = parseFloat(fontSize);
	                    } else if (fontSize.indexOf('pt') !== -1) {
	                        var x = parseFloat(fontSize);
	                        if (!isNaN(x)) {
	                            size = UnitHelper.pointToPixel(x);
	                        }
	                    }
	                    if (!isNaN(size)) {
	                        result.fontSize = size;
	                    }
	                }
	                n++;
	            }
	            if (n < t.length) {
	                var lineHeight = t[n].toLowerCase();
	                if (lineHeight.substring(0, 1) === '/') {
	                    n++;
	                }
	            }
	            if (n < t.length) {
	                var fontFamily = t[n];
	                n++;
	                for (; n < t.length; n++) {
	                    fontFamily = fontFamily + ' ' + t[n];
	                }
	                result.fontFamily = fontFamily;
	            }
	           
	            fontCache[font] = result;
	            return result;
	        };
	
	        ConverterHelper.splitFontString = function (font) {
	            if (StringEx._isNullOrEmpty(font)) {
	                return [];
	            }
	            font = font.trim();
	            var list = [], sb = '';
	            for (var i = 0, len = font.length; i < len; i++) {
	                var currentChar = font[i];
	                if (currentChar === ' ' || currentChar === '/') {
	                    list.push(sb);
	                    sb = '';
	                    if (currentChar === '/') {
	                        sb += '/';
	                    }
	                } else if (currentChar === '\'' || currentChar === '\"') {
	                    i++;
	                    while (font[i] !== currentChar) {
	                        sb += font[i];
	                        i++;
	                    }
	                } else {
	                    sb += currentChar;
	                }
	            }
	            if (sb.length > 0) {
	                list.push(sb);
	            }
	            return list;
	        };
	        ConverterHelper.toVerticalAlignment = function (verticalAlignment) {
	            switch (verticalAlignment) {
	                case 0                     :
	                    return 0;
	                case 1                     :
	                    return 1;
	                case 2                     :
	                    return 2;
	                default:
	                    return 2;
	            }
	        };
	        ConverterHelper.toExcelVerticalAlignment = function (verticalAlignment) {
	            switch (verticalAlignment) {
	                case 2:
	                    return 2 ;
	                case 1:
	                    return 1 ;
	                case 0:
	                    return 0 ;
	                default:
	                    return 0 ;
	            }
	        };
	        ConverterHelper.toHorizontalAlignment = function (horizontalAlignment) {
	            switch (horizontalAlignment) {
	                case 0                     :
	                    return 3;
	                case 1                     :
	                case 6                     :
	                    return 0;
	                case 2                     :
	                    return 1;
	                case 3                     :
	                    return 2;
	                case 4                     :
	                case 5                     :
	                case 7                     :
	                    return 3;
	                default:
	                    return 3;
	            }
	        };
	        ConverterHelper.toExcelHorizontalAlignment = function (horizontalAlignment) {
	            switch (horizontalAlignment) {
	                case 1:
	                    return 2 ;
	                case 0:
	                    return 1 ;
	                case 2:
	                    return 3 ;
	                case 3:
	                    return 0 ;
	                default:
	                    return 0 ;
	            }
	        };
	        ConverterHelper.toBorderLine = function (borderside) {
	            if (!borderside) {
	                return null;
	            }
	            var result = null;
	            if (borderside.lineStyle === 0 ) {
	                return null;
	            }
	            if (borderside.color) {
	                if (borderside.color.isThemeColor()) {
	                    result = {
	                        color: ColorHelper.getThemeColorName(borderside.color),
	                        style: borderside.lineStyle
	                    };
	                } else {
	                    result = {
	                        color: ColorHelper.getRGBColor(borderside.color).toString(),
	                        style: borderside.lineStyle
	                    };
	                }
	            }
	            return result;
	        };
	        ConverterHelper.toExcelBorderSide = function (borderLine) {
	            var border = new ExcelBorderSide();
	            if (!borderLine) {
	                return border;
	            }
	            var borderColor = borderLine.color;
	            if (ColorHelper.isThemeColor(borderColor)) {
	                border.color = ColorHelper.getExcelThemeColor(borderColor);
	            } else {
	                var color = borderLine.color;
	                border.color = new ExcelColor(2 , ColorHelper.fromHtmlColor(color), 0.0);
	            }
	            border.lineStyle = borderLine.style;
	            return border;
	        };
	        ConverterHelper.setStyleInfoBorders = function (border, styleInfo) {
	            styleInfo.borderLeft = ConverterHelper.toBorderLine(border.left);
	            styleInfo.borderRight = ConverterHelper.toBorderLine(border.right);
	            styleInfo.borderTop = ConverterHelper.toBorderLine(border.top);
	            styleInfo.borderBottom = ConverterHelper.toBorderLine(border.bottom);
	            styleInfo.borderVertical = ConverterHelper.toBorderLine(border.vertical);
	            styleInfo.borderHorizontal = ConverterHelper.toBorderLine(border.horizontal);
	            styleInfo.diagonalUp = ConverterHelper.toBorderLine(border.diagonalUp);
	            styleInfo.diagonalDown = ConverterHelper.toBorderLine(border.diagonalDown);
	        };
	        ConverterHelper.toCellStyle = function (format, headingFont, bodyFont) {
	            var result = {};
	            if (!format) {
	                return null;
	            }
	           
	           
	           
	            if ((!format.isStyleFormat || (format.isStyleFormat && (format.applyFont === keyword_undefined || format.applyFont))) && format.font) {
	                ConverterHelper.setStyleInfoFont(format.font, result, headingFont, bodyFont);
	            }
	            if (!format.isStyleFormat || (format.isStyleFormat && (format.applyProtection === keyword_undefined || format.applyProtection))) {
	                result.locked = format.isLocked;
	            }
	            if (!format.isStyleFormat || (format.isStyleFormat && (format.applyAlignment === keyword_undefined || format.applyAlignment))) {
	                if (format.indent !== keyword_undefined) {
	                    result.textIndent = format.indent;
	                    if (result.textIndent > 0) {
	                        var indent = result.textIndent, smallNum = Math.floor(indent);
	                        if (indent - smallNum === 0.5 && (smallNum & 1) === 0) {
	                            result.textIndent = smallNum;
	                        } else {
	                            result.textIndent = Math.round(indent);
	                        }
	                    }
	                }
	                result.wordWrap = format.isWordWrap;
	                result.vAlign = ConverterHelper.toVerticalAlignment(format.verticalAlign);
	                result.hAlign = ConverterHelper.toHorizontalAlignment(format.horizontalAlign);
	                if (format.rotation === 255) {
	                    result.isVerticalText = true;
	                }
	            }
	            if (format.border) {
	                var border = format.border;
	                if (format.isStyleFormat && format.applyBorder !== keyword_undefined && !format.applyBorder) {
	                    border = null;
	                }
	                if (border) {
	                    ConverterHelper.setStyleInfoBorders(border, result);
	                }
	            }
	            if (format.fillPattern !== 0 ) {
	                if (!format.isStyleFormat || (format.isStyleFormat && (format.applyFill === keyword_undefined || format.applyFill))) {
	                    var patternBackgroundColor = format.patternBackgroundColor;
	                    if (format.fillPattern === 1 ) {
	                        patternBackgroundColor = format.patternColor;
	                    }
	                   
	                    ConverterHelper.setStyleInfoFill(patternBackgroundColor, result);
	                }
	            } else {
	                result.backColor = keyword_null;
	            }
	            if (format.isShrinkToFit) {
	                result.shrinkToFit = true;
	            }
	            var excelFormatCode = ExtendedNumberFormatHelper.getFormatCode(format),
	                isStyleFormat = format.isStyleFormat, applyNumberFormat = format.applyNumberFormat;
	           
	           
	           
	           
	            if ((isStyleFormat && (applyNumberFormat === keyword_undefined || applyNumberFormat) && excelFormatCode !== 'General') ||
	                (!isStyleFormat && applyNumberFormat)) {
	                result.formatter = excelFormatCode;
	            }
	            if (!isNullOrUndefined(format.quotePrefix)) {
	                result.quotePrefix = format.quotePrefix;
	            }
	            return result;
	        };
	        ConverterHelper.toSchemeClrValue = function (scheme) {
	            switch (scheme) {
	                case 255                     :
	                    return '';
	                case 1                     :
	                    return 'dk1';
	                case 0                     :
	                    return 'lt1';
	                case 3                     :
	                    return 'dk2';
	                case 2                     :
	                    return 'lt2';
	                case 4                     :
	                    return 'accent1';
	                case 5                     :
	                    return 'accent2';
	                case 6                     :
	                    return 'accent3';
	                case 7                     :
	                    return 'accent4';
	                case 8                     :
	                    return 'accent5';
	                case 9                     :
	                    return 'accent6';
	                case 10                     :
	                    return 'hlink';
	                case 11                     :
	                    return 'folHlink';
	                case 240                     :
	                    return 'phClr';
	                case 241                     :
	                    return 'tx1';
	                case 242                     :
	                    return 'tx2';
	                case 243                     :
	                    return 'bg1';
	                case 244                     :
	                    return 'bg2';
	                default:
	                    return '';
	            }
	        };
	        ConverterHelper.setStyleInfoFill = function (patternBackgroundColor, styleInfo) {
	            if (!isNullOrUndefined(patternBackgroundColor)) {
	                var isNullColor = (patternBackgroundColor.isRGBColor() && patternBackgroundColor.value() === 0);
	                if ((patternBackgroundColor.isRGBColor() && patternBackgroundColor.value() === 0) || (patternBackgroundColor.isIndexedColor() && patternBackgroundColor.value() === 64) || (patternBackgroundColor.isIndexedColor() && patternBackgroundColor.value() === 65)) {
	                   
	                   
	                    if (isNullColor) {
	                       
	                       
	                        styleInfo.backColor = null;
	                    }
	                    return;
	                }
	                if (patternBackgroundColor.isThemeColor()) {
	                    styleInfo.backColor = ColorHelper.getThemeColorName(patternBackgroundColor);
	                } else {
	                    styleInfo.backColor = ColorHelper.toRGBColor(patternBackgroundColor);
	                }
	            }
	        };
	        ConverterHelper.getStyleFormatter = function (style) {
	            var retValue = keyword_null, formatterString = style.formatter;
	            if (typeof formatterString === 'string' && formatterString !== ' ') {
	                retValue = formatterString;
	            } else if (style.autoFormatter) {
	                var formatCached = style.autoFormatter.formatCached;
	                if (formatCached && !StringEx._isNullOrWhiteSpace(formatCached)) {
	                    retValue = formatCached;
	                }
	            }
	            return retValue;
	        };
	        ConverterHelper.toExtendedFormat = function (style) {
	            if (!style) {
	                return;
	            }
	            var result = new ExtendedFormat();
	
	           
	            var formatString = ConverterHelper.getStyleFormatter(style);
	            if (formatString) {
	                var ret = ExtendedNumberFormatHelper.getFormatId(formatString);
	                var id = ret.id, isBuiltIn = ret.isBuiltIn;
	                if (isBuiltIn) {
	                    result.numberFormatIndex = id;
	                } else {
	                    result.numberFormat = new ExcelNumerFormat(id, formatString);
	                }
	                if (id > 0) {
	                    result.applyNumberFormat = true;
	                }
	            } else {
	                result.numberFormatIndex = 0;
	            }
	
	           
	            if (style.backColor) {
	                if (ColorHelper.isThemeColor(style.backColor)) {
	                    result.patternBackgroundColor = new ExcelColor(1 , 64);
	                    result.patternColor = ColorHelper.getExcelThemeColor(style.backColor);
	                } else {
	                    var color = ColorHelper.fromHtmlColor(style.backColor);
	                    if (color !== 0xffffff) {
	                        result.patternColor = ColorHelper.fromColorToExcelColor(ColorHelper.fromArgb(color));
	                    }
	                }
	                if (result.patternColor) {
	                    result.fillPattern = 1 ;
	                    result.applyFill = true;
	                }
	            }
	
	           
	            if (style.borderLeft || style.borderRight || style.borderTop || style.borderBottom || style.diagonalUp || style.diagonalDown) {
	                result.border = new ExcelBorder();
	                if (style.borderLeft) {
	                    result.border.left = ConverterHelper.toExcelBorderSide(style.borderLeft);
	                }
	                if (style.borderRight) {
	                    result.border.right = ConverterHelper.toExcelBorderSide(style.borderRight);
	                }
	                if (style.borderTop) {
	                    result.border.top = ConverterHelper.toExcelBorderSide(style.borderTop);
	                }
	                if (style.borderBottom) {
	                    result.border.bottom = ConverterHelper.toExcelBorderSide(style.borderBottom);
	                }
	                if (style.diagonalDown) {
	                    result.border.diagonalDown = ConverterHelper.toExcelBorderSide(style.diagonalDown);
	                }
	                if (style.diagonalUp) {
	                    result.border.diagonalUp = ConverterHelper.toExcelBorderSide(style.diagonalUp);
	                }
	                result.applyBorder = true;
	            }
	
	           
	            if (style.font || style.foreColor || style.themeFont || (style.textDecoration !== keyword_undefined && style.textDecoration !== null)) {
	                result.applyFont = true;
	                var fontName = DEFAULT_FONT_FAMILY;
	                if (style.font) {
	                    var styleFont = ConverterHelper.fromHtmlFont(style.font);
	                    if (styleFont.fontFamily) {
	                        fontName = ConverterHelper.getFontName(styleFont.fontFamily);
	                    }
	                    if (StringEx._isNullOrEmpty(fontName)) {
	                        fontName = DEFAULT_FONT_FAMILY;
	                    }
	                    result.font = new ExcelFont(fontName.trim(), null, 0 );
	                    if (styleFont.fontSize) {
	                        result.font.fontSize = Math.round(UnitHelper.pixelToPoint(styleFont.fontSize));
	                    }
	                    if (styleFont.fontStyle === ITALIC) {
	                        result.font.isItalic = true;
	                    }
	                    if (styleFont.fontWeight === BOLD) {
	                        result.font.isBold = true;
	                    }
	                }
	                if ((style.textDecoration & 0x01) === 0x01) {
	                    result.font.underLineStyle = 1 ;
	                }
	                if ((style.textDecoration & 0x08) === 0x08) {
	                    result.font.underLineStyle = 2 ;
	                }
	                if (style.foreColor) {
	                    if (ColorHelper.isThemeColor(style.foreColor)) {
	                        result.font.fontColor = ColorHelper.getExcelThemeColor(style.foreColor);
	                    } else {
	                        color = ColorHelper.fromHtmlColor(style.foreColor);
	                        var color1 = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), ColorHelper.fromArgb(color));
	                        color = color1.a * Math.pow(16, 6) + color1.r * Math.pow(16, 4) + color1.g * Math.pow(16, 2) + color1.b;
	                        result.font.fontColor = new ExcelColor(2 , color, 0.0);
	                    }
	                }
	                result.font.isStrikeOut = ((style.textDecoration & 0x02) === 0x02);
	            }
	            if (style.themeFont) {
	                if (style.themeFont.toUpperCase() === 'Headings'.toUpperCase()) {
	                    result.font.fontScheme = 1 ;
	                } else if (style.themeFont.toUpperCase() === 'Body'.toUpperCase()) {
	                    result.font.fontScheme = 2 ;
	                }
	            }
	            if (style.shrinkToFit) {
	                result.isShrinkToFit = true;
	            }
	            if (style.locked !== keyword_undefined) {
	                result.isLocked = style.locked;
	            } else {
	                result.isLocked = true;
	            }
	            if (style.wordWrap !== keyword_null && style.wordWrap !== keyword_undefined) {
	                result.isWordWrap = style.wordWrap;
	            }
	            if (style.textIndent !== keyword_null && style.textIndent !== keyword_undefined) {
	                result.indent = Math.ceil(style.textIndent);
	            }
	            result.verticalAlign = ConverterHelper.toExcelVerticalAlignment(style.vAlign);
	            result.horizontalAlign = ConverterHelper.toExcelHorizontalAlignment(style.hAlign);
	            if (style.isVerticalText === true) {
	                result.isVerticalText = style.isVerticalText;
	            }
	            if (!isNullOrUndefined(style.quotePrefix)) {
	                result.quotePrefix = style.quotePrefix;
	            }
	            return result;
	        };
	        ConverterHelper.toDifferentialFormatting = function (style) {
	            var result = {}, isSlicerHeader = style.isSlicerHeader;
	            var formatString = style.formatter;
	            if (typeof formatString === 'string' && formatString !== ' ') {
	                var ret = ExtendedNumberFormatHelper.getFormatId(formatString);
	                var id = ret.id, isBuiltIn = ret.isBuiltIn;
	                if (isBuiltIn) {
	                    result.numberFormatIndex = id;
	                    result.numberFormatCode = formatString;
	                } else {
	                    result.numberFormat = new ExcelNumerFormat(id, formatString);
	                }
	            }
	            if (!isNullOrUndefined(style.backColor)) {
	                var pattern = 0 , patternColor = null;
	                patternColor = ColorHelper.toExcelColor(style.backColor);
	                if (patternColor) {
	                    pattern = 1 ;
	                }
	                result.fill = new Tuple(pattern, null, patternColor);
	            }
	            if (style.borderLeft || style.borderRight || style.borderTop || style.borderBottom || style.borderVertical || style.borderHorizontal) {
	                result.border = new ExcelBorder();
	                if (style.borderLeft) {
	                    result.border.left = ConverterHelper.toExcelBorderSide(style.borderLeft);
	                } else if (isSlicerHeader) {
	                    result.border.left = keyword_undefined;
	                }
	                if (style.borderRight) {
	                    result.border.right = ConverterHelper.toExcelBorderSide(style.borderRight);
	                } else if (isSlicerHeader) {
	                    result.border.right = keyword_undefined;
	                }
	                if (style.borderTop) {
	                    result.border.top = ConverterHelper.toExcelBorderSide(style.borderTop);
	                } else if (isSlicerHeader) {
	                    result.border.top = keyword_undefined;
	                }
	                if (style.borderBottom) {
	                    result.border.bottom = ConverterHelper.toExcelBorderSide(style.borderBottom);
	                } else if (isSlicerHeader) {
	                    result.border.bottom = keyword_undefined;
	                }
	                if (style.borderVertical) {
	                    result.border.vertical = ConverterHelper.toExcelBorderSide(style.borderVertical);
	                }
	                if (style.borderHorizontal) {
	                    result.border.horizontal = ConverterHelper.toExcelBorderSide(style.borderHorizontal);
	                }
	            }
	            if (style.font || style.foreColor || style.themeFont || (style.textDecoration !== keyword_undefined && style.textDecoration !== null)) {
	                var fontName = DEFAULT_FONT_FAMILY, color;
	                if (style.font) {
	                    var styleFont = ConverterHelper.fromHtmlFont(style.font);
	                    if (styleFont.fontFamily) {
	                        fontName = ConverterHelper.getFontName(styleFont.fontFamily);
	                    }
	                    if (StringEx._isNullOrEmpty(fontName)) {
	                        fontName = DEFAULT_FONT_FAMILY;
	                    }
	                    result.font = new ExcelFont(fontName.trim(), null, 0 );
	                    if (styleFont.fontSize) {
	                        result.font.fontSize = Math.round(UnitHelper.pixelToPoint(styleFont.fontSize));
	                    }
	                    if (styleFont.fontStyle === 'italic') {
	                        result.font.isItalic = true;
	                    }
	                    if (styleFont.fontWeight === 'bold') {
	                        result.font.isBold = true;
	                    }
	                }
	                if (!result.font) {
	                    result.font = new ExcelFont(fontName.trim(), null, 0 );
	                }
	                if ((style.textDecoration & 0x01) === 0x01) {
	                    result.font.underLineStyle = 1 ;
	                }
	                if ((style.textDecoration & 0x08) === 0x08) {
	                    result.font.underLineStyle = 2 ;
	                }
	                if (style.foreColor) {
	                    if (ColorHelper.isThemeColor(style.foreColor)) {
	                        result.font.fontColor = ColorHelper.getExcelThemeColor(style.foreColor);
	                    } else {
	                        color = ColorHelper.fromHtmlColor(style.foreColor);
	                        var color1 = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), ColorHelper.fromArgb(color));
	                        color = color1.a * Math.pow(16, 6) + color1.r * Math.pow(16, 4) + color1.g * Math.pow(16, 2) + color1.b;
	                        result.font.fontColor = new ExcelColor(2 , color, 0.0);
	                    }
	                }
	                result.font.isStrikeOut = ((style.textDecoration & 0x02) === 0x02);
	            }
	            result.isPartFontStyle = style.isPartFontStyle;
	            result.isSlicerHeader = isSlicerHeader;
	
	            return result;
	        };
	        ConverterHelper.cloneSpreadJSStyle = function (style) {
	            var result = {};
	            result.backColor = style.backColor;
	            result.foreColor = style.foreColor;
	            result.hAlign = style.hAlign;
	            result.vAlign = style.vAlign;
	            result.font = style.font;
	            result.themeFont = style.themeFont;
	            result.formatter = style.formatter;
	            result.borderLeft = style.borderLeft;
	            result.borderTop = style.borderTop;
	            result.borderRight = style.borderRight;
	            result.borderBottom = style.borderBottom;
	            result.locked = style.locked;
	            result.textIndent = style.textIndent;
	            result.wordWrap = style.wordWrap;
	            result.shrinkToFit = style.shrinkToFit;
	            result.textDecoration = style.textDecoration;
	            result.name = style.name;
	            result.parentName = style.parentName;
	            return result;
	        };
	        ConverterHelper.convertDxfToStyle = function (dxf, headingFont, bodyFont) {
	            var style = {};
	            if (dxf.font) {
	                ConverterHelper.setStyleInfoFont(dxf.font, style, headingFont, bodyFont);
	            }
	            if (dxf.fill) {
	                ConverterHelper.setStyleInfoFill(dxf.fill.backgroundColor, style);
	            }
	            if (dxf.border) {
	                ConverterHelper.setStyleInfoBorders(dxf.border, style);
	            }
	            if (dxf.numberFormat) {
	                var excelFormatCode = ExtendedNumberFormatHelper.getFormatCode(dxf);
	                if (excelFormatCode !== 'General') {
	                    style.formatter = excelFormatCode;
	                }
	            }
	            return style;
	        };
	        return ConverterHelper;
	    })();
	    exports.ConverterHelper = ConverterHelper;
	
	    var DefaultStyle = function () {
	        function DefaultStyle() {
	
	        }
	
	        DefaultStyle._getDefaultStyle = function (workbook) {
	            var defaultStyle = {
	                foreColor: 'black',
	                font: 'normal normal normal 11pt/normal Calibri',
	                locked: true,
	                name: 'Normal',
	                textDecoration: 0,
	                hAlign: 3,
	                vAlign: 0,
	                formatter: 'General'
	            };
	            for (var sheetName in workbook.sheets) {
	                if (workbook.sheets.hasOwnProperty(sheetName)) {
	                    var sheet = workbook.sheets[sheetName];
	                    if (sheet.data && sheet.data.defaultDataNode && sheet.data.defaultDataNode.style) {
	                        var sheetDefaultStyle = sheet.data.defaultDataNode.style;
	                        for (var p in sheetDefaultStyle) {
	                            if (sheetDefaultStyle.hasOwnProperty(p) && !isNullOrUndefined(sheetDefaultStyle[p])) {
	                                defaultStyle[p] = sheetDefaultStyle[p];
	                            }
	                        }
	                        break;
	                    }
	                }
	            }
	            return defaultStyle;
	        };
	
	        return DefaultStyle;
	    }();
	    exports.DefaultStyle = DefaultStyle;
	
	    var GcSystemColors = (function () {
	        function GcSystemColors() {
	        }
	
	        GcSystemColors.getSystemColor = function (index) {
	            return ColorHelper.fromArgb(GcSystemColors._systemColors[index]);
	        };
	        GcSystemColors._systemColors = [
	            0xFFB4B4B4, 0xFF99B4D1, 0xFF000000, 0xFFABABAB, 0xFFF0F0F0, 0xFFA0A0A0, 0xFF696969, 0xFFE3E3E3,
	            0xFFFFFFFF, 0xFF000000, 0xFF000000, 0xFFB9D1EA, 0xFFD7E4F2, 0xFF6D6D6D, 0xFF3399FF, 0xFFFFFFFF, 0xFF0066CC, 0xFFF4F7FC,
	            0xFFBFCDDB, 0xFF434E54, 0xFFFFFFE1, 0xFF000000, 0xFFF0F0F0, 0xFFF0F0F0, 0xFF3399FF, 0xFF000000, 0xFFC8C8C8, 0xFFFFFFFF,
	            0xFF646464, 0xFF000000, 0xFFA0A0A0, 0xFFE3E3E3, 0xFFF0F0F0, 0xFFFFFFFF, 0xFFA0A0A0, 0xFF000000
	        ];
	        return GcSystemColors;
	    })();
	
	    var ExcelSystemColor = (function () {
	        function ExcelSystemColor() {
	        }
	
	        ExcelSystemColor.getSystemColor = function (name) {
	            return ExcelSystemColor.systemColors[name.toUpperCase()];
	        };
	        ExcelSystemColor.systemColors = {
	            length: 0,
	            '3DDKSHADOW': GcSystemColors.getSystemColor(30 ),
	            '3DLIGHT': GcSystemColors.getSystemColor(31 ),
	            'ACTIVEBORDER': GcSystemColors.getSystemColor(0 ),
	            'ACTIVECAPTION': GcSystemColors.getSystemColor(1 ),
	            'APPWORKSPACE': GcSystemColors.getSystemColor(3 ),
	            'BACKGROUND': GcSystemColors.getSystemColor(10 ),
	            'BTNFACE': GcSystemColors.getSystemColor(32 ),
	            'BTNHIGHLIGHT': GcSystemColors.getSystemColor(33 ),
	            'BTNSHADOW': GcSystemColors.getSystemColor(34 ),
	            'BTNTEXT': GcSystemColors.getSystemColor(35 ),
	            'CAPTIONTEXT': GcSystemColors.getSystemColor(2 ),
	            'GRAYTEXT': GcSystemColors.getSystemColor(13 ),
	            'HIGHLIGHT': GcSystemColors.getSystemColor(14 ),
	            'HIGHLIGHTTEXT': GcSystemColors.getSystemColor(15 ),
	            'INACTIVEBORDER': GcSystemColors.getSystemColor(17 ),
	            'INACTIVECAPTION': GcSystemColors.getSystemColor(18 ),
	            'INACTIVECAPTIONTEXT': GcSystemColors.getSystemColor(19 ),
	            'INFOBK': GcSystemColors.getSystemColor(20 ),
	            'INFOTEXT': GcSystemColors.getSystemColor(21 ),
	            'MENU': GcSystemColors.getSystemColor(22 ),
	            'GRADIENTACTIVECAPTION': GcSystemColors.getSystemColor(11 ),
	            'HOTLIGHT': GcSystemColors.getSystemColor(16 ),
	            'GRADIENTINACTIVECAPTION': GcSystemColors.getSystemColor(12 ),
	            'MENUBAR': GcSystemColors.getSystemColor(23 ),
	            'MENUHIGHLIGHT': GcSystemColors.getSystemColor(24 ),
	            'MENUTEXT': GcSystemColors.getSystemColor(25 ),
	            'SCROLLBAR': GcSystemColors.getSystemColor(26 ),
	            'WINDOW': GcSystemColors.getSystemColor(27 ),
	            'WINDOWFRAME': GcSystemColors.getSystemColor(28 ),
	            'WINDOWTEXT': GcSystemColors.getSystemColor(29 )
	        };
	        return ExcelSystemColor;
	    })();
	    exports.ExcelSystemColor = ExcelSystemColor;
	
	    exports.clearCache = function () {
	        UnitHelper._maxiumDigitWidthCache = keyword_undefined;
	        ExtendedNumberFormatHelper._formatIDCache = keyword_undefined;
	        ConverterHelper._fontParseCache = keyword_undefined;
	        ColorHelper._themeColorCache = keyword_undefined;
	        ColorHelper._htmlColorCache = keyword_undefined;
	    };
	}());


/***/ }),
/* 13 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    exports.BuiltInStylesResource = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><numFmts count="4"><numFmt numFmtId="42" formatCode="_(&quot;$&quot;* #,##0_);_(&quot;$&quot;* \(#,##0\);_(&quot;$&quot;* &quot;-&quot;_);_(@_)"/><numFmt numFmtId="41" formatCode="_(* #,##0_);_(* \(#,##0\);_(* &quot;-&quot;_);_(@_)"/><numFmt numFmtId="44" formatCode="_(&quot;$&quot;* #,##0.00_);_(&quot;$&quot;* \(#,##0.00\);_(&quot;$&quot;* &quot;-&quot;??_);_(@_)"/><numFmt numFmtId="43" formatCode="_(* #,##0.00_);_(* \(#,##0.00\);_(* &quot;-&quot;??_);_(@_)"/></numFmts><fonts count="18"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="18"/><color theme="3"/><name val="Cambria"/><family val="2"/><scheme val="major"/></font><font><b/><sz val="15"/><color theme="3"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="13"/><color theme="3"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="3"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF006100"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF9C0006"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF9C6500"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF3F3F76"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color rgb="FF3F3F3F"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color rgb="FFFA7D00"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FFFA7D00"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="0"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FFFF0000"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><i/><sz val="11"/><color rgb="FF7F7F7F"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color theme="0"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="33"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill><fill><patternFill patternType="solid"><fgColor rgb="FFC6EFCE"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFC7CE"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFEB9C"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFCC99"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFF2F2F2"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFA5A5A5"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFFFCC"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill></fills><borders count="10"><border><left/><right/><top/><bottom/><diagonal/></border><border><left/><right/><top/><bottom style="thick"><color theme="4"/></bottom><diagonal/></border><border><left/><right/><top/><bottom style="thick"><color theme="4" tint="0.499984740745262"/></bottom><diagonal/></border><border><left/><right/><top/><bottom style="medium"><color theme="4" tint="0.39997558519241921"/></bottom><diagonal/></border><border><left style="thin"><color rgb="FF7F7F7F"/></left><right style="thin"><color rgb="FF7F7F7F"/></right><top style="thin"><color rgb="FF7F7F7F"/></top><bottom style="thin"><color rgb="FF7F7F7F"/></bottom><diagonal/></border><border><left style="thin"><color rgb="FF3F3F3F"/></left><right style="thin"><color rgb="FF3F3F3F"/></right><top style="thin"><color rgb="FF3F3F3F"/></top><bottom style="thin"><color rgb="FF3F3F3F"/></bottom><diagonal/></border><border><left/><right/><top/><bottom style="double"><color rgb="FFFF8001"/></bottom><diagonal/></border><border><left style="double"><color rgb="FF3F3F3F"/></left><right style="double"><color rgb="FF3F3F3F"/></right><top style="double"><color rgb="FF3F3F3F"/></top><bottom style="double"><color rgb="FF3F3F3F"/></bottom><diagonal/></border><border><left style="thin"><color rgb="FFB2B2B2"/></left><right style="thin"><color rgb="FFB2B2B2"/></right><top style="thin"><color rgb="FFB2B2B2"/></top><bottom style="thin"><color rgb="FFB2B2B2"/></bottom><diagonal/></border><border><left/><right/><top style="thin"><color theme="4"/></top><bottom style="double"><color theme="4"/></bottom><diagonal/></border></borders><cellStyleXfs count="47"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/><xf numFmtId="43" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="41" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="44" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="42" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="9" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="2" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="3" fillId="0" borderId="1" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="4" fillId="0" borderId="2" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="5" fillId="0" borderId="3" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="5" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="6" fillId="2" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="7" fillId="3" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="8" fillId="4" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="9" fillId="5" borderId="4" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="10" fillId="6" borderId="5" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="11" fillId="6" borderId="4" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="12" fillId="0" borderId="6" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="13" fillId="7" borderId="7" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="14" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="8" borderId="8" applyNumberFormat="0" applyFont="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="15" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="16" fillId="0" borderId="9" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="9" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="10" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="11" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="12" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="13" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="14" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="15" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="16" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="17" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="18" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="19" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="20" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="21" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="22" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="23" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="24" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="25" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="26" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="27" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="28" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="29" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="30" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="31" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="32" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/></cellStyleXfs><cellXfs count="47"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/><xf numFmtId="0" fontId="6" fillId="2" borderId="0" xfId="11"/><xf numFmtId="0" fontId="7" fillId="3" borderId="0" xfId="12"/><xf numFmtId="0" fontId="8" fillId="4" borderId="0" xfId="13"/><xf numFmtId="0" fontId="13" fillId="7" borderId="7" xfId="18"/><xf numFmtId="0" fontId="11" fillId="6" borderId="4" xfId="16"/><xf numFmtId="0" fontId="15" fillId="0" borderId="0" xfId="21"/><xf numFmtId="0" fontId="9" fillId="5" borderId="4" xfId="14"/><xf numFmtId="0" fontId="12" fillId="0" borderId="6" xfId="17"/><xf numFmtId="0" fontId="0" fillId="8" borderId="8" xfId="20" applyFont="1"/><xf numFmtId="0" fontId="14" fillId="0" borderId="0" xfId="19"/><xf numFmtId="0" fontId="10" fillId="6" borderId="5" xfId="15"/><xf numFmtId="0" fontId="1" fillId="14" borderId="0" xfId="28"/><xf numFmtId="0" fontId="3" fillId="0" borderId="1" xfId="7"/><xf numFmtId="0" fontId="4" fillId="0" borderId="2" xfId="8"/><xf numFmtId="0" fontId="5" fillId="0" borderId="3" xfId="9"/><xf numFmtId="0" fontId="5" fillId="0" borderId="0" xfId="10"/><xf numFmtId="0" fontId="2" fillId="0" borderId="0" xfId="6"/><xf numFmtId="0" fontId="16" fillId="0" borderId="9" xfId="22"/><xf numFmtId="0" fontId="1" fillId="10" borderId="0" xfId="24"/><xf numFmtId="0" fontId="1" fillId="18" borderId="0" xfId="32"/><xf numFmtId="0" fontId="1" fillId="22" borderId="0" xfId="36"/><xf numFmtId="0" fontId="1" fillId="26" borderId="0" xfId="40"/><xf numFmtId="0" fontId="1" fillId="30" borderId="0" xfId="44"/><xf numFmtId="0" fontId="1" fillId="11" borderId="0" xfId="25"/><xf numFmtId="0" fontId="1" fillId="15" borderId="0" xfId="29"/><xf numFmtId="0" fontId="17" fillId="12" borderId="0" xfId="26"/><xf numFmtId="0" fontId="17" fillId="9" borderId="0" xfId="23"/><xf numFmtId="43" fontId="0" fillId="0" borderId="0" xfId="1" applyFont="1"/><xf numFmtId="0" fontId="1" fillId="19" borderId="0" xfId="33"/><xf numFmtId="0" fontId="17" fillId="16" borderId="0" xfId="30"/><xf numFmtId="0" fontId="17" fillId="13" borderId="0" xfId="27"/><xf numFmtId="0" fontId="17" fillId="20" borderId="0" xfId="34"/><xf numFmtId="0" fontId="17" fillId="17" borderId="0" xfId="31"/><xf numFmtId="0" fontId="1" fillId="23" borderId="0" xfId="37"/><xf numFmtId="0" fontId="17" fillId="24" borderId="0" xfId="38"/><xf numFmtId="0" fontId="17" fillId="21" borderId="0" xfId="35"/><xf numFmtId="0" fontId="17" fillId="28" borderId="0" xfId="42"/><xf numFmtId="0" fontId="1" fillId="27" borderId="0" xfId="41"/><xf numFmtId="0" fontId="17" fillId="25" borderId="0" xfId="39"/><xf numFmtId="0" fontId="1" fillId="31" borderId="0" xfId="45"/><xf numFmtId="0" fontId="17" fillId="32" borderId="0" xfId="46"/><xf numFmtId="0" fontId="17" fillId="29" borderId="0" xfId="43"/><xf numFmtId="9" fontId="0" fillId="0" borderId="0" xfId="5" applyFont="1"/><xf numFmtId="42" fontId="0" fillId="0" borderId="0" xfId="4" applyFont="1"/><xf numFmtId="44" fontId="0" fillId="0" borderId="0" xfId="3" applyFont="1"/><xf numFmtId="41" fontId="0" fillId="0" borderId="0" xfId="2" applyFont="1"/></cellXfs><cellStyles count="47"><cellStyle name="20% - Accent1" xfId="24" builtinId="30"/><cellStyle name="20% - Accent2" xfId="28" builtinId="34"/><cellStyle name="20% - Accent3" xfId="32" builtinId="38"/><cellStyle name="20% - Accent4" xfId="36" builtinId="42"/><cellStyle name="20% - Accent5" xfId="40" builtinId="46"/><cellStyle name="20% - Accent6" xfId="44" builtinId="50"/><cellStyle name="40% - Accent1" xfId="25" builtinId="31"/><cellStyle name="40% - Accent2" xfId="29" builtinId="35"/><cellStyle name="40% - Accent3" xfId="33" builtinId="39"/><cellStyle name="40% - Accent4" xfId="37" builtinId="43"/><cellStyle name="40% - Accent5" xfId="41" builtinId="47"/><cellStyle name="40% - Accent6" xfId="45" builtinId="51"/><cellStyle name="60% - Accent1" xfId="26" builtinId="32"/><cellStyle name="60% - Accent2" xfId="30" builtinId="36"/><cellStyle name="60% - Accent3" xfId="34" builtinId="40"/><cellStyle name="60% - Accent4" xfId="38" builtinId="44"/><cellStyle name="60% - Accent5" xfId="42" builtinId="48"/><cellStyle name="60% - Accent6" xfId="46" builtinId="52"/><cellStyle name="Accent1" xfId="23" builtinId="29"/><cellStyle name="Accent2" xfId="27" builtinId="33"/><cellStyle name="Accent3" xfId="31" builtinId="37"/><cellStyle name="Accent4" xfId="35" builtinId="41"/><cellStyle name="Accent5" xfId="39" builtinId="45"/><cellStyle name="Accent6" xfId="43" builtinId="49"/><cellStyle name="Bad" xfId="12" builtinId="27"/><cellStyle name="Calculation" xfId="16" builtinId="22"/><cellStyle name="Check Cell" xfId="18" builtinId="23"/><cellStyle name="Comma" xfId="1" builtinId="3"/><cellStyle name="Comma [0]" xfId="2" builtinId="6"/><cellStyle name="Currency" xfId="3" builtinId="4"/><cellStyle name="Currency [0]" xfId="4" builtinId="7"/><cellStyle name="Explanatory Text" xfId="21" builtinId="53"/><cellStyle name="Good" xfId="11" builtinId="26"/><cellStyle name="Heading 1" xfId="7" builtinId="16"/><cellStyle name="Heading 2" xfId="8" builtinId="17"/><cellStyle name="Heading 3" xfId="9" builtinId="18"/><cellStyle name="Heading 4" xfId="10" builtinId="19"/><cellStyle name="Input" xfId="14" builtinId="20"/><cellStyle name="Linked Cell" xfId="17" builtinId="24"/><cellStyle name="Neutral" xfId="13" builtinId="28"/><cellStyle name="Normal" xfId="0" builtinId="0"/><cellStyle name="Note" xfId="20" builtinId="10"/><cellStyle name="Output" xfId="15" builtinId="21"/><cellStyle name="Percent" xfId="5" builtinId="5"/><cellStyle name="Title" xfId="6" builtinId="15"/><cellStyle name="Total" xfId="22" builtinId="25"/><cellStyle name="Warning Text" xfId="19" builtinId="11"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleLight16"/></styleSheet>';
	    
	    function getClrScheme(themeName, background1, background2, text1, text2, accent1, accent2, accent3, accent4, accent5, accent6, link, followedLink) {
	        return '<a:clrScheme name="' + themeName + '"><a:dk1><a:sysClr val="windowText" lastClr="' + text1 + '"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="' + background1 + '"/></a:lt1><a:dk2><a:srgbClr val="' + text2 + '"/></a:dk2><a:lt2><a:srgbClr val="' + background2 + '"/></a:lt2><a:accent1><a:srgbClr val="' + accent1 + '"/></a:accent1><a:accent2><a:srgbClr val="' + accent2 + '"/></a:accent2><a:accent3><a:srgbClr val="' + accent3 + '"/></a:accent3><a:accent4><a:srgbClr val="' + accent4 + '"/></a:accent4><a:accent5><a:srgbClr val="' + accent5 + '"/></a:accent5><a:accent6><a:srgbClr val="' + accent6 + '"/></a:accent6><a:hlink><a:srgbClr val="' + link + '"/></a:hlink><a:folHlink><a:srgbClr val="' + followedLink + '"/></a:folHlink></a:clrScheme>';
	    }
	    var color000000 = '000000';
	    var colorFFFFFF = 'FFFFFF';
	    exports.ThemeClrSchemes = {
	        Default: getClrScheme('Default', colorFFFFFF, 'EEECE1', color000000, '1F497D', '4F81BD', 'C0504D', '9BBB59', '8064A2', '4BACC6', 'F79646', '0000FF', '800080'),
	        Office2007: getClrScheme('Office2007', colorFFFFFF, 'EEECE1', color000000, '1F497D', '4F81BD', 'C0504D', '9BBB59', '8064A2', '4BACC6', 'F79646', '0000FF', '800080'),
	        Office: getClrScheme('Office', colorFFFFFF, 'E7E6E6', color000000, '44546A', '5B9BD5', 'ED7D31', 'A5A5A5', 'FFC000', '4472C4', '70AD47', '0563C1', '954F72'),
	        Apex: getClrScheme('Apex', colorFFFFFF, 'C9C2D1', color000000, '69676D', 'CEB966', '9CB084', '6BB1C9', '6585CF', '7E6BC9', 'A379BB', '410082', '932968'),
	        Aspect: getClrScheme('Aspect', colorFFFFFF, 'E3DED1', color000000, '323232', 'F07F09', '9F2936', '1B587C', '4E8542', '604878', 'C19859', '6B9F25', 'B26B02'),
	        Concourse: getClrScheme('Concourse', colorFFFFFF, 'DEF5FA', color000000, '464646', '2DA2BF', 'DA1F28', 'EB641B', '39639D', '474B78', '7D3C4A', 'FF8119', '44B9E8'),
	        Civic: getClrScheme('Civic', colorFFFFFF, 'C5D1D7', color000000, '646B86', 'D16349', 'CCB400', '8CADAE', '8C7B70', '8FB08C', 'D19049', '00A3D6', '694F07'),
	        Oriel: getClrScheme('Oriel', colorFFFFFF, 'FFF39D', color000000, '575F6D', 'FE8637', '7598D9', 'B32C16', 'F5CD2D', 'AEBAD5', '777C84', 'D2611C', '3B435B'),
	        Origin: getClrScheme('Origin', colorFFFFFF, 'DDE9EC', color000000, '464653', '727CA3', '9FB8CD', 'D2DA7A', 'FADA7A', 'B88472', '8E736A', 'B292CA', '6B5680'),
	        Paper: getClrScheme('Paper', colorFFFFFF, 'FEFAC9', color000000, '444D26', 'A5B592', 'F3A447', 'E7BC29', 'D092A7', '9C85C0', '809EC2', '8E58B6', '7F6F6F'),
	        Solstice: getClrScheme('Solstice', colorFFFFFF, 'E7DEC9', color000000, '4F271C', '3891A7', 'FEB80A', 'C32D2E', '84AA33', '964305', '475A8D', '8DC765', 'AA8A14'),
	        Technic: getClrScheme('Technic', colorFFFFFF, 'D4D2D0', color000000, '3B3B3B', '6EA0B0', 'CCAF0A', '8D89A4', '748560', '9E9273', '7E848D', '00C8C3', 'A116E0'),
	        Trek: getClrScheme('Trek', colorFFFFFF, 'FBEEC9', color000000, '4E3B30', 'F0A22E', 'A5644E', 'B58B80', 'C3986D', 'A19574', 'C17529', 'AD1F1F', 'FFC42F'),
	        Urban: getClrScheme('Urban', colorFFFFFF, 'DEDEDE', color000000, '424456', '53548A', '438086', 'A04DA3', 'C4652D', '8B5D3D', '5C92B5', '67AFBD', 'C2A874'),
	        Verve: getClrScheme('Verve', colorFFFFFF, 'D2D2D2', color000000, '666666', 'FF388C', 'E40059', '9C007F', '68007F', '005BD3', '00349E', '17BBFD', 'FF79C2'),
	        Equity: getClrScheme('Equity', colorFFFFFF, 'E9E5DC', color000000, '696464', 'D34817', '9B2D1F', 'A28E6A', '956251', '918485', '855D5D', 'CC9900', '96A9A9'),
	        Flow: getClrScheme('Flow', colorFFFFFF, 'DBF5F9', color000000, '04617B', '0F6FC6', '009DD9', '0BD0D9', '10CF9B', '7CCA62', 'A5C249', 'E2D700', '85DFD0'),
	        Foundry: getClrScheme('Foundry', colorFFFFFF, 'EAEBDE', color000000, '676A55', '72A376', 'B0CCB0', 'A8CDD7', 'C0BEAF', 'CEC597', 'E8B7B7', 'DB5353', '903638'),
	        Median: getClrScheme('Median', colorFFFFFF, 'EBDDC3', color000000, '775F55', '94B6D2', 'DD8047', 'A5AB81', 'D8B25C', '7BA79D', '968C8C', 'F7B615', '704404'),
	        Metro: getClrScheme('Metro', colorFFFFFF, 'D6ECFF', color000000, '4E5B6F', '7FD13B', 'EA157A', 'FEB80A', '00ADDC', '738AC8', '1AB39F', 'EB8803', '5F7791'),
	        Module: getClrScheme('Module', colorFFFFFF, 'D4D4D6', color000000, '5A6378', 'F0AD00', '60B5CC', 'E66C7D', '6BB76D', 'E88651', 'C64847', '168BBA', '680000'),
	        Opulent: getClrScheme('Opulent', colorFFFFFF, 'F4E7ED', color000000, 'B13F9A', 'B83D68', 'AC66BB', 'DE6C36', 'F9B639', 'CF6DA4', 'FA8D3D', 'FFDE66', 'D490C5')
	    };
	    
	    function getFontScheme(themeName, headerFont, bodyFont) {
	        return '<a:fontScheme name="' + themeName + '"><a:majorFont><a:latin typeface="' + headerFont + '" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="' + bodyFont + '" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme>';
	    }
	    exports.ThemeFontSchemes = {
	        Default: getFontScheme('Default', 'Cambria', 'Calibri'),
	        Office: getFontScheme('Office', 'Calibri Light', 'Calibri'),
	        Office2007: getFontScheme('Office2007', 'Cambria', 'Calibri'),
	        Apex: getFontScheme('Apex', 'Lucida Sans', 'Book Antiqua'),
	        Aspect: getFontScheme('Aspect', 'Verdana', 'Verdana'),
	        Concourse: getFontScheme('Concourse', 'Lucida Sans Unicode', 'Lucida Sans Unicode'),
	        Civic: getFontScheme('Civic', 'Georgia', 'Georgia'),
	        Oriel: getFontScheme('Oriel', 'Century Schoolbook', 'Century Schoolbook'),
	        Origin: getFontScheme('Origin', 'Bookman Old Style', 'Gill Sans MT'),
	        Paper: getFontScheme('Paper', 'Constantia', 'Constantia'),
	        Solstice: getFontScheme('Solstice', 'Gill Sans MT', 'Gill Sans MT'),
	        Technic: getFontScheme('Technic', 'Franklin Gothic Book', 'Arial'),
	        Trek: getFontScheme('Trek', 'Franklin Gothic Medium', 'Franklin Gothic Book'),
	        Urban: getFontScheme('Urban', 'Trebuchet MS', 'Georgia'),
	        Verve: getFontScheme('Verve', 'Century Gothic', 'Century Gothic'),
	        Equity: getFontScheme('Equity', 'Franklin Gothic Book', 'Perpetua'),
	        Flow: getFontScheme('Flow', 'Calibri', 'Constantia'),
	        Foundry: getFontScheme('Foundry', 'Rockwell', 'Rockwell'),
	        Median: getFontScheme('Median', 'Tw Cen MT', 'Tw Cen MT'),
	        Metro: getFontScheme('Metro', 'Consolas', 'Corbel'),
	        Module: getFontScheme('Module', 'Corbel', 'Corbel'),
	        Opulent: getFontScheme('Opulent', 'Trebuchet MS', 'Trebuchet MS')
	    };
	    
	    function getFmtScheme(themeName) {
	        return '<a:fmtScheme name="' + themeName + '"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000"/><a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme>';
	    }
	    var ThemeFmtSchemes = {};
	    ['Default', 'Office', 'Office2007', 'Apex', 'Aspect', 'Concourse', 'Civic', 'Oriel',
	        'Origin', 'Paper', 'Solstice', 'Technic', 'Trek', 'Urban', 'Verve', 'Equity', 'Flow',
	        'Foundry', 'Median', 'Metro', 'Module', 'Opulent'].forEach(function (themeName) {
	            ThemeFmtSchemes[themeName] = getFmtScheme(themeName);
	    });
	    exports.ThemeFmtSchemes = ThemeFmtSchemes;
	    
	    exports.RelationsFile = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
	    
	   
	    
	
	}());

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    var Tuple = (function () {
	        function Tuple() {
	            var len = arguments.length;
	            for (var i = 1; i <= len; i++) {
	                this['item' + i] = arguments[i - 1];
	            }
	            this.count = len;
	        }
	    
	        Tuple.prototype.equals = function (other) {
	            for (var i = 1, len = this.count; i <= len; i++) {
	                var currentItem = this['item' + i], otherItem = other['item' + i];
	                if ((currentItem.equals && currentItem.equals(otherItem)) || currentItem === otherItem) {
	                    continue;
	                } else {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return Tuple;
	    })();
	    
	    module.exports = Tuple;
	
	}());

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var xmlReader = __webpack_require__(8);
	    var excelStyle = __webpack_require__(12);
	    var readColor = __webpack_require__(16);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var Util = common._Util;
	    var StringEx = common._StringEx;
	    var FontSchemeCategory = excelStyle.FontSchemeCategory;
	    var ExcelColor = excelStyle.ExcelColor;
	    var ExcelVerticalAlignment = excelStyle.ExcelVerticalAlignment;
	    var isNullOrUndefined = common._isNullOrUndefined;
	
	    function readStyle(dataString, readerDataModel) {
	        var reader = new xmlReader();
	        reader.setXml(dataString);
	        var styleCellStyleXfs = [];
	        var styleFonts = [], numberFormats = {}, styleFills = [], styleBorders = [], styleCellXfs = [];
	        while (reader.read()) {
	            if (reader.depth !== 1 || reader.elementType === 2 ) {
	                continue;
	            }
	            switch (reader.name()) {
	                case 'numFmts':
	                    readNumberFormats(reader, numberFormats);
	                    break;
	                case 'fonts':
	                    readFonts(reader, styleFonts);
	                    break;
	                case 'fills':
	                    readFills(reader, styleFills);
	                    break;
	                case 'borders':
	                    readBorders(reader, styleBorders);
	                    break;
	                case 'cellStyleXfs':
	                    readXFs(reader, styleCellStyleXfs, styleFonts, styleBorders, numberFormats, styleFills, true);
	                    break;
	                case 'cellXfs':
	                    readXFs(reader, styleCellXfs, styleFonts, styleBorders, numberFormats, styleFills, false);
	                    break;
	                case 'cellStyles':
	                    readCellStyles(reader, readerDataModel, styleCellStyleXfs);
	                    break;
	                case 'colors':
	                    readColors(reader, readerDataModel);
	                    break;
	                case 'dxfs':
	                    readDxfs(reader, readerDataModel);
	                    break;
	                case 'tableStyles':
	                    readTableStyles(reader, readerDataModel);
	                    break;
	                case 'extLst':
	                    readExtLst(reader, readerDataModel);
	                    break;
	                default:
	                    break;
	            }
	        }
	        var cellStyleXfsLength = styleCellStyleXfs.length;
	       
	        if (cellStyleXfsLength > 0) {
	            readerDataModel._setExcelDefaultCellFormat(styleCellStyleXfs[0]);
	        }
	        for (var i = 0, len = cellStyleXfsLength; i < len; i++) {
	            readerDataModel._setExcelCellFormat(styleCellStyleXfs[i], i);
	        }
	        for (i = 0, len = styleCellXfs.length; i < len; i++) {
	            readerDataModel._setExcelCellFormat(styleCellXfs[i], i);
	        }
	        return cellStyleXfsLength;
	    }
	
	    function readNumberFormats(reader, numberFormats) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'numFmt') {
	                var numberFormat = readNumberFormat(reader);
	                if (numberFormat && numberFormat.numberFormatId > 0) {
	                    numberFormats[numberFormat.numberFormatId] = numberFormat;
	                }
	            }
	        }
	    }
	
	    function readNumberFormat(reader) {
	        var formatId = -1, formatCode = '';
	        while (reader.moveToNextAttribute()) {
	            switch (reader.readAttributeNameAsString()) {
	                case 'numFmtId':
	                    formatId = reader.readContentAsInt(-1);
	                    break;
	                case 'formatCode':
	                    formatCode = reader.readContentAsString();
	                    break;
	                default:
	                    break;
	            }
	        }
	        formatCode = Util._xmlDecode(formatCode);
	        return new excelStyle.ExcelNumerFormat(formatId, formatCode);
	    }
	
	    function readFonts(reader, styleFonts) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'font') {
	                styleFonts.push(readFont(reader));
	            }
	        }
	    }
	
	    function readFont(reader) {
	        var styleFont = new excelStyle.ExcelFont();
	        var fontDepth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= fontDepth) {
	                break;
	            }
	            if (reader.nodeType() === 1 ) {
	                switch (reader.name()) {
	                    case 'b':
	                        styleFont.isBold = true;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.isBold = reader.readContentAsBoolean(-1);
	                            }
	                        }
	                        break;
	                    case 'charset':
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.charSetIndex = reader.readContentAsInt(-1);
	                            }
	                        }
	                        break;
	                    case 'family':
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.fontFamily = reader.readContentAsInt(0);
	                            }
	                        }
	                        break;
	                    case 'name':
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.fontName = reader.readContentAsString();
	                            }
	                        }
	                        break;
	                    case 'scheme':
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                var scheme = reader.readContentAsString();
	                                if (!StringEx._isNullOrWhiteSpace(scheme) && FontSchemeCategory[scheme.toLocaleLowerCase()] !== undefined) {
	                                    styleFont.fontScheme = FontSchemeCategory[scheme.toLocaleLowerCase()];
	                                }
	                            }
	                        }
	                        break;
	                    case 'u':
	                        var underLineStyle = 1 ;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                var u = reader.readContentAsString();
	                                if (!StringEx._isNullOrWhiteSpace(u) && excelStyle.UnderLineStyle[u] !== undefined) {
	                                    underLineStyle = excelStyle.UnderLineStyle[u];
	                                }
	                            }
	                        }
	                        styleFont.underLineStyle = underLineStyle;
	                        break;
	                    case 'i':
	                        styleFont.isItalic = true;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.isItalic = reader.readContentAsBoolean(-1);
	                            }
	                        }
	                        break;
	                    case 'outline':
	                        styleFont.isOutlineStyle = true;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.isOutlineStyle = reader.readContentAsBoolean(-1);
	                            }
	                        }
	                        break;
	                    case 'shadow':
	                        styleFont.isShadowStyle = true;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.isShadowStyle = reader.readContentAsBoolean(-1);
	                            }
	                        }
	                        break;
	                    case 'strike':
	                        styleFont.isStrikeOut = true;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.isStrikeOut = reader.readContentAsBoolean(-1);
	                            }
	                        }
	                        break;
	                    case 'sz':
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                styleFont.fontSize = reader.readContentAsDouble(0);
	                            }
	                        }
	                        break;
	                    case 'vertAlign':
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'val') {
	                                var vertAlign = reader.readContentAsString();
	                                if (vertAlign && excelStyle.VerticalAlignRun[vertAlign.toLocaleLowerCase()] !== undefined) {
	                                    styleFont.verticalAlignRun = excelStyle.VerticalAlignRun[vertAlign.toLocaleLowerCase()];
	                                }
	                            }
	                        }
	                        break;
	                    case'color':
	                        var color = readColor(reader);
	                        if (color !== ExcelColor.EmptyColor) {
	                            styleFont.fontColor = color;
	                        }
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	        return styleFont;
	    }
	
	    function readFills(reader, styleFills) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'fill') {
	                styleFills.push(readFill(reader));
	                if (styleFills.length === 0) {
	                    styleFills.push({
	                        patternType: 0 ,
	                        foreColor: ExcelColor.EmptyColor,
	                        backgroundColor: ExcelColor.EmptyColor
	                    });
	                }
	            }
	        }
	    }
	
	    function readFill(reader) {
	        var fill = {
	            patternType: 0 ,
	            foreColor: new ExcelColor(1 , 64, 0),
	            backgroundColor: new ExcelColor(1 , 65, 0)
	        };
	        var fillDepth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= fillDepth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'patternFill') {
	                while (reader.moveToNextAttribute()) {
	                    if (reader.readAttributeNameAsString() === 'patternType') {
	                        var patternTypeStr = reader.readContentAsString();
	                        if (patternTypeStr && excelStyle.FillPatternType[patternTypeStr] !== undefined) {
	                            fill.patternType = excelStyle.FillPatternType[patternTypeStr];
	                        }
	                    }
	                }
	                if (reader.elementType === 3 ) {
	                    break;
	                }
	                var patternFillDepth = reader.depth;
	                while (reader.read()) {
	                    if (reader.depth <= patternFillDepth) {
	                        break;
	                    }
	                    if (reader.nodeType() === 1 ) {
	                        if (reader.name() === 'fgColor') {
	                            fill.foreColor = readColor(reader);
	                        } else if (reader.name() === 'bgColor') {
	                            fill.backgroundColor = readColor(reader);
	                        }
	                    }
	                }
	            }
	        }
	        return fill;
	    }
	
	    function readBorders(reader, styleBorders) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'border') {
	                styleBorders.push(readBorder(reader));
	            }
	        }
	    }
	
	    function readBorder(reader) {
	        var borderDepth = reader.depth, border = new excelStyle.ExcelBorder();
	        var haveDiagonalUp = false;
	        var haveDiagonalDown = false;
	        while (reader.moveToNextAttribute()) {
	            var attributeName = reader.readAttributeNameAsString();
	            if (attributeName === 'diagonalUp') {
	                haveDiagonalUp = true;
	            } else if (attributeName === 'diagonalDown') {
	                haveDiagonalDown = true;
	            }
	        }
	        if (reader.elementType === 3  && !haveDiagonalUp && !haveDiagonalDown) {
	            return border;
	        }
	        while (reader.read()) {
	            if (reader.depth <= borderDepth) {
	                break;
	            }
	            if (reader.nodeType() === 1 ) {
	                switch (reader.name()) {
	                    case 'top':
	                        border.top = readOneBorder(reader);
	                        break;
	                    case 'right':
	                        border.right = readOneBorder(reader);
	                        break;
	                    case 'bottom':
	                        border.bottom = readOneBorder(reader);
	                        break;
	                    case 'left':
	                        border.left = readOneBorder(reader);
	                        break;
	                    case 'vertical':
	                        border.vertical = readOneBorder(reader);
	                        break;
	                    case 'horizontal':
	                        border.horizontal = readOneBorder(reader);
	                        break;
	                    case 'diagonal':
	                        var tempBorder = readOneBorder(reader);
	                        if (haveDiagonalUp) {
	                            border.diagonalUp = tempBorder;
	                        }
	                        if (haveDiagonalDown) {
	                            border.diagonalDown = tempBorder;
	                        }
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	        return border;
	    }
	
	    function readOneBorder(reader) {
	        var borderside = new excelStyle.ExcelBorderSide();
	        borderside.lineStyle = 0 ;
	        while (reader.moveToNextAttribute()) {
	            if (reader.readAttributeNameAsString() === 'style') {
	                var style = reader.readContentAsString();
	                if (style && excelStyle.ExcelBorderStyle[style] !== undefined) {
	                    borderside.lineStyle = excelStyle.ExcelBorderStyle[style];
	                }
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return borderside;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'color') {
	                borderside.color = readColor(reader);
	            }
	        }
	        return borderside;
	    }
	
	    function readXFs(reader, result, styleFonts, styleBorders, numberFormats, styleFills, isStyleXf) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'xf') {
	                var style = new excelStyle.ExtendedFormat();
	                style.isStyleFormat = isStyleXf;
	                readXFAttr(reader, style, styleFonts, styleBorders, numberFormats, styleFills);
	                result.push(style);
	
	                if (reader.elementType === 3 ) {
	                    continue;
	                }
	                var styleDepth = reader.depth;
	                while (reader.read()) {
	                    if (reader.depth <= styleDepth) {
	                        break;
	                    }
	                    if (reader.nodeType() === 1 ) {
	                        if (reader.name() === 'alignment') {
	                            readAlignment(reader, style);
	                        } else if (reader.name() === 'protection') {
	                            readProtection(reader, style);
	                        }
	                    }
	                }
	            }
	        }
	    }
	
	    function readXFAttr(reader, style, styleFonts, styleBorders, numberFormats, styleFills) {
	        var formatId = 0, fontId = 0, fillId = 0, borderId = 0;
	        while (reader.moveToNextAttribute()) {
	            switch (reader.readAttributeNameAsString()) {
	                case 'numFmtId':
	                    formatId = reader.readContentAsInt(0);
	                    break;
	                case 'fontId':
	                    fontId = reader.readContentAsInt(0);
	                    break;
	                case 'fillId':
	                    fillId = reader.readContentAsInt(0);
	                    break;
	                case 'borderId':
	                    borderId = reader.readContentAsInt(0);
	                    break;
	                case 'applyAlignment':
	                    var applyAlignment = reader.readContentAsInt(-1);
	                    if (applyAlignment === 0 || applyAlignment === 1) {
	                        style.applyAlignment = (applyAlignment === 1);
	                    }
	                    break;
	                case 'applyBorder':
	                    var applyBorder = reader.readContentAsInt(-1);
	                    if (applyBorder === 0 || applyBorder === 1) {
	                        style.applyBorder = (applyBorder === 1);
	                    }
	                    break;
	                case 'applyFill':
	                    var applyFill = reader.readContentAsInt(-1);
	                    if (applyFill === 0 || applyFill === 1) {
	                        style.applyFill = (applyFill === 1);
	                    }
	                    break;
	                case 'applyFont':
	                    var applyFont = reader.readContentAsInt(-1);
	                    if (applyFont === 0 || applyFont === 1) {
	                        style.applyFont = (applyFont === 1);
	                    }
	                    break;
	                case 'applyProtection':
	                    var applyProtection = reader.readContentAsInt(-1);
	                    if (applyProtection === 0 || applyProtection === 1) {
	                        style.applyProtection = (applyProtection === 1);
	                    }
	                    break;
	                case 'applyNumberFormat':
	                    var applyNumberFormat = reader.readContentAsInt(-1);
	                    if (applyNumberFormat === 0 || applyNumberFormat === 1) {
	                        style.applyNumberFormat = (applyNumberFormat === 1);
	                    }
	                    break;
	                case 'xfId':
	                    var parentXfID = reader.readContentAsInt(-1);
	                    if (parentXfID >= 0) {
	                        style.parentFormatID = parentXfID;
	                    }
	                    break;
	                case 'quotePrefix':
	                    var quotePrefix = reader.readContentAsBoolean();
	                    style.quotePrefix = quotePrefix;
	                    break;
	                default:
	                    break;
	            }
	        }
	        style.font = styleFonts[fontId];
	        style.border = styleBorders[borderId];
	        if (numberFormats[formatId]) {
	            style.numberFormat = numberFormats[formatId];
	        } else {
	            style.numberFormatIndex = formatId;
	        }
	        var fill = styleFills[fillId];
	        style.fillPattern = fill.patternType;
	        style.patternColor = fill.foreColor;
	        style.patternBackgroundColor = fill.backgroundColor;
	        style.isLocked = true;
	        style.isHidden = false;
	        style.horizontalAlign = 0 ;
	        style.verticalAlign = 2 ;
	    }
	
	    function readAlignment(reader, style) {
	        var hAlign = null, vAlign = null, justifyLastLine = false, isShrinkToFit = false, isWordWrap = false;
	        while (reader.moveToNextAttribute()) {
	            switch (reader.readAttributeNameAsString()) {
	                case 'horizontal':
	                    hAlign = reader.readContentAsString();
	                    break;
	                case 'vertical':
	                    vAlign = reader.readContentAsString();
	                    break;
	                case 'textRotation':
	                    var textRotation = reader.readContentAsString();
	                    if (!StringEx._isNullOrWhiteSpace(textRotation)) {
	                        style.rotation = parseInt(textRotation);
	                    }
	                    break;
	                case 'readingOrder':
	                    var readingOrder = reader.readContentAsString();
	                    if (!StringEx._isNullOrWhiteSpace(readingOrder)) {
	                        style.readingOrder = parseInt(readingOrder);
	                    }
	                    break;
	                case 'indent':
	                    var indent = reader.readContentAsString();
	                    if (!StringEx._isNullOrWhiteSpace(indent)) {
	                        style.indent = parseInt(indent);
	                    }
	                    break;
	                case 'justifyLastLine':
	                    justifyLastLine = reader.readContentAsBoolean(false);
	                    break;
	                case 'shrinkToFit':
	                    isShrinkToFit = reader.readContentAsBoolean(false);
	                    break;
	                case 'wrapText':
	                    isWordWrap = reader.readContentAsBoolean(false);
	                    break;
	                default:
	                    break;
	            }
	        }
	        style.isJustfyLastLine = justifyLastLine;
	        style.isShrinkToFit = isShrinkToFit;
	        style.isWordWrap = isWordWrap;
	        if (StringEx._isNullOrWhiteSpace(hAlign)) {
	            hAlign = 'general';
	        }
	        if (StringEx._isNullOrWhiteSpace(vAlign)) {
	            vAlign = 'bottom';
	        }
	        style.verticalAlign = ExcelVerticalAlignment[vAlign];
	        style.horizontalAlign = excelStyle.ExcelHorizontalAlignment[hAlign];
	    }
	
	    function readProtection(reader, style) {
	        while (reader.moveToNextAttribute()) {
	            var attrName = reader.readAttributeNameAsString();
	            if (attrName === 'hidden') {
	                style.isHidden = reader.readContentAsBoolean(false);
	            } else if (attrName === 'locked') {
	                var lockedStr = reader.readContentAsString();
	                if (!StringEx._isNullOrEmpty(lockedStr) && (lockedStr === '0' || lockedStr === 'false')) {
	                    style.isLocked = false;
	                }
	            }
	        }
	    }
	
	    function readCellStyles(reader, readerDataModel, styleCellStyleXfs) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'cellStyle') {
	                var name = void 0, xfId = 0, builtinId = -1, customBuiltin = false, iLevel = 0;
	                while (reader.moveToNextAttribute()) {
	                    switch (reader.readAttributeNameAsString()) {
	                        case 'name':
	                            name = reader.readContentAsString();
	                            break;
	                        case 'xfId':
	                            xfId = reader.readContentAsInt(0);
	                            break;
	                        case 'builtinId':
	                            builtinId = reader.readContentAsInt(-1);
	                            break;
	                        case 'customBuiltin':
	                            customBuiltin = reader.readContentAsBoolean(false);
	                            break;
	                        case 'iLevel':
	                            iLevel = reader.readContentAsInt(0);
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                var cellFormat = styleCellStyleXfs[xfId];
	                if (builtinId !== -1) {
	                    var style = new excelStyle.ExcelStyle();
	                    style.name = name;
	                    style.format(cellFormat.clone());
	                    style.isCustomBuiltin = customBuiltin;
	                    style.builtInStyle = builtinId;
	                    if (style.builtInStyle === 2  || style.builtInStyle === 1 ) {
	                        style.outLineLevel = iLevel;
	                    }
	                    readerDataModel._setExcelStyle(style, xfId);
	                } else {
	                    var customStyle = new excelStyle.CustomExcelStyle();
	                    customStyle.name = name;
	                    customStyle.format(cellFormat.clone());
	                    readerDataModel._setExcelStyle(customStyle, xfId);
	                }
	            }
	        }
	    }
	
	    function readColors(reader, readerDataModel) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth, palette = [];
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                return;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'indexedColors') {
	                var indexedColorsDepth = reader.depth;
	                while (reader.read()) {
	                    if (reader.depth <= indexedColorsDepth) {
	                        readerDataModel._setColorPalette(palette);
	                        return;
	                    }
	                    if (reader.nodeType() === 1 ) {
	                        var value = 0;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'rgb') {
	                                value = parseInt(reader.readContentAsString(), 16);
	                            }
	                        }
	                        palette.push((value & 0xFFFFFF) + 0xFF000000);
	                    }
	                }
	            }
	        }
	    }
	
	    function readExtLst(reader, readerDataModel) {
	        var dxfsRecords = null;
	        var slicerStylesNode = null;
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'ext') {
	                while (reader.moveToNextAttribute()) {
	                    if (reader.readAttributeNameAsString() === 'uri') {
	                        var uriStr = reader.readContentAsString();
	                        switch (uriStr) {
	                            case "{46F421CA-312F-682f-3DD2-61675219B42D}":
	                                dxfsRecords = readExtDxfs(reader);
	                                break;
	                            case "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}":
	                                var extNode = parseXmlToObject(reader.readFullElement())['ext'];
	                                if (!isNullOrUndefined(extNode)) {
	                                    slicerStylesNode = extNode['x14:slicerStyles'];
	                                }
	                                break;
	                        }
	                    }
	                }
	            }
	        }
	        readerDataModel._extDxfRecords = dxfsRecords;
	        readerDataModel._slicerStylesNode = slicerStylesNode;
	    }
	
	    function readExtDxfs(reader) {
	        var dxfsRecords = [];
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'x14:dxfs') {
	                dxfsRecords = readDifferentialFormattingRecords(reader);
	            }
	        }
	        return dxfsRecords;
	    }
	
	    function readDxfs(reader, readerDataModel) {
	        var differentialFormattingRecords = readDifferentialFormattingRecords(reader);
	        readerDataModel._dxfRecords = differentialFormattingRecords;
	    }
	
	    function readDifferentialFormattingRecords(reader) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        var differentialFormattingRecords = [];
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'dxf') {
	                differentialFormattingRecords.push(readDifferentialFormattingRecord(reader));
	            }
	        }
	        return differentialFormattingRecords;
	    }
	
	    function readDifferentialFormattingRecord(reader) {
	        var differentialFormattingRecord = {};
	        if (reader.elementType === 3 ) {
	            return differentialFormattingRecord;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1 ) {
	                switch (reader.name()) {
	                    case 'font':
	                        differentialFormattingRecord.font = readFont(reader);
	                        break;
	                    case 'border':
	                        differentialFormattingRecord.border = readBorder(reader);
	                        break;
	                    case 'fill':
	                        differentialFormattingRecord.fill = readFill(reader);
	                        break;
	                    case 'numFmt':
	                        differentialFormattingRecord.numberFormat = readNumberFormat(reader);
	                        break;
	                    case 'alignment':
	                        break;
	                    case 'protection':
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	        return differentialFormattingRecord;
	    }
	
	    function readTableStyles(reader, readerDataModel) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        readerDataModel.tableStylesObj = parseXmlToObject(reader.readFullElement()).tableStyles;
	    }
	
	    exports._readNumberFormats = readNumberFormats;
	    exports._readFonts = readFonts;
	    exports._readFills = readFills;
	    exports._readBorders = readBorders;
	    exports._readXFs = readXFs;
	    exports._readStyle = readStyle;
	    exports._readDifferentialFormattingRecord = readDifferentialFormattingRecord;
	
	}());

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excelStyle = __webpack_require__(12);
	    var common = __webpack_require__(4);
	    var xmlReader = __webpack_require__(8);
	    
	    var ExcelColor = excelStyle.ExcelColor;
	    var StringEx = common._StringEx;
	    
	    function readColor(obj) {
	        var color = ExcelColor.EmptyColor, auto = false, themeColorIndex = -1, tint = 0, rgb = '', index = -1;
	    
	        if (obj && obj instanceof xmlReader) {
	            var reader = obj;
	    
	            while (reader.moveToNextAttribute()) {
	                switch (reader.readAttributeNameAsString()) {
	                    case 'auto':
	                        auto = reader.readContentAsBoolean(false);
	                        break;
	                    case 'theme':
	                        themeColorIndex = reader.readContentAsInt(-1);
	                        break;
	                    case 'tint':
	                        tint = reader.readContentAsDouble(0.0);
	                        break;
	                    case 'rgb':
	                        rgb = reader.readContentAsString();
	                        break;
	                    case 'indexed':
	                        index = reader.readContentAsInt(-1);
	                        break;
	                    default:
	                        break;
	                }
	                }
	        } else if (obj) {
	            auto = !!obj._attr.auto;
	            if (obj._attr.theme) {
	                themeColorIndex = parseInt(obj._attr.theme);
	            }
	            if (obj._attr.tint) {
	                tint = parseFloat(obj._attr.tint);
	            }
	            rgb = obj._attr.rgb || '';
	            if (obj._attr.indexed) {
	                index = parseInt(obj._attr.indexed);
	            }
	        }
	    
	        if (auto) {
	            color.isAutoColor(true);
	            return color;
	        }
	        if (themeColorIndex !== -1) {
	            color = new ExcelColor(3 , themeColorIndex, tint);
	            return color;
	        }
	        if (!StringEx._isNullOrEmpty(rgb)) {
	            var argb = parseInt(rgb, 16);
	            color = new ExcelColor(2 , argb, tint);
	            return color;
	        }
	        if (index >= 0) {
	            color = new ExcelColor(1 , index, 0.0);
	            return color;
	        }
	        return color;
	    }
	    
	    module.exports = readColor;
	
	}());

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	
	
	(function (root) {
	    'use strict';
	    var Sha1 = {};
	    var EXTRA = [-2147483648, 8388608, 32768, 128];
	    var SHIFT = [24, 16, 8, 0];
	
	    var blocks = [];
	
	    var sha1 = function (message) {
	
	
	        var h0, h1, h2, h3, h4, block = 0, end = false, t, f,
	            i, j, index = 0, start = 0, bytes = 0, length = message.length;
	
	        h0 = 0x67452301;
	        h1 = 0xEFCDAB89;
	        h2 = 0x98BADCFE;
	        h3 = 0x10325476;
	        h4 = 0xC3D2E1F0;
	
	        do {
	            blocks[0] = block;
	            blocks[16] = blocks[1] = blocks[2] = blocks[3] =
	                blocks[4] = blocks[5] = blocks[6] = blocks[7] =
	                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
	                        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
	            for (i = start; index < length && i < 64; ++index) {
	                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
	            }
	
	            bytes += i - start;
	            start = i - 64;
	            if (index === length) {
	                blocks[i >> 2] |= EXTRA[i & 3];
	                ++index;
	            }
	            block = blocks[16];
	            if (index > length && i < 56) {
	                blocks[15] = bytes << 3;
	                end = true;
	            }
	
	            for (j = 16; j < 80; ++j) {
	                t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
	                blocks[j] = (t << 1) | (t >>> 31);
	            }
	
	            var a = h0, b = h1, c = h2, d = h3, e = h4;
	            for (j = 0; j < 20; j += 5) {
	                f = (b & c) | ((~b) & d);
	                t = (a << 5) | (a >>> 27);
	                e = t + f + e + 1518500249 + blocks[j] << 0;
	                b = (b << 30) | (b >>> 2);
	
	                f = (a & b) | ((~a) & c);
	                t = (e << 5) | (e >>> 27);
	                d = t + f + d + 1518500249 + blocks[j + 1] << 0;
	                a = (a << 30) | (a >>> 2);
	
	                f = (e & a) | ((~e) & b);
	                t = (d << 5) | (d >>> 27);
	                c = t + f + c + 1518500249 + blocks[j + 2] << 0;
	                e = (e << 30) | (e >>> 2);
	
	                f = (d & e) | ((~d) & a);
	                t = (c << 5) | (c >>> 27);
	                b = t + f + b + 1518500249 + blocks[j + 3] << 0;
	                d = (d << 30) | (d >>> 2);
	
	                f = (c & d) | ((~c) & e);
	                t = (b << 5) | (b >>> 27);
	                a = t + f + a + 1518500249 + blocks[j + 4] << 0;
	                c = (c << 30) | (c >>> 2);
	            }
	
	            for (; j < 40; j += 5) {
	                f = b ^ c ^ d;
	                t = (a << 5) | (a >>> 27);
	                e = t + f + e + 1859775393 + blocks[j] << 0;
	                b = (b << 30) | (b >>> 2);
	
	                f = a ^ b ^ c;
	                t = (e << 5) | (e >>> 27);
	                d = t + f + d + 1859775393 + blocks[j + 1] << 0;
	                a = (a << 30) | (a >>> 2);
	
	                f = e ^ a ^ b;
	                t = (d << 5) | (d >>> 27);
	                c = t + f + c + 1859775393 + blocks[j + 2] << 0;
	                e = (e << 30) | (e >>> 2);
	
	                f = d ^ e ^ a;
	                t = (c << 5) | (c >>> 27);
	                b = t + f + b + 1859775393 + blocks[j + 3] << 0;
	                d = (d << 30) | (d >>> 2);
	
	                f = c ^ d ^ e;
	                t = (b << 5) | (b >>> 27);
	                a = t + f + a + 1859775393 + blocks[j + 4] << 0;
	                c = (c << 30) | (c >>> 2);
	            }
	
	            for (; j < 60; j += 5) {
	                f = (b & c) | (b & d) | (c & d);
	                t = (a << 5) | (a >>> 27);
	                e = t + f + e - 1894007588 + blocks[j] << 0;
	                b = (b << 30) | (b >>> 2);
	
	                f = (a & b) | (a & c) | (b & c);
	                t = (e << 5) | (e >>> 27);
	                d = t + f + d - 1894007588 + blocks[j + 1] << 0;
	                a = (a << 30) | (a >>> 2);
	
	                f = (e & a) | (e & b) | (a & b);
	                t = (d << 5) | (d >>> 27);
	                c = t + f + c - 1894007588 + blocks[j + 2] << 0;
	                e = (e << 30) | (e >>> 2);
	
	                f = (d & e) | (d & a) | (e & a);
	                t = (c << 5) | (c >>> 27);
	                b = t + f + b - 1894007588 + blocks[j + 3] << 0;
	                d = (d << 30) | (d >>> 2);
	
	                f = (c & d) | (c & e) | (d & e);
	                t = (b << 5) | (b >>> 27);
	                a = t + f + a - 1894007588 + blocks[j + 4] << 0;
	                c = (c << 30) | (c >>> 2);
	            }
	
	            for (; j < 80; j += 5) {
	                f = b ^ c ^ d;
	                t = (a << 5) | (a >>> 27);
	                e = t + f + e - 899497514 + blocks[j] << 0;
	                b = (b << 30) | (b >>> 2);
	
	                f = a ^ b ^ c;
	                t = (e << 5) | (e >>> 27);
	                d = t + f + d - 899497514 + blocks[j + 1] << 0;
	                a = (a << 30) | (a >>> 2);
	
	                f = e ^ a ^ b;
	                t = (d << 5) | (d >>> 27);
	                c = t + f + c - 899497514 + blocks[j + 2] << 0;
	                e = (e << 30) | (e >>> 2);
	
	                f = d ^ e ^ a;
	                t = (c << 5) | (c >>> 27);
	                b = t + f + b - 899497514 + blocks[j + 3] << 0;
	                d = (d << 30) | (d >>> 2);
	
	                f = c ^ d ^ e;
	                t = (b << 5) | (b >>> 27);
	                a = t + f + a - 899497514 + blocks[j + 4] << 0;
	                c = (c << 30) | (c >>> 2);
	            }
	
	            h0 = h0 + a << 0;
	            h1 = h1 + b << 0;
	            h2 = h2 + c << 0;
	            h3 = h3 + d << 0;
	            h4 = h4 + e << 0;
	        } while (!end);
	
	        return [
	            16 * ((h0 >> 28) & 0x0F) + ((h0 >> 24) & 0x0F),
	            16 * ((h0 >> 20) & 0x0F) + ((h0 >> 16) & 0x0F),
	            16 * ((h0 >> 12) & 0x0F) + ((h0 >> 8) & 0x0F),
	            16 * ((h0 >> 4) & 0x0F) + (h0 & 0x0F),
	            16 * ((h1 >> 28) & 0x0F) + ((h1 >> 24) & 0x0F),
	            16 * ((h1 >> 20) & 0x0F) + ((h1 >> 16) & 0x0F),
	            16 * ((h1 >> 12) & 0x0F) + ((h1 >> 8) & 0x0F),
	            16 * ((h1 >> 4) & 0x0F) + (h1 & 0x0F),
	            16 * ((h2 >> 28) & 0x0F) + ((h2 >> 24) & 0x0F),
	            16 * ((h2 >> 20) & 0x0F) + ((h2 >> 16) & 0x0F),
	            16 * ((h2 >> 12) & 0x0F) + ((h2 >> 8) & 0x0F),
	            16 * ((h2 >> 4) & 0x0F) + (h2 & 0x0F),
	            16 * ((h3 >> 28) & 0x0F) + ((h3 >> 24) & 0x0F),
	            16 * ((h3 >> 20) & 0x0F) + ((h3 >> 16) & 0x0F),
	            16 * ((h3 >> 12) & 0x0F) + ((h3 >> 8) & 0x0F),
	            16 * ((h3 >> 4) & 0x0F) + (h3 & 0x0F),
	            16 * ((h4 >> 28) & 0x0F) + ((h4 >> 24) & 0x0F),
	            16 * ((h4 >> 20) & 0x0F) + ((h4 >> 16) & 0x0F),
	            16 * ((h4 >> 12) & 0x0F) + ((h4 >> 8) & 0x0F),
	            16 * ((h4 >> 4) & 0x0F) + (h4 & 0x0F)
	        ];
	
	    };
	
	    root.sha1 = sha1;
	    Sha1.hash = sha1;
	    module.exports = Sha1;
	}(this));


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	(function () {
	    'use strict';
	
	   
	    
	    module.exports = {
	        
	        fileIOError: 0,
	        
	        fileFormatError: 1,
	        
	        noPassword: 2,
	        
	        invalidPassword: 3
	    };
	
	}());

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	    var getCultureInfo = __webpack_require__(4)._getCulture;
	
	    var errorRes = {
	        en: {
	            EXP_IO: 'File read and write exception.',
	            EXP_FILE_FORMAT: 'Incorrect file format.',
	            EXP_NO_PASSWORD: 'The Excel file cannot be opened because the workbook/worksheet is password protected.',
	            EXP_INVALID_PASSWORD: 'The specified password is incorrect.'
	        },
	        ja: {
	            EXP_IO: '\u30d5\u30a1\u30a4\u30ebIO\u306b\u95a2\u3059\u308b\u4f8b\u5916\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002',
	            EXP_FILE_FORMAT: '\u30d5\u30a1\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306b\u8aa4\u308a\u304c\u3042\u308a\u307e\u3059\u3002',
	            EXP_NO_PASSWORD: '\u30ef\u30fc\u30af\u30d6\u30c3\u30af/\u30ef\u30fc\u30af\u30b7\u30fc\u30c8\u306f\u30d1\u30b9\u30ef\u30fc\u30c9\u3067\u4fdd\u8b77\u3055\u308c\u3066\u3044\u307e\u3059\u3002Excel\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093\u3067\u3057\u305f\u3002',
	            EXP_INVALID_PASSWORD: '\u30d1\u30b9\u30ef\u30fc\u30c9\u304c\u4e0d\u6b63\u3067\u3059\u3002'
	        },
	        zh: {
	            EXP_IO: '\u6587\u4ef6\u8bfb\u5199\u5f02\u5e38',
	            EXP_FILE_FORMAT: '\u6587\u4ef6\u683c\u5f0f\u9519\u8bef',
	            EXP_NO_PASSWORD: 'Excel\u6587\u4ef6\u53d7\u5bc6\u7801\u4fdd\u62a4\uff0c\u65e0\u6cd5\u88ab\u6253\u5f00',
	            EXP_INVALID_PASSWORD: '\u5bc6\u7801\u9519\u8bef'
	        }
	    };
	
	    module.exports = function () {
	       
	       
	       
	        var cultureStr = getCultureInfo() || "en";
	        var cultureRes = errorRes[cultureStr.split('-')[0]];
	        return cultureRes ? cultureRes : errorRes["en"];
	    };
	}());

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excel = __webpack_require__(21);
	    var ReaderDataModel = __webpack_require__(22);
	    var readSharedString = __webpack_require__(27);
	    var readTheme = __webpack_require__(28);
	    var readWorkbook = __webpack_require__(29);
	    var readStyle = __webpack_require__(15)._readStyle;
	    var readWorksheets = __webpack_require__(30);
	    var readComments = __webpack_require__(36);
	    var readDrawings = __webpack_require__(37);
	    var readSlicers = __webpack_require__(40)._readSlicers;
	    var readTables = __webpack_require__(41);
	    var readVmlDrawing = __webpack_require__(35)._readVmlDrawing;
	    var excelStyleHelper = __webpack_require__(12);
	    
	    var RelationshipConstants = excel._RelationshipConstants;
	    
	    var keyword_null = null;
	    
	    
	    var XlsxReader = (function () {
	        function XlsxReader() {
	            var self = this;
	            self._filesData = {};
	           
	            self._cellStyleXfsLength = 0;
	            self._sheetIDs = [];
	            self._readerDataModel = new ReaderDataModel();
	        }
	    
	        XlsxReader.prototype._load = function (filesData) {
	            if (!filesData) {
	                return;
	            }
	            this._filesData = filesData;
	            var packageFile = new excel._XFile('', '');
	            packageFile._loadPackageRelationFiles(filesData);
	            var workbookFile = packageFile._getFileByType(RelationshipConstants._relationshipWorkbookType);
	            if (!workbookFile) {
	                workbookFile = packageFile._getFileByType(RelationshipConstants._relationshipWorkbookType2);
	            }
	            this._loadWorkbook(workbookFile);
	            this._cleanFilesData();
	            this._dispose();
	            return this._readerDataModel._spread;
	        };
	        XlsxReader.prototype._loadWorkbook = function (workbookFile) {
	            if (!workbookFile) {
	                throw new Error('Incorrect file format.');
	            }
	            this._readSharedStrings(workbookFile);
	            this._readTheme(workbookFile);
	            this._readStyles(workbookFile);
	            this._readWorkbook(workbookFile);
	            if (this._sheetIDs.length === 0) {
	                throw new Error('Incorrect file format.');
	            }
	            this._readWorksheets(workbookFile);
	        };
	        XlsxReader.prototype._readSharedStrings = function (workbookFile) {
	            var stringTableFile = workbookFile._getFileByType(RelationshipConstants._relationshipSharedStringsType);
	            if (!stringTableFile) {
	                stringTableFile = workbookFile._getFileByType(RelationshipConstants._relationshipSharedStringsType2);
	            }
	            if (!stringTableFile) {
	                return;
	            }
	            var self = this;
	            var dataString = self._getFileDataAndCleanData(stringTableFile.fileName);
	            if (dataString) {
	                try {
	                    self.sharedString = readSharedString(dataString);
	                } catch (e) {
	                   
	                }
	            }
	        };
	        XlsxReader.prototype._readTheme = function (workbookFile) {
	            var themeFile = workbookFile._getFileByType(RelationshipConstants._relationshipThemeType);
	            if (!themeFile) {
	                themeFile = workbookFile._getFileByType(RelationshipConstants._relationshipThemeType2);
	            }
	            if (!themeFile) {
	                return;
	            }
	            var self = this;
	            var dataString = self._getFileDataAndCleanData(themeFile.fileName);
	            if (dataString) {
	                try {
	                    readTheme(dataString, this._readerDataModel);
	                } catch (e) {
	                   
	                }
	            }
	        };
	        XlsxReader.prototype._readStyles = function (workbookFile) {
	            var stylesFile = workbookFile._getFileByType(RelationshipConstants._relationshipStylesType);
	            if (!stylesFile) {
	                stylesFile = workbookFile._getFileByType(RelationshipConstants._relationshipStylesType2);
	            }
	            if (!stylesFile) {
	                return;
	            }
	            var self = this;
	            var dataString = self._getFileDataAndCleanData(stylesFile.fileName, true);
	            if (dataString) {
	                try {
	                    self._cellStyleXfsLength = readStyle(dataString, self._readerDataModel, true);
	                } catch (e) {
	                   
	                }
	            }
	        };
	        XlsxReader.prototype._readWorkbook = function (workbookFile) {
	            var self = this;
	            var dataString = self._getFileDataAndCleanData(workbookFile.fileName);
	            if (dataString) {
	                try {
	                    self._sheetIDs = readWorkbook(dataString, self._readerDataModel);
	                } catch (e) {
	                   
	                }
	            }
	        };
	        XlsxReader.prototype._readWorksheets = function (workbookFile) {
	            var self = this;
	            var readerDataModel = self._readerDataModel;
	            var getFileDataAndCleanData = self._getFileDataAndCleanData.bind(self);
	            var sheetInfo, sheetName;
	            for (var i = 0, len = self._sheetIDs.length; i < len; i++) {
	                sheetInfo = self._sheetIDs[i];
	                sheetName = sheetInfo.name;
	                var sheetviewFile = workbookFile._getFileByRelationID(sheetInfo.rID);
	                if (!sheetviewFile) {
	                    continue;
	                }
	                var dataString = self._getFileDataAndCleanData(sheetviewFile.fileName);
	                readerDataModel._excelPrintPageSetting = {};
	                if (dataString) {
	                    try {
	                        readWorksheets(dataString, sheetName, readerDataModel, self._cellStyleXfsLength, self.sharedString);
	                    } catch (e) {
	                       
	                    }
	                }
	    
	                var relationFiles = sheetviewFile.relationFiles;
	               
	                try {
	                    readComments(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
	                } catch (e) {
	                   
	                }
	               
	                try {
	                    readDrawings(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
	                } catch (e) {
	                   
	                }
	               
	                try {
	                    readTables(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
	                } catch (e) {
	                   
	                }
	               
	                try {
	                    readVmlDrawing(relationFiles, readerDataModel, getFileDataAndCleanData);
	                } catch (e) {
	                   
	                }
	    
	               
	                readerDataModel._setPrintPageSetting(sheetName, readerDataModel._excelPrintPageSetting);
	                readerDataModel._excelPrintPageSetting = {};
	            }
	            
	           
	           
	            for (i = 0, len = self._sheetIDs.length; i < len; i++) {
	                sheetInfo = self._sheetIDs[i];
	                sheetName = sheetInfo.name;
	                sheetviewFile = workbookFile._getFileByRelationID(sheetInfo.rID);
	                if (!sheetviewFile) {
	                    continue;
	                }
	                relationFiles = sheetviewFile.relationFiles;
	               
	                try {
	                    readSlicers(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData, workbookFile);
	                } catch (e) {
	                   
	                }
	            }
	
	            for (i = 0, len = self._sheetIDs.length; i < len; i++) {
	                sheetInfo = self._sheetIDs[i];
	                sheetName = sheetInfo.name;
	                self._processHiddenRow(sheetName);
	            }
	        };
	        function setRowVisible(sheet, rowFilter) {
	            if (rowFilter) {
	                var filterRange = rowFilter.range, filteredColumns = rowFilter.filteredColumns, i;
	                if (filterRange && sheet.rows && filteredColumns && filteredColumns.length > 0) {
	                    for (i = filterRange.row; i < filterRange.row + filterRange.rowCount; i++) {
	                        if (sheet.rows[i]) {
	                            sheet.rows[i].visible = true;
	                        }
	                    }
	                }
	            }
	        }
	       
	       
	       
	       
	        XlsxReader.prototype._processHiddenRow = function (sheetName) {
	            var spread = this._readerDataModel._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (sheet) {
	                setRowVisible(sheet, sheet.rowFilter);
	                var tables = sheet.tables;
	                if (tables) {
	                    for (var i = 0; i < tables.length; i++) {
	                        var table = tables[i];
	                        setRowVisible(sheet, table.rowFilter);
	                    }
	                }
	            }
	        };
	        XlsxReader.prototype._getFileDataAndCleanData = function (fileName, keepData) {
	            var fileName2 = fileName.substr(fileName.charAt(0) === '/' ? 1 : 0).toLowerCase();
	            var dataString = this._filesData[fileName2];
	            if (!keepData) {
	                this._filesData[fileName2] = keyword_null;
	            }
	            return dataString;
	        };
	        XlsxReader.prototype._cleanFilesData = function () {
	            this._filesData = {};
	        };
	        XlsxReader.prototype._dispose = function () {
	            excelStyleHelper.clearCache();
	        };
	       
	        return XlsxReader;
	    })();
	    module.exports = XlsxReader;
	    
	    
	    
	
	}());

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var StringEx = __webpack_require__(4)._StringEx;
	    var Util = __webpack_require__(4)._Util;
	    
	    (function (PaneType) {
	        PaneType[PaneType['bottomRight'] = 0x00] = 'bottomRight';
	        PaneType[PaneType['topRight'] = 0x01] = 'topRight';
	        PaneType[PaneType['bottomLeft'] = 0x02] = 'bottomLeft';
	        PaneType[PaneType['topLeft'] = 0x03] = 'topLeft';
	    })(exports.PaneType || (exports.PaneType = {}));
	    
	    var RelationshipConstants = {
	        _relationshipPrefix: 'rId',
	        _relationshipWorkbookType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
	        _relationshipWorkbookType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument',
	        _relationshipStylesType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
	        _relationshipStylesType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/styles',
	        _relationshipWorksheetType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
	        _relationshipSharedStringsType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
	        _relationshipSharedStringsType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/sharedStrings',
	        _relationshipThemeType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
	        _relationshipThemeType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/theme',
	        _relationshipExternalLinkType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink',
	        _relationshipTableType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
	        _relationshipCommentType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
	        _relationshipVMLDrawingType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',
	        _relationshipDrawingType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
	        _relationshipDrawingType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/drawing',
	        _relationshipImageType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
	        _relationshipImageType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/image',
	        _relationshipSlicerType: 'http://schemas.microsoft.com/office/2007/relationships/slicer',
	        _relationshipSlicerCacheType: 'http://schemas.microsoft.com/office/2007/relationships/slicerCache',
	        _relationshipChartType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
	        _realationshipChartUserShapes: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes'
	    };
	    exports._RelationshipConstants = RelationshipConstants;
	    
	    exports._ExcelConstants = {
	        _openXmlMaxColumn: 16384,
	        _openXmlMaxRow: 1048576
	    };
	    
	    exports._DefaultSize = {
	        _defaultColumnHeaderRowHeight: 20,
	        _defaultRowHeaderColumnWidth: 40,
	        _defaultColumnWidth: 62,
	        _defaultRowHeight: 20
	    };
	    
	    var XFileConstants = {
	        _relationshipFileFolder: '_rels',
	        _dataFileRootFolder: '/xl',
	        _contentTypeFileName: '[Content_Types].xml',
	        _binExtension: 'bin',
	        _binType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings',
	        _relsExtension: 'rels',
	        _relsType: 'application/vnd.openxmlformats-package.relationships+xml',
	        _sharedStringType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
	        _stylesType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
	        _themeType: 'application/vnd.openxmlformats-officedocument.theme+xml',
	        _workbookType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
	        _worksheetType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
	        _externalLinkType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml',
	        _tableType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',
	        _drawingType: 'application/vnd.openxmlformats-officedocument.drawing+xml',
	        _chartType: 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml',
	        _chartShapes: 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml',
	        _diagramColorsType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml',
	        _diagramDataType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml',
	        _diagramDrawingType: 'application/vnd.ms-office.drawingml.diagramDrawing+xml',
	        _diagramLayoutType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml',
	        _diagramStyleType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml',
	        _commentsType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',
	        _slicerType:'application/vnd.ms-excel.slicer+xml',
	        _slicerCacheType:'application/vnd.ms-excel.slicerCache+xml',
	        _vbaType: 'application/vnd.ms-office.vbaProject',
	        _vmlDrawingsType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',
	        _controlProperties: 'application/vnd.ms-excel.controlproperties+xml',
	        _xmlExtension: 'xml',
	        _vmlExtension: 'vml',
	        _xmlType: 'application/xml',
	        _jpgExtension: 'jpg',
	        _jpgType: 'image/jpg',
	        _jpegExtension: 'jpeg',
	        _jpegType: 'image/jpeg',
	        _pngExtension: 'png',
	        _pngType: 'image/png',
	        _bmpExtension: 'bmp',
	        _bmpType: 'image/bmp',
	        _gifExtension: 'gif',
	        _gifType: 'image/gif',
	        _emfExtension: 'emf',
	        _emfType: 'image/x-emf',
	        _wmfExtension: 'wmf',
	        _wmfType: 'image/x-wmf',
	        _drawings: 'drawings',
	        _vmlDrawingsFileNamePrefix: 'vmlDrawing',
	        _chartsFileFolder: '/xl/charts',
	        _drawingsFileFolder: '/xl/drawings',
	        _mediaFileFolder: '/xl/media',
	        _worksheetFolder: '/xl/worksheets',
	        _tableFilesFolder: '/xl/tables',
	        _slicerFilesFolder: '/xl/slicers',
	        _slicerCacheFilesFolder: '/xl/slicerCaches',
	        _worksheetNamePrefix: 'sheet',
	        _commentFileNamePrefix: 'comments',
	        _chartFileNamePrefix: 'chart',
	        _drawingFileNamePrefix: 'drawing',
	        _imageFileNamePrefix: 'image',
	        _tableFileNamePrefix: 'table',
	        _slicerFileNamePrefix: 'slicer',
	        _slicerCacheFileNamePrefix: 'slicerCache',
	        _sharedStringsDefaultFileName: '/xl/sharedStrings.xml',
	        _themeDefaultFileName: '/xl/theme/theme1.xml',
	        _worksheetFilePath: '/xl/worksheets',
	        _workbook_default_fileName: '/xl/workbook.xml',
	        _style_fileName: '/xl/styles.xml',
	        _theme_default_fileName: '/xl/theme/theme1.xml',
	        _workbookRels: '/xl/_rels/workbook.xml.rels',
	        _workbookNameSpace: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	        _markupCompatibility: 'http://schemas.openxmlformats.org/markup-compatibility/2006',
	        _drawingNameSpace: 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
	        _drawingNameSpace2: 'http://schemas.openxmlformats.org/drawingml/2006/main',
	        _tableNameSpace: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	        _ac: 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
	        _ignorable: 'x14ac',
	        _relationShipNameSpace: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
	        _contentTypeNameSpace: 'http://schemas.openxmlformats.org/package/2006/content-types',
	        _relationshipNameSpace: 'http://schemas.openxmlformats.org/package/2006/relationships',
	        _themeNameSpace: 'http://schemas.openxmlformats.org/drawingml/2006/main',
	        _a14: 'http://schemas.microsoft.com/office/drawing/2010/main',
	        _extensionListNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
	        _sparklineGroupsNameSpace: 'http://schemas.microsoft.com/office/excel/2006/main',
	        _slicerCompatibility: 'http://schemas.openxmlformats.org/markup-compatibility/2006',
	        _slicerNameSpaceX: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	        _slicerNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
	        _relationship_spreadsheetml_201011 : "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
	    };
	    exports._XFileConstants = XFileConstants;
	    
	    (function (FontLanguage) {
	       
	        FontLanguage[FontLanguage['latin'] = 0] = 'latin';
	    
	       
	        FontLanguage[FontLanguage['cs'] = 1] = 'cs';
	    
	       
	        FontLanguage[FontLanguage['ea'] = 2] = 'ea';
	    
	       
	        FontLanguage[FontLanguage['sym'] = 3] = 'sym';
	    })(exports.FontLanguage || (exports.FontLanguage = {}));
	    
	    var ExcelCell = (function () {
	        function ExcelCell(row, col) {
	            this.row = row;
	            this.col = col;
	        }
	    
	        return ExcelCell;
	    })();
	    exports._ExcelCell = ExcelCell;
	    
	    var ExcelColumn = (function () {
	        function ExcelColumn(index) {
	            this.index = index;
	        }
	    
	        return ExcelColumn;
	    })();
	    exports._ExcelColumn = ExcelColumn;
	    
	    var ExcelRow = (function () {
	        function ExcelRow(index) {
	            this.index = index;
	        }
	    
	        return ExcelRow;
	    })();
	    exports._ExcelRow = ExcelRow;
	
	    var ExcelTheme = (function () {
	        function ExcelTheme(name, colorScheme, fontScheme) {
	            this.name = name;
	            this.colorScheme = colorScheme;
	            this.fontScheme = fontScheme;
	        }
	    
	        return ExcelTheme;
	    })();
	    exports._ExcelTheme = ExcelTheme;
	    
	    var ColorScheme = (function () {
	        function ColorScheme(name, schemeColors) {
	            this.name = name;
	            this.schemeColors = schemeColors;
	        }
	    
	        return ColorScheme;
	    })();
	    exports._ColorScheme = ColorScheme;
	    
	    var FontScheme = (function () {
	        function FontScheme(name, majorFont, minorFont) {
	            this.name = name;
	            this.majorFont = majorFont;
	            this.minorFont = minorFont;
	        }
	    
	        return FontScheme;
	    })();
	    exports._FontScheme = FontScheme;
	    
	    var ThemeFont = (function () {
	        function ThemeFont(script, typeface) {
	            this.script = script;
	            this.typeface = typeface;
	        }
	    
	        return ThemeFont;
	    })();
	    exports._ThemeFont = ThemeFont;
	    
	    var ThemeFonts = (function () {
	        function ThemeFonts(runFormats, themesFonts) {
	            this.runFormattings = runFormats;
	            this.themesFonts = themesFonts;
	        }
	    
	        return ThemeFonts;
	    })();
	    exports._ThemeFonts = ThemeFonts;
	    
	    var RunFormatting = (function () {
	        function RunFormatting(language, typeface) {
	            this.fontLanguage = language;
	            this.typeface = typeface;
	        }
	    
	        return RunFormatting;
	    })();
	    exports._RunFormatting = RunFormatting;
	    
	    var SheetInfo = (function () {
	        function SheetInfo() {
	        }
	    
	        return SheetInfo;
	    })();
	    exports._SheetInfo = SheetInfo;
	    
	    var DefaultContentType = (function () {
	        function DefaultContentType() {
	        }
	    
	        return DefaultContentType;
	    })();
	    exports._DefaultContentType = DefaultContentType;
	    
	    var OverrideContentType = (function () {
	        function OverrideContentType() {
	        }
	    
	        return OverrideContentType;
	    })();
	    exports._OverrideContentType = OverrideContentType;
	    
	    var Relationship = (function () {
	        function Relationship() {
	        }
	    
	        return Relationship;
	    })();
	    
	    var XFile = (function () {
	        function XFile(fileName, fileType) {
	            this.fileName = fileName;
	            this.fileType = fileType;
	            this.relationFiles = {count: 0};
	        }
	    
	        XFile.prototype._addRelationFile = function (file) {
	            if (!file) {
	                return '';
	            }
	            var key = RelationshipConstants._relationshipPrefix + (++this.relationFiles.count);
	            this.relationFiles[key] = file;
	            return key;
	        };
	        XFile.prototype._loadPackageRelationFiles = function (filesData) {
	            if (!filesData) {
	                return;
	            }
	            var relationships = this._getRelationshipsByBaseName(this.fileName, filesData);
	            if (relationships) {
	                for (var i = 0, len = relationships.length; i < len; i++) {
	                    var item = relationships[i];
	                    var fileName = item.target;
	    
	                   
	                    if (fileName[0] !== '/') {
	                        fileName = Util._joinPath(this.fileName, fileName);
	                    } else {
	                        fileName = fileName.substr(1);
	                    }
	    
	                    var relationFile = new XFile(fileName, item.type);
	                    relationFile._loadPackageRelationFiles(filesData);
	                   
	                    if (!this.relationFiles[item.id]) {
	                        this.relationFiles.count++;
	                    }
	                    this.relationFiles[item.id] = relationFile;
	                }
	            }
	        };
	        XFile.prototype._getRelationshipsByBaseName = function (baseName, filesData) {
	            if (baseName === null || !filesData) {
	                return null;
	            }
	            var relationshipName = this._getRelationshipsNameByBaseName(baseName);
	            if (!relationshipName) {
	                return null;
	            }
	            return this._readRelationships(filesData[relationshipName.toLowerCase()]);
	        };
	        XFile.prototype._getRelationshipsNameByBaseName = function (baseName) {
	            if (baseName === null) {
	                return '';
	            }
	            if (baseName.length === 0) {
	                return XFileConstants._relationshipFileFolder + '/.' + XFileConstants._relsExtension;
	            }
	            return baseName.substring(baseName.charAt(0) === '/' ? 1 : 0, baseName.lastIndexOf('/')) +
	                '/' + XFileConstants._relationshipFileFolder +
	                '/' + baseName.substring(baseName.lastIndexOf('/') + 1) +
	                '.' + XFileConstants._relsExtension;
	        };
	        XFile.prototype._getFileByType = function (type) {
	            if (!this.relationFiles || this.relationFiles.count === 0) {
	                return null;
	            }
	            if (StringEx._isNullOrEmpty(type)) {
	                return null;
	            }
	            for (var key in this.relationFiles) {
	                if (key !== 'count') {
	                    var relationFile = this.relationFiles[key];
	                    if (relationFile.fileType === type) {
	                        return relationFile;
	                    }
	                }
	            }
	            return null;
	        };
	        XFile.prototype._getFileByRelationID = function (id) {
	            if (!this.relationFiles || this.relationFiles.count === 0 || StringEx._isNullOrWhiteSpace(id)) {
	                return null;
	            }
	            return this.relationFiles[id];
	        };
	        XFile.prototype._readRelationships = function (dataString) {
	            if (!dataString) {
	                return;
	            }
	            var list = [];
	            var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	            var obj = parseXmlToObject(dataString);
	            var relationships = obj.Relationships;
	            if (relationships) {
	                var rels = relationships.Relationship;
	                if (!Array.isArray(rels)) {
	                    rels = [rels];
	                }
	                for (var i = 0, len = rels.length; i < len; i++) {
	                    var rel = rels[i];
	                    if (rel) {
	                        var r = new Relationship();
	                        if (rel._attr.Id) {
	                            r.id = rel._attr.Id;
	                        }
	                        if (rel._attr.Target) {
	                            r.target = rel._attr.Target;
	                        }
	                        if (rel._attr.Type) {
	                            r.type = rel._attr.Type;
	                        }
	                        list.push(r);
	                    }
	                }
	            }
	            return list;
	        };
	        return XFile;
	    })();
	    exports._XFile = XFile;
	    
	    
	
	}());

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var excelStyle = __webpack_require__(12);
	    var excelHelper = __webpack_require__(23);
	    var DateTimeHelper = __webpack_require__(25);
	    var rangeParser = __webpack_require__(26);
	    var getRangesFromString = rangeParser._getRangesFromString;
	    var excel = __webpack_require__(21);
	    var IndexHelper = common._IndexHelper;
	    var ExcelConstants = excel._ExcelConstants;
	    var Range = common._Range;
	    var StyleHelper = common._StyleHelper;
	    var ConverterHelper = excelStyle.ConverterHelper;
	    var StringEx = common._StringEx;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var isNullOrWhiteSpace = StringEx._isNullOrWhiteSpace;
	    var ColorHelper = excelStyle.ColorHelper;
	    var UnitHelper = excelStyle.UnitHelper;
	    var ExcelColor = excelStyle.ExcelColor;
	    var CalcHelper = common._CalcHelper;
	    var convertDxfToStyle = excelStyle.ConverterHelper.convertDxfToStyle;
	    var convertFromExcelComment = excelHelper.convertFromExcelComment;
	    var convertFromExcelPicture = excelHelper.convertFromExcelPicture;
	    var convertFromExcelChart = excelHelper.convertFromExcelChart;
	    var inflateWorksheetBySlicer = excelHelper.inflateWorksheetBySlicer;
	    var processTableCell = excelHelper.processTableCellStyle;
	    var toProtectionOptions = excelHelper.toProtectionOptions;
	    var isRangeWholeRow = common.isRangeWholeRow, isRangeWholeColumn = common.isRangeWholeColumn;
	
	    var keyword_null = null, keyword_undefined = void 0, CONST_NORMAL = 'Normal';
	
	   
	    function modifyOutlineCollapsed(outlines, index, outlineLevel, summaryFlag, hidden, previousHidden) {
	        var itemsData = outlines.itemsData;
	        if (!itemsData) {
	            return;
	        }
	        var lastItemData = itemsData[itemsData.length - 1];
	        var lastSecondItemData = itemsData[itemsData.length - 2];
	        var lastItemDataInfo = lastItemData && lastItemData.info;
	        var lastSecondItemdataInfo = lastSecondItemData && lastSecondItemData.info;
	
	        if (!lastItemDataInfo) {
	            return;
	        }
	
	        if (summaryFlag && hidden && lastItemData.count === 1) {
	            if (lastSecondItemdataInfo && lastSecondItemData.index === lastItemData.index - 1 && lastSecondItemdataInfo.level === lastItemDataInfo.level - 1) {
	                lastSecondItemdataInfo.collapsed = true;
	            } else if (index > 0) {
	                itemsData.splice(itemsData.length - 2, 0, {
	                    index: lastItemData.index - 1,
	                    count: 1,
	                    info: {
	                        level: lastItemDataInfo.level - 1,
	                        collapsed: true
	                    }
	                });
	            } else {
	                outlines.head = {
	                    collapsed: true,
	                    level: outlineLevel - 1
	                };
	            }
	        } else if (!summaryFlag && previousHidden) {
	            if (lastSecondItemdataInfo && lastItemData.index === lastSecondItemData.index + 1 && lastItemDataInfo.level === lastSecondItemdataInfo.level - 1) {
	                lastItemData.collapsed = true;
	            } else if (index >= lastItemData.index + lastItemData.count) {
	                itemsData.push({
	                    index: lastItemData.index + lastItemData.count,
	                    count: 1,
	                    info: {
	                        level: lastItemDataInfo.level - 1,
	                        collapsed: true
	                    }
	                });
	            }
	        }
	    }
	
	   
	
	   
	    function createCondition(conType, compareType, expected, ignoreBlank, type, isPercent, item1, item2, ranges, expectTypeId) {
	        var condition = {};
	        condition.conType = conType;
	        if (!isNullOrUndefined(compareType)) {
	            condition.compareType = compareType;
	        }
	        if (!isNullOrUndefined(expected)) {
	            condition.expected = expected;
	        }
	        if (!isNullOrUndefined(ignoreBlank)) {
	            condition.ignoreBlank = ignoreBlank;
	        }
	        if (!isNullOrUndefined(type)) {
	            condition.type = type;
	        }
	        if (!isNullOrUndefined(isPercent)) {
	            condition.isPercent = isPercent;
	        }
	        if (!isNullOrUndefined(item1)) {
	            condition.item1 = item1;
	        }
	        if (!isNullOrUndefined(item2)) {
	            condition.item2 = item2;
	        }
	        if (!isNullOrUndefined(ranges)) {
	            condition.ranges = ranges;
	        }
	        if (!isNullOrUndefined(expectTypeId)) {
	            condition.expectTypeId = expectTypeId;
	        }
	        if (conType === 2 ) {
	            condition.ignoreCase = true;
	        }
	        return condition;
	    }
	
	    function createColorFilterCondition(colorFilter, conditionColor) {
	        var compareType = colorFilter.cellColor ? 0  : 1 ,
	            fill = conditionColor.fill, color;
	        if (fill) {
	            if (fill.patternType === 0 ) {
	                color = '';    
	            } else {
	                color = ColorHelper.toRGBColor(fill.foreColor);
	            }
	        }
	       
	        return createCondition(3 , compareType, color);
	    }
	    function getAutoFilterRangeType(rangeData) {
	        if(rangeData.length > 0) {
	            var data = rangeData[0];
	            if(typeof data === "number") {
	                return "number";
	            }else if(typeof data === "string" && data.indexOf("/OADate(") === 0 && data.indexOf(")") === data.length - 2) {
	                return "date";
	            }else if(typeof data === "boolean") {
	                return "boolean";
	            }
	        }
	        return "";
	
	    }
	    function createConditionByCellValue(dataType, operator, value) {
	        var conType;
	        var ComparisonOperators = {        
	            none: 0 ,
	            equal: 0 ,
	            lessThan: 4 ,
	            lessThanOrEqual: 5 ,
	            notEqual: 1 ,
	            greaterThan: 2 ,
	            greaterThanOrEqual: 3 
	        };
	        switch (dataType) {
	            case "string":
	                conType = 2 ;
	                break;
	            case "number":
	                conType = 1 ;
	                value = parseFloat(value);
	                break;
	            case "date":
	                conType = 5 ;
	               
	                if(typeof value === "string" && value.indexOf("/OADate(") === 0) {
	                    var dataNumber = parseInt(value.replace("/OADate(", ""));
	                    value = DateTimeHelper._fromOADate(dataNumber);
	                }else{
	                    value = DateTimeHelper._fromOADate(parseInt(value));
	                }
	                ComparisonOperators = {
	                    none: 0 ,
	                    equal: 0 ,
	                    lessThan: 2 ,
	                    lessThanOrEqual: 3 ,
	                    notEqual: 1 ,
	                    greaterThan: 4 ,
	                    greaterThanOrEqual: 5 
	                };
	                break;
	            case "boolean":
	            default:
	                conType = 11 ;
	                break;
	        }
	        return createCondition(conType, ComparisonOperators[operator || true], value);
	    }
	
	    function createCustomFilterCondition(customFilters, rangeData) {
	        function identifyTextAndCellValueCondition(customFilter) {
	            var retCondition, op, isNotEqual = customFilter.operator === 'notEqual' ;
	            var value = customFilter.value;
	            var startIndex = value.indexOf('*'), endIndex = value.lastIndexOf('*');
	           
	            if (startIndex !== -1) {
	                if (startIndex === value.length - 1 && startIndex !== 0) {  
	                    op = isNotEqual ? 3  : 2 ;
	                    retCondition = createCondition(2 , op, value.substring(0, value.length - 1));
	                } else if (startIndex === 0 && startIndex === endIndex) {      
	                    op = isNotEqual ? 5  : 4 ;
	                    retCondition = createCondition(2 , op, value.substring(1));
	                } else {
	                    var textCompareType = isNotEqual ? 7  : 6 ;
	                    if (startIndex !== -1 && endIndex !== -1) {
	                        value = value.substr(1, value.length - 2);
	                    }
	                    retCondition = createCondition(2 , textCompareType, value);
	                }
	            } else {
	                var dataType = getAutoFilterRangeType(rangeData);
	                retCondition = createConditionByCellValue(dataType, customFilter.operator, value);
	            }
	            return retCondition;
	        }
	
	        var condition;
	        if (customFilters.filter1) {
	            condition = identifyTextAndCellValueCondition(customFilters.filter1);
	        }
	        if (customFilters.filter2) {
	            var relationType = customFilters.and ? 1  : 0 ;
	            condition = createCondition(0 , relationType, keyword_null, keyword_null,
	                keyword_null, keyword_null, condition, identifyTextAndCellValueCondition(customFilters.filter2));
	        }
	        return condition;
	    }
	
	    function createDynamicFilterCondition(dynamicFilter, filterRange, columnId) {
	        var condition;
	        var range = new Range(filterRange.row, columnId, filterRange.rowCount, 1);
	        var type = dynamicFilter.type;
	       
	        if (type === 100  || type === 101 ) { 
	            condition = createCondition(10 , keyword_null, keyword_null,
	                keyword_null, type - 100 , keyword_null, keyword_null, keyword_null, range);
	        }else if(type === 16 ) {
	           
	            condition = createCondition(6 , keyword_null, 0, keyword_null,
	                keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, 6 );
	        } else if (type >= 17  && type <= 20 ) {  
	            condition = createCondition(6 , keyword_null, type - 17, keyword_null,
	                keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, 2 );
	        } else if (type >= 21  && type <= 32  ) {  
	            condition = createCondition(6 , keyword_null, type - 21, keyword_null,
	                keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, 3 );
	        } else if (type >= 0  && type <= 15  ) {    
	            condition = createCondition(6 , keyword_null, type);
	        }
	        return condition;
	    }
	
	    function createTop10FilterCondition(top10Filter) {
	        var top10Type = top10Filter.top ? 0  : 1 ;
	        return createCondition(8 , keyword_null, top10Filter.value,
	            keyword_null, top10Type, top10Filter.percent);
	    }
	
	   
	
	   
	    function addFormulaPrefixSymbol(formula) {
	        if (isNullOrWhiteSpace(formula)) {
	            return formula;
	        }
	        return "=" + formula;
	    }
	
	    function addStringPrefixSymbol(formula) {
	        if (isNullOrWhiteSpace(formula) || formula.length <= 2) {
	            return formula;
	        }
	        return formula.substr(1, formula.length - 2);
	    }
	
	   
	
	    var ReaderDataModel = (function () {
	        function ReaderDataModel() {
	            var self = this;
	            self._spread = {version: ('11.2.2')};
	            self._normalStyleInfo = keyword_null;
	            self._defaultExcelExtendedFormat = keyword_null;
	            self._cellStyleInfos = [];
	            self._dateTimeFormatter = [];
	            self._textFormatter = [];
	            self._builtInStyleNames = [];
	            self._builtInTableStylesCount = 0;
	            self._builtInValidatorStylesCount = 0;
	            self._normalStyleIndex = 0;
	            self._styleNames = [];
	            self._extendedFormats = [];
	            self._extendedFormatsIdCaches = {};
	            self._namedStylesExtendedFormats = {};
	            self._initStyle = true;
	            self._builtInStyles = keyword_null;
	            self._styles = [];
	            self._isDate1904 = false;
	            self._activePaneType = 3 ;
	            self._columnDataArray = [];
	            self._rowDataArray = [];
	            self._headingFont = 'Calibri Light';
	            self._bodyFont = 'Calibri';
	            self._dxfRecords = [];
	            self._rowInfos = [];
	            self._colInfos = [];
	            self._namedStylesNamesIndexImp = {};
	        }
	
	        ReaderDataModel.prototype._setTheme = function (theme) {
	            if (!theme) {
	                return;
	            }
	            var spreadJSTheme = {name: theme.name};
	            if (theme.colorScheme) {
	                var colorScheme = theme.colorScheme;
	                spreadJSTheme.themeColor = {
	                    name: colorScheme.name,
	                    text1: colorScheme.schemeColors[1 ],
	                    text2: colorScheme.schemeColors[3 ],
	                    background1: colorScheme.schemeColors[0 ],
	                    background2: colorScheme.schemeColors[2 ],
	                    accent1: colorScheme.schemeColors[4 ],
	                    accent2: colorScheme.schemeColors[5 ],
	                    accent3: colorScheme.schemeColors[6 ],
	                    accent4: colorScheme.schemeColors[7 ],
	                    accent5: colorScheme.schemeColors[8 ],
	                    accent6: colorScheme.schemeColors[9 ],
	                    hyperlink: colorScheme.schemeColors[10 ],
	                    followedHyperlink: colorScheme.schemeColors[11 ]
	                };
	            }
	            if (theme.fontScheme) {
	                var fontScheme = theme.fontScheme;
	                var majorRunFormattings = fontScheme.majorFont.runFormattings,
	                    minorRunFormattings = fontScheme.minorFont.runFormattings;
	                for (var i = 0, len = majorRunFormattings.length; i < len; i++) {
	                    var runFormatting = majorRunFormattings[i];
	                    if (runFormatting && runFormatting.fontLanguage === 0 ) {
	                        spreadJSTheme.headingFont = runFormatting.typeface;
	                        this._headingFont = runFormatting.typeface;
	                    }
	                }
	                for (i = 0, len = minorRunFormattings.length; i < len; i++) {
	                    runFormatting = minorRunFormattings[i];
	                    if (runFormatting && runFormatting.fontLanguage === 0 ) {
	                        spreadJSTheme.bodyFont = runFormatting.typeface;
	                        this._bodyFont = runFormatting.typeface;
	                    }
	                }
	            }
	            this._theme = spreadJSTheme;
	        };
	        ReaderDataModel.prototype._setExcelDefaultCellFormat = function (format) {
	            if (!format) {
	                return;
	            }
	            var self = this;
	            self._normalStyleInfo = ConverterHelper.toCellStyle(format, self._headingFont, self._bodyFont);
	            self._defaultExcelExtendedFormat = format;
	        };
	        ReaderDataModel.prototype._setExcelCellFormat = function (format, index) {
	            if (!format) {
	                return;
	            }
	            var self = this, spread = self._spread;
	            var styleInfo = ConverterHelper.toCellStyle(format, self._headingFont, self._bodyFont);
	            if (!isNullOrUndefined(styleInfo.formatter)) {
	               
	               
	               
	                var reg = new RegExp('\\[DBNum\\d+\\]', 'ig');
	                var dbNumArray;
	                var formatter = styleInfo.formatter;
	                while ((dbNumArray = reg.exec(styleInfo.formatter)) !== null) {
	                    var dbStr = dbNumArray[0];
	                    var numType = parseInt(dbStr.substring(dbStr.indexOf('m') + 1, dbStr.indexOf(']')));
	                    if (numType > 3) {
	                        formatter = formatter.replace(dbStr, '[DBNum3]');
	                    }
	                }
	                styleInfo.formatter = formatter;
	            }
	            self._cellStyleInfos.push(styleInfo);
	            var formatCode = excelStyle.ExtendedNumberFormatHelper.getFormatCode(format);
	            self._dateTimeFormatter.push(DateTimeHelper._isDatesOrTimesNumberFormat(formatCode));
	            if (formatCode === '@') {
	                self._textFormatter.push(true);
	            } else {
	                self._textFormatter.push(false);
	            }
	            if (format.isStyleFormat) {
	                var styleIndex = self._getExtendedFormatIndex(index);
	                if (styleIndex === -1) {
	                    styleIndex = self._normalStyleIndex;
	                }
	                if (self._styleNames.length > styleIndex) {
	                    self._builtInStyleNames[self._builtInStyleNames.length] = self._styleNames[styleIndex];
	                } else {
	                    self._builtInStyleNames[self._builtInStyleNames.length] = '__builtInStyle' + self._builtInStyleNames.length;
	                }
	            } else {
	                var name = '';
	                if (format.parentFormatID !== keyword_undefined && self._builtInStyleNames.length > format.parentFormatID) {
	                    name = self._builtInStyleNames[format.parentFormatID];
	                }
	                if (name === CONST_NORMAL || name.substring(0, 14) === '__builtInStyle' || StringEx._isNullOrEmpty(name)) {
	                    name = '__builtInStyle' + self._builtInStyleNames.length;
	                }
	                styleInfo.name = name;
	                var namedStyleExtendedFormat;
	                if (!(name.substring(0, 14) === '__builtInStyle') && (namedStyleExtendedFormat = self._namedStylesExtendedFormats[name]) !== keyword_undefined && !format.equals(namedStyleExtendedFormat)) {
	                    styleInfo.parentName = name;
	                    name = '__builtInStyle' + self._builtInStyleNames.length;
	                    styleInfo.name = name;
	                }
	                if (!spread.namedStyles) {
	                    spread.namedStyles = [];
	                }
	                StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, styleInfo);
	                self._builtInStyleNames[self._builtInStyleNames.length] = name;
	            }
	        };
	        ReaderDataModel.prototype._getExtendedFormatIndex = function (index) {
	            return this._extendedFormatsIdCaches[index] ? this._extendedFormatsIdCaches[index] : -1;
	        };
	        ReaderDataModel.prototype._setExcelStyle = function (style, id) {
	            if (!style) {
	                return;
	            }
	            var self = this, spread = self._spread;
	            if (self._initStyle) {
	                self._initExcelDefaultBuiltInStyles();
	                self._initStyle = false;
	            }
	            var styleName = style.name, buildInStyles = self._builtInStyles;
	            if (buildInStyles && style.isBuiltInStyle()) {
	                for (var i = 0, len = buildInStyles.length; i < len; i++) {
	                    var item = buildInStyles[i];
	                    if (item.builtInStyle === style.builtInStyle) {
	                        styleName = item.name;
	                        break;
	                    }
	                }
	            }
	            if (!StyleHelper._findName(self._namedStylesNamesIndexImp, styleName)) {
	                self._namedStylesExtendedFormats[styleName] = style.format();
	                self._styles.push(style);
	                self._extendedFormats.push(style.format());
	                self._extendedFormatsIdCaches[id] = self._extendedFormats.length - 1;
	                self._styleNames.push(styleName);
	                if (!spread.namedStyles) {
	                    spread.namedStyles = [];
	                }
	                var namedStyle = ConverterHelper.toCellStyle(style.format(), self._headingFont, self._bodyFont);
	                namedStyle.name = styleName;
	                StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, namedStyle);
	            } else {
	                for (i = 0, len = self._styles.length; i < len; i++) {
	                    var st = self._styles[i];
	                    if (st.name === styleName) {
	                        self._styles[i] = style;
	                        self._extendedFormats[i] = style.format();
	                        self._extendedFormatsIdCaches[id] = i;
	                        break;
	                    }
	                }
	                self._namedStylesExtendedFormats[styleName] = style.format();
	                namedStyle = ConverterHelper.toCellStyle(style.format(), self._headingFont, self._bodyFont);
	                namedStyle.name = styleName;
	                StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, namedStyle);
	            }
	        };
	        ReaderDataModel.prototype._initExcelDefaultBuiltInStyles = function () {
	            var self = this, spread = self._spread;
	            if (self._initStyle) {
	                if (!spread.namedStyles) {
	                    spread.namedStyles = [];
	                }
	                self._builtInStyles = excelStyle.BuiltInExcelStyles.getBuiltInStyles();
	                for (var i = 0, len = self._builtInStyles.length; i < len; i++) {
	                    var item = self._builtInStyles[i];
	                    if (item && item.name === CONST_NORMAL) {
	                        self._normalStyleIndex = self._extendedFormats.length;
	                    }
	                    self._styles.push(item);
	                    self._extendedFormats.push(item.format());
	                    self._styleNames.push(item.name);
	                    self._namedStylesExtendedFormats[item.name] = item.format();
	                    var namedStyle = ConverterHelper.toCellStyle(item.format(), self._headingFont, self._bodyFont);
	                    namedStyle.name = item.name;
	                    StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, namedStyle);
	                }
	            }
	        };
	        ReaderDataModel.prototype._setExcelWorkbookProperty = function (workbookProperty) {
	            this._isDate1904 = workbookProperty;
	        };
	        ReaderDataModel.prototype._setScroll = function (showHorizontalScrollbar, showVerticalScrollbar) {
	            var spread = this._spread;
	            if (!showHorizontalScrollbar) {
	                spread.showHorizontalScrollbar = showHorizontalScrollbar;
	            }
	            if (!showVerticalScrollbar) {
	                spread.showVerticalScrollbar = showVerticalScrollbar;
	            }
	        };
	        ReaderDataModel.prototype._setTabs = function (showSheetTabs, activeTab, firstSheet, tabRatio) {
	            var spread = this._spread;
	            if (!showSheetTabs) {
	                spread.tabStripVisible = showSheetTabs;
	            }
	            spread.startSheetIndex = firstSheet;
	            spread.activeSheetIndex = activeTab;
	            spread.tabStripRatio = tabRatio / 1000;
	        };
	        ReaderDataModel.prototype._addSheet = function (name, index, hidden) {
	            var sheet = {}, spread = this._spread;
	            sheet.name = name;
	            sheet.index = index;
	            if (hidden === 1 || hidden === 2) {
	                sheet.visible = false;
	            }
	            sheet.allowCellOverflow = true;
	            sheet.theme = this._theme;
	            sheet.defaults = common._getSheetDefaults();
	            if (isNullOrUndefined(spread.sheetCount)) {
	                spread.sheetCount = 0;
	            }
	            spread.sheetCount++;
	            if (!spread.sheets) {
	                spread.sheets = {};
	            }
	            spread.sheets[name] = sheet;
	        };
	        ReaderDataModel.prototype._setCalculationProperty = function (isR1C1) {
	            if (isR1C1) {
	                var spread = this._spread;
	                spread.referenceStyle = 1;
	                if (spread.sheets) {
	                    for (var item in spread.sheets) {
	                        if (spread.sheets.hasOwnProperty(item)) {
	                            var sheet = spread.sheets[item];
	                            sheet.referenceStyle = 1;
	                            sheet.colHeaderAutoText = 1;
	                        }
	                    }
	                }
	            }
	        };
	        ReaderDataModel.prototype._setOutlineDirection = function (sheetName, summaryRight, summaryBelow) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (summaryBelow === false) {
	                if (!sheet.rowOutlines) {
	                    sheet.rowOutlines = {};
	                }
	                sheet.rowOutlines.direction = 0;
	            }
	            if (summaryRight === false) {
	                if (!sheet.columnOutlines) {
	                    sheet.columnOutlines = {};
	                }
	                sheet.columnOutlines.direction = 0;
	            }
	        };
	        ReaderDataModel.prototype._setSheetTabColor = function (sheetName, color) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (color !== ExcelColor.EmptyColor) {
	                if (color.isThemeColor()) {
	                    sheet.sheetTabColor = ColorHelper.getThemeColorName(color);
	                } else {
	                    sheet.sheetTabColor = ColorHelper.toRGBColor(color);
	                }
	            }
	        };
	        ReaderDataModel.prototype._setDimensions = function (sheetName, rowCount, columnCount) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.rowCount = rowCount;
	            sheet.columnCount = columnCount;
	        };
	        ReaderDataModel.prototype._setDisplayElements = function (sheetName, gridLineColor, showGridLine, showRowColHeaders, zoom) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!showRowColHeaders) {
	                sheet.rowHeaderVisible = showRowColHeaders;
	                sheet.colHeaderVisible = showRowColHeaders;
	            }
	            if (zoom !== 100) {
	                sheet.zoomFactor = zoom / 100;
	            }
	            if (gridLineColor && gridLineColor.isIndexedColor() && gridLineColor.value() === 64) {
	                gridLineColor = null;
	            }
	            if (gridLineColor !== null || !showGridLine) {
	                var gridline = {};
	                if (gridLineColor !== null) {
	                    gridline.color = ColorHelper.toRGBColor(gridLineColor).toString();
	                }
	                if (!showGridLine) {
	                    gridline.showVerticalGridline = showGridLine;
	                    gridline.showHorizontalGridline = showGridLine;
	                }
	                sheet.gridline = gridline;
	            }
	        };
	        ReaderDataModel.prototype._setSelection = function (sheetName, paneType, rowActive, columnActive, refCount, rowFirst, rowLast, colFirst, colLast) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (this._activePaneType === paneType) {
	                if (sheet.rowCount <= rowActive) {
	                    sheet.rowCount = rowActive + 1;
	                }
	                if (sheet.columnCount <= columnActive) {
	                    sheet.columnCount = columnActive + 1;
	                }
	                for (var i = 0, len = rowFirst.length; i < len; i++) {
	                    var firstRow = rowFirst[i], lastRow = rowLast[i], firstCol = colFirst[i], lastCol = colLast[i];
	                    if (lastRow === -1) {
	                        lastRow = sheet.rowCount - 1;
	                    }
	                    if (lastCol === -1) {
	                        lastCol = sheet.columnCount - 1;
	                    }
	                    firstRow = firstRow >= 0 ? firstRow : 0;
	                    lastRow = lastRow >= 0 ? lastRow : 0;
	                    firstCol = firstCol >= 0 ? firstCol : 0;
	                    lastCol = lastCol >= 0 ? lastCol : 0;
	                    if (firstRow < sheet.rowCount && firstCol < sheet.columnCount) {
	                        var rowCount = Math.min(sheet.rowCount - firstRow, lastRow - firstRow + 1);
	                        var columnCount = Math.min(sheet.columnCount - firstCol, lastCol - firstCol + 1);
	                        if (rowCount >= 1 && columnCount >= 1) {
	                           
	                           
	                            sheet.selections = sheet.selections || {};
	                            sheet.selections[i] = {
	                                row: firstRow,
	                                rowCount: rowCount,
	                                col: firstCol,
	                                colCount: columnCount
	                            };
	                        }
	                    }
	                }
	                if (sheet.selections) {
	                    sheet.selections.length = rowFirst.length;
	                }
	                sheet.activeRow = (rowActive >= 0 && rowActive < sheet.rowCount) ? rowActive : 0;
	                sheet.activeCol = (columnActive >= 0 && columnActive < sheet.columnCount) ? columnActive : 0;
	            }
	        };
	        ReaderDataModel.prototype._setPane = function (sheetName, xSplit, ySplit, isFrozen) {
	            if (isFrozen) {
	                var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	                var topLeftCell = this._sheetViewTopLeftCell;
	                var topVisibleRow = IndexHelper._getRowIndexInNumber(topLeftCell),
	                    topVisibleColumn = IndexHelper._getColumnIndexInNumber(topLeftCell);
	               
	               
	               
	                
	               
	               
	                if (ySplit) {
	                    var frozenRow = ySplit + topVisibleRow;
	                    if (sheet.rowCount <= frozenRow) {
	                        sheet.rowCount = frozenRow + 1;
	                    }
	                    sheet.frozenRowCount = frozenRow;
	                }
	                if (xSplit) {
	                    var frozenColumn = xSplit + topVisibleColumn;
	                    if (sheet.columnCount <= frozenColumn) {
	                        sheet.columnCount = frozenColumn + 1;
	                    }
	
	                    sheet.frozenColCount = frozenColumn;
	                }
	            }
	        };
	        ReaderDataModel.prototype._setDefaults = function (sheetName, defaultRowHeight, defaultColumnWidth) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.defaults = {
	                colHeaderRowHeight: 20,
	                rowHeaderColWidth: 40,
	                rowHeight: defaultRowHeight,
	                colWidth: defaultColumnWidth
	            };
	        };
	        ReaderDataModel.prototype._setDefaultRowHeight = function (sheetName, defaultRowHeight) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.defaults.rowHeight = UnitHelper.pointToPixel(defaultRowHeight);
	        };
	        ReaderDataModel.prototype._setDefaultColumnWidth = function (sheetName, baseColumnWidth, defaultColumnWidth) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var defaultWidth;
	            if (!isNaN(defaultColumnWidth)) {
	                defaultWidth = this._getColumnWidthInPixel(defaultColumnWidth);
	            } else {
	                defaultWidth = this._getDefaultColumnWidthInPixel(baseColumnWidth);
	            }
	            sheet.defaults.colWidth = defaultWidth;
	        };
	        ReaderDataModel.prototype._getDefaultColumnWidthInPixel = function (width) {
	            if (width === 0) {
	                return 0;
	            }
	            var defaultStyle = this._normalStyleInfo;
	            var maxDigitWidth = this.getMaxiumDigitWidth(defaultStyle.font);
	           
	            return Math.floor(width * maxDigitWidth + 5);
	        };
	        ReaderDataModel.prototype._getColumnWidthInPixel = function (width) {
	            if (width === 0.0) {
	                return 0;
	            }
	            var defaultStyle = this._normalStyleInfo;
	           
	            var maxDigitWidth = Math.round(this.getMaxiumDigitWidth(defaultStyle.font));
	            return Math.floor(((256 * width + Math.floor(128 / maxDigitWidth)) / 256) * maxDigitWidth);
	        };
	        ReaderDataModel.prototype.getMaxiumDigitWidth = function (font) {
	            if (this._maxiumDigitWidth === keyword_undefined) {
	                this._maxiumDigitWidth = UnitHelper.getMaxiumDigitWidth(font);
	            }
	            return this._maxiumDigitWidth;
	        };
	        ReaderDataModel.prototype._setMissedRowColumnCount = function (sheetName) {
	           
	           
	           
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (sheet.columnCount === keyword_undefined && self._lastReadColumn >= 0) {
	                sheet.columnCount = self._lastReadColumn;
	            }
	            if (sheet.rowCount === keyword_undefined && self._lastReadRow >= 0) {
	                sheet.rowCount = self._lastReadRow;
	            }
	        };
	        ReaderDataModel.prototype._setColumnInfo = function (sheetName, colFirst, colLast, formatIndex, width, hidden, outlineLevel, collapsed) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName],
	                summaryLeft = sheet.columnOutlines && sheet.columnOutlines.direction === 0, colInfos = this._colInfos;
	            var actualWidth = this._getColumnWidthInPixel(width, spread);
	            if (colLast === CalcHelper._maxColumnCount) {
	                colLast -= 1;
	            }
	            for (var column = colFirst; column <= colLast; column++) {
	                if (outlineLevel > 0 || collapsed) {
	                    if ((column + 2) > sheet.columnCount) {
	                        sheet.columnCount = column + 2;
	                    }
	                    if (!sheet.columnOutlines) {
	                        sheet.columnOutlines = {};
	                    }
	                    if (!sheet.columnOutlines.itemsData) {
	                        sheet.columnOutlines.itemsData = [];
	                    }
	                    var itemsData = sheet.columnOutlines.itemsData;
	                    var itemData = itemsData[itemsData.length - 1];
	                    if (itemData && column === itemData.index + itemData.count && itemData.info.level === outlineLevel - 1 && itemData.info.collapsed === collapsed) {
	                        itemData.count++;
	                    } else {
	                        itemsData.push({
	                            index: column,
	                            count: 1,
	                            info: {
	                                level: outlineLevel - 1,
	                                collapsed: collapsed
	                            }
	                        });
	                    }
	                }
	
	                if (sheet.columnOutlines && sheet.columnOutlines.itemsData) {
	                    var columnOutlinesItemsData = sheet.columnOutlines.itemsData;
	                    modifyOutlineCollapsed(columnOutlinesItemsData, column, outlineLevel, summaryLeft, hidden, colInfos[column - 1] && colInfos[column - 1].hidden);
	                }
	
	                if (actualWidth !== -1 || hidden) {
	                    if (!sheet.columns) {
	                        sheet.columns = [];
	                    }
	                    for (var c = sheet.columns.length; c < column; c++) {
	                        sheet.columns.push(keyword_null);
	                        colInfos.push(keyword_null);
	                    }
	                    var colInfo = {};
	                    if (actualWidth !== -1) {
	                        colInfo.size = actualWidth;
	                    }
	                    if (hidden) {
	                        colInfos.push({hidden: true});
	                        if (outlineLevel <= 0) {
	                            colInfo.visible = !hidden;
	                        }
	                    } else {
	                        colInfos.push(colInfo);
	                    }
	                    sheet.columns.push(colInfo);
	                }
	                if (formatIndex !== 1) {
	                    var styleName = this._builtInStyleNames[formatIndex];
	                    if (styleName !== keyword_undefined) {
	                        this._columnDataArray[column] = {style: styleName};
	                    } else if (formatIndex < this._cellStyleInfos.length) {
	                        this._columnDataArray[column] = {style: this._cellStyleInfos[formatIndex]};
	                    }
	                }
	            }
	        };
	        ReaderDataModel.prototype._setMergeCells = function (sheetName, startRow, endRow, startCol, endCol) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet.spans) {
	                sheet.spans = [];
	            }
	            if (endRow >= sheet.rowCount) {
	                endRow = sheet.rowCount - 1;
	            }
	            if (endCol >= sheet.columnCount) {
	                endCol = sheet.columnCount - 1;
	            }
	            sheet.spans.push(new Range(startRow, startCol, endRow - startRow + 1, endCol - startCol + 1));
	        };
	        ReaderDataModel.prototype._setProtect = function (sheetName, isProtect) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.isProtected = isProtect;
	        };
	        ReaderDataModel.prototype._setProtectionOptions = function (sheetName, protectionOptions) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.protectionOptions = sheet.protectionOptions || {};
	            for(var i = 0; i < protectionOptions.length; i++) {
	                var name = protectionOptions[i].name, value = protectionOptions[i].value;
	                var protectionOptionsName = toProtectionOptions[name];
	                sheet.protectionOptions[protectionOptionsName] = value;
	            }
	            if(!sheet.protectionOptions.allowEditObjects) {
	                sheet.protectionOptions.allowEditObjects = true;
	            }
	        };
	        ReaderDataModel.prototype._setSheetData = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet.data) {
	                sheet.data = {};
	            }
	            var data = sheet.data;
	            if (this._rowDataArray.length > 0) {
	                data.rowDataArray = this._rowDataArray;
	                this._rowDataArray = [];
	            }
	            if (this._columnDataArray.length > 0) {
	                data.columnDataArray = this._columnDataArray;
	                this._columnDataArray = [];
	            }
	            if (this._normalStyleInfo) {
	                data.defaultDataNode = {style: this._normalStyleInfo};
	            }
	            if (this._theme) {
	                sheet.theme = this._theme;
	            }
	            this._setMissedRowColumnCount(sheetName);
	        };
	        ReaderDataModel.prototype._setRowInfo = function (sheetName, rowIndex, formatIndex, height, outlineLevel, collapsed, hidden) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName],
	                summaryTop = sheet.rowOutlines && sheet.rowOutlines.direction === 0, rowInfos = this._rowInfos;
	            if (outlineLevel > 0 || collapsed) {
	                if ((rowIndex + 2) > sheet.rowCount) {
	                    sheet.rowCount = rowIndex + 2;
	                }
	                if (!sheet.rowOutlines) {
	                    sheet.rowOutlines = {};
	                }
	                if (!sheet.rowOutlines.itemsData) {
	                    sheet.rowOutlines.itemsData = [];
	                }
	                var itemsData = sheet.rowOutlines.itemsData;
	                var itemData = itemsData[itemsData.length - 1];
	                if (itemData && rowIndex === itemData.index + itemData.count && itemData.info.level === outlineLevel - 1 && itemData.info.collapsed === collapsed) {
	                    itemData.count++;
	                } else {
	                    itemsData.push({
	                        index: rowIndex,
	                        count: 1,
	                        info: {
	                            level: outlineLevel - 1,
	                            collapsed: collapsed
	                        }
	                    });
	                }
	            }
	            var preRowHidden = rowInfos[rowIndex - 1] && rowInfos[rowIndex - 1].hidden;
	            if (sheet.rowOutlines && sheet.rowOutlines.itemsData) {
	                modifyOutlineCollapsed(sheet.rowOutlines, rowIndex, outlineLevel, summaryTop, hidden, preRowHidden);
	            }
	            if (outlineLevel <= 0 && (rowIndex + 1) > sheet.rowCount) {
	                sheet.rowCount = rowIndex + 1;
	            }
	            if (formatIndex !== -1 && rowIndex < sheet.rowCount) {
	                var styleName = this._builtInStyleNames[formatIndex];
	                if (styleName !== keyword_undefined) {
	                    this._rowDataArray[rowIndex] = {style: styleName};
	                } else if (formatIndex < this._cellStyleInfos.length) {
	                    this._rowDataArray[rowIndex] = {style: this._cellStyleInfos[formatIndex]};
	                }
	            }
	            if (height !== -1 || hidden) {
	                if (!sheet.rows) {
	                    sheet.rows = [];
	                }
	                for (var r = sheet.rows.length; r < rowIndex; r++) {
	                    sheet.rows.push(keyword_null);
	                    rowInfos.push(keyword_null);
	                }
	                var rowInfo = {};
	                if (height !== -1) {
	                    rowInfo.size = Math.round(UnitHelper.pointToPixel(height));
	                }
	                if (hidden) {
	                    rowInfos.push({hidden: true});
	                    if (outlineLevel <= 0) {
	                        rowInfo.visible = !hidden;
	                    }
	                } else {
	                    rowInfos.push(rowInfo);
	                }
	                sheet.rows.push(rowInfo);
	            }
	        };
	        ReaderDataModel.prototype._initDataTable = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet.data) {
	                sheet.data = {};
	            }
	            var data = sheet.data;
	            if (!data.dataTable) {
	                data.dataTable = {};
	            }
	        };
	        ReaderDataModel.prototype._initRow = function (sheetName, rowIndex) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var dataTable = sheet.data.dataTable;
	            if (!dataTable[rowIndex]) {
	                dataTable[rowIndex] = {};
	            }
	        };
	        ReaderDataModel.prototype._setCellStyle = function (sheetName, rowIndex, columnIndex, formatIndex) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var row = sheet.data.dataTable[rowIndex];
	            if (!row[columnIndex]) {
	                row[columnIndex] = {};
	            }
	            var cell = row[columnIndex];
	            var styleName = self._builtInStyleNames[formatIndex];
	            if (styleName !== keyword_undefined) {
	                cell.style = styleName;
	            } else if (formatIndex < self._cellStyleInfos.length) {
	                cell.style = self._cellStyleInfos[formatIndex];
	            }
	        };
	        ReaderDataModel.prototype._setCell = function (sheetName, rowIndex, columnIndex, formatIndex, value, formula, arrayFormula) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var row = sheet.data.dataTable[rowIndex];
	            if (!row[columnIndex]) {
	                row[columnIndex] = {};
	            }
	            var cell = row[columnIndex];
	
	            if (formatIndex < self._dateTimeFormatter.length && self._dateTimeFormatter[formatIndex] && typeof value === 'number') {
	                value = self._convertToOADateString(value);
	            }
	            if (value !== undefined) {
	                cell.value = value;
	            }
	            if (formula !== undefined) {
	                cell.formula = formula;
	            }
	            if (arrayFormula) {
	                cell.arrayInfo = arrayFormula;
	            }
	        };
	        ReaderDataModel.prototype._convertToOADateString = function (value) {
	            if (this._isDate1904) {
	                value += 1462;
	            }
	            value = DateTimeHelper._fromExcelOADate(value);
	            if (value instanceof Date) {
	                value = DateTimeHelper._toOADate(value);
	            }
	            return DateTimeHelper._addOADateString(value);
	        };
	        ReaderDataModel.prototype._setColorPalette = function (palette) {
	            if (palette && palette.length > 0) {
	                ColorHelper.useCustomPalette = true;
	                var customPalette = {};
	                for (var i = 0, len = palette.length; i < len; i++) {
	                    customPalette[i] = ColorHelper.fromArgb(palette[i]);
	                }
	                ColorHelper.customPalette = customPalette;
	            }
	        };
	        ReaderDataModel.prototype._resetActivePaneType = function () {
	            this._activePaneType = 3 ;
	        };
	        ReaderDataModel.prototype._setActivePaneType = function (value) {
	            this._activePaneType = value;
	        };
	        ReaderDataModel.prototype._initDefinedNames = function () {
	            this._spread.names = [];
	            for (var sheetName in this._spread.sheets) {
	                if (this._spread.sheets.hasOwnProperty(sheetName)) {
	                    this._spread.sheets[sheetName].names = [];
	                }
	            }
	        };
	        ReaderDataModel.prototype._addDefinedName = function (name, formula, sheetIndex, comment) {
	            if (sheetIndex === -1) {
	                this._spread.names.push({name: name, formula: formula, row: 0, col: 0, comment: comment});
	            } else {
	                for (var sheetName in this._spread.sheets) {
	                    if (this._spread.sheets.hasOwnProperty(sheetName)) {
	                        var sheet = this._spread.sheets[sheetName];
	                        if (sheet.index === sheetIndex) {
	                            sheet.names.push({name: name, formula: formula, row: 0, col: 0, comment: comment});
	                        }
	                    }
	                }
	            }
	        };
	        ReaderDataModel.prototype._getExtStyleByDxfId = function (dxfId) {
	            var dxf = this._extDxfRecords[dxfId];
	            return convertDxfToStyle(dxf, this._headingFont, this._bodyFont);
	        };
	        ReaderDataModel.prototype._getStyleByDxfId = function (dxfId) {
	            var dxf = this._dxfRecords[dxfId];
	            return convertDxfToStyle(dxf, this._headingFont, this._bodyFont);
	        };
	
	        ReaderDataModel.prototype._addConditionalFormatting = function (sheetName, conditionalFormatting) {
	            var sheet = this._spread.sheets[sheetName];
	            if (!sheet.conditionalFormats) {
	                sheet.conditionalFormats = {rules: []};
	            }
	            for (var i = 0; i < conditionalFormatting.rules.length; i++) {
	                var rule = conditionalFormatting.rules[i];
	                if (!isNullOrUndefined(rule.dxfId) && rule.dxfId > -1) {
	                    var tempStyle = this._getStyleByDxfId(rule.dxfId);
	                   
	                   
	                   
	                    if(tempStyle.font && tempStyle.font.indexOf('normal normal') === 0) {
	                        delete tempStyle.font;
	                    }
	                    rule.style = tempStyle;
	                    delete rule.dxfId;
	                }
	                sheet.conditionalFormats.rules.push(rule);
	            }
	        };
	        ReaderDataModel.prototype._getConditionalFormatting = function (sheetName) {
	            return this._spread.sheets[sheetName].conditionalFormats;
	        };
	        ReaderDataModel.prototype._setComments = function (comments, sheetName) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.comments = comments.map(function (item) {
	                return convertFromExcelComment(sheet, item);
	            });
	        };
	        ReaderDataModel.prototype._addPictures = function (pictures, sheetName) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.floatingObjects = sheet.floatingObjects || [];
	            var floatingObjects = sheet.floatingObjects;
	            pictures.forEach(function (excelPicture) {
	                var picture = convertFromExcelPicture(sheet, excelPicture, floatingObjects);
	                picture.typeName = '1';
	                
	                floatingObjects.push(picture);
	            });
	        };
	        ReaderDataModel.prototype._addCharts = function (charts, sheetName) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.charts = sheet.charts || [];
	            charts.map(function (chartData) {
	                var chart = convertFromExcelChart(sheet, chartData);
	                sheet.charts.push(chart);
	            });
	        };
	        ReaderDataModel.prototype._setSparkLineGroups = function (sparklineGroups, sheetName) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.sparklineGroups = sparklineGroups;
	            for (var i = 0; i < sparklineGroups.length; i++) {
	                var sparklines = sparklineGroups[i].sparklines;
	                for (var j = 0; j < sparklines.length; j++) {
	                    if (sparklines[j].row >= sheet.rowCount) {
	                        sheet.rowCount = sparklines[j].row + 1;
	                    }
	                    if (sparklines[j].col >= sheet.columnCount) {
	                        sheet.columnCount = sparklines[j].col + 1;
	                    }
	                }
	            }
	
	        };
	        function isExsit(cache, styleName) {
	            return !!cache[styleName];
	        }
	
	        function resetStyleInfoOfCellInTableRange(readerDataModel, spread, dataTable, row, col, cache) {
	            var defaultStyle = readerDataModel._normalStyleInfo;
	            if (dataTable[row] && dataTable[row][col]) {
	                var styleInfo = dataTable[row][col].style;
	                if (styleInfo === null) {
	                    return;
	                }
	                var style = StyleHelper._getByName(spread.namedStyles, styleInfo);
	                var newStyle = processTableCell(style, defaultStyle);
	               
	               
	                newStyle.name = '__builtInTableStyle' + readerDataModel._builtInTableStylesCount + style.name;
	                StyleHelper._addToNamedStyles(spread.namedStyles, readerDataModel._namedStylesNamesIndexImp, newStyle);
	                readerDataModel._builtInTableStylesCount++;
	                dataTable[row][col].style = newStyle.name;
	                cache[styleInfo] = newStyle.name;
	            }
	        }
	
	        ReaderDataModel.prototype._setTables = function (tables, sheetName) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            sheet.tables = tables;
	            for (var i = 0; i < tables.length; i++) {
	                if (tables[i].row + tables[i].rowCount > sheet.rowCount) {
	                    sheet.rowCount = tables[i].row + tables[i].rowCount;
	                }
	                if (tables[i].col + tables[i].colCount > sheet.columnCount) {
	                    sheet.columnCount = tables[i].col + tables[i].colCount;
	                }
	                var dataTable = sheet.data && sheet.data.dataTable;
	                var table = tables[i];
	                var cache = {};
	                var tableEndRow = table.row + table.rowCount;
	                var tableEndCol = table.col + table.colCount;
	                for (var row = table.row; row < tableEndRow; row++) {
	                    for (var col = table.col; col < tableEndCol; col++) {
	                        if (dataTable[row] && dataTable[row][col]) {
	                            var buildInStyleName = dataTable[row][col].style;
	                            if (isExsit(cache, buildInStyleName)) {
	                                dataTable[row][col].style = cache[buildInStyleName];
	                            } else {
	                                resetStyleInfoOfCellInTableRange(self, spread, dataTable, row, col, cache);
	                            }
	                        }
	                    }
	                }
	            }
	        };
	        
	        ReaderDataModel.prototype._getRangeData = function (sheetName, range, column, dataLength) {
	            var sheet = this._spread.sheets[sheetName], dataTable, data = [], index = 0, temp;
	            if(sheet && sheet.data && sheet.data.dataTable) {
	                dataTable = sheet.data.dataTable;
	                if(dataTable) {
	                    while(dataLength > 0 && index < range.rowCount) {
	                        if(dataTable[range.row + index]) {
	                        temp = dataTable[range.row + index][column];
	                        if(!isNullOrUndefined(temp.value)) {
	                            data.push(temp.value);
	                            dataLength--;
	                        }
	                        }
	                        index++;
	                    }
	                }
	            }
	            return data;
	        };
	        ReaderDataModel.prototype._convertAutoFilterToJSON = function (autoFilter, sheetName) {
	            var self = this;
	            if (isNullOrUndefined(autoFilter) || isNullOrUndefined(autoFilter.range)) {
	                return;
	            }
	            var rowFilter = {};
	            rowFilter.filterItemMap = [];
	            rowFilter.filteredColumns = [];
	
	            var filterRange = autoFilter.range;
	            filterRange = new Range(filterRange.row + 1, filterRange.col, filterRange.rowCount - 1, filterRange.colCount);
	            rowFilter.range = filterRange;
	
	            autoFilter.filterColumns.forEach(function (filterColumn) {
	                var columnId = filterColumn.autoFilterColumnId + filterRange.col;
	                var filterConditions = [];
	                var colorFilter = filterColumn.colorFilter;
	                if (colorFilter) {
	                    filterConditions.push(createColorFilterCondition(colorFilter, self._dxfRecords[colorFilter.dxfId]));
	                }
	                var filters = filterColumn.filters;
	                if (filters) {
	                    filters.filter.forEach(function (filterItem) {
	                        filterConditions.push(createCondition(2 , 0 , filterItem, filters.blank));
	                    });
	                    filters.dateGroupItem.forEach(function (dateItem) {
	                            var dt = new Date(dateItem.year, dateItem.month - 1, dateItem.day, dateItem.hour, dateItem.minute, dateItem.second);
	                            filterConditions.push(createCondition(5 , 0 , dt, !filters.blank));
	                    });
	                }
	                if (filterColumn.customFilters) {
	                    filterConditions.push(createCustomFilterCondition(filterColumn.customFilters, self._getRangeData(sheetName, filterRange, columnId, 1)));//1 is data length
	                }
	                if (filterColumn.dynamicFilter) {
	                    filterConditions.push(createDynamicFilterCondition(filterColumn.dynamicFilter, filterRange, columnId));
	                }
	                if (filterColumn.top10Filter) {
	                    filterConditions.push(createTop10FilterCondition(filterColumn.top10Filter));
	                }
	                rowFilter.filteredColumns.push(columnId);
	                rowFilter.filterItemMap.push({index: columnId, conditions: filterConditions});
	            });
	            var sortInfo = autoFilter.sortInfo;
	            if (sortInfo && sortInfo.dxfId === keyword_undefined) {
	                rowFilter.sortInfo = sortInfo;
	            }else if(sortInfo && sortInfo.dxfId !== keyword_undefined) {
	                var color, isBackColor = autoFilter.sortInfo.isBackColor, fill = self._dxfRecords[sortInfo.dxfId] && self._dxfRecords[sortInfo.dxfId].fill;
	                if (fill) {
	                    if (fill.patternType === 0 ) {
	                        color = '';    
	                    } else {
	                        color = ColorHelper.toRGBColor(fill.foreColor);
	                    }
	                }
	
	                rowFilter.sortInfo = {
	                    ascending : sortInfo.ascending,
	                    index : sortInfo.index,
	                    isBackColor : isBackColor,
	                    color : color
	                };
	            }
	            return rowFilter;
	        };
	        ReaderDataModel.prototype._setAutoFilter = function (sheetName, autoFilter) {
	            if (!isNullOrUndefined(sheetName)) {
	                var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	                sheet.rowFilter = self._convertAutoFilterToJSON(autoFilter, sheetName);
	            }
	        };
	
	        function getTableName(tableId, tables) {
	            var tableName = null;
	            tables.forEach(function (table) {
	                if (table.id === tableId) {
	                    tableName = table.name;
	                }
	            });
	            return tableName;
	        }
	
	        function getTableColumnName(tableId, columnId, tables) {
	            var columnName = null;
	            tables.forEach(function (table) {
	                if (table.id === tableId) {
	                    table.columns.forEach(function (column) {
	                        if (column.id === columnId) {
	                            columnName = column.name;
	                        }
	                    });
	                }
	            });
	            return columnName;
	        }
	
	        ReaderDataModel.prototype._addSlicers = function (slicers, sheetName) {
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	
	            sheet.slicers = sheet.slicers || [];
	
	            var sheetSlicers = sheet.slicers;
	            var tables = [];
	            for (var name in spread.sheets) {
	                if (spread.sheets[name].tables) {
	                    tables = tables.concat(spread.sheets[name].tables);
	                }
	            }
	
	            slicers.forEach(function (slicer) {
	                slicer.tableName = getTableName(slicer.tableId, tables);
	                slicer.columnName = getTableColumnName(slicer.tableId, slicer.columnId, tables);
	                delete slicer.tableId;
	                delete slicer.columnId;
	
	                inflateWorksheetBySlicer(sheet, slicer);
	                sheetSlicers.push(slicer);
	            });
	        };
	
	       
	        function getDataValidationRangesAsString(ranges, separator) {
	            separator = separator || ' ';
	            return ranges.map(getDataValidationRangeString).join(separator);
	        }
	
	        function getDataValidationRangeString(range) {
	            var firstRow = range.row, firstCol = range.col;
	            var rowCount = range.rowCount, colCount = range.colCount;
	            var lastCol = firstCol + colCount - 1, lastRow = firstRow + rowCount - 1;
	            var rangeStr;
	
	            if (isRangeWholeRow(range) && isRangeWholeColumn(range)) {
	                rangeStr = "$1:$" + ExcelConstants._openXmlMaxRow;
	            } else if (isRangeWholeRow(range)) { 
	                rangeStr = (firstRow + 1) + ':' + (lastRow + 1);
	            } else if (isRangeWholeColumn(range)) { 
	                rangeStr = IndexHelper._getColumnIndexInA1Letter(firstCol) + ':' + IndexHelper._getColumnIndexInA1Letter(lastCol);
	            } else {
	                rangeStr = IndexHelper._getColumnIndexInA1Letter(firstCol) + (firstRow + 1);
	                if (rowCount > 1 || colCount > 1) {
	                    rangeStr += (':' + IndexHelper._getColumnIndexInA1Letter(lastCol) + (lastRow + 1));
	                }
	            }
	            return rangeStr;
	        }
	
	        ReaderDataModel.prototype._setDataValidation = function (sheetName, dataValidation) {
	            if (isNullOrUndefined(sheetName)) {
	                return;
	            }
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var validator = self._toDataValidator(dataValidation);
	            var validations = sheet.validations;
	            if (!validations) {
	                validations = sheet.validations = [];
	            }
	            validator.ranges = getDataValidationRangesAsString(dataValidation.ranges, ', ');
	            validations.push(validator);
	        };
	        ReaderDataModel.prototype._toDataValidator = function (dataValidation) {
	            if (isNullOrUndefined(dataValidation)) {
	                return keyword_null;
	            }
	
	            var criteriaType = dataValidation.type, cp = dataValidation.compareOperator;
	            var firstFormula = dataValidation.firstFormula;
	            var secondFormula = dataValidation.secondFormula;
	
	            var result = {type: criteriaType}, validatorInfo;
	            switch (criteriaType) {
	                case 0: 
	                    break;
	                case 1: 
	                case 2: 
	                case 6: 
	                    validatorInfo = {
	                        operator: cp,
	                        value1: addFormulaPrefixSymbol(firstFormula),
	                        value2: addFormulaPrefixSymbol(secondFormula)
	                    };
	                    break;
	                case 3: 
	                    var formula = firstFormula;
	                    if (isNullOrUndefined(formula)) {
	                        formula = secondFormula;
	                    }
	                    if (formula) {
	                        if (formula[0] === "\"" && formula[formula.length - 1] === "\"") {
	                            validatorInfo = {value: addStringPrefixSymbol(formula)};
	                        } else {
	                            validatorInfo = {formula: addFormulaPrefixSymbol(formula)};
	                        }
	                    }
	                    break;
	                case 4: 
	                case 5: 
	                    var temp;
	                    if (!isNullOrUndefined(firstFormula)) {
	                        temp = parseFloat(firstFormula);
	                        if (!isNaN(temp)) {
	                            firstFormula = this._convertToOADateString(temp);
	                        }
	                    }
	                    if (!isNullOrUndefined(secondFormula)) {
	                        temp = parseFloat(secondFormula);
	                        if (!isNaN(temp)) {
	                            secondFormula = this._convertToOADateString(temp);
	                        }
	                    }
	                    validatorInfo = {
	                        operator: cp,
	                        value1: firstFormula && firstFormula.indexOf('/OADate(') !== -1 ? firstFormula : addFormulaPrefixSymbol(firstFormula),
	                        value2: secondFormula && secondFormula.indexOf('/OADate(') !== -1 ? secondFormula : addFormulaPrefixSymbol(secondFormula)
	                    };
	                    break;
	                case 7: 
	                    validatorInfo = {formula: addFormulaPrefixSymbol(firstFormula)};
	                    break;
	                default:
	                    break;
	            }
	            if (validatorInfo) {
	                result.validatorInfo = validatorInfo;
	            }
	            if (result !== keyword_null) {
	                result.errorStyle = dataValidation.errorType;
	                result.errorMessage = dataValidation.error;
	                result.errorTitle = dataValidation.errorTitle;
	                result.ignoreBlank = dataValidation.allowBlank;
	                result.inCellDropdown = dataValidation.showPromptBox;
	                result.inputMessage = dataValidation.prompt;
	                result.inputTitle = dataValidation.promptTitle;
	                result.showErrorMessage = dataValidation.showErrorMessage;
	                result.showInputMessage = dataValidation.showInputMessage;
	            }
	            return result;
	        };
	        ReaderDataModel.prototype._setPrintPageMargin = function (sheetName, printMargin) {
	            function getPageMarginInSpread(margin) {
	                margin = margin || 0;
	                return parseInt(Math.round(margin * 100));
	            }
	
	            if (isNullOrUndefined(sheetName)) {
	                return;
	            }
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet.printInfo) {
	                sheet.printInfo = {};
	            }
	            var printInfo = sheet.printInfo;
	            printInfo.margin = {
	                top: getPageMarginInSpread(printMargin.top),
	                bottom: getPageMarginInSpread(printMargin.bottom),
	                left: getPageMarginInSpread(printMargin.left),
	                right: getPageMarginInSpread(printMargin.right),
	                header: getPageMarginInSpread(printMargin.header),
	                footer: getPageMarginInSpread(printMargin.footer)
	            };
	        };
	        ReaderDataModel.prototype._setPrintOption = function (sheetName, printOption) {
	            if (isNullOrUndefined(sheetName)) {
	                return;
	            }
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet.printInfo) {
	                sheet.printInfo = {};
	            }
	            var printInfo = sheet.printInfo;
	            printInfo.showGridLine = printOption.printGridLine;
	            var horizontalCentered = printOption.horizontalCentered, verticalCentered = printOption.verticalCentered;
	            var centering = 0 ;
	            if (horizontalCentered && verticalCentered) {
	                centering = 3 ;
	            } else if (horizontalCentered) {
	                centering = 1 ;
	            } else if (verticalCentered) {
	                centering = 2 ;
	            }
	            printInfo.centering = centering;
	            var headerVisibility = printOption.printRowColumnsHeaders ? 2  : 1 ;
	            printInfo.showColumnHeader = headerVisibility;
	            printInfo.showRowHeader = headerVisibility;
	        };
	        ReaderDataModel.prototype._setRowPageBreak = function (sheet, row, value) {
	            if (!sheet.rows) {
	                sheet.rows = [];
	            }
	            var info = sheet.rows[row];
	            if (info) {
	                info.pageBreak = value;
	            } else {
	                sheet.rows[row] = {pageBreak: value};
	            }
	        };
	        ReaderDataModel.prototype._setColumnPageBreak = function (sheet, column, value) {
	            if (!sheet.columns) {
	                sheet.columns = [];
	            }
	            var info = sheet.columns[column];
	            if (info) {
	                info.pageBreak = value;
	            } else {
	                sheet.columns[column] = {pageBreak: value};
	            }
	        };
	        ReaderDataModel.prototype._setPrintPageSetting = function (sheetName, pageSetting) {
	            function parseExcelPrintHeader(header) {
	                if (header === keyword_undefined) {
	                    return keyword_null;
	                }
	                var result = ['', '', ''];
	                if (header === keyword_null || header === '') {
	                    return result;
	                }
	                var i = 0;
	                var area = 1;
	                var headerLength = header.length;
	                while (i < headerLength) {
	                    if (i < headerLength - 1) {
	                        var flag = header.substr(i, 2);
	                        if (flag === "&L") {
	                            area = 0;
	                            i += 2;
	                            continue;
	                        } else if (flag === "&C") {
	                            area = 1;
	                            i += 2;
	                            continue;
	                        } else if (flag === "&R") {
	                            area = 2;
	                            i += 2;
	                            continue;
	                        }
	                    }
	                    result[area] = result[area].concat(header[i]);
	                    i++;
	                }
	                return result;
	            }
	
	            if (isNullOrUndefined(sheetName)) {
	                return;
	            }
	            var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet.printInfo) {
	                sheet.printInfo = {};
	            }
	            var printInfo = sheet.printInfo;
	
	            var paperKind = pageSetting.paperSizeIndex;
	            if (paperKind !== 0 ) {
	                printInfo.paperSize = {kind: paperKind};
	            }
	            if (pageSetting.useCustomStartingPage) {
	                printInfo.firstPageNumber = pageSetting.firstPageNumber;
	            }
	            if (!isNullOrUndefined(pageSetting.showColor)) {
	                printInfo.blackAndWhite = !pageSetting.showColor;
	            }
	            printInfo.orientation = pageSetting.orientation === 1  ? 1  : 2 ;
	            printInfo.pageOrder = pageSetting.pageOrder === 2  ? 2  : 1 ;
	            if (pageSetting.zoomFactor > 0) {
	                printInfo.zoomFactor = pageSetting.zoomFactor;
	            }
	            if (pageSetting.useSmartPrint) {
	                if (pageSetting.smartPrintPagesWidth >= 1) {
	                    printInfo.fitPagesWide = pageSetting.smartPrintPagesWidth;
	                }
	                if (pageSetting.smartPrintPagesHeight >= 1) {
	                    printInfo.fitPagesTall = pageSetting.smartPrintPagesHeight;
	                }
	            }
	
	            var advancedHeadFooterSetting = pageSetting.advancedHeadFooterSetting;
	            if (advancedHeadFooterSetting) {
	                var oddHeaders = parseExcelPrintHeader(advancedHeadFooterSetting.headerOddPage);
	                if (oddHeaders) {
	                    printInfo.headerLeft = oddHeaders[0];
	                    printInfo.headerCenter = oddHeaders[1];
	                    printInfo.headerRight = oddHeaders[2];
	                }
	
	                var oddFooters = parseExcelPrintHeader(advancedHeadFooterSetting.footerOddPage);
	                if (oddFooters) {
	                    printInfo.footerLeft = oddFooters[0];
	                    printInfo.footerCenter = oddFooters[1];
	                    printInfo.footerRight = oddFooters[2];
	                }
	
	                if (advancedHeadFooterSetting.headerLeftImage) {
	                    printInfo.headerLeftImage = advancedHeadFooterSetting.headerLeftImage;
	                }
	                if (advancedHeadFooterSetting.headerCenterImage) {
	                    printInfo.headerCenterImage = advancedHeadFooterSetting.headerCenterImage;
	                }
	                if (advancedHeadFooterSetting.headerRightImage) {
	                    printInfo.headerRightImage = advancedHeadFooterSetting.headerRightImage;
	                }
	                if (advancedHeadFooterSetting.footerLeftImage) {
	                    printInfo.footerLeftImage = advancedHeadFooterSetting.footerLeftImage;
	                }
	                if (advancedHeadFooterSetting.footerCenterImage) {
	                    printInfo.footerCenterImage = advancedHeadFooterSetting.footerCenterImage;
	                }
	                if (advancedHeadFooterSetting.footerRightImage) {
	                    printInfo.footerRightImage = advancedHeadFooterSetting.footerRightImage;
	                }
	            }
	
	            var rowBreakLines = pageSetting.rowBreakLines;
	            if (rowBreakLines && rowBreakLines.length > 0) {
	                rowBreakLines.forEach(function (rowIndex) {
	                    self._setRowPageBreak(sheet, rowIndex, true);
	                });
	            }
	            var columnBreakLines = pageSetting.columnBreakLines;
	            if (columnBreakLines && columnBreakLines.length > 0) {
	                columnBreakLines.forEach(function (columnIndex) {
	                    self._setColumnPageBreak(sheet, columnIndex, true);
	                });
	            }
	
	           
	           
	           
	           
	        };
	        ReaderDataModel.prototype._setPrintArea = function (sheetIndex, formula) {
	            if (sheetIndex < 0) {
	                return;
	            }
	            var self = this;
	            var sheet = self._getSheetByIndex(sheetIndex);
	            if (!sheet.printInfo) {
	                sheet.printInfo = {};
	            }
	            var ranges = getRangesFromString(formula);
	            if (ranges.length === 1) {
	                var range = ranges[0];
	                if (range.row > -1) {
	                    sheet.printInfo.rowStart = range.row;
	                }
	                if (range.rowCount > 0) {
	                    sheet.printInfo.rowEnd = range.row + range.rowCount - 1;
	                }
	                if (range.col > -1) {
	                    sheet.printInfo.columnStart = range.col;
	                }
	                if (range.colCount > 0) {
	                    sheet.printInfo.columnEnd = range.col + range.colCount - 1;
	                }
	            }
	        };
	        ReaderDataModel.prototype._setPrintTitles = function (sheetIndex, formula) {
	            if (sheetIndex < 0) {
	                return;
	            }
	            var self = this;
	            var sheet = self._getSheetByIndex(sheetIndex);
	            if (!sheet.printInfo) {
	                sheet.printInfo = {};
	            }
	            var ranges = getRangesFromString(formula.replace(',', ' '));
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                if (isRangeWholeRow(range)) {
	                    sheet.printInfo.repeatRowStart = range.row;
	                    sheet.printInfo.repeatRowEnd = range.row + range.rowCount - 1;
	                } else if (isRangeWholeColumn(range)) {
	                    sheet.printInfo.repeatColumnStart = range.col;
	                    sheet.printInfo.repeatColumnEnd = range.col + range.colCount - 1;
	                }
	            }
	
	        };
	        ReaderDataModel.prototype._getSheetByIndex = function (index) {
	            var sheets = this._spread.sheets;
	            for (var sheetName in sheets) {
	                if (sheets.hasOwnProperty(sheetName)) {
	                    var sheet = sheets[sheetName];
	                    if (sheet.index === index) {
	                        return sheet;
	                    }
	                }
	            }
	            return keyword_undefined;
	        };
	        return ReaderDataModel;
	    })();
	    module.exports = ReaderDataModel;
	
	
	}());

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var excelStyle = __webpack_require__(12);
	    var Charts = __webpack_require__(24);
	    
	    var ColorHelper = excelStyle.ColorHelper;
	    var UnitHelper = excelStyle.UnitHelper;
	    var ExcelColor = excelStyle.ExcelColor;
	    
	    var StringEx = common._StringEx;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var keyword_null = null;
	    
	    var ArrayFind = [].find;
	    
	    
	    function getActualColumnWidth(sheet, beginColumn, endColumn) {
	        var defaultColumnWidth = sheet.defaults.colWidth;
	    
	        var columns = sheet.columns, width = 0;
	        var defaultWidth = !columns ? defaultColumnWidth : keyword_null;
	    
	        for (var c = beginColumn; c < endColumn; c++) {
	            width += defaultWidth || getColumnWidth(columns, c, defaultColumnWidth);
	        }
	    
	        return width;
	    }
	    
	   
	    function getColumnWidth(columns, index, defaultColumnWidth) {
	        var item = columns[index];
	        if (item) {
	            return item.visible === false ? 0 : item.size;
	        }
	        return defaultColumnWidth;
	    }
	    
	    function getActualRowHeight(sheet, beginRow, endRow) {
	        var defaultRowHeight = sheet.defaults.rowHeight;
	    
	        var rows = sheet.rows, height = 0;
	        var defaultHeight = !rows ? defaultRowHeight : keyword_null;
	    
	        for (var r = beginRow; r < endRow; r++) {
	            height += defaultHeight || getRowHeight(rows, r, defaultRowHeight);
	        }
	    
	        return height;
	    }
	    
	   
	    function getRowHeight(rows, index, defaultRowHeight) {
	        var item = rows[index];
	        if (item) {
	            return item.visible === false ? 0 : item.size;
	        }
	        return defaultRowHeight;
	    }
	    
	    function getColumnAnchor(sheet, width) {
	        var defaultColumnWidth = sheet.defaults.colWidth;
	    
	        var columns = sheet.columnVisibleInfo, totalWidth = 0, c = 0, last;
	        var defaultWidth = !columns ? defaultColumnWidth : keyword_null;
	    
	        while (totalWidth < width) {
	            last = defaultWidth || getColumnWidth(columns, c, defaultColumnWidth);
	            totalWidth += last;
	            c++;
	        }
	    
	        var offset = totalWidth - width;
	        if (offset > 0) {
	            c--;
	            offset = last - offset;
	        }
	    
	        return {col: c, colOffset: offset};
	    }
	    
	    function getRowAnchor(sheet, height) {
	        var defaultRowHeight = sheet.defaults.rowHeight;
	    
	        var rows = sheet.rowsVisibleInfo, totalHeight = 0, r = 0, last;
	        var defaultHeight = !rows ? defaultRowHeight : keyword_null;
	    
	        while (totalHeight < height) {
	            last = defaultHeight || getRowHeight(rows, r, defaultRowHeight);
	            totalHeight += last;
	            r++;
	        }
	        var offset = totalHeight - height;
	        if (offset > 0) {
	            r--;
	            offset = last - offset;
	        }
	    
	        return {row: r, rowOffset: offset};
	    }
	    
	    function getAnchor(sheet, rect) {
	        var x = rect.x, y = rect.y;
	    
	        var startPoint = {}, endPoint = {}, anchor;
	    
	        anchor = getRowAnchor(sheet, y);
	        copyProperties(anchor, startPoint, ['row', 'rowOffset']);
	        anchor = getColumnAnchor(sheet, x);
	        copyProperties(anchor, startPoint, ['col', 'colOffset']);
	    
	        anchor = getRowAnchor(sheet, y + rect.height);
	        copyProperties(anchor, endPoint, ['row', 'rowOffset']);
	        anchor = getColumnAnchor(sheet, x + rect.width);
	        copyProperties(anchor, endPoint, ['col', 'colOffset']);
	    
	        return {startPoint: startPoint, endPoint: endPoint};
	    }
	    
	    
	    
	    var commentHostMargin = 7;
	    
	    function copyProperties(src, dest, props) {
	        props.forEach(function (prop) {
	            if (src[prop] !== undefined) {
	                dest[prop] = src[prop];
	            }
	        });
	    }
	    
	    function convertFromExcelComment(sheet, excelComment) {
	        var comment = {};
	    
	        copyProperties(excelComment, comment, [
	            'fontSize', 'fontStyle', 'fontFamily', 'fontWeight', 'textDecoration', 'text',
	            'autoSize', 'dynamicMove', 'dynamicSize', 'locked', 'lockText', 'displayMode'
	        ]);
	    
	        var beginRow = sheet.forzenRowCount || 0,
	            beginColumn = sheet.forzenColumnCount || 0,
	            row = excelComment.row, col = excelComment.col,
	            anchor = excelComment.anchor ;
	    
	        var topRightX = getActualColumnWidth(sheet, beginColumn, col + 1),
	            topRightY = getActualRowHeight(sheet, beginRow, row);
	    
	        comment.rowIndex = row - beginRow;
	        comment.colIndex = col - beginColumn;
	    
	        if (anchor) {
	            var startX = getActualColumnWidth(sheet, beginColumn, anchor[0]) + anchor[1] - commentHostMargin,
	                startY = getActualRowHeight(sheet, beginRow, anchor[2]) + anchor[3] - commentHostMargin,
	                endX = getActualColumnWidth(sheet, beginColumn, anchor[4]) + anchor[5] + commentHostMargin,
	                endY = getActualRowHeight(sheet, beginRow, anchor[6]) + anchor[7] + commentHostMargin;
	    
	            comment.location = {
	                x: startX - topRightX,
	                y: startY - topRightY
	            };
	            comment.width = endX - startX;
	            comment.height = endY - startY;
	            inflateWorksheetByComment(sheet, anchor);
	        } else {
	            comment.location = {
	                x: UnitHelper.pointToPixel(excelComment.marginLeft) - topRightX - commentHostMargin,
	                y: UnitHelper.pointToPixel(excelComment.marginTop) - topRightY - commentHostMargin
	            };
	            comment.width = pointToPixel(excelComment.width) + 2 * commentHostMargin;
	            comment.height = pointToPixel(excelComment.height) + 2 * commentHostMargin;
	            inflateWorksheetByComment(sheet, keyword_null, {
	                x: comment.location.x + topRightX,
	                y: comment.location.y + topRightY,
	                width: comment.width,
	                height: comment.height
	            });
	        }
	    
	        var color = excelComment.foreColor;
	        if (color && color !== ExcelColor.EmptyColor) {
	            comment.foreColor = ColorHelper.toRGBColor(color);
	        }
	        color = excelComment.backColor;
	        if (color) {
	            comment.backColor = color.split(' ')[0];
	        }
	        color = excelComment.borderColor;
	        if (color) {
	            comment.borderColor = color.split(' ')[0];
	        }
	    
	        var borderWidth = excelComment.borderWidth;
	        if (borderWidth) {
	            comment.borderWidth = pointToPixel(borderWidth);
	        }
	        comment.borderStyle = excelBorderStyleToWebBorderStyle(excelComment.dashStyle, excelComment.lineStyle);
	        var value = excelComment.zIndex;
	        if (!isNullOrUndefined(value)) {
	            comment.zIndex = value;
	        }
	        value = excelComment.opacity;
	        if (!isNullOrUndefined(value)) {
	            comment.opacity = value;
	        }
	        if (excelComment.autoSize) {
	            comment.autoSize = true;
	        }
	        comment.locked = excelComment.locked !== false;
	        comment.lockText = excelComment.lockText !== false;
	        comment.dynamicSize = excelComment.dynamicSize !== false;
	        comment.dynamicMove = excelComment.dynamicMove !== false;
	    
	        value = excelComment.inset;
	        if (value) {
	            var padding = [0, 0, 0, 0];
	            value.trim().split(',').forEach(function (item, index) {
	                var paddingValue = item || ['0.1in', '0.05in'][index % 2];
	                padding[index] = convertToPixel(paddingValue);
	            });
	            comment.padding = {
	                left: padding[0],
	                top: padding[1],
	                right: padding[2],
	                bottom: padding[3]
	            };
	        }
	    
	        var hAlign = ['left', 'center', 'right'].indexOf(excelComment.hAlign);
	        if (hAlign !== -1) {
	            comment.horizontalAlign = hAlign;
	        }
	    
	        return comment;
	    }
	    
	    function convertToExcelComment(sheet, comment) {
	        var row = comment.rowIndex, col = comment.colIndex,
	            location = comment.location || {x: 9, y: -18},
	            excelComment = {row: row, col: col};
	    
	        if (isNullOrUndefined(comment.width)) {
	            comment.width = 160;
	        }
	    
	        if (isNullOrUndefined(comment.height)) {
	            comment.height = 100;
	        }
	    
	        comment.fontFamily = comment.fontFamily || 'Arial';
	        comment.borderColor = comment.borderColor || 'black';
	        comment.backColor = comment.backColor || '#FFFFE1';
	    
	        copyProperties(comment, excelComment, [
	            'zIndex', 'opacity', 'fontStyle', 'fontFamily', 'fontWeight', 'textDecoration', 'text',
	            'autoSize', 'dynamicMove', 'dynamicSize', 'locked', 'lockText', 'displayMode', 'backColor', 'borderColor'
	        ]);
	    
	        var topRightX = getActualColumnWidth(sheet, 0, col + 1);
	        var topRightY = getActualRowHeight(sheet, 0, row);
	    
	        excelComment.marginLeft = UnitHelper.pixelToPoint(topRightX + location.x + commentHostMargin);
	        excelComment.marginTop = UnitHelper.pixelToPoint(topRightY + location.y + commentHostMargin);
	        excelComment.width = UnitHelper.pixelToPoint(comment.width - 2 * commentHostMargin) + 'pt';
	        excelComment.height = UnitHelper.pixelToPoint(comment.height - 2 * commentHostMargin) + 'pt';
	    
	        var fontSize = comment.fontSize || '9pt';
	       
	        if (fontSize.indexOf('px') !== -1) {
	            excelComment.fontSize = UnitHelper.pixelToPoint(parseFloat(fontSize));
	        } else {
	            excelComment.fontSize = fontSize.replace('pt', '');
	        }
	    
	        var foreColor = comment.foreColor;
	        excelComment.foreColor = foreColor && ColorHelper.toExcelColor(foreColor);
	    
	        excelComment.borderWidth = UnitHelper.pixelToPoint(comment.borderWidth || 1) + 'pt';
	    
	        var borderStyle = webBorderStyleToExcelBorderStyle(comment.borderStyle);
	        excelComment.dashStyle = borderStyle.dashStyle;
	        excelComment.lineStyle = borderStyle.lineStyle;
	    
	        var padding = comment.padding;
	        if (padding) {
	            excelComment.inset = [
	                UnitHelper.pixelToPoint(padding.left) + 'pt',
	                UnitHelper.pixelToPoint(padding.top) + 'pt',
	                UnitHelper.pixelToPoint(padding.right) + 'pt',
	                UnitHelper.pixelToPoint(padding.bottom) + 'pt'
	            ].join(',');
	        }
	    
	        excelComment.hAlign = ['Left', 'Center', 'Right'][comment.horizontalAlign || 0] || 'Left';
	    
	        excelComment.visibility = comment.displayMode === 1 ? 'visible' : 'hidden';
	    
	        return excelComment;
	    }
	    
	    function pointToPixel(value) {
	        if (value) {
	            return UnitHelper.pointToPixel(parseFloat(value.replace('pt', '')));
	        }
	        return 0;
	    }
	    
	    function convertToPixel(value) {
	       
	        var point = 0;
	        if (value.indexOf('in') !== -1) {
	            point = parseFloat(value.replace('in', '').trim()) * 72;
	        } else if (value.indexOf('cm') !== -1) {
	            point = parseFloat(value.replace('cm', '').trim()) * 72 / 2.54;
	        } else if (value.indexOf('mm') !== -1) {
	            point = parseFloat(value.replace('mm', '').trim()) * 72 / 25.4;
	        } else if (value.indexOf('pt') !== -1) {
	            point = parseFloat(value.replace('pt', '').trim());
	        }
	        return UnitHelper.pointToPixel(point);
	    }
	    
	    function excelBorderStyleToWebBorderStyle(dashStyle, lineStyle) {
	        if (!StringEx._isNullOrEmpty(lineStyle)) {
	            return 'double';
	        }
	    
	        if (dashStyle) {
	            switch (dashStyle.toLowerCase()) {
	                case 'solid':
	                    return 'solid';
	                case '1 1':
	                    return 'dotted';
	                case 'dash':
	                case 'dashdot':
	                case 'longdash':
	                case 'longdashdot':
	                case 'longdashdotdot':
	                    return 'dashed';
	            }
	        }
	    
	        return 'solid';
	    }
	    
	    function webBorderStyleToExcelBorderStyle(borderStyle) {
	        var dashStyle, lineStyle;
	    
	        if (borderStyle) {
	            switch (borderStyle.toLowerCase()) {
	                case "solid":
	                    dashStyle = "solid";
	                    break;
	                case "dotted":
	                    dashStyle = "1 1";
	                    break;
	                case "dashed":
	                    dashStyle = "dash";
	                    break;
	                case "double":
	                    lineStyle = "thinThin";
	                    break;
	            }
	        }
	    
	        return {dashStyle: dashStyle, lineStyle: lineStyle};
	    }
	    
	    
	    
	    function convertFloatingObjectAnchor(twoCellAnchor, floatingObject) {
	        if (twoCellAnchor) {
	            var startPoint = twoCellAnchor.startPoint,
	                endPoint = twoCellAnchor.endPoint;
	
	            floatingObject.startRow = startPoint.row;
	            floatingObject.startRowOffset = startPoint.rowOffset;
	            floatingObject.startColumn = startPoint.col;
	            floatingObject.startColumnOffset = startPoint.colOffset;
	
	            floatingObject.endRow = endPoint.row;
	            floatingObject.endRowOffset = endPoint.rowOffset;
	            floatingObject.endColumn = endPoint.col;
	            floatingObject.endColumnOffset = endPoint.colOffset;
	        }
	    }
	
	    function convertFromExcelPicture(sheet, excelPicture, floatingObjects) {
	        inflateWorksheetByPicture(sheet, excelPicture);
	        var bounds = getFloatingObjectBounds(sheet, excelPicture);
	    
	        var pictureName = getUniqueName(floatingObjects, excelPicture.name, 'picture'),
	            picture = {name: pictureName};
	    
	        copyProperties(excelPicture, picture, ['src', 'isVisible', 'locked']);
	    
	        if (bounds) {
	            copyProperties(bounds, picture, ['x', 'y', 'width', 'height']);
	            convertFloatingObjectAnchor(excelPicture.twoCellAnchor, picture);
	        }
	            
	        convertPictureStyle(excelPicture.pictureFormat, picture);
	        
	        return picture;
	    }
	    
	    function convertToExcelSlicer(sheet, slicer) {
	        slicer.twoCellAnchor = getFloatingObjectAnchor(sheet, slicer);
	        return slicer;
	    }
	    
	    function excelLineTypeToPictureBorderStyle(lineDashType, compoundLineType) {
	        switch (lineDashType) {
	            case 'solid':
	                return compoundLineType === 'dbl' ? 'double' : 'solid';
	            case 'dot':
	            case 'sysDot':
	                return 'dotted';
	        }
	    
	        return 'dashed';
	    }
	    
	    function pictureBorderStyleToExcelLineType(borderStyle) {
	        switch (borderStyle) {
	            case 'dotted':
	                return 'dot';
	            case 'dashed':
	                return 'dash';
	            case 'double':
	                return 'dbl';
	        }
	        return 'solid';
	    }
	    
	    function convertToExcelPicture(sheet, picture) {
	        var excelPicture = {};
	    
	        var src = picture.src;
	        getPictureInfo(src, excelPicture);
	    
	        copyProperties(picture, excelPicture, ['name', 'locked']);
	        excelPicture.twoCellAnchor = getFloatingObjectAnchor(sheet, picture);
	        excelPicture.hidden = picture.isVisible === false;
	    
	        excelPicture.fillColor = ColorHelper.toExcelColor(picture.backColor);
	        excelPicture.lineBorder = {
	            width: picture.borderWidth,
	            color: ColorHelper.toExcelColor(picture.borderColor),
	            style: pictureBorderStyleToExcelLineType(picture.borderStyle)
	        };
	    
	        return excelPicture;
	    }
	    
	    var imageBase64Flag = ';base64,';
	    function getPictureInfo(src, excelPicture) {
	        var index = src.indexOf(imageBase64Flag);
	        if (index > 0) {
	            excelPicture.base64Image = src.substr(index + imageBase64Flag.length);
	            excelPicture.imageType = src.substr(0, index).split('/').pop();
	        }
	    }
	    
	    function getUniqueName(floatingObjects, name, defaultName) {
	        function isMatch(obj) {
	            return obj.name === this.name;
	        }
	    
	        function isDuplicated(floatingObjectName) {
	            var callback = isMatch.bind({name: floatingObjectName});
	            return (ArrayFind ? ArrayFind.call(floatingObjects, callback) : floatingObjects.filter(callback)[0]) !== undefined;
	        }
	    
	        name = name || defaultName;
	        var newName = name, i = 1;
	    
	        while (isDuplicated(newName)) {
	            newName = name + "_" + i++;
	        }
	    
	        return newName;
	    }
	    
	    function convertPictureStyle(pictureFormat, picture) {
	        if (!pictureFormat) {
	            return null;
	        }
	        var fillFormat = pictureFormat.fillFormat;
	        if (fillFormat && fillFormat.fillFormatType === 1 ) {
	            picture.backColor = ColorHelper.toRGBColor(fillFormat.color);
	        }
	        var lineFormat = pictureFormat.lineFormat;
	        if (lineFormat) {
	            picture.borderWidth = lineFormat.width;
	            var lineFillFormat = lineFormat.fillFormat;
	            if (lineFillFormat && lineFillFormat.fillFormatType === 1 ) {
	                picture.borderColor = ColorHelper.toRGBColor(lineFillFormat.color);
	            }
	            var lineDashType = lineFormat.lineDashType;
	            if (lineDashType) {
	                var compoundLineType = lineFormat.compoundLineType;
	                picture.borderStyle = excelLineTypeToPictureBorderStyle(lineDashType, compoundLineType);
	            }
	        }
	    }
	
	    var _INFLATE_OFFSET = 2;
	    function inflateWorksheetBySlicer(sheet, slicer) {
	        var rowCount = sheet.rowCount, columnCount = sheet.columnCount,
	            rc = 0, cc = 0;
	        var point = slicer.endPoint;
	        if (point) {
	            rc = point.row + _INFLATE_OFFSET;
	            cc = point.col + _INFLATE_OFFSET;
	        }
	        if (rowCount < rc) {
	            sheet.rowCount = rc;
	        }
	        if (columnCount < cc) {
	            sheet.columnCount = cc;
	        }
	    }
	    function inflateWorksheetByPicture(sheet, picture) {
	        var rowCount = sheet.rowCount, columnCount = sheet.columnCount,
	            rc = 0, cc = 0;
	    
	        var absoluteAnchor = picture.absoluteAnchor;
	        if (absoluteAnchor) {
	            rc = parseInt((absoluteAnchor.y + absoluteAnchor.height) / sheet.defaults.rowHeight) + 1;
	            cc = parseInt((absoluteAnchor.x + absoluteAnchor.width) / sheet.defaults.colWidth) + 1;
	        } else {
	            var oneCellAnchor = picture.oneCellAnchor,
	                twoCellAnchor = picture.twoCellAnchor,
	                point = oneCellAnchor && oneCellAnchor.startPoint || twoCellAnchor && twoCellAnchor.endPoint;
	    
	            if (point) {
	                rc = point.row + _INFLATE_OFFSET;
	                cc = point.col + _INFLATE_OFFSET;
	            }
	        }
	    
	        if (rowCount < rc) {
	            sheet.rowCount = rc;
	        }
	        if (columnCount < cc) {
	            sheet.columnCount = cc;
	        }
	    }
	    
	    function inflateWorksheetByComment(sheet, anchor, rect) {
	        var rowCount = sheet.rowCount, columnCount = sheet.columnCount,
	            rc = 0, cc = 0;
	    
	        if (anchor) {
	            rc = anchor[6]   + 1;
	            cc = anchor[4]   + 1;
	        } else {
	            var twoPointsAnchor = getAnchor(sheet, rect);
	            rc = twoPointsAnchor.endPoint.row + _INFLATE_OFFSET;
	            cc = twoPointsAnchor.endPoint.col + _INFLATE_OFFSET;
	        }
	    
	        if (rowCount < rc) {
	            sheet.rowCount = rc;
	        }
	        if (columnCount < cc) {
	            sheet.columnCount = cc;
	        }
	    }
	    function getBounds(sheet, startPoint, endPoint) {
	        var x, y, x1, y1;
	        x = getActualColumnWidth(sheet, 0, startPoint.col) + startPoint.colOffset;
	        y = getActualRowHeight(sheet, 0, startPoint.row) + startPoint.rowOffset;
	        x1 = getActualColumnWidth(sheet, 0, endPoint.col) + endPoint.colOffset;
	        y1 = getActualRowHeight(sheet, 0, endPoint.row) + endPoint.rowOffset;
	    
	        return {x: x, y: y, width: x1 - x, height: y1 - y};
	    }
	    function getBoundsByTwoCellAnchor(sheet, twoCellAnchor) {
	        var startPoint = twoCellAnchor.startPoint;
	        var endPoint = twoCellAnchor.endPoint;
	
	        var x = getActualColumnWidth(sheet, 0, startPoint.col) + startPoint.colOffset;
	        var y = getActualRowHeight(sheet, 0, startPoint.row) + startPoint.rowOffset;
	        var x1 = getActualColumnWidth(sheet, 0, endPoint.col) + endPoint.colOffset;
	        var y1 = getActualRowHeight(sheet, 0, endPoint.row) + endPoint.rowOffset;
	    
	        return {x: x, y: y, width: x1 - x, height: y1 - y};
	    }
	    function getBoundsByOneCellAnchor(sheet, oneCellAnchor) {
	        var startPoint = oneCellAnchor.startPoint;
	
	        var x = getActualColumnWidth(sheet, 0, startPoint.col) + startPoint.colOffset;
	        var y = getActualRowHeight(sheet, 0, startPoint.row) + startPoint.rowOffset;
	
	        return {x: x, y: y, width: oneCellAnchor.width, height: oneCellAnchor.height};
	    }
	    function getBoundsByAbsoluteAnchor(absoluteAnchor) {
	        return {x: absoluteAnchor.x, y: absoluteAnchor.y, width: absoluteAnchor.width, height: absoluteAnchor.height};
	    }
	    function getBoundsByRelativeSizeAnchor(relSizeAnchor, containerWidth, containerHeight) {
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	
	        var startPoint = relSizeAnchor.startPoint, endPoint = relSizeAnchor.endPoint;
	
	        var x = startPoint.x * containerWidth;
	        var y = startPoint.y * containerHeight;
	        var x1 = endPoint.x * containerWidth;
	        var y1 = endPoint.y * containerHeight;
	
	        return {x: x, y: y, width: x1 - x, height: y1 - y};
	    }
	    function getBoundsByAbsoluteSizeAnchor(absSizeAnchor, containerWidth, containerHeight) {
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        
	        var startPoint = absSizeAnchor.startPoint;
	
	        return {x: startPoint.x * containerWidth, y: startPoint.y * containerHeight, width: absSizeAnchor.width, height: absSizeAnchor.height};
	    }
	    function getFloatingObjectBounds(sheet, picture) {
	        if (picture.twoCellAnchor) {
	            return getBoundsByTwoCellAnchor(sheet, picture.twoCellAnchor);
	        }
	        if (picture.oneCellAnchor) {
	            return getBoundsByOneCellAnchor(sheet, picture.oneCellAnchor);
	        }
	        if (picture.absoluteAnchor) {
	            return getBoundsByAbsoluteAnchor(picture.absoluteAnchor);
	        }
	        return keyword_null;
	    }
	    
	    function getFloatingObjectAnchor(sheet, floatingObject) {
	        if (!isNullOrUndefined(floatingObject.startRow)) {
	            var startPoint = {
	                row: floatingObject.startRow,
	                rowOffset: floatingObject.startRowOffset || 0,
	                col: floatingObject.startColumn,
	                colOffset: floatingObject.startColumnOffset || 0
	            }, endPoint = {
	                row: floatingObject.endRow,
	                rowOffset: floatingObject.endRowOffset || 0,
	                col: floatingObject.endColumn,
	                colOffset: floatingObject.endColumnOffset || 0
	            };
	            return { startPoint: startPoint, endPoint: endPoint };
	        }
	
	        return getAnchor(sheet, {
	            x: floatingObject.x || 0,
	            y: floatingObject.y || 0,
	            width: floatingObject.width || 0,
	            height: floatingObject.height || 0
	        });
	    }
	    
	    
	        
	    function getChartBounds(sheet, anchor, containerWidth, containerHeight) {
	        var anchorType = anchor.anchorType;
	        if(anchorType === 0 ) {
	            return getBoundsByTwoCellAnchor(sheet, anchor);
	        } else if(anchorType === 1 ) {
	            return getBoundsByOneCellAnchor(sheet, anchor);
	        } else if(anchorType === 2 ) {
	            return getBoundsByAbsoluteAnchor(anchor);
	        } else if(anchorType === 3 ) {
	            return getBoundsByRelativeSizeAnchor(anchor, containerWidth, containerHeight);
	        } else if(anchorType === 4 ) {
	            return getBoundsByAbsoluteSizeAnchor(anchor, containerWidth, containerHeight);
	        }
	        return null;
	    }
	    function inflateWorksheetByChart(sheet, chart) {
	       
	       
	        var endPoint = chart.endPoint;
	        if (endPoint) {
	            var endRow = endPoint.row;
	            if (endRow >= sheet.rowCount) {
	                sheet.rowCount = endRow + 1;
	            }
	            var endCol = endPoint.col;
	            if (endCol >= sheet.columnCount) {
	                sheet.columnCount = endCol + 1;
	            }
	        }
	    }
	    function getMoveSizeValueFromEditAs(moveSizeProperty) {
	        var dynamicMove = true, dynamicSize = true;    
	        if (moveSizeProperty === 2 ) {
	            dynamicMove = false;
	            dynamicSize = false;
	        } else if (moveSizeProperty === 1 ) {
	            dynamicSize = false;
	        }
	        return {
	            dynamicMove: dynamicMove,
	            dynamicSize: dynamicSize
	        };
	    }
	    function getEditAsValueFromMoveSize(dynamicMove, dynamicSize) {
	        var editAsValue;
	        if (dynamicMove === false && dynamicSize === false) {
	            editAsValue = 2 ;
	        } else if (dynamicSize === false) {
	            editAsValue = 1 ;
	        }
	        return editAsValue;
	    }
	    function getUserShapesDrawingAnchor(shapeItem, containerWidth, containerHeight) {
	        var anchorInfo = {
	            x: shapeItem.x || 0,
	            y: shapeItem.y || 0,
	            width: shapeItem.width || 0,
	            height: shapeItem.height || 0
	        };
	        return {
	            startPoint: {
	                x: (anchorInfo.x / containerWidth).toFixed(5),
	                y: (anchorInfo.y / containerHeight).toFixed(5)
	            },
	            endPoint: {
	                x: ((anchorInfo.x + anchorInfo.width) / containerWidth).toFixed(5),
	                y: ((anchorInfo.y + anchorInfo.height) / containerHeight).toFixed(5)
	            }
	        };
	    }
	    function getExcelColor(color) {
	        if (!color) {
	            return null;
	        }
	        var excelColor = ColorHelper.toExcelColor(color),
	            colorType = excelColor.colorType();
	        if (colorType === 2 ) {
	            var tempColor = ColorHelper.getRGBAColorData(excelColor);            
	            return {
	                srgbClr: {
	                    val: tempColor.rgb
	                }
	            };
	        } else if (colorType === 3 ) {
	            return {
	                schemeClr: {
	                    val: excelColor.value()
	                }
	            };
	        }
	        return null;
	    }
	
	    function convertFromExcelChart(sheet, excelChart) {
	        inflateWorksheetByChart(sheet, excelChart);
	
	        var cNvPrValue = excelChart.graphicFrame && excelChart.graphicFrame.nvGraphicFramePr &&
	                excelChart.graphicFrame.nvGraphicFramePr.cNvPr && excelChart.graphicFrame.nvGraphicFramePr.cNvPr;
	        var chartName = getUniqueName(sheet.charts, cNvPrValue.name, 'chart');
	        var bounds = getChartBounds(sheet, excelChart);
	        var moveSizeValue = getMoveSizeValueFromEditAs(excelChart.editAs);
	        var chartSpace = excelChart.chartSpace;
	        var chartJsonData = {
	            name: chartName,
	            dynamicMove: moveSizeValue.dynamicMove,
	            dynamicSize: moveSizeValue.dynamicSize,
	            chartSpace: chartSpace,
	            isVisible: !cNvPrValue.hidden
	        };
	        copyProperties(bounds, chartJsonData, ['x', 'y', 'width', 'height']);
	        if (excelChart.anchorType === 0 ) {
	            convertFloatingObjectAnchor(excelChart, chartJsonData);
	        }
	        var clientData = excelChart.clientData;
	        if (clientData) {
	            chartJsonData.isLocked = clientData.fLocksWithSheet;
	            chartJsonData.canPrint = clientData.fPrintsWithSheet;
	        }
	
	       
	        var userShapes = chartSpace.userShapes;
	        if(userShapes) {
	            chartSpace.userShapes = userShapes.map(function (shapeItem) {
	                if (shapeItem.pic) {
	                    return convertFromExcelPictureInChart(sheet, shapeItem, bounds.width, bounds.height);
	                } else if (shapeItem.graphicFrame) {
	                    return convertFromExcelChartInChart(sheet, shapeItem, bounds.width, bounds.height);
	                }
	            });
	        }
	
	        return chartJsonData;
	    }    
	    function convertToExcelChart(sheet, chart, id) {
	        var anchorInfo = getFloatingObjectAnchor(sheet, chart);
	        var isVisible = chart.isVisible;
	        var chartSpace = chart.chartSpace;
	        var excelChartData = {
	            anchorType: 0 ,
	            startPoint: anchorInfo.startPoint,
	            endPoint: anchorInfo.endPoint,
	            graphicFrame: {
	                nvGraphicFramePr: {
	                    cNvPr: {
	                        id: id,                        
	                        name: chart.name,
	                        hidden: isNullOrUndefined(isVisible) ? false : !isVisible
	                    }
	                }
	            },
	            clientData: {
	                fLocksWithSheet: chart.isLocked,
	                fPrintsWithSheet: chart.canPrint
	            },
	            chartSpace: chartSpace
	        };
	        var editAsValue = getEditAsValueFromMoveSize(chart.dynamicMove, chart.dynamicSize);
	        if(editAsValue > 0) {
	            excelChartData.editAs = editAsValue;
	        }
	       
	        var currentId = 1, relSizeAnchor;
	        var userShapes = chartSpace.userShapes;
	        if(userShapes && userShapes.length > 0) {
	            relSizeAnchor = userShapes.map(function (shapeItem) {
	                if (shapeItem.typeName === '1' ) {
	                    return convertToExcelPictureInChart(shapeItem, currentId++, chart.width, chart.height);
	                } else if(shapeItem.typeName === '2' ) {
	                    return convertToExcelChartInChart(shapeItem, currentId++, chart.width, chart.height);
	                }
	            });
	            chartSpace.userShapes = {
	                relSizeAnchor: relSizeAnchor
	            };
	        }
	        return excelChartData;
	    }
	    
	    function convertFromExcelChartInChart(sheet, excelChartInChart, containerWidth, containerHeight) {
	        var cNvPrValue = excelChartInChart.graphicFrame && excelChartInChart.graphicFrame.nvGraphicFramePr &&
	                excelChartInChart.graphicFrame.nvGraphicFramePr.cNvPr && excelChartInChart.graphicFrame.nvGraphicFramePr.cNvPr;
	        var chartName = getUniqueName(sheet.charts, cNvPrValue.name, 'chart');
	        var bounds = getChartBounds(sheet, excelChartInChart, containerWidth, containerHeight);
	        var chartJsonData = {
	            name: chartName,
	            chartSpace: excelChartInChart.chartSpace,
	            isVisible: !cNvPrValue.hidden
	        };
	        copyProperties(bounds, chartJsonData, ['x', 'y', 'width', 'height']);
	        return chartJsonData;
	    }
	    function convertToExcelChartInChart(chart, id, containerWidth, containerHeight) {
	        var anchorInfo = getUserShapesDrawingAnchor(chart, containerWidth, containerHeight);
	        var isVisible = chart.isVisible;
	        return {
	            typeName: chart.typeName,
	            anchorType: 3 ,
	            startPoint: anchorInfo.startPoint,
	            endPoint: anchorInfo.endPoint,
	            graphicFrame: {
	                nvGraphicFramePr: {
	                    cNvPr: {
	                        id: id,
	                        name: chart.name,
	                        hidden: isNullOrUndefined(isVisible) ? false : !isVisible
	                    }
	                }
	            },
	            chartSpace: chart.chartSpace
	        };
	    }
	
	    function convertFromExcelPictureInChart(sheet, excelPictureInChart, containerWidth, containerHeight) {
	        var cNvPrValue = excelPictureInChart.pic && excelPictureInChart.pic.nvPicPr && 
	                excelPictureInChart.pic.nvPicPr.cNvPr;
	        var pictureName = cNvPrValue.name;
	        var floatingObjects = sheet.floatingObjects;
	        if(floatingObjects) {
	            pictureName = getUniqueName(floatingObjects, pictureName, 'picture');
	        }
	        var blipFill = excelPictureInChart.pic && excelPictureInChart.pic.blipFill;
	        var blipBlob = blipFill && blipFill.blip && blipFill.blip.blipBlob;
	        var src = blipBlob && blipBlob.blob;
	        var picture = {
	            name: pictureName,
	            src: src,
	            isVisible: !cNvPrValue.hidden
	        };
	        var bounds = getChartBounds(sheet, excelPictureInChart, containerWidth, containerHeight);
	        copyProperties(bounds, picture, ['x', 'y', 'width', 'height']);
	
	        convertPictureStyle(excelPictureInChart.pictureFormat, picture);
	
	        return picture;
	    }
	    function convertToExcelPictureInChart(picture, id, containerWidth, containerHeight) {
	        var anchorInfo = getUserShapesDrawingAnchor(picture, containerWidth, containerHeight);
	        var excelPicture = {
	            typeName: picture.typeName,
	            anchorType: 3 ,
	            startPoint: anchorInfo.startPoint,
	            endPoint: anchorInfo.endPoint,
	            pic: {
	                nvPicPr: {
	                    cNvPr: {
	                        id: id,
	                        name: picture.name
	                    },
	                    cNvPicPr: {        
	                        picLocks: {}
	                    }
	                },
	                spPr: {
	                    ln: {
	                        w: picture.borderWidth
	                    },
	                    prstGeom: {        
	                        prst: 1 ,
	                        avLst: {}
	                    }
	                }
	            },
	            src: picture.src
	        };
	        var spPr = excelPicture.pic.spPr, ln = spPr.ln;
	        var backColor = getExcelColor(picture.backColor);
	        if(backColor) {
	            spPr.solidFill = backColor;
	        }
	        var borderColor = getExcelColor(picture.borderColor);
	        if(borderColor) {
	            ln.solidFill = borderColor;
	        }
	        var borderStyle = pictureBorderStyleToExcelLineType(picture.borderStyle);
	        if (borderStyle === 'dbl') {
	            ln.cmpd = Charts.ST_CompoundLine[borderStyle];
	        } else {
	            ln.prstDash = Charts.ST_PresetLineDashVal[borderStyle];
	        }
	
	        return excelPicture;
	    }
	
	    
	
	    function isBorderEqual(border1, border2) {
	        if (border1 && border2 && border1.color === border2.color && border1.type === border2.type) {
	            return true;
	        }
	        return (!border1 && !border2);
	    }
	    
	   
	   
	    var needResetStyleName = {
	        backColor: 0,
	        foreColor: 0,
	        borderBottom: 1,
	        borderLeft: 1,
	        borderRight: 1,
	        borderTop: 1,
	        font: 0,
	        textDecoration: 0
	    };
	    
	    function processTableCellStyle(style, defaultStyle) {
	        var newStyle = {};
	        for (var item in style) {
	            if (!style.hasOwnProperty(item)) {
	                continue;
	            }
	            if (needResetStyleName[item] === 0) {
	                if (style[item] !== defaultStyle[item]) {
	                    newStyle[item] = style[item];
	                }
	            } else if (needResetStyleName[item] === 1) {
	                if (!isBorderEqual(style[item], defaultStyle[item])) {
	                    newStyle[item] = style[item];
	                }
	            } else {
	                newStyle[item] = style[item];
	            }
	        }
	        return newStyle;
	    }
	
	    var toProtectionOptions = {
	        'selectLockedCells': 'allowSelectLockCells',
	        'selectUnlockedCells': 'allowSelectUnlockCells',
	        'autoFilter': 'allowFilter',
	        'sort': 'allowSort',
	        'insertColumns': 'allowInsertColumns',
	        'insertRows': 'allowInsertRows',
	        'deleteColumns': 'allowDeleteColumns',
	        'deleteRows': 'allowDeleteRows',
	        'editObject': 'allowEditObjects'
	    };
	
	    var fromProtectionOptions = {
	        'allowSelectLockCells': 'selectLockedCells',
	        'allowSelectUnlockCells': 'selectUnlockedCells',
	        'allowFilter': 'autoFilter',
	        'allowSort': 'sort',
	        'allowInsertColumns': 'insertColumns',
	        'allowInsertRows': 'insertRows',
	        'allowDeleteColumns': 'deleteColumns',
	        'allowDeleteRows': 'deleteRows',
	        'allowEditObjects': 'editObject'
	    };
	
	    function getImageContent(fileName, getFileDataAndCleanData) {
	        var extension = 'png';
	        var pos = fileName.lastIndexOf('.');
	        if (pos !== -1) {
	            extension = fileName.substr(pos + 1);
	        }
	       
	        var imageContent = getFileDataAndCleanData(fileName, true);
	        if (imageContent) {
	            return 'data:image/' + extension + ';base64,' + imageContent;
	        }
	        return keyword_null;
	    }
	    
	    module.exports = {
	        convertFromExcelComment: convertFromExcelComment,
	        convertToExcelComment: convertToExcelComment,
	        convertFromExcelPicture: convertFromExcelPicture,
	        convertToExcelPicture: convertToExcelPicture,
	        convertFromExcelChart: convertFromExcelChart,
	        convertToExcelChart: convertToExcelChart,
	        getBounds: getBounds,
	        convertToExcelSlicer: convertToExcelSlicer,
	        processTableCellStyle: processTableCellStyle,
	        inflateWorksheetBySlicer: inflateWorksheetBySlicer,
	        isBorderEaual: isBorderEqual,
	        getImageContent: getImageContent,
	        getPictureInfo: getPictureInfo,
	        toProtectionOptions: toProtectionOptions,
	        fromProtectionOptions: fromProtectionOptions
	    };
	
	}());

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	(function () {
	    'use strict';
	
	    var keyword_undefined = void 0;
	
	    function generateEnumObject(enumObj) {
	        for (var prop in enumObj) {
	            if (enumObj[prop] !== keyword_undefined) {
	                enumObj[enumObj[prop]] = prop;
	            }
	        }
	    }
	
	    var Charts = {};
	
	    var ST_FontCollectionIndex = {
	        major: 0,
	        minor: 1,
	        none: 2
	    };
	    generateEnumObject(ST_FontCollectionIndex);
	    Charts.ST_FontCollectionIndex = ST_FontCollectionIndex;
	
	    var ST_ColorSchemeIndex = {
	        dk1: 0,
	        lt1: 1,
	        dk2: 2,
	        lt2: 3,
	        accent1: 4,
	        accent2: 5,
	        accent3: 6,
	        accent4: 7,
	        accent5: 8,
	        accent6: 9,
	        hlink: 10,
	        folHlink: 11
	    };
	    generateEnumObject(ST_ColorSchemeIndex);
	    Charts.ST_ColorSchemeIndex = ST_ColorSchemeIndex;
	    
	    var ST_SystemColorVal = {
	        scrollBar: 0,
	        background: 1,
	        activeCaption: 2,
	        inactiveCaption: 3,
	        menu: 4,
	        window: 5,
	        windowFrame: 6,
	        menuText: 7,
	        windowText: 8,
	        captionText: 9,
	        activeBorder: 10,
	        inactiveBorder: 11,
	        appWorkspace: 12,
	        highlight: 13,
	        highlightText: 14,
	        btnFace: 15,
	        btnShadow: 16,
	        grayText: 17,
	        btnText: 18,
	        inactiveCaptionText: 19,
	        btnHighlight: 20,
	        Item3dDkShadow: 21,
	        Item3dLight: 22,
	        infoText: 23,
	        infoBk: 24,
	        hotLight: 25,
	        gradientActiveCaption: 26,
	        gradientInactiveCaption: 27,
	        menuHighlight: 28,
	        menuBar: 29
	    };
	    generateEnumObject(ST_SystemColorVal);
	    Charts.ST_SystemColorVal = ST_SystemColorVal;
	
	    var ST_SchemeColorVal = {
	        bg1: 0,
	        tx1: 1,
	        bg2: 2,
	        tx2: 3,
	        accent1: 4,
	        accent2: 5,
	        accent3: 6,
	        accent4: 7,
	        accent5: 8,
	        accent6: 9,
	        hlink: 10,
	        folHlink: 11,
	        phClr: 12,
	        dk1: 13,
	        lt1: 14,
	        dk2: 15,
	        lt2: 16
	    };
	    generateEnumObject(ST_SchemeColorVal);
	    Charts.ST_SchemeColorVal = ST_SchemeColorVal;
	
	    var ST_PresetColorVal = {
	        aliceBlue: 0,
	        antiqueWhite: 1,
	        aqua: 2,
	        aquamarine: 3,
	        azure: 4,
	        beige: 5,
	        bisque: 6,
	        black: 7,
	        blanchedAlmond: 8,
	        blue: 9,
	        blueViolet: 10,
	        brown: 11,
	        burlyWood: 12,
	        cadetBlue: 13,
	        chartreuse: 14,
	        chocolate: 15,
	        coral: 16,
	        cornflowerBlue: 17,
	        cornsilk: 18,
	        crimson: 19,
	        cyan: 20,
	        dkBlue: 21,
	        dkCyan: 22,
	        dkGoldenrod: 23,
	        dkGray: 24,
	        dkGreen: 25,
	        dkKhaki: 26,
	        dkMagenta: 27,
	        dkOliveGreen: 28,
	        dkOrange: 29,
	        dkOrchid: 30,
	        dkRed: 31,
	        dkSalmon: 32,
	        dkSeaGreen: 33,
	        dkSlateBlue: 34,
	        dkSlateGray: 35,
	        dkTurquoise: 36,
	        dkViolet: 37,
	        deepPink: 38,
	        deepSkyBlue: 39,
	        dimGray: 40,
	        dodgerBlue: 41,
	        firebrick: 42,
	        floralWhite: 43,
	        forestGreen: 44,
	        fuchsia: 45,
	        gainsboro: 46,
	        ghostWhite: 47,
	        gold: 48,
	        goldenrod: 49,
	        gray: 50,
	        green: 51,
	        greenYellow: 52,
	        honeydew: 53,
	        hotPink: 54,
	        indianRed: 55,
	        indigo: 56,
	        ivory: 57,
	        khaki: 58,
	        lavender: 59,
	        lavenderBlush: 60,
	        lawnGreen: 61,
	        lemonChiffon: 62,
	        ltBlue: 63,
	        ltCoral: 64,
	        ltCyan: 65,
	        ltGoldenrodYellow: 66,
	        ltGray: 67,
	        ltGreen: 68,
	        ltPink: 69,
	        ltSalmon: 70,
	        ltSeaGreen: 71,
	        ltSkyBlue: 72,
	        ltSlateGray: 73,
	        ltSteelBlue: 74,
	        ltYellow: 75,
	        lime: 76,
	        limeGreen: 77,
	        linen: 78,
	        magenta: 79,
	        maroon: 80,
	        medAquamarine: 81,
	        medBlue: 82,
	        medOrchid: 83,
	        medPurple: 84,
	        medSeaGreen: 85,
	        medSlateBlue: 86,
	        medSpringGreen: 87,
	        medTurquoise: 88,
	        medVioletRed: 89,
	        midnightBlue: 90,
	        mintCream: 91,
	        mistyRose: 92,
	        moccasin: 93,
	        navajoWhite: 94,
	        navy: 95,
	        oldLace: 96,
	        olive: 97,
	        oliveDrab: 98,
	        orange: 99,
	        orangeRed: 100,
	        orchid: 101,
	        paleGoldenrod: 102,
	        paleGreen: 103,
	        paleTurquoise: 104,
	        paleVioletRed: 105,
	        papayaWhip: 106,
	        peachPuff: 107,
	        peru: 108,
	        pink: 109,
	        plum: 110,
	        powderBlue: 111,
	        purple: 112,
	        red: 113,
	        rosyBrown: 114,
	        royalBlue: 115,
	        saddleBrown: 116,
	        salmon: 117,
	        sandyBrown: 118,
	        seaGreen: 119,
	        seaShell: 120,
	        sienna: 121,
	        silver: 122,
	        skyBlue: 123,
	        slateBlue: 124,
	        slateGray: 125,
	        snow: 126,
	        springGreen: 127,
	        steelBlue: 128,
	        tan: 129,
	        teal: 130,
	        thistle: 131,
	        tomato: 132,
	        turquoise: 133,
	        violet: 134,
	        wheat: 135,
	        white: 136,
	        whiteSmoke: 137,
	        yellow: 138,
	        yellowGreen: 139
	    };
	    generateEnumObject(ST_PresetColorVal);
	    Charts.ST_PresetColorVal = ST_PresetColorVal;
	
	    var ST_RectAlignment = {
	        tl: 0,
	        t: 1,
	        tr: 2,
	        l: 3,
	        ctr: 4,
	        r: 5,
	        bl: 6,
	        b: 7,
	        br: 8
	    };
	    generateEnumObject(ST_RectAlignment);
	    Charts.ST_RectAlignment = ST_RectAlignment;
	
	    var ST_BlackWhiteMode = {
	        clr: 0,
	        auto: 1,
	        gray: 2,
	        ltGray: 3,
	        invGray: 4,
	        grayWhite: 5,
	        blackGray: 6,
	        blackWhite: 7,
	        black: 8,
	        white: 9,
	        hidden: 10
	    };
	    generateEnumObject(ST_BlackWhiteMode);
	    Charts.ST_BlackWhiteMode = ST_BlackWhiteMode;
	
	    var ST_LayoutTarget = {
	        inner: 0,
	        outer: 1
	    };
	    generateEnumObject(ST_LayoutTarget);
	    Charts.ST_LayoutTarget = ST_LayoutTarget;
	
	    var ST_LayoutMode = {
	        edge: 0,
	        factor: 1
	    };
	    generateEnumObject(ST_LayoutMode);
	    Charts.ST_LayoutMode = ST_LayoutMode;
	
	    var ST_SizeRepresents = {
	        area: 0,
	        w: 1
	    };
	    generateEnumObject(ST_SizeRepresents);
	    Charts.ST_SizeRepresents = ST_SizeRepresents;
	
	    var ST_SplitType = {
	        auto: 0,
	        cust: 1,
	        percent: 2,
	        pos: 3,
	        val: 4
	    };
	    generateEnumObject(ST_SplitType);
	    Charts.ST_SplitType = ST_SplitType;
	
	    var ST_LblAlgn = {
	        ctr: 0,
	        l: 1,
	        r: 2
	    };
	    generateEnumObject(ST_LblAlgn);
	    Charts.ST_LblAlgn = ST_LblAlgn;
	
	    var ST_DLblPos = {
	        bestFit: 0,
	        b: 1,
	        ctr: 2,
	        inBase: 3,
	        inEnd: 4,
	        l: 5,
	        outEnd: 6,
	        r: 7,
	        t: 8
	    };
	    generateEnumObject(ST_DLblPos);
	    Charts.ST_DLblPos = ST_DLblPos;
	
	    var ST_MarkerStyle = {
	        circle: 0,
	        dash: 1,
	        diamond: 2,
	        dot: 3,
	        none: 4,
	        picture: 5,
	        plus: 6,
	        square: 7,
	        star: 8,
	        triangle: 9,
	        x: 10
	    };
	    generateEnumObject(ST_MarkerStyle);
	    Charts.ST_MarkerStyle = ST_MarkerStyle;
	
	    var ST_TrendlineType = {
	        exp: 0,
	        linear: 1,
	        log: 2,
	        movingAvg: 3,
	        poly: 4,
	        power: 5
	    };
	    generateEnumObject(ST_TrendlineType);
	    Charts.ST_TrendlineType = ST_TrendlineType;
	
	    var ST_ErrDir = {
	        x: 0,
	        y: 1
	    };
	    generateEnumObject(ST_ErrDir);
	    Charts.ST_ErrDir = ST_ErrDir;
	
	    var ST_ErrBarType = {
	        both: 0,
	        minus: 1,
	        plus: 2
	    };
	    generateEnumObject(ST_ErrBarType);
	    Charts.ST_ErrBarType = ST_ErrBarType;
	
	    var ST_ErrValType = {
	        cust: 0,
	        fixedVal: 1,
	        percentage: 2,
	        stdDev: 3,
	        stdErr: 4
	    };
	    generateEnumObject(ST_ErrValType);
	    Charts.ST_ErrValType = ST_ErrValType;
	
	    var ST_Grouping = {
	        percentStacked: 0,
	        standard: 1,
	        stacked: 2
	    };
	    generateEnumObject(ST_Grouping);
	    Charts.ST_Grouping = ST_Grouping;
	
	    var ST_ScatterStyle = {
	        none: 0,
	        line: 1,
	        lineMarker: 2,
	        marker: 3,
	        smooth: 4,
	        smoothMarker: 5
	    };
	    generateEnumObject(ST_ScatterStyle);
	    Charts.ST_ScatterStyle = ST_ScatterStyle;
	
	    var ST_RadarStyle = {
	        standard: 0,
	        marker: 1,
	        filled: 2
	    };
	    generateEnumObject(ST_RadarStyle);
	    Charts.ST_RadarStyle = ST_RadarStyle;
	
	    var ST_BarGrouping = {
	        percentStacked: 0,
	        clustered: 1,
	        standard: 2,
	        stacked: 3
	    };
	    generateEnumObject(ST_BarGrouping);
	    Charts.ST_BarGrouping = ST_BarGrouping;
	
	    var ST_BarDir = {
	        bar: 0,
	        col: 1
	    };
	    generateEnumObject(ST_BarDir);
	    Charts.ST_BarDir = ST_BarDir;
	
	    var ST_Shape = {
	        cone: 0,
	        coneToMax: 1,
	        box: 2,
	        cylinder: 3,
	        pyramid: 4,
	        pyramidToMax: 5
	    };
	    generateEnumObject(ST_Shape);
	    Charts.ST_Shape = ST_Shape;
	
	    var ST_OfPieType = {
	        pie: 0,
	        bar: 1
	    };
	    generateEnumObject(ST_OfPieType);
	    Charts.ST_OfPieType = ST_OfPieType;
	
	    var ST_AxPos = {
	        b: 0,
	        l: 1,
	        r: 2,
	        t: 3
	    };
	    generateEnumObject(ST_AxPos);
	    Charts.ST_AxPos = ST_AxPos;
	
	    var ST_Crosses = {
	        autoZero: 0,
	        max: 1,
	        min: 2
	    };
	    generateEnumObject(ST_Crosses);
	    Charts.ST_Crosses = ST_Crosses;
	
	    var ST_CrossBetween = {
	        between: 0,
	        midCat: 1
	    };
	    generateEnumObject(ST_CrossBetween);
	    Charts.ST_CrossBetween = ST_CrossBetween;
	
	   
	    var ST_TickMark = {
	        cross: 0,
	        in: 1,
	        none: 2,
	        out: 3
	    };
	    generateEnumObject(ST_TickMark);
	    Charts.ST_TickMark = ST_TickMark;
	
	   
	    var ST_TickLblPos = {
	        high: 0,
	        low: 1,
	        nextTo: 2,
	        none: 3
	    };
	    generateEnumObject(ST_TickLblPos);
	    Charts.ST_TickLblPos = ST_TickLblPos;
	
	   
	    var ST_TimeUnit = {
	        days: 0,
	        months: 1,
	        years: 2
	    };
	    generateEnumObject(ST_TimeUnit);
	    Charts.ST_TimeUnit = ST_TimeUnit;
	
	   
	    var ST_BuiltInUnit = {
	        hundreds: 0,
	        thousands: 1,
	        tenThousands: 2,
	        hundredThousands: 3,
	        millions: 4,
	        tenMillions: 5,
	        hundredMillions: 6,
	        billions: 7,
	        trillions: 8
	    };
	    generateEnumObject(ST_BuiltInUnit);
	    Charts.ST_BuiltInUnit = ST_BuiltInUnit;
	
	   
	    var ST_PictureFormat = {
	        stretch: 0,
	        stack: 1,
	        stackScale: 2
	    };
	    generateEnumObject(ST_PictureFormat);
	    Charts.ST_PictureFormat = ST_PictureFormat;
	
	    var ST_Orientation = {
	        maxMin: 0,
	        minMax: 1
	    };
	    generateEnumObject(ST_Orientation);
	    Charts.ST_Orientation = ST_Orientation;
	
	    var ST_LegendPos = {
	        b: 0,
	        tr: 1,
	        l: 2,
	        r: 3,
	        t: 4
	    };
	    generateEnumObject(ST_LegendPos);
	    Charts.ST_LegendPos = ST_LegendPos;
	
	   
	    var ST_DispBlanksAs = {
	        span: 0,
	        gap: 1,
	        zero: 2
	    };
	    generateEnumObject(ST_DispBlanksAs);
	    Charts.ST_DispBlanksAs = ST_DispBlanksAs;
	
	    var ST_PageSetupOrientation = {
	        default: 0,
	        portrait: 1,
	        landscape: 2
	    };
	    generateEnumObject(ST_PageSetupOrientation);
	    Charts.ST_PageSetupOrientation = ST_PageSetupOrientation;
	
	   
	    var ST_PresetCameraType = {
	        legacyObliqueTopLeft: 0,
	        legacyObliqueTop: 1,
	        legacyObliqueTopRight: 2,
	        legacyObliqueLeft: 3,
	        legacyObliqueFront: 4,
	        legacyObliqueRight: 5,
	        legacyObliqueBottomLeft: 6,
	        legacyObliqueBottom: 7,
	        legacyObliqueBottomRight: 8,
	        legacyPerspectiveTopLeft: 9,
	        legacyPerspectiveTop: 10,
	        legacyPerspectiveTopRight: 11,
	        legacyPerspectiveLeft: 12,
	        legacyPerspectiveFront: 13,
	        legacyPerspectiveRight: 14,
	        legacyPerspectiveBottomLeft: 15,
	        legacyPerspectiveBottom: 16,
	        legacyPerspectiveBottomRight: 17,
	        orthographicFront: 18,
	        isometricTopUp: 19,
	        isometricTopDown: 20,
	        isometricBottomUp: 21,
	        isometricBottomDown: 22,
	        isometricLeftUp: 23,
	        isometricLeftDown: 24,
	        isometricRightUp: 25,
	        isometricRightDown: 26,
	        isometricOffAxis1Left: 27,
	        isometricOffAxis1Right: 28,
	        isometricOffAxis1Top: 29,
	        isometricOffAxis2Left: 30,
	        isometricOffAxis2Right: 31,
	        isometricOffAxis2Top: 32,
	        isometricOffAxis3Left: 33,
	        isometricOffAxis3Right: 34,
	        isometricOffAxis3Bottom: 35,
	        isometricOffAxis4Left: 36,
	        isometricOffAxis4Right: 37,
	        isometricOffAxis4Bottom: 38,
	        obliqueTopLeft: 39,
	        obliqueTop: 40,
	        obliqueTopRight: 41,
	        obliqueLeft: 42,
	        obliqueRight: 43,
	        obliqueBottomLeft: 44,
	        obliqueBottom: 45,
	        obliqueBottomRight: 46,
	        perspectiveFront: 47,
	        perspectiveLeft: 48,
	        perspectiveRight: 49,
	        perspectiveAbove: 50,
	        perspectiveBelow: 51,
	        perspectiveAboveLeftFacing: 52,
	        perspectiveAboveRightFacing: 53,
	        perspectiveContrastingLeftFacing: 54,
	        perspectiveContrastingRightFacing: 55,
	        perspectiveHeroicLeftFacing: 56,
	        perspectiveHeroicRightFacing: 57,
	        perspectiveHeroicExtremeLeftFacing: 58,
	        perspectiveHeroicExtremeRightFacing: 59,
	        perspectiveRelaxed: 60,
	        perspectiveRelaxedModerately: 61
	    };
	    generateEnumObject(ST_PresetCameraType);
	    Charts.ST_PresetCameraType = ST_PresetCameraType;
	
	    var ST_LightRigDirection = {
	        tl: 0,
	        t: 1,
	        tr: 2,
	        l: 3,
	        r: 4,
	        bl: 5,
	        b: 6,
	        br: 7
	    };
	    generateEnumObject(ST_LightRigDirection);
	    Charts.ST_LightRigDirection = ST_LightRigDirection;
	
	   
	    var ST_LightRigType = {
	        legacyFlat1: 0,
	        legacyFlat2: 1,
	        legacyFlat3: 2,
	        legacyFlat4: 3,
	        legacyNormal1: 4,
	        legacyNormal2: 5,
	        legacyNormal3: 6,
	        legacyNormal4: 7,
	        legacyHarsh1: 8,
	        legacyHarsh2: 9,
	        legacyHarsh3: 10,
	        legacyHarsh4: 11,
	        threePt: 12,
	        balanced: 13,
	        soft: 14,
	        harsh: 15,
	        flood: 16,
	        contrasting: 17,
	        morning: 18,
	        sunrise: 19,
	        sunset: 20,
	        chilly: 21,
	        freezing: 22,
	        flat: 23,
	        twoPt: 24,
	        glow: 25,
	        brightRoom: 26
	    };
	    generateEnumObject(ST_LightRigType);
	    Charts.ST_LightRigType = ST_LightRigType;
	
	    var ST_BevelPresetType = {
	        relaxedInset: 0,
	        circle: 1,
	        slope: 2,
	        cross: 3,
	        angle: 4,
	        softRound: 5,
	        convex: 6,
	        coolSlant: 7,
	        divot: 8,
	        riblet: 9,
	        hardEdge: 10,
	        artDeco: 11
	    };
	    generateEnumObject(ST_BevelPresetType);
	    Charts.ST_BevelPresetType = ST_BevelPresetType;
	
	    var ST_PresetMaterialType = {
	        legacyMatte: 0,
	        legacyPlastic: 1,
	        legacyMetal: 2,
	        legacyWireframe: 3,
	        matte: 4,
	        plastic: 5,
	        metal: 6,
	        warmMatte: 7,
	        translucentPowder: 8,
	        powder: 9,
	        dkEdge: 10,
	        softEdge: 11,
	        clear: 12,
	        flat: 13,
	        softmetal: 14
	    };
	    generateEnumObject(ST_PresetMaterialType);
	    Charts.ST_PresetMaterialType = ST_PresetMaterialType;
	
	   
	    var ST_PresetShadowVal = {
	        shdw1: 0,
	        shdw2: 1,
	        shdw3: 2,
	        shdw4: 3,
	        shdw5: 4,
	        shdw6: 5,
	        shdw7: 6,
	        shdw8: 7,
	        shdw9: 8,
	        shdw10: 9,
	        shdw11: 10,
	        shdw12: 11,
	        shdw13: 12,
	        shdw14: 13,
	        shdw15: 14,
	        shdw16: 15,
	        shdw17: 16,
	        shdw18: 17,
	        shdw19: 18,
	        shdw20: 19
	    };
	    generateEnumObject(ST_PresetShadowVal);
	    Charts.ST_PresetShadowVal = ST_PresetShadowVal;
	
	    var ST_PathShadeType = {
	        shape: 0,
	        circle: 1,
	        rect: 2
	    };
	    generateEnumObject(ST_PathShadeType);
	    Charts.ST_PathShadeType = ST_PathShadeType;
	
	    var ST_TileFlipMode = {
	        none: 0,
	        x: 1,
	        y: 2,
	        xy: 3
	    };
	    generateEnumObject(ST_TileFlipMode);
	    Charts.ST_TileFlipMode = ST_TileFlipMode;
	
	    var ST_BlipCompression = {
	        email: 0,
	        screen: 1,
	        print: 2,
	        hqprint: 3,
	        none: 4
	    };
	    generateEnumObject(ST_BlipCompression);
	    Charts.ST_BlipCompression = ST_BlipCompression;
	
	    var ST_PresetPatternVal = {
	        pct5: 0,
	        pct10: 1,
	        pct20: 2,
	        pct25: 3,
	        pct30: 4,
	        pct40: 5,
	        pct50: 6,
	        pct60: 7,
	        pct70: 8,
	        pct75: 9,
	        pct80: 10,
	        pct90: 11,
	        horz: 12,
	        vert: 13,
	        ltHorz: 14,
	        ltVert: 15,
	        dkHorz: 16,
	        dkVert: 17,
	        narHorz: 18,
	        narVert: 19,
	        dashHorz: 20,
	        dashVert: 21,
	        cross: 22,
	        dnDiag: 23,
	        upDiag: 24,
	        ltDnDiag: 25,
	        ltUpDiag: 26,
	        dkDnDiag: 27,
	        dkUpDiag: 28,
	        wdDnDiag: 29,
	        wdUpDiag: 30,
	        dashDnDiag: 31,
	        dashUpDiag: 32,
	        diagCross: 33,
	        smCheck: 34,
	        lgCheck: 35,
	        smGrid: 36,
	        lgGrid: 37,
	        dotGrid: 38,
	        smConfetti: 39,
	        lgConfetti: 40,
	        horzBrick: 41,
	        diagBrick: 42,
	        solidDmnd: 43,
	        openDmnd: 44,
	        dotDmnd: 45,
	        plaid: 46,
	        sphere: 47,
	        weave: 48,
	        divot: 49,
	        shingle: 50,
	        wave: 51,
	        trellis: 52,
	        zigZag: 53
	    };
	    generateEnumObject(ST_PresetPatternVal);
	    Charts.ST_PresetPatternVal = ST_PresetPatternVal;
	
	   
	    var ST_BobType = {
	        png: 0,
	        jpg: 1,
	        jpeg: 2,
	        emf: 3
	    };
	    generateEnumObject(ST_BobType);
	    Charts.ST_BobType = ST_BobType;
	
	    var ST_BlendMode = {
	        over: 0,
	        mult: 1,
	        screen: 2,
	        darken: 3,
	        lighten: 4
	    };
	    generateEnumObject(ST_BlendMode);
	    Charts.ST_BlendMode = ST_BlendMode;
	
	    var ST_EffectContainerType = {
	        sib: 0,
	        tree: 1
	    };
	    generateEnumObject(ST_EffectContainerType);
	    Charts.ST_EffectContainerType = ST_EffectContainerType;
	
	    Charts.ST_PathToType = {
	        PathLine: 0,
	        PathMove: 1,
	        PathQuadBez: 2,
	        PathCubicBez: 3
	    };
	
	    var ST_ShapeType = {
	        line: 0,
	        lineInv: 1,
	        triangle: 2,
	        rtTriangle: 3,
	        rect: 4,
	        diamond: 5,
	        parallelogram: 6,
	        trapezoid: 7,
	        nonIsoscelesTrapezoid: 8,
	        pentagon: 9,
	        hexagon: 10,
	        heptagon: 11,
	        octagon: 12,
	        decagon: 13,
	        dodecagon: 14,
	        star4: 15,
	        star5: 16,
	        star6: 17,
	        star7: 18,
	        star8: 19,
	        star10: 20,
	        star12: 21,
	        star16: 22,
	        star24: 23,
	        star32: 24,
	        roundRect: 25,
	        round1Rect: 26,
	        round2CommunityBuyeRect: 27,
	        round2DiagRect: 28,
	        snipRoundRect: 29,
	        snip1Rect: 30,
	        snip2CommunityBuyeRect: 31,
	        snip2DiagRect: 32,
	        plaque: 33,
	        ellipse: 34,
	        teardrop: 35,
	        homePlate: 36,
	        chevron: 37,
	        pieWedge: 38,
	        pie: 39,
	        blockArc: 40,
	        donut: 41,
	        noSmoking: 42,
	        rightArrow: 43,
	        leftArrow: 44,
	        upArrow: 45,
	        downArrow: 46,
	        stripedRightArrow: 47,
	        notchedRightArrow: 48,
	        bentUpArrow: 49,
	        leftRightArrow: 50,
	        upDownArrow: 51,
	        leftUpArrow: 52,
	        leftRightUpArrow: 53,
	        quadArrow: 54,
	        leftArrowCallout: 55,
	        rightArrowCallout: 56,
	        upArrowCallout: 57,
	        downArrowCallout: 58,
	        leftRightArrowCallout: 59,
	        upDownArrowCallout: 60,
	        quadArrowCallout: 61,
	        bentArrow: 62,
	        uturnArrow: 63,
	        circularArrow: 64,
	        leftCircularArrow: 65,
	        leftRightCircularArrow: 66,
	        curvedRightArrow: 67,
	        curvedLeftArrow: 68,
	        curvedUpArrow: 69,
	        curvedDownArrow: 70,
	        swooshArrow: 71,
	        cube: 72,
	        can: 73,
	        lightningBolt: 74,
	        heart: 75,
	        sun: 76,
	        moon: 77,
	        smileyFace: 78,
	        irregularSeal1: 79,
	        irregularSeal2: 80,
	        foldedCorner: 81,
	        bevel: 82,
	        frame: 83,
	        halfFrame: 84,
	        corner: 85,
	        diagStripe: 86,
	        chord: 87,
	        arc: 88,
	        leftBracket: 89,
	        rightBracket: 90,
	        leftBrace: 91,
	        rightBrace: 92,
	        bracketPair: 93,
	        bracePair: 94,
	        straightConnector1: 95,
	        bentConnector2: 96,
	        bentConnector3: 97,
	        bentConnector4: 98,
	        bentConnector5: 99,
	        curvedConnector2: 100,
	        curvedConnector3: 101,
	        curvedConnector4: 102,
	        curvedConnector5: 103,
	        callout1: 104,
	        callout2: 105,
	        callout3: 106,
	        accentCallout1: 107,
	        accentCallout2: 108,
	        accentCallout3: 109,
	        borderCallout1: 110,
	        borderCallout2: 111,
	        borderCallout3: 112,
	        accentBorderCallout1: 113,
	        accentBorderCallout2: 114,
	        accentBorderCallout3: 115,
	        wedgeRectCallout: 116,
	        wedgeRoundRectCallout: 117,
	        wedgeEllipseCallout: 118,
	        cloudCallout: 119,
	        cloud: 120,
	        ribbon: 121,
	        ribbon2: 122,
	        ellipseRibbon: 123,
	        ellipseRibbon2: 124,
	        leftRightRibbon: 125,
	        verticalScroll: 126,
	        horizontalScroll: 127,
	        wave: 128,
	        doubleWave: 129,
	        plus: 130,
	        flowChartProcess: 131,
	        flowChartDecision: 132,
	        flowChartInputOutput: 133,
	        flowChartPredefinedProcess: 134,
	        flowChartInternalStorage: 135,
	        flowChartDocument: 136,
	        flowChartMultidocument: 137,
	        flowChartTerminator: 138,
	        flowChartPreparation: 139,
	        flowChartManualInput: 140,
	        flowChartManualOperation: 141,
	        flowChartConnector: 142,
	        flowChartPunchedCard: 143,
	        flowChartPunchedTape: 144,
	        flowChartSummingJunction: 145,
	        flowChartOr: 146,
	        flowChartCollate: 147,
	        flowChartSort: 148,
	        flowChartExtract: 149,
	        flowChartMerge: 150,
	        flowChartOfflineStorage: 151,
	        flowChartOnlineStorage: 152,
	        flowChartMagneticTape: 153,
	        flowChartMagneticDisk: 154,
	        flowChartMagneticDrum: 155,
	        flowChartDisplay: 156,
	        flowChartDelay: 157,
	        flowChartAlternateProcess: 158,
	        flowChartOffpageConnector: 159,
	        actionButtonBlank: 160,
	        actionButtonHome: 161,
	        actionButtonHelp: 162,
	        actionButtonInformation: 163,
	        actionButtonForwardNext: 164,
	        actionButtonBackPrevious: 165,
	        actionButtonEnd: 166,
	        actionButtonBeginning: 167,
	        actionButtonReturn: 168,
	        actionButtonDocument: 169,
	        actionButtonSound: 170,
	        actionButtonMovie: 171,
	        gear6: 172,
	        gear9: 173,
	        funnel: 174,
	        mathPlus: 175,
	        mathMinus: 176,
	        mathMultiply: 177,
	        mathDivide: 178,
	        mathEqual: 179,
	        mathNotEqual: 180,
	        cornerTabs: 181,
	        squareTabs: 182,
	        plaqueTabs: 183,
	        chartX: 184,
	        chartStar: 185,
	        chartPlus: 186
	    };
	    generateEnumObject(ST_ShapeType);
	    Charts.ST_ShapeType = ST_ShapeType;
	
	    var ST_TextShapeType = {
	        textNoShape: 0,
	        textPlain: 1,
	        textStop: 2,
	        textTriangle: 3,
	        textTriangleInverted: 4,
	        textChevron: 5,
	        textChevronInverted: 6,
	        textRingInside: 7,
	        textRingOutside: 8,
	        textArchUp: 9,
	        textArchDown: 10,
	        textCircle: 11,
	        textButton: 12,
	        textArchUpPour: 13,
	        textArchDownPour: 14,
	        textCirclePour: 15,
	        textButtonPour: 16,
	        textCurveUp: 17,
	        textCurveDown: 18,
	        textCanUp: 19,
	        textCanDown: 20,
	        textWave1: 21,
	        textWave2: 22,
	        textDoubleWave1: 23,
	        textWave4: 24,
	        textInflate: 25,
	        textDeflate: 26,
	        textInflateBottom: 27,
	        textDeflateBottom: 28,
	        textInflateTop: 29,
	        textDeflateTop: 30,
	        textDeflateInflate: 31,
	        textDeflateInflateDeflate: 32,
	        textFadeRight: 33,
	        textFadeLeft: 34,
	        textFadeUp: 35,
	        textFadeDown: 36,
	        textSlantUp: 37,
	        textSlantDown: 38,
	        textCascadeUp: 39,
	        textCascadeDown: 40
	    };
	    generateEnumObject(ST_TextShapeType);
	    Charts.ST_TextShapeType = ST_TextShapeType;
	
	    var ST_PathFillMode = {
	        none: 0,
	        norm: 1,
	        lighten: 2,
	        lightenLess: 3,
	        darken: 4,
	        darkenLess: 5
	    };
	    generateEnumObject(ST_PathFillMode);
	    Charts.ST_PathFillMode = ST_PathFillMode;
	
	   
	    var ST_LineEndType = {
	        none: 0,
	        triangle: 1,
	        stealth: 2,
	        diamond: 3,
	        oval: 4,
	        arrow: 5
	    };
	    generateEnumObject(ST_LineEndType);
	    Charts.ST_LineEndType = ST_LineEndType;
	
	   
	    var ST_LineEndWidth = {
	        sm: 0,
	        med: 1,
	        lg: 2
	    };
	    generateEnumObject(ST_LineEndWidth);
	    Charts.ST_LineEndWidth = ST_LineEndWidth;
	
	   
	    var ST_LineEndLength = {
	        sm: 0,
	        med: 1,
	        lg: 2
	    };
	    generateEnumObject(ST_LineEndLength);
	    Charts.ST_LineEndLength = ST_LineEndLength;
	
	   
	    var ST_PresetLineDashVal = {
	        solid: 0,
	        dot: 1,
	        dash: 2,
	        lgDash: 3,
	        dashDot: 4,
	        lgDashDot: 5,
	        lgDashDotDot: 6,
	        sysDash: 7,
	        sysDot: 8,
	        sysDashDot: 9,
	        sysDashDotDot: 10
	    };
	    generateEnumObject(ST_PresetLineDashVal);
	    Charts.ST_PresetLineDashVal = ST_PresetLineDashVal;
	
	    var ST_LineCap = {
	        rnd: 0,
	        sq: 1,
	        flat: 2
	    };
	    generateEnumObject(ST_LineCap);
	    Charts.ST_LineCap = ST_LineCap;
	
	    var ST_PenAlignment = {
	        ctr: 0,
	        in: 1
	    };
	    generateEnumObject(ST_PenAlignment);
	    Charts.ST_PenAlignment = ST_PenAlignment;
	
	   
	    var ST_CompoundLine = {
	        sng: 0,
	        dbl: 1,
	        thickThin: 2,
	        thinThick: 3,
	        tri: 4
	    };
	    generateEnumObject(ST_CompoundLine);
	    Charts.ST_CompoundLine = ST_CompoundLine;
	
	   
	    var ST_EditAs = {
	        twoCell: 0,
	        oneCell: 1,
	        absolute: 2
	    };
	    generateEnumObject(ST_EditAs);
	    Charts.ST_EditAs = ST_EditAs;
	
	    var ST_TextAnchoringType = {
	        t: 0,
	        ctr: 1,
	        b: 2,
	        just: 3,
	        dist: 4
	    };
	    generateEnumObject(ST_TextAnchoringType);
	    Charts.ST_TextAnchoringType = ST_TextAnchoringType;
	
	    var ST_TextVertOverflowType = {
	        overflow: 0,
	        ellipsis: 1,
	        clip: 2
	    };
	    generateEnumObject(ST_TextVertOverflowType);
	    Charts.ST_TextVertOverflowType = ST_TextVertOverflowType;
	
	    var ST_TextHorzOverflowType = {
	        overflow: 0,
	        clip: 1
	    };
	    generateEnumObject(ST_TextHorzOverflowType);
	    Charts.ST_TextHorzOverflowType = ST_TextHorzOverflowType;
	
	    var ST_TextVerticalType = {
	        horz: 0,
	        vert: 1,
	        vert270: 2,
	        wordArtVert: 3,
	        eaVert: 4,
	        mongolianVert: 5,
	        wordArtVertRtl: 6
	    };
	    generateEnumObject(ST_TextVerticalType);
	    Charts.ST_TextVerticalType = ST_TextVerticalType;
	
	    var ST_TextWrappingType = {
	        none: 0,
	        square: 1
	    };
	    generateEnumObject(ST_TextWrappingType);
	    Charts.ST_TextWrappingType = ST_TextWrappingType;
	
	    var ST_TextAutonumberScheme = {
	        alphaLcParenBoth: 0,
	        alphaUcParenBoth: 1,
	        alphaLcParenR: 2,
	        alphaUcParenR: 3,
	        alphaLcPeriod: 4,
	        alphaUcPeriod: 5,
	        arabicParenBoth: 6,
	        arabicParenR: 7,
	        arabicPeriod: 8,
	        arabicPlain: 9,
	        romanLcParenBoth: 10,
	        romanUcParenBoth: 11,
	        romanLcParenR: 12,
	        romanUcParenR: 13,
	        romanLcPeriod: 14,
	        romanUcPeriod: 15,
	        circleNumDbPlain: 16,
	        circleNumWdBlackPlain: 17,
	        circleNumWdWhitePlain: 18,
	        arabicDbPeriod: 19,
	        arabicDbPlain: 20,
	        ea1ChsPeriod: 21,
	        ea1ChsPlain: 22,
	        ea1ChtPeriod: 23,
	        ea1ChtPlain: 24,
	        ea1JpnChsDbPeriod: 25,
	        ea1JpnKorPlain: 26,
	        ea1JpnKorPeriod: 27,
	        arabic1Minus: 28,
	        arabic2Minus: 29,
	        hebrew2Minus: 30,
	        thaiAlphaPeriod: 31,
	        thaiAlphaParenR: 32,
	        thaiAlphaParenBoth: 33,
	        thaiNumPeriod: 34,
	        thaiNumParenR: 35,
	        thaiNumParenBoth: 36,
	        hindiAlphaPeriod: 37,
	        hindiNumPeriod: 38,
	        hindiNumParenR: 39,
	        hindiAlpha1Period: 40
	    };
	    generateEnumObject(ST_TextAutonumberScheme);
	    Charts.ST_TextAutonumberScheme = ST_TextAutonumberScheme;
	
	   
	    var ST_TextUnderlineType = {
	        none: 0,
	        words: 1,
	        sng: 2,
	        dbl: 3,
	        heavy: 4,
	        dotted: 5,
	        dottedHeavy: 6,
	        dash: 7,
	        dashHeavy: 8,
	        dashLong: 9,
	        dashLongHeavy: 10,
	        dotDash: 11,
	        dotDashHeavy: 12,
	        dotDotDash: 13,
	        dotDotDashHeavy: 14,
	        wavy: 15,
	        wavyHeavy: 16,
	        wavyDbl: 17
	    };
	    generateEnumObject(ST_TextUnderlineType);
	    Charts.ST_TextUnderlineType = ST_TextUnderlineType;
	
	    var ST_TextStrikeType = {
	        noStrike: 0,
	        sngStrike: 1,
	        dblStrike: 2
	    };
	    generateEnumObject(ST_TextStrikeType);
	    Charts.ST_TextStrikeType = ST_TextStrikeType;
	
	    var ST_TextCapsType = {
	        none: 0,
	        small: 1,
	        all: 2
	    };
	    generateEnumObject(ST_TextCapsType);
	    Charts.ST_TextCapsType = ST_TextCapsType;
	
	    var ST_TextTabAlignType = {
	        l: 0,
	        ctr: 1,
	        r: 2,
	        dec: 3
	    };
	    generateEnumObject(ST_TextTabAlignType);
	    Charts.ST_TextTabAlignType = ST_TextTabAlignType;
	
	    var ST_TextAlignType = {
	        l: 0,
	        ctr: 1,
	        r: 2,
	        just: 3,
	        justLow: 4,
	        dist: 5,
	        thaiDist: 6
	    };
	    generateEnumObject(ST_TextAlignType);
	    Charts.ST_TextAlignType = ST_TextAlignType;
	
	    var ST_TextFontAlignType = {
	        auto: 0,
	        t: 1,
	        ctr: 2,
	        base: 3,
	        b: 4
	    };
	    generateEnumObject(ST_TextFontAlignType);
	    Charts.ST_TextFontAlignType = ST_TextFontAlignType;
	
	    Charts.CT_PathType = {
	        CT_PathToList: 0,
	        CT_Path2DArcTo: 1,
	        CT_Path2DClose: 2
	    };
	
	    module.exports = Charts;
	
	}());


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var StringEx = common._StringEx;
	    var keyword_null = null, keyword_undefined = void 0;
	
	    var DateTimeHelper = (function () {
	        function DateTimeHelper() {
	        }
	
	        DateTimeHelper._addOADateString = function (date) {
	            return '/OADate(' + date + ')/';
	        };
	        DateTimeHelper._removeOADateString = function (date) {
	            if (typeof date === 'string' && date.substr(0, 8) === '/OADate(') {
	                return parseInt(date.substr(8, date.length - 8 - 1 - 1));
	            }
	            return date;
	        };
	        DateTimeHelper._toOADate = function (date) {
	            if (date === keyword_undefined || date === keyword_null) {
	                return 0;
	            }
	            if (typeof date === 'number' || typeof date === 'string') {
	                date = new Date(date);
	            }
	            if (date instanceof Date) {
	                return (date.getTime() * 1440 + 25569 * 86400000 * 1440 - date.getTimezoneOffset() * 86400000) / (86400000 * 1440);
	            }
	            return 0;
	        };
	        DateTimeHelper._fromOADate = function (oadate) {
	            var offsetDay = oadate - 25569;
	            var date = new Date(offsetDay * 86400000);
	           
	           
	           
	            var adjustValue = offsetDay >= 0 ? 1 : -1;
	            return new Date((oadate * 86400000 * 1440 + adjustValue - 25569 * 86400000 * 1440 + date.getTimezoneOffset() * 86400000) / 1440);
	        };
	        DateTimeHelper._fromExcelOADate = function (d) {
	            if (d > -657435.0 && d < 2958466.0) {
	               
	                if (d < 60) { d++; }
	               
	               
	               
	               
	               
	               
	                return DateTimeHelper._fromOADate(d);
	            }
	            return d;
	        };
	        DateTimeHelper._toExcelOADate = function (dt) {
	           
	           
	           
	           
	           
	            var value = DateTimeHelper._toOADate(dt);
	           
	            if (value < 61) { value--; }
	           
	            return value;
	        };
	        DateTimeHelper._isDatesOrTimesNumberFormat = function (formatCode) {
	            if (!formatCode || formatCode === ' ') {
	                return false;
	            }
	
	            if (formatCode.length === 0) {
	                return false;
	            }
	
	            formatCode = formatCode.toUpperCase();
	            formatCode = formatCode.replace(/(\[.*\])+/g, ' ');
	           
	           
	            formatCode = formatCode.replace(/"[^"]*"/g, ' ');
	           
	            formatCode = formatCode.replace(/(\*.|_.|\\.)+/g, ' ');
	            if (formatCode.indexOf('GENERAL') !== -1) {
	                return false;
	            }
	            var start = -1;
	            var length = 0;
	            var inFormatPattern = false;
	            var isValidDateOrTimePattern = null;
	            var i = 0;
	            for (; i < formatCode.length; i++) {
	                var code = formatCode[i];
	                if (code === '[') {
	                    do {
	                        code = formatCode[i];
	                        i++;
	                    } while (i < formatCode.length && code !== ']');
	                }
	                if (code === 'Y' || code === 'D' || code === 'M' || code === 'H' || code === 'S' || code === 'A') {
	                    if (!inFormatPattern) {
	                        if (i === 0 || (formatCode.length > 0 && formatCode[i - 1] !== '\\')) {
	                            inFormatPattern = true;
	                            start = i;
	                            length = 1;
	                        }
	                       
	                    } else {
	                        length++;
	                    }
	                } else {
	                    inFormatPattern = false;
	                    if (code === ' ' && isValidDateOrTimePattern) {
	                        return true;
	                    }
	
	                    if (length !== 0) {
	                        var subFormatPattern = formatCode.substring(start, start + length);
	                        start = i;
	                        length = 0;
	                        if (isValidDateOrTimePattern === keyword_null) {
	                            isValidDateOrTimePattern = DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
	                        } else {
	                            isValidDateOrTimePattern = isValidDateOrTimePattern && DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
	                        }
	                    }
	                }
	            }
	
	            if (length !== 0 && i === formatCode.length) {
	                subFormatPattern = formatCode.substring(start, start + length);
	                if (isValidDateOrTimePattern === keyword_null) {
	                    isValidDateOrTimePattern = DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
	                } else {
	                    isValidDateOrTimePattern = isValidDateOrTimePattern && DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
	                }
	            }
	
	            return !!isValidDateOrTimePattern;
	        };
	        DateTimeHelper._isValidDateOrTimeFormatPattern = function (pattern) {
	            if (StringEx._isNullOrWhiteSpace(pattern)) {
	                return false;
	            }
	            var itemGroups = [], searchedChars = '';
	            for (var i = 0, len = pattern.length; i < len; i++) {
	                var c = pattern[i];
	                if (searchedChars.indexOf(c) === -1) {
	                    itemGroups.push({key: c, count: pattern.match(new RegExp(c, 'g')).length});
	                    searchedChars += c;
	                }
	            }
	            var DateAndTimeFormatElementDict = {Y: 4, D: 4, M: 5, H: 2, S: 2, A: 4};
	            var len1;
	            for (i = 0, len1 = itemGroups.length; i < len1; i++) {
	                var item = itemGroups[i];
	                var maxCount = DateAndTimeFormatElementDict[item.key];
	                if (maxCount === keyword_undefined) {
	                    return false;
	                }
	                if (item.count > maxCount) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return DateTimeHelper;
	    })();
	
	    module.exports = DateTimeHelper;
	
	}());

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var excel = __webpack_require__(21);
	    var IndexHelper = common._IndexHelper;
	    var ExcelConstants = excel._ExcelConstants;
	    var isRangeWholeRow = common.isRangeWholeRow, isRangeWholeColumn = common.isRangeWholeColumn;
	
	    function getRangesFromString(sqref) {
	        var result = [];
	        if (sqref === null) {
	            return result;
	        }
	        var ranges = sqref.replace(/('[\w ]+')/g, '').split(' ');
	        ranges.forEach(function (range) {
	            var tempRange = getRange(range);
	            if (!tempRange || tempRange.row > ExcelConstants._openXmlMaxRow || tempRange.col > ExcelConstants._openXmlMaxColumn
	                || tempRange.rowCount > ExcelConstants._openXmlMaxRow || tempRange.col > ExcelConstants._openXmlMaxColumn) {
	                return;
	            }
	            result.push(tempRange);
	        });
	        return result;
	    }
	
	    function getRange(sqref) {
	        var range = {};
	        var index = sqref.indexOf('!');
	        if (index > -1) {
	            sqref = sqref.substr(index + 1);
	        }
	        var qref = sqref.split('$').join('');
	        qref = qref.split(':');
	
	        var row, column, row2, column2, leftQref, rightQref;
	        if (qref.length === 1) {
	            leftQref = qref[0];
	            row = IndexHelper._getRowIndexInNumber(leftQref);
	            column = IndexHelper._getColumnIndexInNumber(leftQref);
	            if (row === -1 && column === -1) {
	                return null;
	            }
	            range.row = row;
	            range.col = column;
	            range.rowCount = 1;
	            range.colCount = 1;
	        } else if (qref.length === 2) {
	            leftQref = qref[0];
	            rightQref = qref[1];
	            row = IndexHelper._getRowIndexInNumber(leftQref);
	            column = IndexHelper._getColumnIndexInNumber(leftQref);
	            row2 = IndexHelper._getRowIndexInNumber(rightQref);
	            column2 = IndexHelper._getColumnIndexInNumber(rightQref);
	            range.row = row;
	            range.col = column;
	            range.rowCount = (row2 - row + 1);
	            range.colCount = (column2 - column + 1);
	           
	            if (row === 0 && range.rowCount === ExcelConstants._openXmlMaxRow) {
	                range.row = -1;
	                range.rowCount = -1;
	            }
	            if (column === 0 && range.colCount === ExcelConstants._openXmlMaxColumn) {
	                range.col = -1;
	                range.colCount = -1;
	            }
	        }
	        return range;
	    }
	
	    exports._getRangesFromString = getRangesFromString;
	
	    function getRangeString(ranges) {
	        var rangeStrList = [];
	        for (var i = 0; i < ranges.length; i++) {
	            var range = ranges[i];
	            if (isRangeWholeRow(range)) {
	                range.col = 0;
	                range.colCount = ExcelConstants._openXmlMaxColumn;
	            }
	            if (isRangeWholeColumn(range)) {
	                range.row = 0;
	                range.rowCount = ExcelConstants._openXmlMaxRow;
	            }
	            var firstRow = range.row;
	            var lastRow = range.row + range.rowCount - 1;
	            var firstCol = range.col;
	            var lastCol = range.col + range.colCount - 1;
	            var rangeStr = IndexHelper._getColumnIndexInA1Letter(firstCol) + (firstRow + 1);
	            if (range.rowCount > 1 || range.colCount > 1) {
	                rangeStr += (':' + IndexHelper._getColumnIndexInA1Letter(lastCol) + (lastRow + 1));
	            }
	            rangeStrList.push(rangeStr);
	        }
	        return rangeStrList.join(' ');
	    }
	
	    exports._getRangeString = getRangeString;
	
	}());

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var xmlReader = __webpack_require__(8);
	    var common = __webpack_require__(4);
	    var Util = common._Util;
	    
	    
	    function readSharedString(dataString) {
	        var reader = new xmlReader();
	        reader.setXml(dataString);
	        var result = [];
	        while (reader.read()) {
	            if (reader.depth !== 1 || reader.elementType === 2 ) {
	                continue;
	            }
	            if (reader.name() === 'si') {
	                var depth = reader.depth, text = '';
	                while (reader.read()) {
	                    if (reader.depth <= depth) {
	                        break;
	                    }
	                    if (reader.nodeType() === 1 ) {
	                        var name = reader.name();
	                        if (name === 't' && reader.elementType === 1  && reader.depth === depth + 1 ) {
	                            text = Util._decodeSpecialCharacterFromXML(reader.readElementContentAsString());
	                        } else if (name === 'r') {
	                            var rDepth = reader.depth;
	                            while (reader.read()) {
	                                if (reader.depth <= rDepth) {
	                                    break;
	                                }
	                                if (reader.elementType === 1  && reader.name() === 't') {
	                                    text += Util._decodeSpecialCharacterFromXML(reader.readElementContentAsString(true));  
	                                }
	                            }
	                        }
	                    }
	                }
	                result.push(Util._xmlDecode(text));
	            }
	        }
	        return result;
	    }
	    
	    module.exports = readSharedString;
	
	}());

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var excel = __webpack_require__(21);
	    var excelStyle = __webpack_require__(12);
	    var StringEx = common._StringEx;
	    var ColorHelper = excelStyle.ColorHelper;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    
	    function readTheme(dataString, readerDataModel) {
	        var obj = parseXmlToObject(dataString);
	        var themeObj = obj['a:theme'];
	        if (themeObj) {
	            var themeName = themeObj._attr.name;
	            if (themeName && themeName.toUpperCase().substring(0, 6) === 'OFFICE') {
	                themeName = 'Office';
	            }
	            var themeElementsObj = themeObj['a:themeElements'];
	            if (themeElementsObj) {
	                var colorScheme = readColorScheme(themeElementsObj);
	                var fontScheme = readFontScheme(themeElementsObj);
	                var theme = new excel._ExcelTheme(themeName, colorScheme, fontScheme);
	                readerDataModel._setTheme(theme);
	            }
	        }
	    }
	    
	    function readColorScheme(themeElementsObj) {
	        var colors = [], clrSchemeObj = themeElementsObj['a:clrScheme'];
	        if (clrSchemeObj) {
	           
	            var text1 = readThemeColor(clrSchemeObj['a:lt1']);
	            if (text1) {
	                colors.push(text1);
	            }
	            var background1 = readThemeColor(clrSchemeObj['a:dk1']);
	            if (background1) {
	                colors.push(background1);
	            }
	            var text2 = readThemeColor(clrSchemeObj['a:lt2']);
	            if (text2) {
	                colors.push(text2);
	            }
	            var background2 = readThemeColor(clrSchemeObj['a:dk2']);
	            if (background2) {
	                colors.push(background2);
	            }
	            var accent1 = readThemeColor(clrSchemeObj['a:accent1']);
	            if (accent1) {
	                colors.push(accent1);
	            }
	            var accent2 = readThemeColor(clrSchemeObj['a:accent2']);
	            if (accent2) {
	                colors.push(accent2);
	            }
	            var accent3 = readThemeColor(clrSchemeObj['a:accent3']);
	            if (accent3) {
	                colors.push(accent3);
	            }
	            var accent4 = readThemeColor(clrSchemeObj['a:accent4']);
	            if (accent4) {
	                colors.push(accent4);
	            }
	            var accent5 = readThemeColor(clrSchemeObj['a:accent5']);
	            if (accent5) {
	                colors.push(accent5);
	            }
	            var accent6 = readThemeColor(clrSchemeObj['a:accent6']);
	            if (accent6) {
	                colors.push(accent6);
	            }
	            var hyperlink = readThemeColor(clrSchemeObj['a:hlink']);
	            if (hyperlink) {
	                colors.push(hyperlink);
	            }
	            var followedHyperlink = readThemeColor(clrSchemeObj['a:folHlink']);
	            if (followedHyperlink) {
	                colors.push(followedHyperlink);
	            }
	            return new excel._ColorScheme(clrSchemeObj._attr.name, colors);
	        }
	    }
	    
	    function readFontScheme(themeElementsObj) {
	        var fontSchemeObj = themeElementsObj['a:fontScheme'];
	        if (fontSchemeObj) {
	            var majorFont = readThemeFonts(fontSchemeObj['a:majorFont']);
	            var minorFont = readThemeFonts(fontSchemeObj['a:minorFont']);
	            return new excel._FontScheme(fontSchemeObj._attr.name, majorFont, minorFont);
	        }
	        return null;
	    }
	    
	    function readThemeFonts(fontObj) {
	        var rfs = [], tfs = [];
	        if (fontObj) {
	            if (fontObj['a:latin']) {
	                rfs.push(new excel._RunFormatting(0 , isNullOrUndefined(fontObj['a:latin']._attr.typeface) ? '' : fontObj['a:latin']._attr.typeface));
	            } else if (fontObj['a:ea']) {
	                rfs.push(new excel._RunFormatting(2 , isNullOrUndefined(fontObj['a:ea']._attr.typeface) ? '' : fontObj['a:ea']._attr.typeface));
	            } else if (fontObj['a:cs']) {
	                rfs.push(new excel._RunFormatting(1 , isNullOrUndefined(fontObj['a:cs']._attr.typeface) ? '' : fontObj['a:cs']._attr.typeface));
	            } else if (fontObj['a:sym']) {
	                rfs.push(new excel._RunFormatting(3 , isNullOrUndefined(fontObj['a:sym']._attr.typeface) ? '' : fontObj['a:sym']._attr.typeface));
	            } else if (fontObj['a:font']) {
	                var aFontObjs = fontObj['a:font'];
	                if (!Array.isArray(aFontObjs)) {
	                    aFontObjs = [aFontObjs];
	                }
	                for (var i = 0, len = aFontObjs.length; i < len; i++) {
	                    var aFontObj = aFontObjs[i];
	                    tfs.push(new excel._ThemeFont(aFontObj._attr.script, aFontObj._attr.typeface));
	                }
	            }
	        }
	        return new excel._ThemeFonts(rfs, tfs);
	    }
	    
	    function readThemeColor(colorObj) {
	        var color;
	        if (!colorObj) {
	            return;
	        }
	        if (colorObj['a:sysClr']) {
	            var clc = colorObj['a:sysClr']._attr.val;
	            var sysColor = excelStyle.ExcelSystemColor.getSystemColor(clc);
	            if (sysColor !== undefined) {
	                color = sysColor;
	            } else {
	                clc = colorObj['a:sysClr']._attr.lastClr;
	                if (!StringEx._isNullOrEmpty(clc)) {
	                    var colorValue = 0xFF000000 + (parseInt(clc, 16) & 0xFFFFFF);
	                    color = ColorHelper.fromArgb(colorValue);
	                }
	            }
	        } else if (colorObj['a:srgbClr']) {
	            clc = colorObj['a:srgbClr']._attr.val;
	            if (!StringEx._isNullOrEmpty(clc)) {
	                colorValue = 0xFF000000 + (parseInt(clc, 16) & 0xFFFFFF);
	                color = ColorHelper.fromArgb(colorValue);
	            }
	        } else if (colorObj['a:scrgbClr']) {
	            var f = parseFloat(colorObj['a:scrgbClr']._r), g = parseFloat(colorObj['a:scrgbClr']._attr.g), b = parseFloat(colorObj['a:scrgbClr']._attr.b);
	            color = new excelStyle._Color(0xff, ColorHelper.scRgbTosRgb(f), ColorHelper.scRgbTosRgb(g), ColorHelper.scRgbTosRgb(b));
	        } else if (colorObj['a:hslClr']) {
	            var h = parseFloat(colorObj['a:hslClr']._hue), s = parseFloat(colorObj['a:hslClr']._attr.sat), l = parseFloat(colorObj['a:hslClr']._attr.lum);
	            color = ColorHelper.convertHLSToRGB(h, l, s);
	        } else if (colorObj['a:prstClr']) {
	            var value = colorObj['a:prstClr']._attr.val;
	            if (!StringEx._isNullOrWhiteSpace(value)) {
	                color = ColorHelper.fromPresetColorVal(value);
	            }
	        } else if (colorObj['a:schemeClr']) {
	           
	           
	           
	           
	        }
	        if (color === undefined) {
	            return;
	        }
	        return {
	            a: color.a,
	            r: color.r,
	            g: color.g,
	            b: color.b
	        };
	    }
	    
	    module.exports = readTheme;
	
	}());

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var XmlNodeHelper = __webpack_require__(11);
	    var excel = __webpack_require__(21);
	    var common = __webpack_require__(4);
	    var Util = common._Util;
	    var StringEx = common._StringEx;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var keyword_undefined = void 0;
	
	    function readWorkbook(dataString, readerDataModel) {
	        var sheetIDs = [];
	        var obj = parseXmlToObject(dataString);
	        var workbookObj = obj.workbook;
	        if (workbookObj) {
	            if (workbookObj.workbookPr) {
	                readWorkbookProperties(workbookObj.workbookPr, readerDataModel);
	            }
	            if (workbookObj.bookViews) {
	                var workbookViewsObj = workbookObj.bookViews.workbookView, workbookViewsCount = workbookViewsObj.length;
	                if (workbookViewsCount === keyword_undefined) {
	                    workbookViewsObj = [workbookViewsObj];
	                    workbookViewsCount = 1;
	                }
	                for (var i = 0; i < workbookViewsCount; i++) {
	                    readWorkbookView(workbookViewsObj[i], readerDataModel);
	                }
	            }
	            if (workbookObj.sheets && workbookObj.sheets.sheet) {
	                var sheetsObj = workbookObj.sheets.sheet;
	                if (!Array.isArray(sheetsObj)) {
	                    sheetsObj = [sheetsObj];
	                }
	                sheetIDs = readSheets(sheetsObj, readerDataModel);
	            }
	            if (workbookObj.definedNames) {
	                var definedNames;
	                if (Array.isArray(workbookObj.definedNames.definedName)) {
	                    definedNames = workbookObj.definedNames.definedName;
	                } else {
	                    definedNames = [workbookObj.definedNames.definedName];
	                }
	                readDefinedNames(definedNames, readerDataModel);
	            }
	            if (workbookObj.calcPr) {
	                readWorkbookCalcProperties(workbookObj.calcPr, readerDataModel);
	            }
	        }
	        return sheetIDs;
	    }
	
	    function readWorkbookProperties(workbookPrObj, readerDataModel) {
	        var dataCompatibility = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookPrObj._attr.dateCompatibility, true);
	        if (dataCompatibility) {
	            readerDataModel._setExcelWorkbookProperty(XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookPrObj._attr.date1904, false));
	        }
	    }
	
	    function readWorkbookView(workbookViewObj, readerDataModel) {
	        var showHorizontalScrollbar = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookViewObj._attr.showHorizontalScroll, true);
	        var showVerticalScrollbar = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookViewObj._attr.showVerticalScroll, true);
	        var showSheetTabs = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookViewObj._attr.showSheetTabs, true);
	        var firstSheet = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(workbookViewObj._attr.firstSheet, 0);
	        var activeTab = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(workbookViewObj._attr.activeTab, 0);
	        var tabRatio = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(workbookViewObj._attr.tabRatio, 600);
	
	        readerDataModel._setScroll(showHorizontalScrollbar, showVerticalScrollbar);
	        readerDataModel._setTabs(showSheetTabs, activeTab, firstSheet, tabRatio);
	    }
	
	    function readSheets(sheetObjs, readerDataModel) {
	        var sheetIDs = [];
	        for (var i = 0; i < sheetObjs.length; i++) {
	            var sheetObj = sheetObjs[i];
	            var si = new excel._SheetInfo();
	            var name = Util._xmlDecode(sheetObj._attr.name);
	            si.name = name;
	            si.index = i;
	            si.sheetId = sheetObj._attr.sheetId;
	            si.rID = sheetObj._attr['r:id'];
	            if (!StringEx._isNullOrWhiteSpace(si.rID)) {
	                sheetIDs.push(si);
	            }
	            var state = sheetObj._attr.state, hidden = 0;
	            if (state) {
	                if (state === 'hidden') {
	                    hidden = 1;
	                } else if (state === 'veryHidden') {
	                    hidden = 2;
	                }
	            }
	            readerDataModel._addSheet(name, i, hidden);
	        }
	        return sheetIDs;
	    }
	
	    function readDefinedNames(definedNames, readerDataModel) {
	        if (definedNames.length > 0) {
	            readerDataModel._initDefinedNames();
	            var definedName;
	            for (var i = 0; i < definedNames.length; i++) {
	                definedName = definedNames[i];
	                if (definedName) {
	                    var local = definedName._attr.localSheetId;
	                    var name = Util._xmlDecode(definedName._attr.name);
	                    var comment = Util._xmlDecode(definedName._attr.comment);
	                    var formula = Util._xmlDecode(definedName.definedName);
	                    var sheetIndex = -1;
	                    if (!isNullOrUndefined(local)) {
	                        sheetIndex = parseInt(local, 10);
	                    }
	                    if (name === '_xlnm.Print_Area') {
	                        readerDataModel._setPrintArea(sheetIndex, formula);
	                    } else if (name === '_xlnm.Print_Titles') {
	                        readerDataModel._setPrintTitles(sheetIndex, formula);
	                    } else {
	                        readerDataModel._addDefinedName(name, formula, sheetIndex, comment);
	                    }
	                }
	            }
	        }
	    }
	
	    function readWorkbookCalcProperties(calcPrObj, readerDataModel) {
	        var refModeStr = calcPrObj._attr.refMode;
	        if (refModeStr && refModeStr === 'R1C1') {
	           
	            readerDataModel._setCalculationProperty(true);
	        }
	    }
	
	    module.exports = readWorkbook;
	
	}());

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var readColor = __webpack_require__(16);
	    var xmlReader = __webpack_require__(8);
	    var common = __webpack_require__(4);
	    var excel = __webpack_require__(21);
	    var excelStyle = __webpack_require__(12);
	    var conditionFormatReader = __webpack_require__(31);
	    var sparklineReader = __webpack_require__(32);
	    var autoFilterReader = __webpack_require__(33);
	    var dataValidatorReader = __webpack_require__(34);
	    var printReader = __webpack_require__(35);
	    
	    var IndexHelper = common._IndexHelper;
	    var ExcelColor = excelStyle.ExcelColor;
	    var CalcHelper = common._CalcHelper;
	    var Util = common._Util;
	    
	    var keyword_null = null;
	    
	    function readWorksheets(dataString, sheetName, readerDataModel, cellStyleXfsLength, sharedString) {
	        var reader = new xmlReader();
	        reader.reset();
	        reader.setXml(dataString);
	        var defaultRowHeight = 15;
	        var sharedFormula = {};
	        readerDataModel._rowInfos = [];
	        readerDataModel._colInfos = [];
	        while (reader.read()) {
	            if (reader.depth !== 1 || reader.elementType === 2 ) {
	                continue;
	            }
	            try {
	                switch (reader.name()) {
	                    case 'sheetPr':
	                        readSheetPr(reader, sheetName, readerDataModel);
	                        break;
	                    case 'dimension':
	                        readDimension(reader, sheetName, readerDataModel);
	                        break;
	                    case 'sheetViews':
	                        readSheetViews(reader, sheetName, readerDataModel);
	                        break;
	                    case 'sheetFormatPr':
	                        defaultRowHeight = readSheetFormatProperties(reader, sheetName, readerDataModel);
	                        break;
	                    case 'cols':
	                        readColumnInfo(reader, sheetName, readerDataModel, cellStyleXfsLength);
	                        break;
	                    case 'mergeCells':
	                        readMergeCells(reader, sheetName, readerDataModel);
	                        break;
	                    case 'sheetData':
	                        readSheetData(reader, sheetName, readerDataModel, sharedFormula, defaultRowHeight, cellStyleXfsLength, sharedString);
	                        break;
	                    case 'sheetProtection':
	                        readSheetProtection(reader, sheetName, readerDataModel);
	                        break;
	                    case 'conditionalFormatting':
	                        conditionFormatReader._readConditionalFormatting(reader, sheetName, readerDataModel);
	                        break;
	                    case 'extLst':
	                        readExtensionList(reader, sheetName, readerDataModel);
	                        break;
	                    case 'autoFilter':
	                        autoFilterReader._readAutoFilterForSheet(reader, sheetName, readerDataModel);
	                        break;
	                    case 'dataValidations':
	                        dataValidatorReader._readDataValidations(reader, sheetName, readerDataModel);
	                        break;
	                    case 'pageMargins':
	                        printReader._readPageMargins(reader, sheetName, readerDataModel);
	                        break;
	                    case 'printOptions':
	                        printReader._readPrintOptions(reader, sheetName, readerDataModel);
	                        break;
	                    case 'pageSetup':
	                        printReader._readPageSetup(reader, readerDataModel);
	                        break;
	                    case 'headerFooter':
	                        printReader._readHeaderFooter(reader, readerDataModel);
	                        break;
	                    case 'rowBreaks':
	                        printReader._readRowColumnBreaks(reader, readerDataModel, true);
	                        break;
	                    case 'colBreaks':
	                        printReader._readRowColumnBreaks(reader, readerDataModel, false);
	                        break;
	                    case 'legacyDrawingHF':
	                        printReader._readLegacyDrawingHF(reader, readerDataModel);
	                        break;
	                    default:
	                        break;
	                }
	            } catch (e) {
	               
	            }
	        }
	    }
	    
	    function readSheetPr(reader, sheetName, readerDataModel) {
	        while (reader.moveToNextAttribute()) {
	            var attrName = reader.readAttributeNameAsString();
	            if (attrName === 'filterMode') {
	                reader.readContentAsString();
	            }
	        }
	       
	       
	       
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1 ) {
	                switch (reader.name()) {
	                    case 'tabColor':
	                        readerDataModel._setSheetTabColor(sheetName, readColor(reader));
	                        break;
	                    case 'outlinePr':
	                        var summaryBelow = true, summaryRight = true;
	                        while (reader.moveToNextAttribute()) {
	                            if (reader.readAttributeNameAsString() === 'summaryBelow') {
	                                summaryBelow = reader.readContentAsBoolean();
	                            } else if (reader.readAttributeNameAsString() === 'summaryRight') {
	                                summaryRight = reader.readContentAsBoolean();
	                            }
	                        }
	                        readerDataModel._setOutlineDirection(sheetName, summaryRight, summaryBelow);
	                        break;
	                    case 'pageSetUpPr':
	                        printReader._readPageSetupAdditionalProperty(reader, readerDataModel);
	                        break;
	                }
	            }
	        }
	    }
	    function readDimension(reader, sheetName, readerDataModel) {
	        while (reader.moveToNextAttribute()) {
	            if (reader.readAttributeNameAsString() === 'ref') {
	                var ref = reader.readContentAsString();
	                var rc = ref.split(':');
	                var rowCount, columnCount;
	                if (rc.length === 2) {
	                    var r1 = IndexHelper._getRowIndexInNumber(rc[0]);
	                    var r2 = IndexHelper._getRowIndexInNumber(rc[1]);
	                    var c1 = IndexHelper._getColumnIndexInNumber(rc[0]);
	                    var c2 = IndexHelper._getColumnIndexInNumber(rc[1]);
	                    rowCount = Math.max(r1, r2) + 1;
	                    columnCount = Math.max(c1, c2) + 1;
	                } else if (rc.length === 1) {
	                    r1 = IndexHelper._getRowIndexInNumber(rc[0]);
	                    c1 = IndexHelper._getColumnIndexInNumber(rc[0]);
	                    rowCount = r1 + 1;
	                    columnCount = c1 + 1;
	                }
	                readerDataModel._setDimensions(sheetName, rowCount, columnCount);
	            }
	        }
	    }
	    function readSheetViews(reader, sheetName, readerDataModel) {
	        readerDataModel._resetActivePaneType();
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'sheetView') {
	                readSheetViewAttr(reader, sheetName, readerDataModel);
	                if (reader.elementType === 3 ) {
	                    continue;
	                }
	                var sheetViewDepth = reader.depth;
	                while (reader.read()) {
	                    if (reader.depth <= sheetViewDepth) {
	                        break;
	                    }
	                    if (reader.nodeType() === 1 ) {
	                        if (reader.name() === 'selection') {
	                            var rowActive = -1, columnActive = -1, refCount = 0, rowFirst = [], rowLast = [],
	                                colFirst = [], colLast = [], ranges = [], activeCell = '', paneType = 3 ;
	                            while (reader.moveToNextAttribute()) {
	                                switch (reader.readAttributeNameAsString()) {
	                                    case 'sqref':
	                                        ranges = reader.readContentAsString().split(' ');
	                                        break;
	                                    case 'activeCellId':
	                                       
	                                        break;
	                                    case 'activeCell':
	                                        activeCell = reader.readContentAsString();
	                                        break;
	                                    case 'pane':
	                                        var pane = reader.readContentAsString();
	                                        if (pane && excel.PaneType[pane] !== undefined) {
	                                            paneType = excel.PaneType[pane];
	                                        }
	                                        break;
	                                    default:
	                                        break;
	                                }
	                            }
	                            for (var i = 0, len1 = ranges.length; i < len1; i++) {
	                                var qref = ranges[i].split(':');
	                                if (qref.length === 1) {
	                                    var rowIndex = IndexHelper._getRowIndexInNumber(qref[0]);
	                                    var colIndex = IndexHelper._getColumnIndexInNumber(qref[0]);
	                                    rowFirst.push(rowIndex);
	                                    rowLast.push(rowIndex);
	                                    colFirst.push(colIndex);
	                                    colLast.push(colIndex);
	                                    refCount++;
	                                } else if (qref.length === 2) {
	                                    rowFirst.push(IndexHelper._getRowIndexInNumber(qref[0]));
	                                    colFirst.push(IndexHelper._getColumnIndexInNumber(qref[0]));
	                                    rowLast.push(IndexHelper._getRowIndexInNumber(qref[1]));
	                                    colLast.push(IndexHelper._getColumnIndexInNumber(qref[1]));
	                                    refCount++;
	                                }
	                            }
	                            if (activeCell) {
	                                rowActive = IndexHelper._getRowIndexInNumber(activeCell);
	                                columnActive = IndexHelper._getColumnIndexInNumber(activeCell);
	                            }
	    
	                            readerDataModel._setSelection(sheetName, paneType, rowActive, columnActive, refCount, rowFirst, rowLast, colFirst, colLast);
	                        } else if (reader.name() === 'pane') {
	                            var state = null, isFrozen = false, activePane = 3 , xSplit = 0, ySplit = 0;
	                            while (reader.moveToNextAttribute()) {
	                                switch (reader.readAttributeNameAsString()) {
	                                    case 'xSplit':
	                                        xSplit = reader.readContentAsInt(0);
	                                        break;
	                                    case 'ySplit':
	                                        ySplit = reader.readContentAsInt(0);
	                                        break;
	                                    case 'state':
	                                        state = reader.readContentAsString();
	                                        if (state && (state === 'frozen' || state === 'frozenSplit')) {
	                                            isFrozen = true;
	                                        }
	                                        break;
	                                    case 'activePane':
	                                        pane = reader.readContentAsString();
	                                        if (pane && excel.PaneType[pane] !== undefined) {
	                                            activePane = excel.PaneType[pane];
	                                        }
	                                        break;
	                                    default:
	                                        break;
	                                }
	                            }
	                            readerDataModel._setActivePaneType(activePane);
	                            readerDataModel._setPane(sheetName, xSplit, ySplit, isFrozen);
	                        }
	                    }
	                }
	            }
	        }
	    }
	    function readSheetViewAttr(reader, sheetName, readerDataModel) {
	        var gridLineColor = null, showGridLine = true, showRowColHeaders = true, zoom = 100,
	            topLeftCell = 'A1';
	        while (reader.moveToNextAttribute()) {
	            switch (reader.readAttributeNameAsString()) {
	                case 'colorId':
	                    var colorId = reader.readContentAsInt(-1);
	                    if (colorId >= 0) {
	                        gridLineColor = new ExcelColor(1 , colorId, 0.0);
	                    }
	                    break;
	                case 'showGridLines':
	                    showGridLine = reader.readContentAsBoolean();
	                    break;
	                case 'showRowColHeaders':
	                    showRowColHeaders = reader.readContentAsBoolean();
	                    break;
	                case 'zoomScale':
	                    zoom = reader.readContentAsDouble(100);
	                    break;
	                case 'topLeftCell':
	                    topLeftCell = reader.readContentAsString();
	                    break;
	                default:
	                    break;
	            }
	        }
	        readerDataModel._setDisplayElements(sheetName, gridLineColor, showGridLine, showRowColHeaders, zoom);
	        readerDataModel._sheetViewTopLeftCell = topLeftCell;
	    }
	    function readSheetFormatProperties(reader, sheetName, readerDataModel) {
	        var height = NaN, defaultColumnWidth = NaN, baseColumnWidth = 8;
	        var defaultRowHeight = 15;
	        while (reader.moveToNextAttribute()) {
	            if (reader.readAttributeNameAsString() === 'defaultRowHeight') {
	                height = reader.readContentAsDouble(NaN);
	            } else if (reader.readAttributeNameAsString() === 'baseColWidth') {
	                baseColumnWidth = reader.readContentAsDouble(8);
	            } else if (reader.readAttributeNameAsString() === 'defaultColWidth') {
	                defaultColumnWidth = reader.readContentAsDouble(NaN);
	            }
	        }
	        if (!isNaN(height)) {
	            readerDataModel._setDefaultRowHeight(sheetName, height);
	            defaultRowHeight = height;
	        }
	        readerDataModel._setDefaultColumnWidth(sheetName, baseColumnWidth, defaultColumnWidth);
	        return defaultRowHeight;
	    }
	    function readColumnInfo(reader, sheetName, readerDataModel, cellStyleXfsLength) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'col') {
	                var colFirst = 0, colLast = 0, ixf = 0, width = 0, outlineLevel = 0, hidden = false, collapsed = false;
	                while (reader.moveToNextAttribute()) {
	                    switch (reader.readAttributeNameAsString()) {
	                        case 'min':
	                            colFirst = reader.readContentAsInt(0) - 1;
	                            break;
	                        case 'max':
	                            colLast = reader.readContentAsInt(0) - 1;
	                            break;
	                        case 'style':
	                            ixf = reader.readContentAsInt(0);
	                            break;
	                        case 'width':
	                            width = reader.readContentAsDouble(8);
	                            break;
	                        case 'hidden':
	                            hidden = reader.readContentAsBoolean(false);
	                            break;
	                        case 'collapsed':
	                            collapsed = reader.readContentAsBoolean(false);
	                            break;
	                        case 'outlineLevel':
	                            outlineLevel = reader.readContentAsInt(0);
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                if (colFirst >= 0 && colLast >= 0) {
	                    readerDataModel._setColumnInfo(sheetName, colFirst, colLast, ixf + cellStyleXfsLength, width, hidden, outlineLevel, collapsed);
	                }
	            }
	        }
	    }
	    function readMergeCells(reader, sheetName, readerDataModel) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1  && reader.name() === 'mergeCell') {
	                while (reader.moveToNextAttribute()) {
	                    if (reader.readAttributeNameAsString() === 'ref') {
	                        var s = reader.readContentAsString();
	                        var rc = s.split(':');
	                        if (rc.length === 2) {
	                            var startRow = IndexHelper._getRowIndexInNumber(rc[0]), endRow = IndexHelper._getRowIndexInNumber(rc[1]),
	                                startCol = IndexHelper._getColumnIndexInNumber(rc[0]), endCol = IndexHelper._getColumnIndexInNumber(rc[1]);
	                            readerDataModel._setMergeCells(sheetName, startRow, endRow, startCol, endCol);
	                        }
	                    }
	                }
	            }
	        }
	    }
	    function readSheetData(reader, sheetName, readerDataModel, sharedFormula, defaultRowHeight, cellStyleXfsLength, sharedString) {
	        if (reader.elementType !== 3 ) {
	            var sheetDataDepth = reader.depth;
	            readerDataModel._initDataTable(sheetName);
	            var lastReadRow = -1;
	            do {
	                reader.fastRead();
	                if (reader.depth <= sheetDataDepth) {
	                    break;
	                }
	                lastReadRow = readRow(reader, sheetName, sharedFormula, lastReadRow, readerDataModel, defaultRowHeight, cellStyleXfsLength, sharedString);
	            } while (reader.depth > sheetDataDepth);
	            if (readerDataModel._lastReadRow === void 0 || readerDataModel._lastReadRow < lastReadRow) {
	                readerDataModel._lastReadRow = lastReadRow;
	            }
	        }
	
	       
	       
	        readerDataModel._setSheetData(sheetName);
	    }
	    function readRow(reader, sheetName, sharedFormula, lastReadRow, readerDataModel, defaultRowHeight, cellStyleXfsLength, sharedString) {
	        var rowIndex = lastReadRow + 1, ixf = -1, collapsed = false, hidden = false, height = defaultRowHeight, outlineLevel = 0;
	        while (reader.moveToNextAttribute()) {
	            switch (reader.readAttributeNameAsString()) {
	                case 'r':
	                    rowIndex = reader.readContentAsInt(0) - 1;
	                    break;
	                case 'spans':
	                    break;
	                case 's':
	                    ixf = reader.readContentAsInt(-1);
	                    break;
	                case 'collapsed':
	                    collapsed = reader.readContentAsBoolean(false);
	                    break;
	                case 'hidden':
	                    hidden = reader.readContentAsBoolean(false);
	                    break;
	                case 'ht':
	                    height = reader.readContentAsDouble(0);
	                    break;
	                case 'outlineLevel':
	                    outlineLevel = reader.readContentAsInt(0);
	                    break;
	                default:
	                    break;
	            }
	        }
	       
	        if (height > 409.5) {
	            height = defaultRowHeight;
	        }
	        var rowIxf = (ixf === -1 ? -1 : ixf + cellStyleXfsLength);
	        readerDataModel._setRowInfo(sheetName, rowIndex, rowIxf, height, outlineLevel, collapsed, hidden);
	        if (reader.elementType === 3 ) {
	            return rowIndex;
	        }
	        var lastReadColumn = -1;
	        var rowDepth = reader.depth;
	        do {
	            reader.fastRead();
	            if (reader.depth <= rowDepth) {
	                break;
	            }
	            readerDataModel._initRow(sheetName, rowIndex);
	            lastReadColumn = readCell(reader, sheetName, sharedFormula, rowIndex, lastReadColumn, readerDataModel, cellStyleXfsLength, sharedString);
	        } while (reader.depth > rowDepth);
	
	        if (readerDataModel._lastReadColumn === void 0 || readerDataModel._lastReadColumn < lastReadColumn) {
	            readerDataModel._lastReadColumn = lastReadColumn;
	        }
	        return rowIndex;
	    }
	    function processFunction(formula) {
	        var specialFunctionName = '_xlfn.';
	       
	        if (formula && formula.toLowerCase().indexOf(specialFunctionName) >= 0) {
	            return formula.replace(/_xlfn\./gi, '');
	        }
	        return formula;
	    }
	    function readCell(reader, sheetName, sharedFormula, rowIndex, lastReadColumn, readerDataModel, cellStyleXfsLength, sharedString) {
	        var columnIndex = lastReadColumn + 1, dataTypeString = 'n', ixf = 0;
	        while (reader.moveToNextAttribute()) {
	            switch (reader.readAttributeNameAsString()) {
	                case 'r':
	                    columnIndex = IndexHelper._getColumnIndexInNumber(reader.readContentAsString());
	                    break;
	                case 't':
	                    dataTypeString = reader.readContentAsString();
	                    break;
	                case 's':
	                    ixf = reader.readContentAsInt(0);
	                    break;
	                default:
	                    break;
	            }
	        }
	        var formatIndex = ixf + cellStyleXfsLength;
	        readerDataModel._setCellStyle(sheetName, rowIndex, columnIndex, formatIndex);
	        if (reader.elementType === 3 ) {
	            return columnIndex;
	        }
	        var cellDepth = reader.depth;
	        var value = void 0, formula = void 0, arrayFormula = null;
	        do {
	            reader.fastRead();
	            if (reader.depth <= cellDepth) {
	                break;
	            }
	            var c = reader.buffer[reader._nameIndex];
	            if ((reader.elementType & 1 ) === 1 ) {
	                if (c === 'v' && reader.elementType === 1 ) {
	                    var s = reader.readElementContentAsString();
	                    switch (dataTypeString) {
	                        case 'b':
	                            value = s === '1';
	                            break;
	                        case 'd':
	                            value = new Date(s);
	                            break;
	                        case 'e':
	                            var code = keyword_null;
	                            switch (s) {
	                                case '#DIV/0!':
	                                    code = 0x07;
	                                    break;
	                                case '#N/A':
	                                    code = 0x2A;
	                                    break;
	                                case '#NAME?':
	                                    code = 0x1D;
	                                    break;
	                                case '#NULL!':
	                                    code = 0x00;
	                                    break;
	                                case '#NUM!':
	                                    code = 0x24;
	                                    break;
	                                case '#REF!':
	                                    code = 0x17;
	                                    break;
	                                case '#VALUE!':
	                                    code = 0x0F;
	                                    break;
	                                default:
	                                    break;
	                            }
	                            if (code !== keyword_null) {
	                                value = { _error: s, _code: code };
	                            } else {
	                                value = keyword_null;
	                            }
	                            break;
	                        case 'inlineStr':
	                            value = '';
	                            break;
	                        case 'n':
	                            value = parseFloat(s);
	                            break;
	                        case 's':
	                            var sharedStringIndex = parseInt(s);
	                            if (sharedString && sharedStringIndex >= 0 && sharedStringIndex < sharedString.length) {
	                                value = sharedString[sharedStringIndex];
	                            } else {
	                                value = s;
	                            }
	                            break;
	                        case 'str':
	                            value = s;
	                            break;
	                        default:
	                            value = s;
	                            break;
	                    }
	                } else if (c === 'f') {
	                    var formulaTypeString = keyword_null, range = keyword_null, si = keyword_null;
	                    while (reader.moveToNextAttribute()) {
	                        switch (reader.readAttributeNameAsString()) {
	                            case 't':
	                                formulaTypeString = reader.readContentAsString();
	                                break;
	                            case 'ref':
	                                range = reader.readContentAsString();
	                                break;
	                            case 'si':
	                                si = reader.readContentAsString();
	                                break;
	                            default:
	                                break;
	                        }
	                    }
	                    if (reader.elementType === 1 ) {
	                        formula = reader.readElementContentAsString();
	                    }
	                    if (formulaTypeString === 'array') {
	                        var rangeParts = range.split(':');
	                        var firstRow = 0, lastRow = 0, firstCol = 0, lastCol = 0;
	                        firstRow = IndexHelper._getRowIndexInNumber(rangeParts[0]);
	                        firstCol = IndexHelper._getColumnIndexInNumber(rangeParts[0]);
	                        if (rangeParts.length === 1) {
	                            lastRow = firstRow;
	                            lastCol = firstCol;
	                        } else {
	                            lastRow = IndexHelper._getRowIndexInNumber(rangeParts[1]);
	                            lastCol = IndexHelper._getColumnIndexInNumber(rangeParts[1]);
	                        }
	                        arrayFormula = {
	                            row: firstRow,
	                            rowCount: lastRow - firstRow + 1,
	                            col: firstCol,
	                            colCount: lastCol - firstCol + 1
	                        };
	                    } else if (formulaTypeString === 'shared' && si !== keyword_null) {
	                        var index = parseInt(si);
	                        if (formula) {
	                            var sf = { baseFormula: formula };
	                            if (range) {
	                                var token = range.split(':');
	                                if (token.length === 2) {
	                                    lastRow = IndexHelper._getRowIndexInNumber(token[1]);
	                                    var lastColumn = IndexHelper._getColumnIndexInNumber(token[1]);
	                                    sf.baseRow = rowIndex;
	                                    sf.baseColumn = columnIndex;
	                                    sf.isRowShared = (lastRow === sf.baseRow);
	                                    if (sf.isRowShared) {
	                                        sf.count = lastColumn - sf.baseColumn + 1;
	                                    } else {
	                                        sf.count = lastRow - sf.baseRow + 1;
	                                    }
	                                } else {
	                                    sf.baseRow = IndexHelper._getRowIndexInNumber(token[0]);
	                                    sf.baseColumn = IndexHelper._getColumnIndexInNumber(token[0]);
	                                    sf.isRowShared = true;
	                                    sf.count = 1;
	                                }
	                            }
	                            if (sharedFormula[index]) {
	                                throw new Error('sharedFormulaError');
	                            }
	                            sharedFormula[index] = sf;
	                        } else {
	                            sf = sharedFormula[index];
	                            if (sf) {
	                                var columnOffset = columnIndex - sf.baseColumn;
	                                var rowOffset = rowIndex - sf.baseRow;
	                                formula = CalcHelper._getSharedFormula(sf, columnOffset, rowOffset);
	                            }
	                        }
	                    }
	                }
	            }
	        } while (reader.depth > cellDepth);
	        readerDataModel._setCell(sheetName, rowIndex, columnIndex, formatIndex, value, Util._xmlDecode(processFunction(formula)), arrayFormula);
	        return columnIndex;
	    }
	    function readSheetProtection(reader, sheetName, readerDataModel) {
	        var attributeName, protectionOptions = [];
	        while (reader.moveToNextAttribute()) {
	            attributeName = reader.readAttributeNameAsString();
	            if (attributeName === 'sheet') {
	                readerDataModel._setProtect(sheetName, reader.readContentAsBoolean(false));
	            } else {
	                protectionOptions.push({ name: attributeName, value: !reader.readContentAsBoolean(false) });
	            }
	        }
	        readerDataModel._setProtectionOptions(sheetName, protectionOptions);
	    }
	    
	    function readExtensionList(reader, sheetName, readerDataModel) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	            if (reader.nodeType() === 1 ) {
	                var uri, xmlnsx14;
	                if (reader.name() === 'ext') {
	                    while (reader.moveToNextAttribute()) {
	                        switch (reader.readAttributeNameAsString()) {
	                            case 'uri':
	                                uri = reader.readContentAsString();
	                                break;
	                            case 'xmlns:x14':
	                                xmlnsx14 = reader.readContentAsString();
	                        }
	                    }
	                }
	                if (isConditionalFormatElement(uri, xmlnsx14)) {
	                    conditionFormatReader._readExtensionConditionalFormating(reader, sheetName, readerDataModel);
	                }
	                if (isSparklineElement(uri, xmlnsx14)) {
	                    sparklineReader._readSparklineGroups(reader, sheetName, readerDataModel);
	                }
	                if (isValidationElement(uri, xmlnsx14)) {
	                    dataValidatorReader._readExtensionDataValidation(reader, sheetName, readerDataModel);
	                }
	            }
	        }
	    }
	    
	    function isConditionalFormatElement(uri, xmlnsx14) {
	        var uriTrue = uri === '{78C0D931-6437-407d-A8EE-F0AAD7539E65}';
	        var namespaceTrue = xmlnsx14 === 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
	        return uriTrue && namespaceTrue;
	    }
	    
	    function isSparklineElement(uri, xmlnsx14) {
	        var uriTrue = uri === '{05C60535-1F16-4fd2-B633-F4F36F0B64E0}';
	        var namespaceTrue = xmlnsx14 === 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
	        return uriTrue && namespaceTrue;
	    }
	    
	    function isValidationElement(uri, xmlnsx14) {
	        var uriTrue = uri === '{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}';
	        var namespaceTrue = xmlnsx14 === 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
	        return uriTrue && namespaceTrue;
	    }
	    
	    module.exports = readWorksheets;
	
	}());

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var getRangesFromString = __webpack_require__(26)._getRangesFromString;
	    var readColor = __webpack_require__(16);
	    var excelStyle = __webpack_require__(12);
	    var xmlParser = __webpack_require__(7);
	    var parseXmlToObject = xmlParser._parseXmlToObject;
	    var convertObjectToXml = xmlParser._convertObjectToXml;
	    var common = __webpack_require__(4);
	    var XmlNodeHelper = __webpack_require__(11);
	    var readDifferentialFormattingRecord = __webpack_require__(15)._readDifferentialFormattingRecord;
	    var xmlReader = __webpack_require__(8);
	
	    var ColorHelper = excelStyle.ColorHelper;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var getAsArray = XmlNodeHelper._getAsArray;
	    var Util = common._Util;
	    var getValueFromObject = XmlNodeHelper._getValueFromObject;
	    var convertDxfToStyle = excelStyle.ConverterHelper.convertDxfToStyle;
	
	    function getNodeValue(obj, key, subkey) {
	        return Util._xmlDecode(getValueFromObject(obj, key, subkey));
	    }
	
	
	    function readConditionalFormatting(reader, sheetName, readerDataModel) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	
	        var oneConditionalFormat = parseXmlToObject(reader.readFullElement()).conditionalFormatting;
	
	        var conditionalFormat = { rules: [] };
	        var ranges = [];
	        if (oneConditionalFormat._attr.sqref) {
	            ranges = getRangesFromString(oneConditionalFormat._attr.sqref);
	        }
	        if (ranges.length === 0) {
	            return;
	        }
	
	        var excelRules = getAsArray(oneConditionalFormat.cfRule);
	        for (var j = 0; j < excelRules.length; j++) {
	            var rule = readRule(excelRules[j], ranges);
	            if (rule) {
	                conditionalFormat.rules.push(rule);
	            }
	        }
	
	        readerDataModel._addConditionalFormatting(sheetName, conditionalFormat);
	    }
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	    var NormalRuleTypes = {
	        beginsWith: 2 ,
	        endsWith: 2 ,
	        notContainsText: 2 ,
	        containsText: 2 ,
	        expression: 3 ,
	        containsBlanks: 3 ,
	        notContainsBlanks: 3 ,
	        containsErrors: 3 ,
	        notContainsErrors: 3 ,
	        timePeriod: 4 ,
	        today: 4 ,
	        tomorrow: 4 ,
	        yesterday: 4 ,
	        last7Days: 4 ,
	        lastMonth: 4 ,
	        nextMonth: 4 ,
	        thisWeek: 4 ,
	        nextWeek: 4 ,
	        lastWeek: 4 ,
	        thisMonth: 4 ,
	        top10: 5 ,
	        uniqueValues: 6 ,
	        duplicateValues: 7 ,
	        aboveAverage: 8 ,
	        belowAverage: 8 ,
	        aboveOrEqualToAverage: 8 ,
	        belowOrEqualToAverage: 8 
	    };
	
	    var ScaleValueType = {
	        num: 0 ,
	        min: 1 ,
	        max: 2 ,
	        percent: 3 ,
	        percentile: 4 ,
	        stddev: 0 ,
	        formula: 6 ,
	        autoMin: 5 ,
	        autoMax: 7 
	    };
	    var IconSetTypes = {
	        $3Arrows: 0 ,
	        $3ArrowsGray: 1 ,
	        $3Flags: 4 ,
	        $3TrafficLights1: 5 ,
	        $3TrafficLights2: 6 ,
	        $3Signs: 7 ,
	        $3Symbols: 8 ,
	        $3Symbols2: 9 ,
	        $4Arrows: 10 ,
	        $4ArrowsGray: 11 ,
	        $4RedToBlack: 12 ,
	        $4Rating: 13 ,
	        $4TrafficLights: 14 ,
	        $5Arrows: 15 ,
	        $5ArrowsGray: 16 ,
	        $5Rating: 17 ,
	        $5Quarters: 18 ,
	        $3Stars: 3 ,
	        $3Triangles: 2 ,
	        $5Boxes: 19 ,
	        $NoIcons: 20 
	    };
	    var IconValueTypes = {
	        num: 1,
	        percent: 4,
	        formula: 7,
	        percentile: 5
	    };
	    var ComparisonOperators = {
	        equal: 0,
	        notEqual: 1,
	        greaterThan: 2,
	        greaterThanOrEqual: 3,
	        lessThan: 4,
	        lessThanOrEqual: 5,
	        between: 6,
	        notBetween: 7
	    };
	
	
	    function addEqualSign(val) {
	        if (val && val.charAt(0) !== '=') {
	            return '=' + val;
	        }
	        return val;
	    }
	
	    function readRule(cfRule, ranges) {
	        var rule = { priority: 0, ranges: ranges }, ruleType;
	
	        var ruleAttributes = cfRule._attr;
	        if (!isNullOrUndefined(ruleAttributes.type)) {
	            ruleType = ruleAttributes.type;
	        }
	        if (!isNullOrUndefined(ruleAttributes.priority)) {
	            rule.priority = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.priority, 0);
	        }
	
	        var ruleChildNodes;
	        switch (ruleType) {
	            case 'colorScale':
	                ruleChildNodes = readRuleChilds(cfRule.colorScale);
	                rule.minType = ScaleValueType[ruleChildNodes._cfvoArray[0].type];
	               
	                rule.minValue = addEqualSign(ruleChildNodes._cfvoArray[0].val);
	                rule.minColor = ruleChildNodes._colorArray[0];
	                if (ruleChildNodes._cfvoArray.length === 3) {
	                    rule.ruleType = 11 ;
	                    rule.midType = ScaleValueType[ruleChildNodes._cfvoArray[1].type];
	                    rule.midValue = addEqualSign(ruleChildNodes._cfvoArray[1].val);
	                    rule.midColor = ruleChildNodes._colorArray[1];
	                    rule.maxType = ScaleValueType[ruleChildNodes._cfvoArray[2].type];
	                    rule.maxValue = addEqualSign(ruleChildNodes._cfvoArray[2].val);
	                    rule.maxColor = ruleChildNodes._colorArray[2];
	                } else {
	                    rule.ruleType = 10 ;
	                    rule.maxType = ScaleValueType[ruleChildNodes._cfvoArray[1].type];
	                    rule.maxValue = addEqualSign(ruleChildNodes._cfvoArray[1].val);
	                    rule.maxColor = ruleChildNodes._colorArray[1];
	                }
	                break;
	            case 'dataBar':
	                rule.ruleType = 12 ;
	                var dataBar = cfRule.dataBar;
	                if (!isNullOrUndefined(dataBar._attr.showValue)) {
	                    rule.showBarOnly = !XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(dataBar._attr.showValue, true);
	                }
	                ruleChildNodes = readRuleChilds(dataBar);
	                rule.minType = ScaleValueType[ruleChildNodes._cfvoArray[0].type];
	                rule.minValue = addEqualSign(ruleChildNodes._cfvoArray[0].val);
	                rule.maxType = ScaleValueType[ruleChildNodes._cfvoArray[1].type];
	                rule.maxValue = addEqualSign(ruleChildNodes._cfvoArray[1].val);
	                rule.color = ruleChildNodes._colorArray[0];
	                break;
	            case 'iconSet':
	                rule.ruleType = 13 ;
	                rule.iconSetType = IconSetTypes.$3TrafficLights1;
	                var iconSet = cfRule.iconSet;
	                var iconSetAttributes = iconSet._attr;
	                if (!isNullOrUndefined(iconSetAttributes.iconSet)) {
	                    rule.iconSetType = IconSetTypes['$' + iconSetAttributes.iconSet];
	                }
	                if (!isNullOrUndefined(iconSetAttributes.showValue)) {
	                    rule.showIconOnly = !XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.showValue, true);
	                }
	                if (!isNullOrUndefined(iconSetAttributes.reverse)) {
	                    rule.reverseIconOrder = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.reverse, false);
	                }
	
	                rule.iconCriteria = readCriteria(iconSet);
	                break;
	            case 'cellIs':
	                rule.ruleType = 1 ;
	                var cellIsAttributes = cfRule._attr;
	                if (!isNullOrUndefined(cellIsAttributes.stopIfTrue)) {
	                    rule.stopIfTrue = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cellIsAttributes.stopIfTrue, false);
	                }
	                if (!isNullOrUndefined(cellIsAttributes.dxfId)) {
	                    rule.dxfId = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(cellIsAttributes.dxfId, -1);
	                }
	                if (!isNullOrUndefined(cellIsAttributes.operator)) {
	                    rule.operator = ComparisonOperators[cellIsAttributes.operator];
	                }
	
	                var formulas = getAsArray(cfRule.formula);
	                rule.value1 = '=' + Util._xmlDecode(formulas[0].formula);
	                if (formulas.length === 2) {
	                    rule.value2 = '=' + Util._xmlDecode(formulas[1].formula);
	                }
	                break;
	            default:
	                rule.ruleType = NormalRuleTypes[ruleType];
	                if (!isNullOrUndefined(ruleAttributes.dxfId)) {
	                    rule.dxfId = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.dxfId, -1);
	                }
	                if (!isNullOrUndefined(ruleAttributes.aboveAverage)) {
	                    rule.aboveAverage = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.aboveAverage, true);
	                    if (!rule.aboveAverage && ruleType === 'aboveAverage') {
	                        ruleType = 'belowAverage';
	                    }
	                }
	                if (!isNullOrUndefined(ruleAttributes.bottom)) {
	                    rule.bottom = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.bottom, false);
	                }
	                if (!isNullOrUndefined(ruleAttributes.equalAverage)) {
	                    var equalAverage = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.equalAverage, false);
	                    if (equalAverage) {
	                        if (ruleType === 'aboveAverage') {
	                            ruleType = 'aboveOrEqualToAverage';
	                        }
	                        if (ruleType === 'belowAverage') {
	                            ruleType = 'belowOrEqualToAverage';
	                        }
	                    }
	                }
	                if (!isNullOrUndefined(ruleAttributes.operator)) {
	                    rule.operator = ruleAttributes.operator;
	                }
	                if (!isNullOrUndefined(ruleAttributes.percent)) {
	                    rule.percent = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.percent, false);
	                }
	                if (!isNullOrUndefined(ruleAttributes.rank)) {
	                    rule.rank = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.rank, 0);
	                }
	                if (!isNullOrUndefined(ruleAttributes.stdDev)) {
	                    rule.stdDev = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.stdDev, 0);
	                }
	                if (!isNullOrUndefined(ruleAttributes.stopIfTrue)) {
	                    rule.stopIfTrue = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.stopIfTrue, false);
	                }
	                if (!isNullOrUndefined(ruleAttributes.text)) {
	                    rule.text = Util._xmlDecode(ruleAttributes.text);
	                }
	                if (!isNullOrUndefined(ruleAttributes.timePeriod)) {
	                    ruleType = ruleAttributes.timePeriod;
	                }
	                if (!isNullOrUndefined(cfRule.formula)) {
	                    rule.formula = getNodeValue(cfRule, 'formula');
	                }
	                rule = convertNormalRuleToSpreadJSRule(rule, ruleType);
	                break;
	        }
	
	        if (cfRule.extLst && cfRule.extLst.ext && cfRule.extLst.ext['x14:id']) {
	            rule.id = getNodeValue(cfRule.extLst.ext, 'x14:id');
	        }
	        return rule;
	    }
	
	    function convertNormalRuleToSpreadJSRule(rule, ruleType) {
	        switch (ruleType) {
	            case 'expression':
	            case 'containsBlanks':
	            case 'notContainsBlanks':
	            case 'containsErrors':
	            case 'notContainsErrors':
	               
	                return rule;
	            case 'top10':
	                var range = rule.ranges[0];
	                var top10Rule = {
	                    ruleType: rule.ruleType,
	                    dxfId: rule.dxfId,
	                    rank: rule.rank,
	                    stopIfTrue: rule.stopIfTrue,
	                    priority: rule.priority,
	                    ranges: rule.ranges
	                };
	               
	                top10Rule.type = 0 ;
	                if (rule.bottom) {
	                    top10Rule.type = 1 ;
	                }
	                if (rule.percent) {
	                    var rank = Math.floor((range.rowCount * range.colCount) * rule.rank / 100);
	                    if (rank === 0) {
	                        rank = 1;
	                    }
	                    top10Rule.rank = rank;
	                }
	                return top10Rule;
	           
	            case 'uniqueValues':
	            case 'duplicateValues':
	                return rule;
	            case 'containsText':
	                rule.operator = 0;
	                
	                return rule;
	            case 'aboveAverage':
	            case 'belowAverage':
	            case 'aboveOrEqualToAverage':
	            case 'belowOrEqualToAverage':
	                
	                var averageType = 0 , above = true;
	                if (ruleType === 'belowAverage') {
	                    above = false;
	                    averageType = 1 ;
	                }
	                if (ruleType === 'belowOrEqualToAverage') {
	                    above = false;
	                    averageType = 3 ;
	                }
	                if (ruleType === 'aboveOrEqualToAverage') {
	                    averageType = 2 ;
	                }
	                if (!isNullOrUndefined(rule.stdDev)) {
	                    var stdDev = rule.stdDev;
	                    if (above) {
	                        if (stdDev === 1) {
	                            averageType = 4 ;
	                        } else if (stdDev === 2) {
	                            averageType = 6 ;
	                        } else if (stdDev === 3) {
	                            averageType = 8 ;
	                        }
	                    } else if (stdDev === 1) {
	                        averageType = 5 ;
	                    } else if (stdDev === 2) {
	                        averageType = 7 ;
	                    } else if (stdDev === 3) {
	                        averageType = 9 ;
	                    }
	                }
	                rule.type = averageType;
	                return rule;
	            case 'beginsWith':
	                
	                rule.operator = 2 ;
	                return rule;
	            case 'endsWith':
	                rule.operator = 3 ;
	                return rule;
	            case 'notContainsText':
	                rule.operator = 1 ;
	                return rule;
	            case 'timePeriod':
	            case 'today':
	            case 'tomorrow':
	            case 'yesterday':
	            case 'last7Days':
	            case 'lastMonth':
	            case 'nextMonth':
	            case 'thisWeek':
	            case 'nextWeek':
	            case 'lastWeek':
	            case 'thisMonth':
	                var DateOccurringType = {
	                    today: 0,
	                    yesterday: 1,
	                    tomorrow: 2,
	                    last7Days: 3,
	                    thisMonth: 4,
	                    lastMonth: 5,
	                    nextMonth: 6,
	                    thisWeek: 7,
	                    lastWeek: 8,
	                    nextWeek: 9
	                };
	                rule.type = 0 ;
	                if (DateOccurringType[ruleType]) {
	                    rule.type = DateOccurringType[ruleType];
	                }
	                return rule;
	            default:
	                return rule;
	        }
	    }
	
	    function readCriteria(node) {
	        var iconCriteria = [];
	        var ruleChildNodes = readRuleChilds(node);
	       
	        for (var i = 1; i < ruleChildNodes._cfvoArray.length; i++) {
	            var criteria = { isGreaterThanOrEqualTo: true };
	            if (ruleChildNodes._cfvoArray[i].gte === false) {
	                criteria.isGreaterThanOrEqualTo = ruleChildNodes._cfvoArray[i].gte;
	            }
	            criteria.iconValueType = IconValueTypes[ruleChildNodes._cfvoArray[i].type];
	           
	            criteria.iconValue = addEqualSign(ruleChildNodes._cfvoArray[i].val);
	            iconCriteria.push(criteria);
	        }
	        return iconCriteria;
	    }
	
	    function readIcons(node) {
	        var iconInfos = [];
	        var ruleChildNodes = readRuleChilds(node);
	        for (var i = 0; i < ruleChildNodes._cfIconArray.length; i++) {
	            var iconInfo = {};
	            iconInfo.iconSetType = ruleChildNodes._cfIconArray[i].iconSetType;
	            iconInfo.iconIndex = ruleChildNodes._cfIconArray[i].iconIndex;
	            iconInfos.push(iconInfo);
	        }
	        return iconInfos;
	    }
	
	    function readCfvo(cfvoNode) {
	        var cfvo = {};
	        if (!isNullOrUndefined(cfvoNode._attr.type)) {
	            cfvo.type = cfvoNode._attr.type;
	        }
	        if (!isNullOrUndefined(cfvoNode._attr.val)) {
	            cfvo.val = cfvoNode._attr.val;
	        }
	        if (!isNullOrUndefined(cfvoNode._attr.gte)) {
	            cfvo.gte = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfvoNode._attr.gte, true);
	        }
	        if (cfvoNode['xm:f']) {
	            cfvo.val = getNodeValue(cfvoNode, 'xm:f');
	        }
	        return cfvo;
	    }
	
	    function readCfIcon(cfIconNode) {
	        var cfIcon = {};
	        if (!isNullOrUndefined(cfIconNode._attr.iconSet)) {
	            cfIcon.iconSetType = IconSetTypes['$' + cfIconNode._attr.iconSet];
	        }
	        if (!isNullOrUndefined(cfIconNode._attr.iconId)) {
	            cfIcon.iconIndex = cfIconNode._attr.iconId;
	        }
	        return cfIcon;
	    }
	
	    function readRuleChilds(ruleNode) {
	        var ruleChildNodes = { _cfvoArray: [], _colorArray: [], _cfIconArray: [] };
	
	        var cfvos = getAsArray(ruleNode.cfvo || ruleNode['x14:cfvo']);
	        var cfIcons = getAsArray(ruleNode['x14:cfIcon']);
	        for (var i = 0; i < cfvos.length; i++) {
	            var cfvo = readCfvo(cfvos[i]);
	            ruleChildNodes._cfvoArray.push(cfvo);
	        }
	        for (i = 0; i < cfIcons.length; i++) {
	            var cfIcon = readCfIcon(cfIcons[i]);
	            ruleChildNodes._cfIconArray.push(cfIcon);
	        }
	        if (ruleNode.color) {
	            var colors = getAsArray(ruleNode.color || ruleNode['x14:color']);
	            for (var j = 0; j < colors.length; j++) {
	                ruleChildNodes._colorArray.push(ColorHelper.toRGBColor(readColor(colors[j])));
	            }
	        }
	
	        return ruleChildNodes;
	    }
	
	    function readExtensionConditionalFormating(reader, sheetName, readerDataModel) {
	        var ext = parseXmlToObject(reader.readFullElement()).ext;
	        var type, id;
	        if (ext['x14:conditionalFormattings'] && ext['x14:conditionalFormattings']['x14:conditionalFormatting']) {
	            var conditionalFormatings = getAsArray(ext['x14:conditionalFormattings']['x14:conditionalFormatting']);
	            for (var i = 0; i < conditionalFormatings.length; i++) {
	                var oneConditionalFormat = conditionalFormatings[i];
	                var cfRules = getAsArray(oneConditionalFormat['x14:cfRule']);
	                for (var j = 0; j < cfRules.length; j++) {
	                    var cfRule = cfRules[j];
	                    var cfRuleAttributes = cfRule._attr;
	                    if (!isNullOrUndefined(cfRuleAttributes.type)) {
	                        type = cfRuleAttributes.type;
	                    }
	                    id = cfRuleAttributes.id;
	                    var rule = getRuleById(readerDataModel, sheetName, id);
	                    if (cfRuleAttributes.priority) {
	                        rule.priority = cfRuleAttributes.priority;
	                    }
	                    if (type === 'dataBar') {
	                        rule.ruleType = 12 ;
	                        readExtensionDataBarRule(cfRule['x14:dataBar'], rule);
	                    } else if (type === 'iconSet') {
	                        rule.ruleType = 13 ;
	                        readExtensionIconSetRule(cfRule['x14:iconSet'], rule);
	                    } else if (type === 'expression') {
	                        rule.ruleType = 3;
	                        
	                        readExtensionFormulaRule(cfRule, rule, readerDataModel);
	                    }
	                    if (oneConditionalFormat['xm:sqref']) {
	                        var ranges = getRangesFromString(getNodeValue(oneConditionalFormat, 'xm:sqref'));
	                        if (rule) {
	                            rule.ranges = ranges;
	                        }
	                    }
	                }
	            }
	        }
	    }
	
	    function getRuleById(readerDataModel, sheetName, id) {
	        var conditionalFormatting = readerDataModel._getConditionalFormatting(sheetName);
	        if (!conditionalFormatting) {
	            conditionalFormatting = { rules: [] };
	        }
	        if (!isNullOrUndefined(id)) {
	            var rules = conditionalFormatting.rules;
	            if (rules && rules.length > 0) {
	                for (var i = 0; i < rules.length; i++) {
	                    if (rules[i].id === id) {
	                        return rules[i];
	                    }
	                }
	            }
	        }
	        var newRule = {};
	        readerDataModel._addConditionalFormatting(sheetName, { rules: [newRule] });
	        return newRule;
	    }
	
	    var DataBarAxisPositions = {
	        automatic: 0,
	        middle: 1,
	        none: 2
	    };
	
	    function readExtensionFormulaRule(cfRule, rule, readerDataModel) {
	        rule.formula = addEqualSign(getNodeValue(cfRule, 'xm:f'));
	        var dxfXml = convertObjectToXml(cfRule['x14:dxf'], 'x14:dxf');
	        var reader = new xmlReader();
	        reader.setXml(dxfXml);
	        reader.read();
	        var dxf = readDifferentialFormattingRecord(reader);
	        rule.style = convertDxfToStyle(dxf, readerDataModel._headingFont, readerDataModel._bodyFont);
	    }
	
	    function readExtensionDataBarRule(dataBar, rule) {
	        var cfRuleAttributes = dataBar._attr;
	        if (!isNullOrUndefined(cfRuleAttributes.showValue)) {
	            rule.showBarOnly = !XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.showValue, true);
	        }
	        if (!isNullOrUndefined(cfRuleAttributes.border)) {
	            rule.showBorder = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.border, false);
	        }
	        if (!isNullOrUndefined(cfRuleAttributes.gradient)) {
	            rule.gradient = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.gradient, true);
	        }
	        if (!isNullOrUndefined(cfRuleAttributes.direction)) {
	            rule.dataBarDirection = cfRuleAttributes.direction === 'rightToLeft' ? 1 : 0 ;
	        }
	        if (!isNullOrUndefined(cfRuleAttributes.axisPosition)) {
	            rule.axisPosition = DataBarAxisPositions[cfRuleAttributes.axisPosition];
	        }
	        if (!isNullOrUndefined(cfRuleAttributes.negativeBarColorCommunityBuyeAsPositive)) {
	            rule.useNegativeFillColor = !XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.negativeBarColorCommunityBuyeAsPositive, false);
	        }
	        if (!isNullOrUndefined(cfRuleAttributes.negativeBarBorderColorCommunityBuyeAsPositive)) {
	            rule.useNegativeBorderColor = !XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.negativeBarBorderColorCommunityBuyeAsPositive, true);
	        }
	        var cfvoList = [];
	        if (dataBar['x14:cfvo']) {
	            getAsArray(dataBar['x14:cfvo']).forEach(function (value) {
	                cfvoList.push(readCfvo(value));
	            });
	        }
	        if (dataBar['x14:fillColor']) {
	            rule.color = ColorHelper.toRGBColor(readColor(dataBar['x14:fillColor']));
	        }
	        if (dataBar['x14:borderColor']) {
	            rule.borderColor = ColorHelper.toRGBColor(readColor(dataBar['x14:borderColor']));
	        }
	        if (dataBar['x14:negativeFillColor']) {
	            rule.negativeFillColor = ColorHelper.toRGBColor(readColor(dataBar['x14:negativeFillColor']));
	        }
	        if (dataBar['x14:negativeBorderColor']) {
	            rule.negativeBorderColor = ColorHelper.toRGBColor(readColor(dataBar['x14:negativeBorderColor']));
	        }
	        if (dataBar['x14:axisColor']) {
	            rule.axisColor = ColorHelper.toRGBColor(readColor(dataBar['x14:axisColor']));
	        }
	        if (cfvoList.length === 2) {
	            rule.minType = ScaleValueType[cfvoList[0].type];
	            rule.minValue = addEqualSign(cfvoList[0].val);
	            rule.maxType = ScaleValueType[cfvoList[1].type];
	            rule.maxValue = addEqualSign(cfvoList[1].val);
	        }
	    }
	
	    function readExtensionIconSetRule(iconSet, rule) {
	        var iconSetAttributes = iconSet._attr;
	        if (!isNullOrUndefined(iconSetAttributes.iconSet)) {
	            rule.iconSetType = IconSetTypes['$' + iconSetAttributes.iconSet];
	        }
	        if (!isNullOrUndefined(iconSetAttributes.showValue)) {
	            rule.showIconOnly = !XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.showValue, true);
	        }
	        if (!isNullOrUndefined(iconSetAttributes.reverse)) {
	            rule.reverseIconOrder = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.reverse, false);
	        }
	        rule.iconCriteria = readCriteria(iconSet);
	        rule.icons = readIcons(iconSet);
	    }
	
	    exports._readConditionalFormatting = readConditionalFormatting;
	    exports._readExtensionConditionalFormating = readExtensionConditionalFormating;
	
	}());

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var XmlNodeHelper = __webpack_require__(11);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var readColor = __webpack_require__(16);
	    var common = __webpack_require__(4);
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var getRangesFromString = __webpack_require__(26)._getRangesFromString;
	    var excelStyle = __webpack_require__(12);
	    var nodeHelper = __webpack_require__(11);
	    var ColorHelper = excelStyle.ColorHelper;
	    var getAsArray = nodeHelper._getAsArray;
	    
	    function readSparklineGroups(reader, sheetName, readerDataModel) {
	        if (reader.elementType === 3 ) {
	            return;
	        }
	        var sparklineGroups = [];
	        var depth = reader.depth;
	        while (reader.read()) {
	            if (reader.depth <= depth) {
	                break;
	            }
	    
	            if (reader.nodeType() === 1  && reader.name() === 'x14:sparklineGroup') {
	                var sparklineGroup = readSparklineGroup(parseXmlToObject(reader.readFullElement())[reader.name()], sheetName);
	                if (sparklineGroup.sparklines && sparklineGroup.sparklines.length > 0) {
	                    sparklineGroups.push(sparklineGroup);
	                }
	            }
	        }
	        readerDataModel._setSparkLineGroups(sparklineGroups, sheetName);
	    }
	    
	    var ExcelSparklineEmptyCellDisplayAs = {
	       
	        span: 2, 
	       
	        gap: 0,
	       
	        zero: 1
	    };
	    
	    var ExcelSparklineType = {
	       
	        line: 0,
	       
	        column: 1,
	       
	        stacked: 2 
	    };
	    
	    var ExcelSparklineAxisMinMax = {
	       
	       
	       
	        individual: 0,
	       
	       
	       
	        group: 1,
	       
	       
	        custom: 2
	    };
	    
	    function readSparklineGroup(node, sheetName) {
	        if (isNullOrUndefined(node)) {
	            return;
	        }
	        var sparklineGroup = {setting: {}};
	       
	        sparklineGroup.sparklineType = 0;
	        var attr = node._attr;
	        if (!isNullOrUndefined(attr)) {
	            if (!isNullOrUndefined(attr.manualMax)) {
	                sparklineGroup.setting.manualMax = XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.manualMax, 0.0);
	            }
	            if (!isNullOrUndefined(attr.manualMin)) {
	                sparklineGroup.setting.manualMin = XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.manualMin, 0.0);
	            }
	            if (!isNullOrUndefined(attr.lineWeight)) {
	                sparklineGroup.setting.lineWeight = XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.lineWeight, 1) * 4 / 3.0;
	            }
	            if (!isNullOrUndefined(attr.type)) {
	                sparklineGroup.sparklineType = ExcelSparklineType[attr.type] || 0;
	            }
	            if (!isNullOrUndefined(attr.dateAxis)) {
	                sparklineGroup.displayDateAxis = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.dateAxis, false);
	            }
	            if (!isNullOrUndefined(attr.displayEmptyCellsAs)) {
	                sparklineGroup.setting.displayEmptyCellsAs = ExcelSparklineEmptyCellDisplayAs[attr.displayEmptyCellsAs] || 0;
	            }
	            if (!isNullOrUndefined(attr.markers)) {
	                sparklineGroup.setting.showMarkers = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.markers, false);
	            }
	            if (!isNullOrUndefined(attr.high)) {
	                sparklineGroup.setting.showHigh = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.high, false);
	            }
	            if (!isNullOrUndefined(attr.low)) {
	                sparklineGroup.setting.showLow = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.low, false);
	            }
	            if (!isNullOrUndefined(attr.first)) {
	                sparklineGroup.setting.showFirst = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.first, false);
	            }
	            if (!isNullOrUndefined(attr.last)) {
	                sparklineGroup.setting.showLast = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.last, false);
	            }
	            if (!isNullOrUndefined(attr.negative)) {
	                sparklineGroup.setting.showNegative = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.negative, false);
	            }
	            if (!isNullOrUndefined(attr.displayXAxis)) {
	                sparklineGroup.setting.displayXAxis = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.displayXAxis, false);
	            }
	            if (!isNullOrUndefined(attr.displayHidden)) {
	                sparklineGroup.setting.displayHidden = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.displayHidden, false);
	            }
	            if (!isNullOrUndefined(attr.rightToLeft)) {
	                sparklineGroup.setting.rightToLeft = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.rightToLeft, false);
	            }
	            if (!isNullOrUndefined(attr.minAxisType)) {
	                sparklineGroup.setting.minAxisType = ExcelSparklineAxisMinMax[attr.minAxisType] || 0;
	            }
	            if (!isNullOrUndefined(attr.maxAxisType)) {
	                sparklineGroup.setting.maxAxisType = ExcelSparklineAxisMinMax[attr.maxAxisType] || 0;
	            }
	    
	        }
	        if (!isNullOrUndefined(node['x14:colorSeries'])) {
	            sparklineGroup.setting.seriesColor = convertColor(readColor(node['x14:colorSeries'])) || "rgba(36,64,98,255)";
	        }
	        if (!isNullOrUndefined(node['x14:colorNegative'])) {
	            sparklineGroup.setting.negativeColor = convertColor(readColor(node['x14:colorNegative'])) || "Brown";
	        }
	        if (!isNullOrUndefined(node['x14:colorAxis'])) {
	            sparklineGroup.setting.axisColor = convertColor(readColor(node['x14:colorAxis'])) || "Black";
	        }
	        if (!isNullOrUndefined(node['x14:colorMarkers'])) {
	            sparklineGroup.setting.markersColor = convertColor(readColor(node['x14:colorMarkers'])) || "rgba(36,64,98,255)";
	        }
	        if (!isNullOrUndefined(node['x14:colorFirst'])) {
	            sparklineGroup.setting.firstMarkerColor = convertColor(readColor(node['x14:colorFirst'])) || "rgba(149,179,215,255)";
	        }
	        if (!isNullOrUndefined(node['x14:colorLast'])) {
	            sparklineGroup.setting.lastMarkerColor = convertColor(readColor(node['x14:colorLast'])) || "rgba(149,179,215,255)";
	        }
	        if (!isNullOrUndefined(node['x14:colorHigh'])) {
	            sparklineGroup.setting.highMarkerColor = convertColor(readColor(node['x14:colorHigh'])) || "Blue";
	        }
	        if (!isNullOrUndefined(node['x14:colorLow'])) {
	            sparklineGroup.setting.lowMarkerColor = convertColor(readColor(node['x14:colorLow'])) || "Blue";
	        }
	        if (!isNullOrUndefined(node['xm:f'])) {
	            var xmfObj = node['xm:f'];
	            var rangeStringArray = xmfObj['xm:f'].split('!');
	            sparklineGroup.axisReference = getRangesFromString(rangeStringArray[1])[0] || null;
	            if (rangeStringArray[0] !== sheetName) {
	                sparklineGroup.axisReference.sheetName = rangeStringArray[0];
	            }
	        }
	        if (!isNullOrUndefined(node['x14:sparklines'])) {
	            sparklineGroup.sparklines = readSparklines(node['x14:sparklines'], sheetName);
	        }
	        var axisReference = sparklineGroup.axisReference;
	        if (sparklineGroup.displayDateAxis && axisReference) {
	           
	           
	           
	           
	            sparklineGroup.axisOrientation = axisReference.rowCount === 1 ? 1  : 0 ;
	        }
	        return sparklineGroup;
	    }
	    
	    function readSparklines(sparklinesNode, sheetName) {
	        var sparklines = [];
	        var node = sparklinesNode && sparklinesNode['x14:sparkline'];
	        var sparklineArray = getAsArray(node);
	        sparklineArray.forEach(function (sparklineObj) {
	            var dataRange, location;
	            if (!isNullOrUndefined(sparklineObj['xm:f'])) {
	                var xmfObj = sparklineObj['xm:f'];
	                var rangeStringArray = xmfObj['xm:f'].split('!');
	                dataRange = getRangesFromString(rangeStringArray[1])[0] || null;
	            }
	            if (!isNullOrUndefined(sparklineObj['xm:sqref'])) {
	                var xmsqrefObj = sparklineObj['xm:sqref'];
	                location = getRangesFromString(xmsqrefObj['xm:sqref'])[0] || null;
	            }
	            if (!isNullOrUndefined(dataRange) && !isNullOrUndefined(location)) {
	                var sparkline = {};
	                sparkline.row = location.row;
	                sparkline.col = location.col;
	                sparkline.orientation = dataRange.rowCount === 1 ? 1 : 0;
	                sparkline.data = dataRange;
	                if (rangeStringArray && rangeStringArray[0] !== sheetName) {
	                    sparkline.data.sheetName = rangeStringArray[0];
	                }
	                sparklines.push(sparkline);
	            }
	        });
	        return sparklines;
	    }
	    
	    function convertColor(excelColor) {
	        var color;
	        if (excelColor.isThemeColor()) {
	            color = ColorHelper.getThemeColorName(excelColor);
	        } else {
	            color = ColorHelper.toRGBColor(excelColor);
	        }
	        return color;
	    }
	    
	    exports._readSparklineGroups = readSparklineGroups;
	
	}());

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var StringEx = __webpack_require__(4)._StringEx;
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var getRangesFromString = __webpack_require__(26)._getRangesFromString;
	    var XmlNodeHelper = __webpack_require__(11);
	    
	    var getAttrValueOrDefaultOfBooleanType = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType,
	        getAttrValueOrDefaultOfDoubleType = XmlNodeHelper._getAttrValueOrDefaultOfDoubleType,
	        getAttributeValueOrDefaultOfIntType = XmlNodeHelper._getAttributeValueOrDefaultOfIntType,
	        getAsArray = XmlNodeHelper._getAsArray;
	    var isNullOrWhiteSpace = StringEx._isNullOrWhiteSpace;
	    
	
	    var DynamicFilterType = {          
	        null: -1,
	       
	        aboveAverage: 100,
	       
	        belowAverage: 101,
	       
	        tomorrow: 2,
	       
	        today: 0,
	       
	        yesterday: 1,
	       
	        nextWeek: 9,
	       
	        thisWeek: 7,
	       
	        lastWeek: 8,
	       
	        nextMonth: 6,
	       
	        thisMonth: 4,
	       
	        lastMonth: 5,
	       
	        nextQuarter: 10,
	       
	        thisQuarter: 11,
	       
	        lastQuarter: 12,
	       
	        nextYear: 13,
	       
	        thisYear: 14,
	       
	        lastYear : 15,
	       
	        yearToDate : 16,
	       
	        Q1: 17,
	       
	        Q2: 18,
	       
	        Q3: 19,
	       
	        Q4: 20,
	       
	        M1: 21,
	       
	        M2: 22,
	       
	        M3: 23,
	       
	        M4: 24,
	       
	        M5: 25,
	       
	        M6: 26,
	       
	        M7: 27,
	       
	        M8: 28,
	       
	        M9: 29,
	       
	        M10: 30,
	       
	        M11: 31,
	       
	        M12: 32
	    };
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    
	    function readColorFilter(colorFilterNode) {
	        var colorFilter = {};
	        colorFilter.cellColor = getAttrValueOrDefaultOfBooleanType(colorFilterNode._attr.cellColor, true);
	        colorFilter.dxfId = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(colorFilterNode._attr.dxfId, 0);
	        return colorFilter;
	    }
	    function readFilters(filtersNode) {
	        var filters = {};
	        filters.filter = [];
	        filters.blank = filtersNode._attr.blank;
	        var filtersArrayNode = getAsArray(filtersNode.filter);
	        filtersArrayNode.forEach(function (filterItemNode) {
	            filters.filter.push(filterItemNode._attr.val);
	        });
	        filters.dateGroupItem = [];
	        var dateGroupArrayNode = getAsArray(filtersNode.dateGroupItem);
	        dateGroupArrayNode.forEach(function (dateGroupItemNode) {
	            var dateItem = {}, attr = dateGroupItemNode._attr;
	            dateItem.day = getAttributeValueOrDefaultOfIntType(attr.day, 1);
	            dateItem.hour = getAttributeValueOrDefaultOfIntType(attr.hour, 0);
	            dateItem.minute = getAttributeValueOrDefaultOfIntType(attr.minute, 0);
	            dateItem.month = getAttributeValueOrDefaultOfIntType(attr.month, 0);
	            dateItem.second = getAttributeValueOrDefaultOfIntType(attr.second, 0);
	            dateItem.year = getAttributeValueOrDefaultOfIntType(attr.year, 0);
	            filters.dateGroupItem.push(dateItem);
	        });
	        return filters;
	    }
	    function readCustomFilters(customFiltersNode) {
	        var customFilters = {};
	        var and = customFiltersNode._attr.and;
	        if (!isNullOrWhiteSpace(and)) {
	            customFilters.and = (and === '1');
	        }
	        var customFiltersArrayNode = getAsArray(customFiltersNode.customFilter);
	        if (customFiltersArrayNode.length > 0) {
	            var filter1 = customFilters.filter1 = {};
	            filter1.operator = customFiltersArrayNode[0]._attr.operator;
	            filter1.value = customFiltersArrayNode[0]._attr.val;
	        }
	        if (customFiltersArrayNode.length > 1) {
	            var filter2 = customFilters.filter2 = {};
	            filter2.operator = customFiltersArrayNode[1]._attr.operator;
	            filter2.value = customFiltersArrayNode[1]._attr.val;
	        }
	        return customFilters;
	    }
	    function readDynamicFilter(dynamicFilterNode) {
	        var dynamicFilter = {};
	        dynamicFilter.type = DynamicFilterType[dynamicFilterNode._attr.type];
	        var valStr = dynamicFilterNode._attr.val;
	        var maxValStr = dynamicFilterNode._attr.maxVal;
	        if (!isNullOrWhiteSpace(valStr)) {
	            dynamicFilter.value = valStr;
	        }
	        if (!isNullOrWhiteSpace(maxValStr)) {
	            dynamicFilter.maxValue = maxValStr;
	        }
	        return dynamicFilter;
	    }
	    function readTop10Filter(top10FilterNode) {
	        var top10Filter = {};
	        top10Filter.value = getAttrValueOrDefaultOfDoubleType(top10FilterNode._attr.val, NaN);
	        top10Filter.percent = getAttrValueOrDefaultOfBooleanType(top10FilterNode._attr.percent, false);
	        top10Filter.top = getAttrValueOrDefaultOfBooleanType(top10FilterNode._attr.top, true);
	        return top10Filter;
	    }
	    
	    function readSortInfo(sortNode) {
	        var sortInfo = {};
	        var attr = sortNode.sortCondition._attr;
	        if (attr) {
	            sortInfo.ascending = !attr.descending;
	            sortInfo.index = getRangesFromString(attr.ref)[0].col;
	            if(attr.sortBy === 'fontColor' || attr.sortBy === 'cellColor') {
	                sortInfo.isBackColor = (attr.sortBy === 'cellColor' );
	                sortInfo.dxfId = getAttributeValueOrDefaultOfIntType(attr.dxfId, 0);
	            }
	        }
	        return sortInfo;
	    }
	    exports._readSortInfo = readSortInfo;
	    function readAutoFilter(autoFilterNode) {
	        var autoFilter = {};
	    
	        var refInA1Style = autoFilterNode._attr.ref.toUpperCase();
	        if (!refInA1Style || refInA1Style === '#REF!') {
	            return null;
	        }
	        var ranges = getRangesFromString(refInA1Style);
	        if (ranges[0]) {
	            autoFilter.range = ranges[0];
	        }
	        autoFilter.filterColumns = [];
	        var filterColumnsNode = getAsArray(autoFilterNode.filterColumn);
	        filterColumnsNode.forEach(function (filterColumnNode) {
	            var filterColumn = {};
	            var colId = filterColumnNode._attr.colId;
	            filterColumn.hiddenButton = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(filterColumnNode._attr.hiddenButton, false);
	            if (!isNullOrWhiteSpace(colId)) {
	                filterColumn.autoFilterColumnId = parseInt(colId);
	            }
	            if (filterColumnNode.colorFilter) {
	                filterColumn.colorFilter = readColorFilter(filterColumnNode.colorFilter);
	            }
	            if (filterColumnNode.filters) {
	                filterColumn.filters = readFilters(filterColumnNode.filters);
	            }
	            if (filterColumnNode.customFilters) {
	                filterColumn.customFilters = readCustomFilters(filterColumnNode.customFilters);
	            }
	            if (filterColumnNode.dynamicFilter) {
	                filterColumn.dynamicFilter = readDynamicFilter(filterColumnNode.dynamicFilter);
	            }
	            if (filterColumnNode.top10) {
	                filterColumn.top10Filter = readTop10Filter(filterColumnNode.top10);
	            }
	            autoFilter.filterColumns.push(filterColumn);
	        });
	        return autoFilter;
	    }
	    exports._readAutoFilter = readAutoFilter;
	    function readAutoFilterForSheet(reader, sheetName, readerDataModel) {
	        var autoFilterNode = parseXmlToObject(reader.readFullElement()).autoFilter;
	        var autoFilter = readAutoFilter(autoFilterNode);
	        if (autoFilterNode.sortState) {
	            autoFilter.sortInfo = readSortInfo(autoFilterNode.sortState);
	        }
	        readerDataModel._setAutoFilter(sheetName, autoFilter);
	    }
	    exports._readAutoFilterForSheet = readAutoFilterForSheet;
	
	}());

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var XmlNodeHelper = __webpack_require__(11);
	    var getRangesFromString = __webpack_require__(26)._getRangesFromString;
	    
	    var getAttrValueOrDefaultOfBooleanType = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var Util = common._Util, xmlDecode = Util._xmlDecode;
	    
	    function getNodeValue(obj, key, subkey) {
	        return xmlDecode(XmlNodeHelper._getValueFromObject(obj, key, subkey));
	    }
	    
	    var ExcelDataValidationType = {
	       
	        none: 0, 
	       
	        whole: 1, 
	       
	        decimal: 2, 
	       
	        list: 3,
	       
	        date: 4,
	       
	        time: 5,
	       
	        textLength: 6,
	       
	        custom: 7
	    };
	    var ExcelDataValidationErrorStyle = {
	       
	        stop: 0,
	       
	        warning: 1,
	       
	        information: 2
	    };
	    var ExcelDataValidationOperator = {
	       
	        between: 6,
	       
	        notBetween: 7,
	       
	        equal: 0,
	       
	        notEqual: 1,
	       
	        greaterThan: 2,
	       
	        lessThan: 4,
	       
	        greaterThanOrEqual: 3,
	       
	        lessThanOrEqual: 5
	    };
	    
	    function readDataValidation(dataValidationNode, sheetName, readerDataModel, isExtensionRecord) {
	        if (isNullOrUndefined(dataValidationNode) || isNullOrUndefined(sheetName)) {
	            return;
	        }
	        var attr = dataValidationNode._attr;
	    
	        var dataValidation = {
	            type: ExcelDataValidationType[attr.type] || 0 ,
	            errorType: ExcelDataValidationErrorStyle[attr.errorStyle] || 0 ,
	            compareOperator: isNullOrUndefined(ExcelDataValidationOperator[attr.operator]) ? 6  : ExcelDataValidationOperator[attr.operator],
	            allowBlank: getAttrValueOrDefaultOfBooleanType(attr.allowBlank, false),
	            showPromptBox: !getAttrValueOrDefaultOfBooleanType(attr.showDropDown, false),
	            showInputMessage: getAttrValueOrDefaultOfBooleanType(attr.showInputMessage, false),
	            showErrorMessage: getAttrValueOrDefaultOfBooleanType(attr.showErrorMessage, false),
	            errorTitle: xmlDecode(attr.errorTitle),
	            error: xmlDecode(attr.error),
	            promptTitle: xmlDecode(attr.promptTitle),
	            prompt: xmlDecode(attr.prompt)
	        };
	        dataValidation.error = Util._decodeSpecialCharacterFromXML(dataValidation.error);
	        dataValidation.prompt = Util._decodeSpecialCharacterFromXML(dataValidation.prompt);
	        var rangeString, firstFormula, secondFormula;
	        if(isExtensionRecord) {
	            rangeString = getNodeValue(dataValidationNode, 'xm:sqref');
	            var firstFormulaElement = dataValidationNode['x14:formula1'];
	            var secondFormulaElement = dataValidationNode['x14:formula2'];
	            if(firstFormulaElement) {
	                firstFormula = getNodeValue(firstFormulaElement, 'xm:f');
	            }
	            if(secondFormulaElement) {
	                secondFormula = getNodeValue(secondFormulaElement, 'xm:f');
	            }
	        } else {
	            rangeString = attr.sqref;
	            firstFormula = getNodeValue(dataValidationNode, 'formula1');
	            secondFormula = getNodeValue(dataValidationNode, 'formula2');
	        }
	        dataValidation.firstFormula = firstFormula;
	        dataValidation.secondFormula = secondFormula;
	        dataValidation.ranges = getRangesFromString(rangeString);
	        readerDataModel._setDataValidation(sheetName, dataValidation);
	    }
	    
	    function readDataValidations(reader, sheetName, readerDataModel) {
	        var dataValidationsNode = parseXmlToObject(reader.readFullElement()).dataValidations;
	        var dataValidationArrayNode = XmlNodeHelper._getAsArray(dataValidationsNode.dataValidation);
	        dataValidationArrayNode.forEach(function (dataValidationNode) {
	            readDataValidation(dataValidationNode, sheetName, readerDataModel);
	        });
	    }
	    exports._readDataValidations = readDataValidations;
	    
	    function readExtensionDataValidation(reader, sheetName, readerDataModel) {
	        var ext = parseXmlToObject(reader.readFullElement()).ext;
	        var dataValidationsNode = ext['x14:dataValidations'];
	        var dataValidationArrayNode = XmlNodeHelper._getAsArray(dataValidationsNode['x14:dataValidation']);
	        dataValidationArrayNode.forEach(function (dataValidationNode) {
	            readDataValidation(dataValidationNode, sheetName, readerDataModel, true);
	        });
	    }
	    exports._readExtensionDataValidation = readExtensionDataValidation;
	
	}());

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var excel = __webpack_require__(21);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var XmlNodeHelper = __webpack_require__(11);
	    var getImageContent = __webpack_require__(23).getImageContent;
	    var RelationshipConstants = excel._RelationshipConstants;
	    
	    var getAttrValueOrDefaultOfBooleanType = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType,
	        getAttributeValueOrDefaultOfIntType = XmlNodeHelper._getAttributeValueOrDefaultOfIntType,
	        getValueFromObject = XmlNodeHelper._getValueFromObject,
	        getAsArray = XmlNodeHelper._getAsArray;
	    var xmlDecode = common._Util._xmlDecode;
	    var parseFloatFunc = parseFloat;
	    
	    var ExcelPrintPageOrder = {
	        auto: 0,
	        downThenOver: 1,
	        overThenDown: 2
	    };
	    var ExcelPrintOrientation = {
	        auto: 0,
	        portrait: 1,
	        landscape: 2
	    };
	    var PrintHFImage = {
	        LH: 0,
	        CH: 1,
	        RH: 2,
	        LF: 3,
	        CF: 4,
	        RF: 5
	    };
	    
	    function readPageMargins(reader, sheetName, readerDataModel) {
	        var pageMarginsNode = parseXmlToObject(reader.readFullElement()).pageMargins;
	        if (pageMarginsNode) {
	            var attr = pageMarginsNode._attr;
	            readerDataModel._setPrintPageMargin(sheetName, {
	                left: parseFloatFunc(attr.left),
	                right: parseFloatFunc(attr.right),
	                top: parseFloatFunc(attr.top),
	                bottom: parseFloatFunc(attr.bottom),
	                header: parseFloatFunc(attr.header),
	                footer: parseFloatFunc(attr.footer)
	            });
	        }
	    }
	    exports._readPageMargins = readPageMargins;
	    
	    function readPrintOptions(reader, sheetName, readerDataModel) {
	        var printOptionsNode = parseXmlToObject(reader.readFullElement()).printOptions;
	        if (printOptionsNode) {
	            var attr = printOptionsNode._attr;
	            readerDataModel._setPrintOption(sheetName, {
	                printGridLine: getAttrValueOrDefaultOfBooleanType(attr.gridLines, false) && getAttrValueOrDefaultOfBooleanType(attr.gridLinesSet, true),
	                horizontalCentered: getAttrValueOrDefaultOfBooleanType(attr.horizontalCentered, false),
	                verticalCentered: getAttrValueOrDefaultOfBooleanType(attr.verticalCentered, false),
	                printRowColumnsHeaders: getAttrValueOrDefaultOfBooleanType(attr.headings, false)
	            });
	        }
	    }
	    exports._readPrintOptions = readPrintOptions;
	    
	    function readPageSetup(reader, readerDataModel) {
	        var pageSetupNode = parseXmlToObject(reader.readFullElement()).pageSetup;
	        if (pageSetupNode) {
	            var attr = pageSetupNode._attr;
	            var excelPrintPageSetting = readerDataModel._excelPrintPageSetting;
	            var paperSize = parseInt(attr.paperSize);
	            excelPrintPageSetting.showColor = !getAttrValueOrDefaultOfBooleanType(attr.blackAndWhite, false);
	            excelPrintPageSetting.copies = getAttributeValueOrDefaultOfIntType(attr.copies, 1);
	            excelPrintPageSetting.draft = getAttrValueOrDefaultOfBooleanType(attr.draft, false);
	            excelPrintPageSetting.useCustomStartingPage = getAttrValueOrDefaultOfBooleanType(attr.useFirstPageNumber, false);
	            excelPrintPageSetting.firstPageNumber = getAttributeValueOrDefaultOfIntType(attr.firstPageNumber, 1);
	            excelPrintPageSetting.smartPrintPagesHeight = getAttributeValueOrDefaultOfIntType(attr.fitToHeight, 1);
	            excelPrintPageSetting.smartPrintPagesWidth = getAttributeValueOrDefaultOfIntType(attr.fitToWidth, 1);
	            excelPrintPageSetting.pageOrder = ExcelPrintPageOrder[attr.pageOrder] || 0 ;
	            excelPrintPageSetting.paperSizeIndex = typeof paperSize === 'number' ? paperSize : 1 ;
	            excelPrintPageSetting.zoomFactor = XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.scale, 100) / 100;
	            excelPrintPageSetting.orientation = ExcelPrintOrientation[attr.orientation] || 0 ;
	        }
	    }
	    exports._readPageSetup = readPageSetup;
	    
	    function readPageSetupAdditionalProperty(reader, readerDataModel) {
	        var pageSetUpPrNode = parseXmlToObject(reader.readFullElement()).pageSetUpPr;
	        if (pageSetUpPrNode) {
	            readerDataModel._excelPrintPageSetting.useSmartPrint = getAttrValueOrDefaultOfBooleanType(pageSetUpPrNode._attr.fitToPage, false);
	        }
	    }
	    exports._readPageSetupAdditionalProperty = readPageSetupAdditionalProperty;
	    
	    function readHeaderFooter(reader, readerDataModel) {
	        var headerFooterNode = parseXmlToObject(reader.readFullElement()).headerFooter;
	        if (headerFooterNode) {
	            var attr = headerFooterNode._attr;
	            var advancedHeadFooterSetting = readerDataModel._excelPrintPageSetting.advancedHeadFooterSetting = {
	                headerFooterAlignWithPageMargin: getAttrValueOrDefaultOfBooleanType(attr.alignWithMargins, true),
	                headerFooterDifferentFirstPage: getAttrValueOrDefaultOfBooleanType(attr.differentFirst, false)
	            };
	            if (advancedHeadFooterSetting.headerFooterDifferentFirstPage) {
	                advancedHeadFooterSetting.headerFirstPage = headerFooterNode.firstHeader;
	                advancedHeadFooterSetting.footerFirstPage = headerFooterNode.firstFooter;
	            }
	           
	           
	            var headerFooterDifferentOddEvenPages = advancedHeadFooterSetting.headerFooterDifferentOddEvenPages = getAttrValueOrDefaultOfBooleanType(attr.differentOddEven, false);
	            var oddHeader = xmlDecode(getValueFromObject(headerFooterNode, 'oddHeader')), oddFooter = xmlDecode(getValueFromObject(headerFooterNode, 'oddFooter'));
	            advancedHeadFooterSetting.headerEvenPage = headerFooterDifferentOddEvenPages ? xmlDecode(getValueFromObject(headerFooterNode, 'evenHeader')) : oddHeader;
	            advancedHeadFooterSetting.footerEvenPage = headerFooterDifferentOddEvenPages ? xmlDecode(getValueFromObject(headerFooterNode, 'evenFooter')) : oddFooter;
	            advancedHeadFooterSetting.headerOddPage = oddHeader;
	            advancedHeadFooterSetting.footerOddPage = oddFooter;
	            advancedHeadFooterSetting.headerFooterScalesWithDocument = getAttrValueOrDefaultOfBooleanType("scaleWithDoc", true);
	        }
	    }
	    exports._readHeaderFooter = readHeaderFooter;
	    
	    function readRowColumnBreaks(reader, readerDataModel, isRowBreaks) {
	        var nodeObject = parseXmlToObject(reader.readFullElement());
	        var breaksNode = isRowBreaks ? nodeObject.rowBreaks : nodeObject.colBreaks;
	        var breaksArray = [];
	        var brkNodeArray = getAsArray(breaksNode.brk);
	        brkNodeArray.forEach(function (brkNode) {
	            if (brkNode) {
	                var brk = getAttributeValueOrDefaultOfIntType(brkNode._attr.id, 0);
	                if (brk > 0) {
	                    breaksArray.push(brk);
	                }
	            }
	        });
	        if (isRowBreaks) {
	            readerDataModel._excelPrintPageSetting.rowBreakLines = breaksArray;
	        } else {
	            readerDataModel._excelPrintPageSetting.columnBreakLines = breaksArray;
	        }
	    }
	    exports._readRowColumnBreaks = readRowColumnBreaks;
	    
	    function readLegacyDrawingHF(reader, readerDataModel) {
	        var legacyDrawingHF = parseXmlToObject(reader.readFullElement()).legacyDrawingHF;
	        if (legacyDrawingHF) {
	            readerDataModel._legacyDrawingHFId = legacyDrawingHF._attr['r:id'];
	        }
	    }
	    exports._readLegacyDrawingHF = readLegacyDrawingHF;
	    
	    function readVMLDrawingRelatedImage(relationFiles) {
	        var imageFileNames = {}, rid;
	        for (rid in relationFiles) {
	            if (relationFiles.hasOwnProperty(rid)) {
	                var relationFile = relationFiles[rid], fileType = relationFile.fileType;
	                if (fileType === RelationshipConstants._relationshipImageType || fileType === RelationshipConstants._relationshipImageType2) {
	                    imageFileNames[rid] = relationFile.fileName;
	                }
	            }
	        }
	        return imageFileNames;
	    }
	    function readHeaderFooterImage(readerDataModel, hfPos, imageString) {
	        if (!imageString) {
	            return;
	        }
	        var excelPrintPageSetting = readerDataModel._excelPrintPageSetting;
	        if (!excelPrintPageSetting.advancedHeadFooterSetting) {
	            excelPrintPageSetting.advancedHeadFooterSetting = {};
	        }
	        var advancedHeadFooterSetting = excelPrintPageSetting.advancedHeadFooterSetting;
	        switch (hfPos) {
	            case PrintHFImage.CH:
	                advancedHeadFooterSetting.headerCenterImage = imageString;
	                break;
	            case PrintHFImage.RH:
	                advancedHeadFooterSetting.headerRightImage = imageString;
	                break;
	            case PrintHFImage.LF:
	                advancedHeadFooterSetting.footerLeftImage = imageString;
	                break;
	            case PrintHFImage.CF:
	                advancedHeadFooterSetting.footerCenterImage = imageString;
	                break;
	            case PrintHFImage.RF:
	                advancedHeadFooterSetting.footerRightImage = imageString;
	                break;
	            case PrintHFImage.LH:
	            default:
	                advancedHeadFooterSetting.headerLeftImage = imageString;
	                break;
	        }
	    }
	    function readVmlDrawing(relationFiles, readerDataModel, getFileDataAndCleanData) {
	        if (relationFiles && readerDataModel._legacyDrawingHFId) {
	            var relationFile = relationFiles[readerDataModel._legacyDrawingHFId];
	            if (relationFile && relationFile.fileType === RelationshipConstants._relationshipVMLDrawingType) {
	                var imagesArray = readVMLDrawingRelatedImage(relationFile.relationFiles);
	                var vmlDrawingFileString = getFileDataAndCleanData(relationFile.fileName);
	                var root = parseXmlToObject(vmlDrawingFileString).xml;
	                var shapeArray = getAsArray(root['v:shape']);
	                shapeArray.forEach(function (item) {
	                    var hfPos = item._attr.id, imageId = item['v:imagedata']._attr['o:relid'];
	                    var imageFileName = imagesArray[imageId];
	                    if (imageFileName) {
	                        var imageString = getImageContent(imageFileName, getFileDataAndCleanData);
	                        if (imageString) {
	                            readHeaderFooterImage(readerDataModel, PrintHFImage[hfPos], imageString);
	                        }
	                    }
	                });
	            }
	            readerDataModel._legacyDrawingHFId = '';
	        }
	    }
	    exports._readVmlDrawing = readVmlDrawing;
	
	}());

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excel = __webpack_require__(21);
	    var common = __webpack_require__(4);
	    var nodeHelper = __webpack_require__(11);
	    var excelStyle = __webpack_require__(12);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var readColor = __webpack_require__(16);
	    var IndexHelper = common._IndexHelper;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var RelationshipConstants = excel._RelationshipConstants;
	    var getAsArray = nodeHelper._getAsArray;
	    var getValueFromObject = nodeHelper._getValueFromObject;
	    var xmlDecode = common._Util._xmlDecode;
	    
	    var ArrayFind = [].find;
	    
	    function readComments(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
	        if (relationFiles) {
	            var commentFile, commentShapeFile;
	    
	            for(var key in relationFiles) {
	                if (key !== 'count') {
	                    var relationFile = relationFiles[key];
	                    if (relationFile) {
	                        var fileType = relationFile.fileType;
	                        if (fileType === RelationshipConstants._relationshipCommentType) {
	                            commentFile = relationFile;
	                        } else if (fileType === RelationshipConstants._relationshipVMLDrawingType) {
	                            commentShapeFile = relationFile;
	                        }
	                        if (commentFile && commentShapeFile) {
	                            break;
	                        }
	                    }
	                }
	            }
	            if (commentFile && commentShapeFile) {
	                var comments = readCommentsFromFile(commentFile, commentShapeFile, getFileDataAndCleanData);
	                readerDataModel._setComments(comments, sheetName);
	            }
	        }
	    }
	    
	    function readCommentsFromFile(commentFile, commentShapeFile, getFileDataAndCleanData) {
	        var comments = [];
	        var dataString = getFileDataAndCleanData(commentFile.fileName);
	    
	        if (dataString) {
	            readComment(dataString, comments);
	    
	            dataString = getFileDataAndCleanData(commentShapeFile.fileName);
	            readCommentShape(dataString, comments);    
	        }
	    
	        return comments;
	    }
	
	    function getComment(comments, row, col) {
	        function isMatch(comment) {
	            return comment.row === row && comment.col === col;
	        }
	
	        if (ArrayFind) {
	            return ArrayFind.call(comments, isMatch);
	        }
	
	        return comments.filter(isMatch)[0];
	    }
	
	    function readCommentShape(dataString, comments) {
	        var obj = parseXmlToObject(dataString),
	            root = obj.xml,
	            shapes = getAsArray(root['v:shape']);
	    
	        if (shapes) {
	            shapes.forEach(function(shape) {
	                var clientdata = shape['x:ClientData'], row, col, comment, value;
	    
	                if (clientdata) {
	                    row = parseInt(getValueFromObject(clientdata, 'x:Row'));
	                    col = parseInt(getValueFromObject(clientdata, 'x:Column'));
	    
	                    if (isNaN(row) || isNaN(col)) {
	                        return;
	                    }
	    
	                    comment = getComment(comments, row, col);
	    
	                    if (!comment) {
	                        return;
	                    }
	    
	                    var shapeAttr = shape._attr;
	                    value = shapeAttr.fillcolor;
	                    if (value) {
	                        comment.backColor = value;
	                    }
	                    value = shapeAttr.strokecolor;
	                    if (value) {
	                        comment.borderColor = value;
	                    }
	                    value = shapeAttr.strokeweight;
	                    if (value) {
	                        comment.borderWidth = value;
	                    }
	                    value = shapeAttr.style;
	                    if (value) {
	                        readCommentStyle(comment, value);
	                    }
	                    value = shape['v:fill'];
	                    if (value) {
	                        var opacity = value._attr.opacity;
	                        if (opacity) {
	                            if (opacity.substr(-1) === 'f') {  
	                                comment.opacity = parseFloat(opacity.substr(0, opacity.length - 1)) / 65535;
	                            } else {
	                                comment.opacity = parseFloat(opacity);
	                            }
	                        }
	                    }
	                    value = shape['v:stroke'];
	                    if (value) {
	                        comment.dashStyle = value._attr.dashstyle;
	                        comment.lineStyle = value._attr.linestyle;
	                    }
	                    value = shape['v:textbox'];
	                    if (value) {
	                        var textboxStyle = value._attr.style;
	                        if (textboxStyle && textboxStyle.indexOf('mso-fit-shape-to-text:t') !== -1) {
	                            comment.autoSize = true;
	                        }
	                        comment.inset = value._attr.inset;
	                    }
	                    if (clientdata['x:SizeWithCells']) {
	                        comment.dynamicSize = false;
	                    }
	                    if (clientdata['x:MoveWithCells']) {
	                        comment.dynamicMove = false;
	                    }
	                    value = getValueFromObject(clientdata, 'x:Anchor');
	                    if (value) {
	                        var anchorItems = value.split(',').map((function(s) { return parseInt(s); }));
	                        comment.anchor = anchorItems;  
	                    }
	                    value = getValueFromObject(clientdata, 'x:Locked');
	                    if (value) {
	                        comment.locked = convertToBoolean(value, true);
	                    }
	                    value = getValueFromObject(clientdata, 'x:LockText');
	                    if (value) {
	                        comment.lockText = convertToBoolean(value, true);
	                    }
	                    value = getValueFromObject(clientdata, 'x:TextHAlign');
	                    if (value) {
	                        comment.hAlign = value.toLowerCase();
	                    }
	                    if (clientdata['x:Visible']) {
	                        comment.displayMode = 1; 
	                    }
	                }
	            });
	        }
	    
	        function convertToBoolean(str, defaultValue) {
	            if (str) {
	                var value = str.trim().toLowerCase();
	                
	                if (['false'].indexOf(value) !== -1) {
	                    return false;
	                } else if (['true'].indexOf(value) !== -1) {
	                    return true;
	                }
	            }
	    
	            return defaultValue;
	        }
	        
	        function getKeyValuePair(value, separator) {
	            var pair = (value || '').trim().split(separator);
	            return { key: pair[0], value: pair[1] };
	        }
	
	        function readCommentStyle(comment, styleString) {
	            var styles = styleString.split(';');
	            styles.forEach(function (style) {
	                var pair = getKeyValuePair(style, ':'), 
	                    key = pair.key,
	                    value = pair.value;
	    
	                if (!isNullOrUndefined(value)) {
	                    switch(key) {
	                        case 'margin-left':
	                            comment.marginLeft = convertUnitToPT(value);
	                            break;
	                        case 'margin-top':
	                            comment.marginTop = convertUnitToPT(value);
	                            break;
	                        case 'width':
	                            comment.width = value;
	                            break;
	                        case 'height':
	                            comment.height = value;
	                            break;
	                       
	                       
	                       
	                        case 'z-index':
	                            comment.zIndex = parseInt(value);
	                            break;
	                    }
	                }
	            });
	        }
	    }
	    
	    function convertUnitToPT(value) {
	        var dpi = 96, pointPerInch = 72, cm = 37.7952755905512;
	        try {
	            if (value.indexOf("pt") !== -1) {
	                return parseFloat(value.replace("pt", ""));
	            } else if (value.indexOf("in") !== -1) {
	                return parseFloat(value.replace("in", "")) * pointPerInch;
	            } else if (value.indexOf("cm") !== -1) {
	                return parseFloat(value.replace("cm", "")) * cm * pointPerInch / dpi;
	            }
	    
	            return parseFloat(value);
	        } catch (e) {
	            return 0;
	        }
	    }
	    
	    function readComment(dataString, comments) {
	        var obj = parseXmlToObject(dataString), 
	            list = obj.comments && obj.comments.commentList;
	    
	        if (list) {
	            var items = getAsArray(list.comment);
	    
	            items.forEach(function(item) {
	                var comment = {},
	                    ref = item._attr.ref;
	    
	                comment.row = IndexHelper._getRowIndexInNumber(ref);
	                comment.col = IndexHelper._getColumnIndexInNumber(ref);
	    
	                readCommentText(comment, item.text);
	                
	                comments.push(comment);
	            });
	        }
	    }
	    
	    function readCommentText(comment, text) {
	        if (text) {
	            var items = getAsArray(text.r),
	                needReadFont = items.length === 1,  
	                segments = [];
	    
	            items.forEach(function(item) {
	                var rPr = item.rPr, value;
	                if (rPr && needReadFont) {
	                    value = rPr.rFont && rPr.rFont._attr.val;
	                    if (value) {
	                        comment.fontFamily = value;
	                    }
	                    var textDecoration = 0;
	    
	                    if (rPr.u) {
	                        var underLineValue = rPr.u && rPr.u._attr.val, underLineStyle = 1;
	                        if (underLineValue) {
	                            underLineStyle = excelStyle.UnderLineStyle[underLineValue];
	                        }
	                        if (underLineStyle === 2) {
	                            textDecoration |= 8;
	                        } else {
	                            textDecoration |= 1;
	                        }
	                    }
	                    if (rPr.strike) {
	                        textDecoration |= 2;
	                    }
	                    if (textDecoration) {
	                        comment.textDecoration = textDecoration;
	                    }
	                    if (rPr.b) {
	                        comment.fontWeight = 'bold';
	                    }
	                    if (rPr.i) {
	                        comment.fontStyle = 'italic';
	                    }
	                    value = rPr.color;
	                    if (value) {
	                        var foreColor = readColor(value);
	                       
	                       
	                       
	                        if (!(foreColor.colorType() === 1  && foreColor.value() === 81)) {
	                            comment.foreColor = foreColor;
	                        }
	                    }
	                    value = rPr.sz && rPr.sz._attr.val;
	                    if (value) {
	                        comment.fontSize = value + 'pt';
	                    }
	                }
	                segments.push(getValueFromObject(item, 't'));
	            });
	            comment.text = xmlDecode(segments.join(''));
	        }
	    }
	    
	    module.exports = readComments;
	
	}());

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excel = __webpack_require__(21);
	    var nodeHelper = __webpack_require__(11);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var excelStyle = __webpack_require__(12);
	    var getImageContent = __webpack_require__(23).getImageContent;
	    var XmlReader = __webpack_require__(8);
	    var DrawingReaderClass = __webpack_require__(38);
	    
	    var RelationshipConstants = excel._RelationshipConstants;
	    var getAsArray = nodeHelper._getAsArray;
	    var readXY = nodeHelper._readXY;
	    var readSize = nodeHelper._readSize;
	    var readAnchorPoint = nodeHelper._readAnchorPoint;
	    var ColorHelper = excelStyle.ColorHelper;
	    var ExcelColor = excelStyle.ExcelColor;
	    var ExcelSystemColor = excelStyle.ExcelSystemColor;
	    var Color = excelStyle._Color;
	    var UnitHelper = excelStyle.UnitHelper;
	
	    function readDrawings(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
	        if (relationFiles) {
	            var drawingFiles = [];
	    
	            for (var key in relationFiles) {
	                if (key !== 'count') {
	                    var relationFile = relationFiles[key];
	                    if (relationFile) {
	                        var fileType = relationFile.fileType;
	                        if (fileType === RelationshipConstants._relationshipDrawingType || fileType === RelationshipConstants._relationshipDrawingType2) {
	                            drawingFiles.push(relationFile);
	                        }
	                    }
	                }
	            }
	            if (drawingFiles.length) {
	                var drawingInfo = readDrawingInfoFromFile(drawingFiles, getFileDataAndCleanData);
	                if(drawingInfo) {
	                    if (drawingInfo.pictures) {
	                        readerDataModel._addPictures(drawingInfo.pictures, sheetName);
	                    }
	                    if (drawingInfo.charts) {
	                        readerDataModel._addCharts(drawingInfo.charts, sheetName);
	                    }
	                }
	            }
	        }
	    }
	    
	    function readDrawingInfoFromFile(drawingFiles, getFileDataAndCleanData) {
	        var drawingRelationFiles = {}, drawingInfo;
	        drawingFiles.forEach(function (file) {
	            var relationFiles = file.relationFiles;
	            if (relationFiles) {
	                for (var key in relationFiles) {
	                    if (key !== 'count') {
	                        var relationFile = relationFiles[key];
	                        if (relationFile) {
	                            var fileType = relationFile.fileType;
	                            if (fileType === RelationshipConstants._relationshipImageType ||
	                                fileType === RelationshipConstants._relationshipImageType2 ||
	                                fileType === RelationshipConstants._relationshipChartType) {
	                                drawingRelationFiles[key] = relationFile;
	                            }
	                        }
	                    }
	                }
	            }
	    
	            var dataString = getFileDataAndCleanData(file.fileName, true);
	            if (dataString) {
	                drawingInfo = readDrawing(dataString, drawingRelationFiles, getFileDataAndCleanData);
	            }
	        });
	        return drawingInfo;
	    }
	
	    function setImageStringToBlipBlob(blipFillContainer, chartRelationFileMap, getFileDataAndCleanData) {
	        var embedImageId = blipFillContainer && blipFillContainer.blipFill && blipFillContainer.blipFill.blip &&
	            blipFillContainer.blipFill.blip.embed;
	        if(!embedImageId) {
	            return;
	        }
	        var imageFile = chartRelationFileMap[embedImageId];
	        if(imageFile) {
	            var fileName = imageFile.fileName;
	            var pos = fileName.lastIndexOf('.');
	            if (pos >= 0) {
	                var imageFileString = getImageContent(fileName, getFileDataAndCleanData);
	                if (imageFileString) {
	                    var blipBlob = blipFillContainer.blipFill.blip.blipBlob = {};
	                    blipBlob.blob = imageFileString;
	                    blipBlob.type = fileName.substr(pos + 1);
	                }
	            }
	        }
	    }
	
	    function readDrawing(dataString, drawingRelationFiles, getFileDataAndCleanData) {
	        var obj = parseXmlToObject(dataString),
	            root = obj['xdr:wsDr'];
	        var drawingResult = {};
	
	        var pictures = readPictureDrawing(root, drawingRelationFiles, getFileDataAndCleanData);
	        if(pictures.length > 0) {
	            drawingResult.pictures = pictures;
	        }        
	        var charts = readChartDrawing(dataString, drawingRelationFiles, getFileDataAndCleanData);
	        if(charts.length > 0) {
	            drawingResult.charts = charts;
	        }
	
	        return drawingResult;
	    }
	
	    function readPictureDrawing(wsDrNodeObj, drawingRelationFiles, getFileDataAndCleanData) {
	        var pictures = [];
	        if (!wsDrNodeObj) {
	            return pictures;
	        }
	        var anchors = getAsArray(wsDrNodeObj['xdr:oneCellAnchor']);
	        anchors.forEach(function (anchor) {
	            var oneCellAnchor = {}, picture = {};
	            if (anchor && anchor['xdr:pic']) {
	                oneCellAnchor.startPoint = readAnchorPoint(anchor['xdr:from']);
	                readSize(anchor['xdr:ext'], oneCellAnchor);
	                readPictureFrame(drawingRelationFiles, anchor['xdr:pic'], picture, getFileDataAndCleanData);
	                readLocked(anchor['xdr:clientData'], picture);
	                picture.oneCellAnchor = oneCellAnchor;
	                if (picture.src) {
	                    pictures.push(picture);
	                }
	            }
	        });
	
	        anchors = getAsArray(wsDrNodeObj['xdr:twoCellAnchor']);
	        anchors.forEach(function (anchor) {
	            var twoCellAnchor = {}, picture = {};
	            if (anchor && anchor['xdr:pic']) {
	                twoCellAnchor.startPoint = readAnchorPoint(anchor['xdr:from']);
	                twoCellAnchor.endPoint = readAnchorPoint(anchor['xdr:to']);
	                readPictureFrame(drawingRelationFiles, anchor['xdr:pic'], picture, getFileDataAndCleanData);
	                readLocked(anchor['xdr:clientData'], picture);
	                picture.twoCellAnchor = twoCellAnchor;
	                if (picture.src) {
	                    pictures.push(picture);
	                }
	            }
	        });
	
	        anchors = getAsArray(wsDrNodeObj['xdr:absoluteAnchor']);
	        anchors.forEach(function (anchor) {
	            var absoluteAnchor = {}, picture = {};
	            if (anchor && anchor['xdr:pic']) {
	                readXY(anchor['xdr:pos'], absoluteAnchor);
	                readSize(anchor['xdr:ext'], absoluteAnchor);
	                readPictureFrame(drawingRelationFiles, anchor['xdr:pic'], picture, getFileDataAndCleanData);
	                readLocked(anchor['xdr:clientData'], picture);
	                picture.absoluteAnchor = absoluteAnchor;
	                if (picture.src) {
	                    pictures.push(picture);
	                }
	            }
	        });
	        return pictures;
	    }
	
	    function readChartDrawing(dataString, drawingRelationFiles, getFileDataAndCleanData) {
	        var chartDrawingObj = readChartDrawingNode(dataString);
	        var anchorBaseList = chartDrawingObj && chartDrawingObj.AnchorBaseList;
	        var charts = [];
	        if (anchorBaseList && anchorBaseList.length > 0) {
	            anchorBaseList.forEach(function (item) {
	                var chartFileId = item.graphicFrame && item.graphicFrame.graphic &&
	                    item.graphicFrame.graphic.graphicData && item.graphicFrame.graphic.graphicData.chart &&
	                    item.graphicFrame.graphic.graphicData.chart.id;
	                if (chartFileId) {
	                    var chartFile = drawingRelationFiles[chartFileId];
	                    var chartSpace = readChartSpace(chartFile, getFileDataAndCleanData);
	                    if (chartSpace) {
	                        var chartRelationFileMap = {};
	                        var relationFiles = chartFile.relationFiles;
	                        for (var key in relationFiles) {
	                            if (key !== 'count') {
	                                var relationFile = relationFiles[key];
	                                if (relationFile) {
	                                    var fileType = relationFile.fileType;
	                                    if (fileType === RelationshipConstants._realationshipChartUserShapes ||
	                                        fileType === RelationshipConstants._relationshipImageType) {
	                                        chartRelationFileMap[key] = relationFile;
	                                    }
	                                }
	                            }
	                        }
	
	                       
	                        var userShapes = readChartUserShapes(chartSpace.userShapes, chartRelationFileMap, getFileDataAndCleanData);
	                        if(userShapes) {
	                            chartSpace.userShapes = userShapes;
	                        }
	                       
	                        readChartEmbededImage(chartSpace, chartRelationFileMap, getFileDataAndCleanData);
	
	                        item.chartSpace = chartSpace;
	                        charts.push(item);
	                    }
	                }
	            });
	        }
	        return charts;
	    }
	
	    function readChartDrawingNode(dataString) {
	        var reader = new XmlReader();
	        reader.reset();
	        reader.setXml(dataString);
	        while (reader.read()) {
	            if(reader.depth !== 0 || reader.elementType === 2 ) {
	                continue;
	            }
	            if(reader.name() === 'xdr:wsDr') {
	                return DrawingReaderClass.ReadCT_Drawing(reader);
	            }
	        }
	        return null;
	    }
	    function readChartSpace(chartFile, getFileDataAndCleanData) {
	        if(!chartFile) {
	            return null;
	        }
	        var fileName = chartFile.fileName;
	        var chartFileString = getFileDataAndCleanData(fileName, true);
	        var reader = new XmlReader();
	        reader.reset();
	        reader.setXml(chartFileString);
	        while (reader.read()) {
	            if (reader.depth !== 0 || reader.elementType === 2 ) {
	                continue;
	            }
	            if (reader.name() === 'c:chartSpace') {
	                return DrawingReaderClass.ReadCT_ChartSpace(reader);
	            }
	        }
	        return null;
	    }
	    function readChartUserShapes(userShapes, chartRelationFileMap, getFileDataAndCleanData) {
	        if(!userShapes || !userShapes.id) {
	            return null;
	        }
	        var drawingFile = chartRelationFileMap[userShapes.id];
	        var userShapeRelationFileMap = {}, userShapeRelationFiles = drawingFile.relationFiles;
	        var key, relationFile, fileType;
	        for (key in userShapeRelationFiles) {
	            if (key !== 'count') {
	                relationFile = userShapeRelationFiles[key];
	                if (relationFile) {
	                    fileType = relationFile.fileType;
	                    if (fileType === RelationshipConstants._relationshipImageType ||
	                        fileType === RelationshipConstants._relationshipChartType) {
	                        userShapeRelationFileMap[key] = relationFile;
	                    }
	                }
	            }
	        }
	
	        var chartUserShapesAnchors = readChartUserShapesNode(drawingFile, getFileDataAndCleanData);
	        if (chartUserShapesAnchors && chartUserShapesAnchors.length > 0) {
	            return chartUserShapesAnchors.map(function (anchorItem) {
	                if (anchorItem.pic) {   
	                    readPictureInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData);
	                } else if (anchorItem.graphicFrame) {  
	                    readChartInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData);
	                }
	                return anchorItem;
	            });
	        }
	    }
	    function getChartPictureStyle(pictureNode) {
	        var userShapes = pictureNode && pictureNode['c:userShapes'];
	        if(userShapes) {
	            var absSizeAnchor = userShapes['cdr:absSizeAnchor'], relSizeAnchor = userShapes['cdr:relSizeAnchor'];
	            if(absSizeAnchor) {
	                return absSizeAnchor['cdr:pic'] && absSizeAnchor['cdr:pic']['cdr:spPr'];
	            } else if(relSizeAnchor) {
	                return relSizeAnchor['cdr:pic'] && relSizeAnchor['cdr:pic']['cdr:spPr'];
	            }
	        }
	        return null;
	    }
	    function readChartUserShapesNode(drawingFile, getFileDataAndCleanData) {
	        if(!drawingFile) {
	            return null;
	        }
	        var fileName = drawingFile.fileName;
	        var drawingFileString = getFileDataAndCleanData(fileName, true);
	        var reader = new XmlReader();
	        reader.reset();
	        reader.setXml(drawingFileString);
	        while (reader.read()) {
	            if (reader.depth !== 0 || reader.elementType === 2 ) {
	                continue;
	            }
	            if (reader.name() === 'c:userShapes') {
	                var drawingObj = DrawingReaderClass.ReadCT_ChartDrawing(reader);
	                if(drawingObj) {
	                    var drawingAnchor = drawingObj.relSizeAnchor.concat(drawingObj.absSizeAnchor);
	                    drawingAnchor.forEach(function (anchor) {
	                        if(anchor.pic) {
	                            var pictureNode = parseXmlToObject(drawingFileString);                            
	                            anchor.pictureStyleInfo = getChartPictureStyle(pictureNode);
	                        }
	                    });
	                    return drawingAnchor;
	                }
	            }
	        }
	        return null;
	    }
	    function readChartInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData) {
	        var innerChartId = anchorItem.graphicFrame.graphic && anchorItem.graphicFrame.graphic.graphicData &&
	                anchorItem.graphicFrame.graphic.graphicData.chart && anchorItem.graphicFrame.graphic.graphicData.chart.id;
	        var innerChartFile = userShapeRelationFileMap[innerChartId];
	        if (innerChartFile) {
	            anchorItem.chartSpace = readChartSpace(innerChartFile, getFileDataAndCleanData);
	        }
	    }
	    function readPictureInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData) {
	        setImageStringToBlipBlob(anchorItem.pic, userShapeRelationFileMap, getFileDataAndCleanData);
	        var pictureStyleInfo = anchorItem.pictureStyleInfo;
	        if (pictureStyleInfo) {
	            anchorItem.pictureFormat = readImageFormat(pictureStyleInfo);
	            delete anchorItem.pictureStyleInfo;
	        }
	    }
	    function readChartEmbededImage(chartSpace, chartRelationFileMap, getFileDataAndCleanData) {
	       
	        chartSpace.chart.plotArea.chartGroups.forEach(function (chart) {
	            if (chart && chart.ser) {
	                chart.ser.forEach(function (serItem) {
	                    if (serItem.spPr) {
	                        setImageStringToBlipBlob(serItem.spPr, chartRelationFileMap, getFileDataAndCleanData);
	                    }
	                    if (serItem.dLbls && serItem.dLbls.spPr) {
	                        setImageStringToBlipBlob(serItem.dLbls.spPr, chartRelationFileMap, getFileDataAndCleanData);
	                    }
	                });
	            }
	        });
	       
	        if (chartSpace.chart.plotArea.spPr) {
	            setImageStringToBlipBlob(chartSpace.chart.plotArea.spPr, chartRelationFileMap, getFileDataAndCleanData);
	        }
	       
	        if (chartSpace.spPr) {
	            setImageStringToBlipBlob(chartSpace.spPr, chartRelationFileMap, getFileDataAndCleanData);
	        }
	    }
	
	    function readLocked(item, picture) {
	        if (item) {
	            picture.locked = nodeHelper._getAttrValueOrDefaultOfBooleanType(item._attr['fLocksWithSheet'], true);
	        }
	    }
	    
	    function readPictureFrame(imageFiles, pic, picture, getFileDataAndCleanData) {
	        if (pic) {
	            var item = pic['xdr:nvPicPr'];
	            if (item) {
	                var cNvPr = item['xdr:cNvPr'];
	                picture.name = cNvPr && cNvPr._attr.name;
	                picture.isVisible = !(nodeHelper._getAttrValueOrDefaultOfBooleanType(cNvPr && cNvPr._attr.hidden, false));
	            }
	    
	            item = pic['xdr:blipFill'];
	            if (item) {
	                var blip = item['a:blip'];
	                var rid = blip && blip._attr['r:embed'];
	                if (rid) {
	                    var imageFile = imageFiles[rid];
	                    if (imageFile) {
	                        var imageContent = getImageContent(imageFile.fileName, getFileDataAndCleanData);
	                        if (imageContent) {
	                            picture.src = imageContent;
	                        }
	                    }
	                }
	            }
	    
	            item = pic['xdr:spPr'];
	            if (item) {
	                picture.pictureFormat = readImageFormat(item);
	            
	           
	           
	           
	           
	           
	           
	           
	            }
	        }
	    }
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	    function readLineFormat(node) {
	        if (node) {
	            var lineFormat = {};
	
	            var attr = node._attr, width = parseInt(attr.w || '0');
	            lineFormat.width = UnitHelper.emuToPixles(width);
	
	            lineFormat.compoundLineType = attr.compd || 'sng';
	            lineFormat.lineEndingCap = attr.cap || 'sq';
	            lineFormat.penAlignment = attr.align || 'ctr';
	            lineFormat.fillFormat = readFillFormat(node);
	            lineFormat.headLineEndStyle = readLineEndStyle(node['a:headEnd']);
	            lineFormat.tailLineEndStyle = readLineEndStyle(node['a:tailEnd']);
	
	            if (node['a:bevel']) {
	                lineFormat.joinType = 'bevel';
	            }
	            if (node['a:miter']) {
	                lineFormat.joinType = 'miter';
	            }
	            if (node['a:round']) {
	                lineFormat.joinType = 'round';
	            }
	            var item = node['a:prstDash'];
	            lineFormat.lineDashType = item && item._attr.val || 'solid';
	
	            return lineFormat;
	        }
	    }
	
	    function readFillFormat(node) {
	        var item = node['a:solidFill'];
	
	        if (item) {
	            return readSolidFillFormat(item);
	        }
	
	        item = node['a:pattFill'];
	        if (item) {
	            return readPatternFillFormat(item);
	        }
	
	        item = node['a:noFill'];
	        if (item) {
	            return readNoFillFormat();
	        }
	
	        item = node['a:gradFill'];
	        if (item) {
	            return readGradientFillFormat(item);
	        }
	
	        item = node['a:blipFill'];
	        if (item) {
	            return readBlipFillFormat(item);
	        }
	    }
	
	    function readSolidFillFormat(node) {
	        var drawingColorSettings = {}, color = readColor(node, drawingColorSettings);
	        return {
	            fillFormatType: 1, 
	            color: color,
	            drawingColorSettings: drawingColorSettings
	        };
	    }
	
	    function setDrawingColorSetting(drawingColorSettings, item, keys) {
	        keys.forEach(function (key) {
	            var node = item['a:' + key];
	            if (node) {
	                drawingColorSettings[key] = parseInt(node._attr.val || '0');
	            }
	        });
	    }
	
	    function readColor(node, drawingColorSettings) {
	        var value, clr, attr, item = node['a:schemeClr'];
	
	        if (item) {
	            value = (item._attr.val || '').toUpperCase();
	            setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint', 'hue', 'hueOff', 'hueMod', 'sat', 'satOff', 'satMod', 'lum', 'lumOff', 'lumMod']);
	
	            if (value) {
	                return new ExcelColor(3 , ColorHelper.toColorSchemeIndex(value), 0);
	            }
	        }
	
	        item = node['a:hslClr'];
	        if (item) {
	            attr = item._attr;
	            var h = parseInt(attr.hue || '0'), s = parseInt(attr.sat || '0'), l = parseInt(attr.lum || '0');
	            setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
	
	            return ColorHelper.fromColorToExcelColor(ColorHelper.convertHLSToRGB(h, l, s));
	        }
	
	        item = node['a:prstClr'];
	        if (item) {
	            value = (item._attr.val || '');
	            setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
	
	            if (value) {
	                return ColorHelper.fromColorToExcelColor(ColorHelper.fromPresetColorVal(value));
	            }
	        }
	
	        item = node['a:scrgbClr'];
	        if (item) {
	            attr = item._attr;
	            var r = parseInt(attr.r || '0'), g = parseInt(attr.g || '0'), b = parseInt(attr.b || '0');
	            setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
	
	            return ColorHelper.fromColorToExcelColor(new Color(255, ColorHelper.scRgbTosRgb(r), ColorHelper.scRgbTosRgb(g), ColorHelper.scRgbTosRgb(b)));
	        }
	
	        item = node['a:srgbClr'];
	        if (item) {
	            clr = item._attr.val;
	            setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
	
	            if (clr) {
	                value = parseInt(clr, 16);
	                if (!isNaN(value)) {
	                    return new ExcelColor(2 , value, 0);
	                }
	            }
	        }
	
	        item = node['a:sysClr'];
	        if (item) {
	            var name = item._attr.val;
	            var color = ExcelSystemColor.getSystemColor(name);
	            setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint', 'lumMode']);
	            if (color) {
	                return ColorHelper.fromColorToExcelColor(color);
	            }
	        }
	
	        return null;
	    }
	
	    function readLineEndStyle(node) {
	        if (node) {
	            var attr = node._attr;
	
	            return {
	                length: attr.len || 'lg',
	                type: attr.type || 'none',
	                width: attr.w || 'lg'
	            };
	        }
	    }
	
	    function readPatternFillFormat(node) {
	        var style = node._attr.prst || 'pct5';
	        var bgDrawingColorSettings, bgColor, fgDrawingColorSettings, fgColor;
	
	        var item = node['a:bgClr'];
	        if (item) {
	            bgDrawingColorSettings = {};
	            bgColor = readColor(item, bgDrawingColorSettings);
	        }
	
	        item = node['a:fgClr'];
	        if (item) {
	            fgDrawingColorSettings = {};
	            fgColor = readColor(item, fgDrawingColorSettings);
	        }
	
	        return {
	            fillFormatType: 4,
	            fillPattern: style,
	            backgroundDrawingColorSettings: bgDrawingColorSettings,
	            backgroundColor: bgColor,
	            foregroundDrawingColorSettings: fgDrawingColorSettings,
	            foregroundColor: fgColor
	        };
	    }
	
	    function readNoFillFormat() {
	        return {
	            fillFormatType: 0
	        };
	    }
	
	    function readGradientFillFormat(node) {
	        var gradientStops = [], attr = node._attr;
	        var result = {
	            fillFomatType: 2,
	            gradientStops: gradientStops
	        };
	
	        result.flipMode = attr.flip || 'none';
	        result.rotateWithShape = nodeHelper._getAttrValueOrDefaultOfBooleanType(attr.rotWithShape, false);
	
	        var item = node['a:gsLst'];
	        if (item) {
	            getAsArray(item['a:gs']).forEach(function(node) { 
	                gradientStops.push(readGradientStop(node));
	            });
	        }
	
	        item = node['a:lin'];
	        if (item) {
	            result.gradientFillType = 'linear';
	            result.angle = parseFloat(item._attr.ang || '0') / 60000;
	            result.scaled = nodeHelper._getAttrValueOrDefaultOfBooleanType(item._attr.scaled, false);
	        }
	
	        item = node['a:path'];
	        if (item) {
	            result.gradientFillType = item._attr.path || 'shape';
	            result.fillToRect = readRelativeRect(item['a:fillToRect']);
	        }
	
	        result.tileRect = readRelativeRect(node['a:tileRect']);
	
	        return result;
	    }
	
	    function readGradientStop(node) {
	        var drawingColorSettings = {}, color = readColor(node, drawingColorSettings);
	        var position = parseFloat(node._attr.pos || '100000') / 100000;
	
	        return {
	            position: position,
	            color: color,
	            drawingColorSettings: drawingColorSettings
	        };
	    }
	
	    function readBlipFillFormat(node) {
	        var result = {transparency: 1};
	
	        result.rotateWithShape = nodeHelper._getAttrValueOrDefaultOfBooleanType(node._attr.rotWithShape, false);
	
	        var item = node['a:blip'];
	        if (item) {
	            result.imageID = item._attr['r:embed'];
	            var alpha = item['a:alphaModFix'];
	            if (alpha) {
	                result.transparency = 1 - parseFloat(alpha._attr.amt || '0') / 100000;
	            }
	        }
	
	        item = node['a:tile'];
	        if (item) {
	            result.tile = readTile(item);
	        }
	
	        item = node['a:stretch'];
	        if (item) {
	            result.stretch = readRelativeRect(item['a:fillRect']);
	        }
	
	        return result;
	    }
	
	    function readTile(node) {
	        var attr = node._attr, sx = attr.sx, sy = attr.sy, tx = attr.tx, ty = attr.ty;
	
	        return {
	            alignment: attr.algn || 'tl',
	            flipping: attr.flip || 'none',
	            horizontalRatio: (sx && (parseFloat(sx) / 100000)) || 1,
	            verticalRatio: (sy && (parseFloat(sy) / 100000)) || 1,
	            horizontalOffset: (tx && (parseFloat(tx) / 100000)) || 0,
	            verticalOffset: (ty && (parseFloat(ty) / 100000)) || 0
	        };
	    }
	
	    function readRelativeRect(node) {
	        if (node) {
	            var attr = node._attr;
	
	            return [attr.l, attr.t, attr.r, attr.b].map(function(sValue) {
	                return parseFloat(sValue || '0') / 100000;
	            });
	        }
	    }
	
	    function readImageFormat(node) {
	        var drawingFormat = {};
	    
	        drawingFormat.lineFormat = readLineFormat(node['a:ln']);
	    
	    
	        var fillFormat = readFillFormat(node);
	        if (fillFormat) {
	            drawingFormat.fillFormat = fillFormat;
	        }
	    
	        return drawingFormat;
	    }
	    
	    module.exports = readDrawings;
	
	}());

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Charts = __webpack_require__(24);
	    var excelStyle = __webpack_require__(12);
	    var UnitHelper = excelStyle.UnitHelper;
	    var emuToPixles = UnitHelper.emuToPixles;
	    var ChartHelper = __webpack_require__(39)._ChartHelper;
	    var common = __webpack_require__(4);
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var xmlDecode = common._Util._xmlDecode;
	    var XmlNodeHelper = __webpack_require__(11);
	    var getAttrValueOrDefaultOfBooleanType = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType;
	    var getAttrValueOrDefaultOfDoubleType = XmlNodeHelper._getAttrValueOrDefaultOfDoubleType;
	    var getAttributeValueOrDefaultOfIntType = XmlNodeHelper._getAttributeValueOrDefaultOfIntType;
	
	    var keyword_null = null,
	        CONST_VAL = 'val', CONST_NAME = 'name', CONST_TYPE = 'type', CONST_PRST = 'prst', CONST_EXTLST = 'extLst',
	        CONST_CNVPR = 'cNvPr', CONST_MACRO = 'macro', CONST_EFFECTLST = 'effectLst', CONST_EFFECT_DAG = 'effectDag',
	        CONST_FPUBLISHED = 'fPublished', CONST_GRAPHIC_FRAME = 'graphicFrame', CONST_DUMY = 'dumy', CONST_EXT = 'ext',
	        CONST_SCRGBCLR = 'scrgbClr', CONST_SRGBCLR = 'srgbClr', CONST_HSLCLR = 'hslClr',
	        CONST_SYSCLR = 'sysClr', CONST_SCHEMECLR = 'schemeClr', CONST_PRSTCLR = 'prstClr',
	        CONST_NO_FILL = 'noFill', CONST_SOLID_FILL = 'solidFill', CONST_GRAD_FILL = 'gradFill',
	        CONST_BLIP_FILL = 'blipFill', CONST_PATT_FILL = 'pattFill', CONST_GRP_FILL = 'grpFill',
	        CONST_DELETE = 'delete', CONST_IDX = 'idx', CONST_SCENE_3D = 'scene3d', CONST_SPPR = 'spPr',
	        CONST_TXPR = 'txPr', CONST_SQREF = 'sqref', CONST_INVERT_IF_NEGATIVE = 'invertIfNegative',
	        CONST_BUBBLE_3D = 'bubble3D', CONST_MARKER = 'marker', CONST_GRPSP = 'grpSp', CONST_CXNSP = 'cxnSp',
	        CONST_CLR_SCHEME = 'clrScheme', CONST_FONT_SCHEME = 'fontScheme', CONST_FMT_SCHEME = 'fmtScheme',
	        CONST_LAYOUT = 'layout', CONST_PICTURE_OPTIONS = 'pictureOptions', CONST_ORDER = 'order',
	        CONST_GAP_WIDTH = 'gapWidth', COSNT_DLBLS = 'dLbls', CONST_TRENDLINE = 'trendline',
	        CONST_ERR_BARS = 'errBars', CONST_SER = 'ser', CONST_DROP_LINES = 'dropLines', CONST_AXID = 'axId',
	        CONST_GROUPING = 'grouping', CONST_VARY_COLORS = 'varyColors', CONST_SCALING = 'scaling',
	        CONST_AX_POS = 'axPos', CONST_MAJOR_GRIDLINES = 'majorGridlines', CONST_MINOR_GRIDLINES = 'minorGridlines',
	        CONST_TITLE = 'title', CONST_NUMFMT = 'numFmt', CONST_MAJOR_TICK_MARK = 'majorTickMark',
	        CONST_MINOR_TICK_MARK = 'minorTickMark', CONST_TICK_LBLPOS = 'tickLblPos', CONST_CROSSAX = 'crossAx',
	        CONST_CROSSES = 'crosses', CONST_CROSSAT = 'crossesAt', CONST_STYLE = 'style',
	        CONST_TOT_WITH_SHAPE = 'rotWithShape';
	
	    function getValidValue(value, defaultValue) {
	        return !isNullOrUndefined(value) ? value : defaultValue;
	    }
	    function getAttributeName(reader) {
	        var attrName = reader.readAttributeNameAsString().split(':');
	        return attrName.length > 1 ? attrName[1] : attrName[0];
	    }
	    function getElementName(reader) {
	        var elementName = reader.name().split(':');
	        return elementName.length > 1 ? elementName[1] : elementName[0];
	    }
	    function readSingleAttributeNode(reader, attrName, convertDataTypeFunc) {
	       
	        while (reader.moveToNextAttribute()) {
	            var tempAttrName = getAttributeName(reader);
	            if (tempAttrName === attrName) {
	                var tempValue = reader.readContentAsString();
	                if(convertDataTypeFunc) {
	                    tempValue = convertDataTypeFunc(tempValue);
	                }
	                return tempValue;
	            }
	        }
	    }
	    function readSingleSubElementNode(reader, elementName, readElementFunc, instance) {
	        var tempInstance = instance || {};
	        if (reader.elementType === 3 ) {
	            return tempInstance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var tempElementName = getElementName(reader);
	            if (tempElementName === elementName) {
	                tempInstance[elementName] = readElementFunc(reader);
	            }
	        }
	        return tempInstance;
	    }
	    function readSubColorElements(reader, instance) {
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SCRGBCLR:
	                    instance.scrgbClr = ReadCT_ScRgbColor(reader);
	                    break;
	                case CONST_SRGBCLR:
	                    instance.srgbClr = ReadCT_SRgbColor(reader);
	                    break;
	                case CONST_HSLCLR:
	                    instance.hslClr = ReadCT_HslColor(reader);
	                    break;
	                case CONST_SYSCLR:
	                    instance.sysClr = ReadCT_SystemColor(reader);
	                    break;
	                case CONST_SCHEMECLR:
	                    instance.schemeClr = ReadCT_SchemeColor(reader);
	                    break;
	                case CONST_PRSTCLR:
	                    instance.prstClr = ReadCT_PresetColor(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	    function readFillProperties(reader, instance) {
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_NO_FILL:
	                    instance.noFill = ReadCT_NoFillProperties();
	                    break;
	                case CONST_SOLID_FILL:
	                    instance.solidFill = ReadCT_SolidColorFillProperties(reader);
	                    break;
	                case CONST_GRAD_FILL:
	                    instance.gradFill = ReadCT_GradientFillProperties(reader);
	                    break;
	                case CONST_BLIP_FILL:
	                    instance.blipFill = ReadCT_BlipFillProperties(reader);
	                    break;
	                case CONST_PATT_FILL:
	                    instance.pattFill = ReadCT_PatternFillProperties(reader);
	                    break;
	                case CONST_GRP_FILL:
	                    instance.grpFill = ReadCT_GroupFillProperties();
	                    break;
	            }
	        }
	        return instance;
	    }
	    function readFillPropertiesAsArrayItem(reader, instance) {
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_NO_FILL:
	                    instance.noFill.push(DrawingReader.ReadCT_NoFillProperties(reader));    
	                    break;
	                case CONST_SOLID_FILL:
	                    instance.solidFill.push(DrawingReader.ReadCT_SolidColorFillProperties(reader));
	                    break;
	                case CONST_GRAD_FILL:
	                    instance.gradFill.push(DrawingReader.ReadCT_GradientFillProperties(reader));
	                    break;
	                case CONST_BLIP_FILL:
	                    instance.blipFill.push(DrawingReader.ReadCT_BlipFillProperties(reader));
	                    break;
	                case CONST_PATT_FILL:
	                    instance.pattFill.push(DrawingReader.ReadCT_PatternFillProperties(reader));
	                    break;
	                case CONST_GRP_FILL:
	                    instance.grpFill.push(DrawingReader.ReadCT_GroupFillProperties(reader));
	                    break;
	            }
	        }
	        return instance;
	    }
	    function readColorSubElement(reader, instance) {
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "tint":
	                    instance.tint = [ReadCT_PositiveFixedPercentage(reader)];
	                    break;
	                case "shade":
	                    instance.shade = [ReadCT_PositiveFixedPercentage(reader)];
	                    break;
	                case "comp":
	                    instance.comp = [ReadCT_ComplementTransform()];
	                    break;
	                case "inv":
	                    instance.inv = [ReadCT_InverseTransform()];
	                    break;
	                case "gray":
	                    instance.gray = [ReadCT_GrayscaleTransform()];
	                    break;
	                case "alpha":
	                    instance.alpha = [ReadCT_PositiveFixedPercentage(reader)];
	                    break;
	                case "alphaMod":
	                    instance.alphaMod = [ReadCT_PositivePercentage(reader)];
	                    break;
	                case "alphaOff":
	                    instance.alphaOff = [ReadCT_FixedPercentage(reader)];
	                    break;
	                case "hue":
	                    instance.hue = [ReadCT_PositiveFixedAngle(reader)];
	                    break;
	                case "hueMod":
	                    instance.hueMod = [ReadCT_PositivePercentage(reader)];
	                    break;
	                case "hueOff":
	                    instance.hueOff = [ReadCT_Angle(reader)];
	                    break;
	                case "sat":
	                    instance.sat = [ReadCT_Percentage(reader)];
	                    break;
	                case "satMod":
	                    instance.satMod = [ReadCT_Percentage(reader)];
	                    break;
	                case "satOff":
	                    instance.satOff = [ReadCT_Percentage(reader)];
	                    break;
	                case "lum":
	                    instance.lum = [ReadCT_Percentage(reader)];
	                    break;
	                case "lumMod":
	                    instance.lumMod = [ReadCT_Percentage(reader)];
	                    break;
	                case "lumOff":
	                    instance.lumOff = [ReadCT_Percentage(reader)];
	                    break;
	                case "red":
	                    instance.red = [ReadCT_Percentage(reader)];
	                    break;
	                case "redMod":
	                    instance.redMod = [ReadCT_Percentage(reader)];
	                    break;
	                case "redOff":
	                    instance.redOff = [ReadCT_Percentage(reader)];
	                    break;
	                case "green":
	                    instance.green = [ReadCT_Percentage(reader)];
	                    break;
	                case "greenMod":
	                    instance.greenMod = [ReadCT_Percentage(reader)];
	                    break;
	                case "greenOff":
	                    instance.greenOff = [ReadCT_Percentage(reader)];
	                    break;
	                case "blue":
	                    instance.blue = [ReadCT_Percentage(reader)];
	                    break;
	                case "blueMod":
	                    instance.blueMod = [ReadCT_Percentage(reader)];
	                    break;
	                case "blueOff":
	                    instance.blueOff = [ReadCT_Percentage(reader)];
	                    break;
	                case "gamma":
	                    instance.gamma = [ReadCT_GammaTransform()];
	                    break;
	                case "invGamma":
	                    instance.invGamma = [ReadCT_InverseGammaTransform()];
	                    break;
	            }
	        }
	        return instance;
	    }
	    function readSurfaceChartSubElement(reader, instance) {
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "wireframe":
	                    instance.wireframe = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_SurfaceSer(reader));
	                    break;
	                case "bandFmts":
	                    instance.bandFmts = ReadCT_BandFmts(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	    function readGraphicFrameNonVisualSubElement(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_CNVPR) {
	                instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
	            }
	           
	           
	           
	        }
	        return instance;
	    }
	    function readSubSqrefElement(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_SQREF) {
	                instance.sqref = reader.readElementContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    var DrawingReader = {};
	
	    function ReadCT_ColorScheme(reader) {
	       
	       
	        var instance = {};
	        instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementArray = ["dk1", "lt1", "dk2", "lt2", "accent1", "accent2", "accent3", "accent4", "accent5", "accent6", "hlink", "folHlink"];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === CONST_EXTLST) {
	                instance[elementName] = ReadCT_OfficeArtExtensionList(reader);
	            } else if(elementArray.indexOf(elementName) >= 0) {
	                instance[elementName] = ReadCT_Color(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ColorScheme = ReadCT_ColorScheme;
	
	    function ReadCT_CustomColor(reader) {
	       
	       
	        var instance = {};
	        instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_CustomColor = ReadCT_CustomColor;
	
	    function ReadCT_SupplementalFont(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "script" || attrName === "typeface") {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SupplementalFont = ReadCT_SupplementalFont;
	
	    function ReadCT_CustomColorList(reader) {
	        var instance = {custClr: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "custClr") {
	                instance.custClr.push(ReadCT_CustomColor(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CustomColorList = ReadCT_CustomColorList;
	
	    function ReadCT_FontCollection(reader) {
	        var instance = {font: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "latin":
	                    instance.latin = ReadCT_TextFont(reader);
	                    break;
	                case "ea":
	                    instance.ea = ReadCT_TextFont(reader);
	                    break;
	                case "cs":
	                    instance.cs = ReadCT_TextFont(reader);
	                    break;
	                case "font":
	                    instance.font.push(ReadCT_SupplementalFont(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_FontCollection = ReadCT_FontCollection;
	
	    function ReadCT_EffectStyleItem(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_EFFECTLST:
	                    instance.effectLst = ReadCT_EffectList(reader);
	                    break;
	                case CONST_EFFECT_DAG:
	                    instance.effectDag = ReadCT_EffectContainer(reader);
	                    break;
	                case CONST_SCENE_3D:
	                    instance.scene3d = ReadCT_Scene3D(reader);
	                    break;
	                case "sp3d":
	                    instance.sp3d = ReadCT_Shape3D(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EffectStyleItem = ReadCT_EffectStyleItem;
	
	    function ReadCT_FontScheme(reader) {
	       
	       
	        var instance = {};
	        instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "majorFont" || elementName === "minorFont") {
	                instance[elementName] = ReadCT_FontCollection(reader);
	            } else if(elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_FontScheme = ReadCT_FontScheme;
	
	    function ReadCT_FillStyleList(reader) {
	        var instance = {
	            noFill: [],
	            solidFill: [],
	            gradFill: [],
	            blipFill: [],
	            pattFill: [],
	            grpFill: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readFillPropertiesAsArrayItem(reader, instance);
	    }
	
	    DrawingReader.ReadCT_FillStyleList = ReadCT_FillStyleList;
	
	    function ReadCT_LineStyleList(reader) {
	        var instance = {ln: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "ln") {
	                instance.ln.push(DrawingReader.ReadCT_LineProperties(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LineStyleList = ReadCT_LineStyleList;
	
	    function ReadCT_EffectStyleList(reader) {
	        var instance = {effectStyle: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "effectStyle") {
	                instance.effectStyle.push(ReadCT_EffectStyleItem(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EffectStyleList = ReadCT_EffectStyleList;
	
	    function ReadCT_BackgroundFillStyleList(reader) {
	        var instance = {
	            noFill: [],
	            solidFill: [],
	            gradFill: [],
	            blipFill: [],
	            pattFill: [],
	            grpFill: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readFillPropertiesAsArrayItem(reader, instance);
	    }
	
	    DrawingReader.ReadCT_BackgroundFillStyleList = ReadCT_BackgroundFillStyleList;
	
	    function ReadCT_StyleMatrix(reader) {
	       
	       
	        var instance = {};
	        instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "fillStyleLst":
	                    instance.fillStyleLst = ReadCT_FillStyleList(reader);
	                    break;
	                case "lnStyleLst":
	                    instance.lnStyleLst = ReadCT_LineStyleList(reader);
	                    break;
	                case "effectStyleLst":
	                    instance.effectStyleLst = ReadCT_EffectStyleList(reader);
	                    break;
	                case "bgFillStyleLst":
	                    instance.bgFillStyleLst = ReadCT_BackgroundFillStyleList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_StyleMatrix = ReadCT_StyleMatrix;
	
	    function ReadCT_BaseStyles(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_CLR_SCHEME:
	                    instance.clrScheme = ReadCT_ColorScheme(reader);
	                    break;
	                case CONST_FONT_SCHEME:
	                    instance.fontScheme = ReadCT_FontScheme(reader);
	                    break;
	                case CONST_FMT_SCHEME:
	                    instance.fmtScheme = ReadCT_StyleMatrix(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BaseStyles = ReadCT_BaseStyles;
	
	    var OOXMLFileTypes = {
	        hiddenScene3dUri: "{31F19639-BCED-4A60-ADC4-E9642A236FB7}",
	        hiddenSp3dUri: "{E45631CC-5BF2-4C18-A39C-3461C7D3F71A}",
	        hiddenFillUri: "{909E8E84-426E-40DD-AFC4-6F175D3DCCD1}",
	        hiddenFillUri2: "{909E8E84-426E-40dd-AFC4-6F175D3DCCD1}",
	        hiddenLineUri: "{91240B29-F687-4F45-9708-019B960494DF}",
	        hiddenLineUri2: "{91240B29-F687-4f45-9708-019B960494DF}"
	    };
	
	    function ReadCT_OfficeArtExtension(reader) {
	       
	        if (reader.elementType === 3 ) {
	            return {hiddenExtensionType: 4};
	        }
	       
	        var instance = {};
	        instance.uri = getValidValue(readSingleAttributeNode(reader, "uri"), "");
	        var uri = instance.uri, hiddenExtensionType;
	        if (uri === OOXMLFileTypes.hiddenScene3dUri) {
	            hiddenExtensionType = 0;
	        } else if (uri === OOXMLFileTypes.hiddenSp3dUri) {
	            hiddenExtensionType = 3;
	        } else if (uri === OOXMLFileTypes.hiddenFillUri || uri === OOXMLFileTypes.hiddenFillUri2) {
	            hiddenExtensionType = 1;
	        } else if (uri === OOXMLFileTypes.hiddenLineUri || uri === OOXMLFileTypes.hiddenLineUri2) {
	            hiddenExtensionType = 2;
	        } else {
	            hiddenExtensionType = 4;
	        }
	        instance.hiddenExtensionType = hiddenExtensionType;
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "hiddenScene3d":
	                    instance.Scene3d = ReadCT_Scene3D(reader);
	                    break;
	                case "hiddenSp3d":
	                    instance.Shape3d = ReadCT_Shape3D(reader);
	                    break;
	                case "hiddenFill":
	                    instance.Fill = ReadCT_FillProperties(reader);
	                    break;
	                case "hiddenLine":
	                    instance.Line = ReadCT_LineProperties(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_OfficeArtExtension = ReadCT_OfficeArtExtension;
	
	    function ReadCT_Angle(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_Angle = ReadCT_Angle;
	
	    function ReadCT_PositiveFixedAngle(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_PositiveFixedAngle = ReadCT_PositiveFixedAngle;
	
	    function ReadCT_Percentage(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_Percentage = ReadCT_Percentage;
	
	    function ReadCT_PositivePercentage(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_PositivePercentage = ReadCT_PositivePercentage;
	
	    function ReadCT_FixedPercentage(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_FixedPercentage = ReadCT_FixedPercentage;
	
	    function ReadCT_PositiveFixedPercentage(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_PositiveFixedPercentage = ReadCT_PositiveFixedPercentage;
	
	    function ReadCT_Ratio(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "n" || attrName === "d") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Ratio = ReadCT_Ratio;
	
	    function ReadCT_Point2D(reader, needPixel) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "x" || attrName === "y") {
	                instance[attrName] = reader.readContentAsInt();
	                if(needPixel) {
	                    instance[attrName] = emuToPixles(instance[attrName]);
	                }
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Point2D = ReadCT_Point2D;
	
	    function ReadCT_PositiveSize2D(reader, needPixel) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "cx" || attrName === "cy") {
	                instance[attrName] = reader.readContentAsInt();
	                if(needPixel) {
	                    instance[attrName] = emuToPixles(instance[attrName]);
	                }
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PositiveSize2D = ReadCT_PositiveSize2D;
	
	    function ReadCT_ComplementTransform() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_ComplementTransform = ReadCT_ComplementTransform;
	
	    function ReadCT_InverseTransform() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_InverseTransform = ReadCT_InverseTransform;
	
	    function ReadCT_GrayscaleTransform() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_GrayscaleTransform = ReadCT_GrayscaleTransform;
	
	    function ReadCT_GammaTransform() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_GammaTransform = ReadCT_GammaTransform;
	
	    function ReadCT_InverseGammaTransform() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_InverseGammaTransform = ReadCT_InverseGammaTransform;
	
	    function ReadCT_ScRgbColor(reader) {
	        var instance = {} ;
	
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "r" || attrName === "g" || attrName === 'b') {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readColorSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_ScRgbColor = ReadCT_ScRgbColor;
	
	    function StringToByteArray(hex) {
	        var bytes = [];
	        if (hex) {
	            var charCount = hex.length;
	            for (var i = 0; i < charCount; i += 2) {
	                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
	            }
	        }
	        return bytes;
	    }
	
	    DrawingReader.StringToByteArray = StringToByteArray;
	
	    function ReadCT_SRgbColor(reader) {
	        var instance = {};
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            instance.val = StringToByteArray(val);
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readColorSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_SRgbColor = ReadCT_SRgbColor;
	
	    function ReadCT_HslColor(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "hue" || attrName === "sat" || attrName === "lum") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readColorSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_HslColor = ReadCT_HslColor;
	
	    function ReadCT_SystemColor(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_VAL) {
	                instance.val = ChartHelper.ToKnownColor(Charts.ST_SystemColorVal[reader.readContentAsString()]);
	            } else if (attrName === "lastClr") {
	                instance.lastClr = StringToByteArray(reader.readContentAsString());
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readColorSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_SystemColor = ReadCT_SystemColor;
	
	    function ReadCT_SchemeColor(reader) {
	        var instance = {} ;
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            instance.val = ChartHelper.ToColorSchemeIndex(Charts.ST_SchemeColorVal[val]);
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readColorSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_SchemeColor = ReadCT_SchemeColor;
	
	    function ReadCT_PresetColor(reader) {
	        var instance = {} ;
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            instance.val = Charts.ST_PresetColorVal[val];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readColorSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_PresetColor = ReadCT_PresetColor;
	
	    function ReadCT_OfficeArtExtensionList(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var ext = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_EXT) {
	                ext.push(ReadCT_OfficeArtExtension(reader));
	            }
	        }
	        if (ext.length > 0) {
	            instance.ext = ext; 
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_OfficeArtExtensionList = ReadCT_OfficeArtExtensionList;
	
	    function ReadCT_Scale2D(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "sx" || elementName === "sy") {
	                instance[elementName] = ReadCT_Ratio(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Scale2D = ReadCT_Scale2D;
	
	    function ReadCT_Transform2D(reader) {
	        var instance = {rot: 0};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "rot") {
	                instance.rot = reader.readContentAsInt();
	            } else if(attrName === "flipH" || attrName === "flipV") {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "off") {
	                instance.off = ReadCT_Point2D(reader);
	            } else if (elementName === CONST_EXT) {
	                instance.ext = ReadCT_PositiveSize2D(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Transform2D = ReadCT_Transform2D;
	
	    function ReadCT_GroupTransform2D(reader) {
	        var instance = {rot: 0};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "rot") {
	                instance.rot = reader.readContentAsInt();
	            } else if(attrName === "flipH" || attrName === "flipV") {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "off":
	                    instance.off = ReadCT_Point2D(reader);
	                    break;
	                case CONST_EXT:
	                    instance.ext = ReadCT_PositiveSize2D(reader);
	                    break;
	                case "chOff":
	                    instance.chOff = ReadCT_Point2D(reader);
	                    break;
	                case "chExt":
	                    instance.chExt = ReadCT_PositiveSize2D(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GroupTransform2D = ReadCT_GroupTransform2D;
	
	    function ReadCT_Point3D(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "x" || attrName === "y" || attrName === "z") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Point3D = ReadCT_Point3D;
	
	    function ReadCT_Vector3D(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "dx" || attrName === "dy" || attrName === "dz") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Vector3D = ReadCT_Vector3D;
	
	    function ReadCT_SphereCoords(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "lat" || attrName === "lon" || attrName === "rev") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SphereCoords = ReadCT_SphereCoords;
	
	    function ReadCT_RelativeRect(reader) {
	        var instance = {l: 0, r: 0, t: 0, b: 0};//new Charts.CT_RelativeRect()
	       
	        var attrNameObj = {"l": true, "t": true, "r": true, "b": true};
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RelativeRect = ReadCT_RelativeRect;
	
	    function ReadCT_Color(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_Color = ReadCT_Color;
	
	    function ReadCT_ColorMRU(reader) {
	        var instance = {
	            scrgbClr: [],
	            srgbClr: [],
	            hslClr: [],
	            sysClr: [],
	            schemeClr: [],
	            prstClr: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SCRGBCLR:
	                    instance.scrgbClr.push(ReadCT_ScRgbColor(reader));
	                    break;
	                case CONST_SRGBCLR:
	                    instance.srgbClr.push(ReadCT_SRgbColor(reader));
	                    break;
	                case CONST_HSLCLR:
	                    instance.hslClr.push(ReadCT_HslColor(reader));
	                    break;
	                case CONST_SYSCLR:
	                    instance.sysClr.push(ReadCT_SystemColor(reader));
	                    break;
	                case CONST_SCHEMECLR:
	                    instance.schemeClr.push(ReadCT_SchemeColor(reader));
	                    break;
	                case CONST_PRSTCLR:
	                    instance.prstClr.push(ReadCT_PresetColor(reader));
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ColorMRU = ReadCT_ColorMRU;
	
	    function ReadCT_EmbeddedWAVAudioFile(reader) {
	        var instance = {
	            name: '',
	            builtIn: false
	        };
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "embed" || attrName === CONST_NAME) {
	                instance[attrName] = reader.readContentAsString();
	            } else if(attrName === "builtIn") {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EmbeddedWAVAudioFile = ReadCT_EmbeddedWAVAudioFile;
	
	    function ReadCT_Hyperlink(reader) {
	        var instance = {
	            invalidUrl: '',
	            action: '',
	            tgtFrame: '',
	            tooltip: '',
	            history: true,
	            highlightClick: false,
	            endSnd: false
	        };
	        var stringAttrNameObj = {"id": true, "invalidUrl": true, "action": true, "tgtFrame": true, "tooltip": true},
	            boolAttrNameObj = {"history": true, "highlightClick": true, "endSnd": true};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(stringAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsString();
	            } else if(boolAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "snd") {
	                instance.snd = ReadCT_EmbeddedWAVAudioFile(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Hyperlink = ReadCT_Hyperlink;
	
	    function ReadCT_Boolean(reader) {
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_VAL) {
	                return reader.readContentAsBoolean();
	            }
	        }
	    }
	
	    DrawingReader.ReadCT_Boolean = ReadCT_Boolean;
	
	    function ReadCT_Double(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
	    }
	
	    DrawingReader.ReadCT_Double = ReadCT_Double;
	
	    function ReadCT_UnsignedInt(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_UnsignedInt = ReadCT_UnsignedInt;
	
	    function ReadCT_Int(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_Int = ReadCT_Int;
	
	    function ReadCT_RelId(reader) {
	       
	       
	        var instance = {};
	        instance.id = readSingleAttributeNode(reader, "id");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RelId = ReadCT_RelId;
	
	    function ReadCT_Extension(reader) {
	        var instance = {};
	       
	        instance.uri = getValidValue(readSingleAttributeNode(reader, "uri"), "{6F2FDCE9-48DA-4B69-8628-5D25D57E5C99}");
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "invertSolidFillFmt") {
	                instance.dataObject = ReadCT_InvertSolidFillFmt(reader);
	            } else if (elementName === "datalabelsRange") {
	                instance.dataObject = ReadCT_SeriesDataLabelsRange(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Extension = ReadCT_Extension;
	
	    function ReadCT_ExtensionList(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var ext = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_EXT) {
	                ext.push(ReadCT_Extension(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        if (ext.length > 0) {
	            instance.ext = ext;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ExtensionList = ReadCT_ExtensionList;
	
	    function ReadCT_NumVal(reader) {
	        var instance = {};//new Charts.CT_NumVal()
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_IDX) {
	                instance.idx = reader.readContentAsInt();
	            } else if (attrName === "formatCode") {
	                instance.formatCode = reader.readContentAsString();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "v") {
	                instance.v = reader.readElementContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NumVal = ReadCT_NumVal;
	
	    function ReadCT_NumData(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var pt = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "formatCode":
	                    instance.formatCode = reader.readElementContentAsString();
	                    break;
	                case "ptCount":
	                    instance.ptCount = ReadCT_UnsignedInt(reader);
	                    break;
	                case "pt":
	                    pt.push(ReadCT_NumVal(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        if (pt.length > 0) {
	            instance.pt = pt.map(function (item) { return item.v; });
	           
	            var formatCodes = pt.map(function (item) { return item.formatCode; });
	            if (formatCodes.some(function (item) { return !!item; })) {
	                instance.formatCodes = formatCodes;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NumData = ReadCT_NumData;
	
	    function ReadCT_NumRef(reader) {
	        var instance = {};//new Charts.CT_NumRef()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "f":
	                    instance.f = xmlDecode(reader.readElementContentAsString());
	                    break;
	                case "numCache":
	                    var numCache = ReadCT_NumData(reader);
	                    delete numCache.pt;
	                    delete numCache.ptCount;
	                    instance.numCache = numCache;
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NumRef = ReadCT_NumRef;
	
	    function ReadCT_NumDataSource(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "numRef") {
	                instance.numRef = ReadCT_NumRef(reader);
	            } else if (elementName === "numLit") {
	                instance.numLit = ReadCT_NumData(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NumDataSource = ReadCT_NumDataSource;
	
	    function ReadCT_StrVal(reader) {
	       
	       
	        var instance = {};
	        instance[CONST_IDX] = readSingleAttributeNode(reader, CONST_IDX, getAttributeValueOrDefaultOfIntType);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "v") {
	                instance.v = xmlDecode(reader.readElementContentAsString());
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_StrVal = ReadCT_StrVal;
	
	    function ReadCT_StrData(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var pt = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "ptCount":
	                    instance.ptCount = ReadCT_UnsignedInt(reader);
	                    break;
	                case "pt":
	                    pt.push(ReadCT_StrVal(reader).v);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        if (pt.length > 0) {
	            instance.pt = pt;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_StrData = ReadCT_StrData;
	
	    function ReadCT_StrRef(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "f":
	                    instance.f = xmlDecode(reader.readElementContentAsString());
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_StrRef = ReadCT_StrRef;
	
	    function ReadCT_Tx(reader) {
	        var instance = {};//new Charts.CT_Tx()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "strRef") {
	                instance.strRef = ReadCT_StrRef(reader);
	            } else if (elementName === "rich") {
	                instance.rich = ReadCT_TextBody(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Tx = ReadCT_Tx;
	
	    function ReadCT_TextLanguageID(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL);
	    }
	
	    DrawingReader.ReadCT_TextLanguageID = ReadCT_TextLanguageID;
	
	    function ReadCT_Lvl(reader) {
	        var instance = {pt: []};//new Charts.CT_Lvl()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "pt") {
	                instance.pt.push(ReadCT_StrVal(reader));
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Lvl = ReadCT_Lvl;
	
	    function ReadCT_MultiLvlStrData(reader) {
	        var instance = {lvl: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "ptCount":
	                    instance.ptCount = ReadCT_UnsignedInt(reader);
	                    break;
	                case "lvl":
	                    instance.lvl.push(ReadCT_StrData(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_MultiLvlStrData = ReadCT_MultiLvlStrData;
	
	    function ReadCT_MultiLvlStrRef(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "f":
	                    instance.f = xmlDecode(reader.readElementContentAsString());
	                    break;
	                case "multiLvlStrCache":
	                    instance.multiLvlStrCache = ReadCT_MultiLvlStrData(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_MultiLvlStrRef = ReadCT_MultiLvlStrRef;
	
	    function ReadCT_AxDataSource(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "multiLvlStrRef":
	                    instance.multiLvlStrRef = ReadCT_MultiLvlStrRef(reader);
	                    break;
	                case "numRef":
	                    instance.numRef = ReadCT_NumRef(reader);
	                    break;
	                case "numLit":
	                    instance.numLit = ReadCT_NumData(reader);
	                    break;
	                case "strRef":
	                    instance.strRef = ReadCT_StrRef(reader);
	                    break;
	                case "strLit":
	                    instance.strLit = ReadCT_StrData(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AxDataSource = ReadCT_AxDataSource;
	
	    function ReadCT_SerTx(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "strRef") {
	                instance.strRef = ReadCT_StrRef(reader);
	            } else if (elementName === "v") {
	                instance.v = reader.readElementContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SerTx = ReadCT_SerTx;
	
	    function ReadCT_LayoutTarget(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_LayoutTarget[val];
	        }
	    }
	
	    DrawingReader.ReadCT_LayoutTarget = ReadCT_LayoutTarget;
	
	    function ReadCT_LayoutMode(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if(!isNullOrUndefined(val)) {
	            return Charts.ST_LayoutMode[val];
	        }
	    }
	
	    DrawingReader.ReadCT_LayoutMode = ReadCT_LayoutMode;
	
	    function ReadCT_ManualLayout(reader) {
	        var instance = {};//new Charts.CT_ManualLayout()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var modeElementNameObj = {"xMode": true, "yMode": true, "wMode": true, "hMode": true},
	            numberElementNameObj = {"x": true, "y": true, "w": true, "h": true};
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(modeElementNameObj[elementName]) {
	                instance[elementName] = ReadCT_LayoutMode(reader);
	            } else if(numberElementNameObj[elementName]) {
	                instance[elementName] = ReadCT_Double(reader);
	            } else if(elementName === "layoutTarget") {
	                instance.layoutTarget = ReadCT_LayoutTarget(reader);
	            } else if(elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_ExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ManualLayout = ReadCT_ManualLayout;
	
	    function ReadCT_Layout(reader) {
	        var instance = {};//new Charts.CT_Layout()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "manualLayout") {
	                instance.manualLayout = ReadCT_ManualLayout(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_ExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Layout = ReadCT_Layout;
	
	    function ReadCT_Title(reader) {
	        var instance = {};//new Charts.CT_Title()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "tx":
	                    instance.tx = ReadCT_Tx(reader);
	                    break;
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "overlay":
	                    instance.overlay = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Title = ReadCT_Title;
	
	    function ReadCT_RotX(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL), 0);
	    }
	
	    DrawingReader.ReadCT_RotX = ReadCT_RotX;
	
	    function ReadCT_HPercent(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
	    }
	
	    DrawingReader.ReadCT_HPercent = ReadCT_HPercent;
	
	    function ReadCT_RotY(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
	    }
	
	    DrawingReader.ReadCT_RotY = ReadCT_RotY;
	
	    function ReadCT_DepthPercent(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
	    }
	
	    DrawingReader.ReadCT_DepthPercent = ReadCT_DepthPercent;
	
	    function ReadCT_Perspective(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL), 30);
	    }
	
	    DrawingReader.ReadCT_Perspective = ReadCT_Perspective;
	
	    function ReadCT_View3D(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "rotX":
	                    instance.rotX = ReadCT_RotX(reader);
	                    break;
	                case "hPercent":
	                    instance.hPercent = ReadCT_HPercent(reader);
	                    break;
	                case "rotY":
	                    instance.rotY = ReadCT_RotY(reader);
	                    break;
	                case "depthPercent":
	                    instance.depthPercent = ReadCT_DepthPercent(reader);
	                    break;
	                case "rAngAx":
	                    instance.rAngAx = ReadCT_Boolean(reader);
	                    break;
	                case "perspective":
	                    instance.perspective = ReadCT_Perspective(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_View3D = ReadCT_View3D;
	
	    function ReadCT_Surface(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "thickness":
	                    instance.thickness = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_PICTURE_OPTIONS:
	                    instance.pictureOptions = ReadCT_PictureOptions(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Surface = ReadCT_Surface;
	
	    function ReadCT_DTable(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementNameObj = {
	            "showHorzBorder": true,
	            "showVertBorder": true,
	            "showOutline": true,
	            "showKeys": true
	        };
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementNameObj[elementName]) {
	                instance[elementName] = ReadCT_Boolean(reader);
	            } else if(elementName === CONST_SPPR) {
	                instance.spPr = ReadCT_ShapeProperties(reader);
	            } else if(elementName === CONST_TXPR) {
	                instance.txPr = ReadCT_TextBody(reader);
	            } else if(elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_ExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DTable = ReadCT_DTable;
	
	    function ReadCT_GapAmount(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 150);
	    }
	
	    DrawingReader.ReadCT_GapAmount = ReadCT_GapAmount;
	
	    function ReadCT_Overlap(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
	    }
	
	    DrawingReader.ReadCT_Overlap = ReadCT_Overlap;
	
	    function ReadCT_BubbleScale(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
	    }
	
	    DrawingReader.ReadCT_BubbleScale = ReadCT_BubbleScale;
	
	    function ReadCT_SizeRepresents(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'area' );
	       
	        return Charts.ST_SizeRepresents[val];
	    }
	
	    DrawingReader.ReadCT_SizeRepresents = ReadCT_SizeRepresents;
	
	    function ReadCT_FirstSliceAng(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
	    }
	
	    DrawingReader.ReadCT_FirstSliceAng = ReadCT_FirstSliceAng;
	
	    function ReadCT_HoleSize(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
	    }
	
	    DrawingReader.ReadCT_HoleSize = ReadCT_HoleSize;
	
	    function ReadCT_SplitType(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'auto' );
	        return ChartHelper.ToChartSplitType(Charts.ST_SplitType[val]);
	    }
	
	    DrawingReader.ReadCT_SplitType = ReadCT_SplitType;
	
	    function ReadCT_CustSplit(reader) {
	        var instance = {secondPiePt: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "secondPiePt") {
	                 instance.secondPiePt.push(ReadCT_UnsignedInt(reader));
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CustSplit = ReadCT_CustSplit;
	
	    function ReadCT_SecondPieSize(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 75);
	    }
	
	    DrawingReader.ReadCT_SecondPieSize = ReadCT_SecondPieSize;
	
	    function ReadCT_NumFmt(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === "formatCode") {
	                instance.formatCode = xmlDecode(reader.readContentAsString());
	            } else if (attrName === "sourceLinked") {
	                var sourceLinked = reader.readContentAsBoolean();
	                if (!sourceLinked) {
	                    instance.sourceLinked = false; 
	                }
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NumFmt = ReadCT_NumFmt;
	
	    function ReadCT_LblAlgn(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_LblAlgn[val];
	        }
	    }
	
	    DrawingReader.ReadCT_LblAlgn = ReadCT_LblAlgn;
	
	    function ReadCT_DLblPos(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_DLblPos[val];
	        }
	    }
	
	    DrawingReader.ReadCT_DLblPos = ReadCT_DLblPos;
	
	    function ReadCT_DLbl(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_Tx(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case "dLblPos":
	                    instance.dLblPos = ReadCT_DLblPos(reader);
	                    break;
	                case "showLegendKey":
	                    instance.showLegendKey = ReadCT_Boolean(reader);
	                    break;
	                case "showVal":
	                    instance.showVal = ReadCT_Boolean(reader);
	                    break;
	                case "showCatName":
	                    instance.showCatName = ReadCT_Boolean(reader);
	                    break;
	                case "showSerName":
	                    instance.showSerName = ReadCT_Boolean(reader);
	                    break;
	                case "showPercent":
	                    instance.showPercent = ReadCT_Boolean(reader);
	                    break;
	                case "showBubbleSize":
	                    instance.showBubbleSize = ReadCT_Boolean(reader);
	                    break;
	                case "separator":
	                    instance.separator = reader.readElementContentAsString(true);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_DLblExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DLbl = ReadCT_DLbl;
	
	    function ReadCT_DLbls(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dLbl = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "dLbl":
	                    dLbl.push(ReadCT_DLbl(reader));
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case "dLblPos":
	                    instance.dLblPos = ReadCT_DLblPos(reader);
	                    break;
	                case "showLegendKey":
	                    instance.showLegendKey = ReadCT_Boolean(reader);
	                    break;
	                case "showVal":
	                    instance.showVal = ReadCT_Boolean(reader);
	                    break;
	                case "showCatName":
	                    instance.showCatName = ReadCT_Boolean(reader);
	                    break;
	                case "showSerName":
	                    instance.showSerName = ReadCT_Boolean(reader);
	                    break;
	                case "showPercent":
	                    instance.showPercent = ReadCT_Boolean(reader);
	                    break;
	                case "showBubbleSize":
	                    instance.showBubbleSize = ReadCT_Boolean(reader);
	                    break;
	                case "separator":
	                    instance.separator = reader.readElementContentAsString(true);
	                    break;
	                case "showLeaderLines":
	                    instance.showLeaderLines = ReadCT_Boolean(reader);
	                    break;
	                case "leaderLines":
	                    instance.leaderLines = ReadCT_ChartLines(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_DLblsExtensionList(reader);
	                    break;
	            }
	        }
	        if (dLbl.length > 0) {
	            instance.dLbl = dLbl;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DLbls = ReadCT_DLbls;
	
	    function ReadCT_MarkerStyle(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_MarkerStyle[val];
	        }
	    }
	
	    DrawingReader.ReadCT_MarkerStyle = ReadCT_MarkerStyle;
	
	    function ReadCT_MarkerSize(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL), 5);
	    }
	
	    DrawingReader.ReadCT_MarkerSize = ReadCT_MarkerSize;
	
	    function ReadCT_Marker(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "symbol":
	                    instance.symbol = ReadCT_MarkerStyle(reader);
	                    break;
	                case "size":
	                    instance.size = ReadCT_MarkerSize(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Marker = ReadCT_Marker;
	
	    function ReadCT_DPt(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_INVERT_IF_NEGATIVE:
	                    instance.invertIfNegative = ReadCT_Boolean(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Marker(reader);
	                    break;
	                case CONST_BUBBLE_3D:
	                    instance.bubble3D = ReadCT_Boolean(reader);
	                    break;
	                case "explosion":
	                    instance.explosion = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_PICTURE_OPTIONS:
	                    instance.pictureOptions = ReadCT_PictureOptions(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DPt = ReadCT_DPt;
	
	    function ReadCT_TrendlineType(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_TrendlineType[val];
	        }
	    }
	
	    DrawingReader.ReadCT_TrendlineType = ReadCT_TrendlineType;
	
	    function ReadCT_Order(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL);
	    }
	
	    DrawingReader.ReadCT_Order = ReadCT_Order;
	
	    function ReadCT_Period(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL);
	    }
	
	    DrawingReader.ReadCT_Period = ReadCT_Period;
	
	    function ReadCT_TrendlineLbl(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_Tx(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TrendlineLbl = ReadCT_TrendlineLbl;
	
	    function ReadCT_Trendline(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_NAME:
	                    instance.name = reader.readElementContentAsString();
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case "trendlineType":
	                    instance.trendlineType = ReadCT_TrendlineType(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_Order(reader);
	                    break;
	                case "period":
	                    instance.period = ReadCT_Period(reader);
	                    break;
	                case "forward":
	                    instance.forward = ReadCT_Double(reader);
	                    break;
	                case "backward":
	                    instance.backward = ReadCT_Double(reader);
	                    break;
	                case "intercept":
	                    instance.intercept = ReadCT_Double(reader);
	                    break;
	                case "dispRSqr":
	                    instance.dispRSqr = ReadCT_Boolean(reader);
	                    break;
	                case "dispEq":
	                    instance.dispEq = ReadCT_Boolean(reader);
	                    break;
	                case "trendlineLbl":
	                    instance.trendlineLbl = ReadCT_TrendlineLbl(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Trendline = ReadCT_Trendline;
	
	    function ReadCT_ErrDir(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_ErrDir[val];
	        }
	    }
	
	    DrawingReader.ReadCT_ErrDir = ReadCT_ErrDir;
	
	    function ReadCT_ErrBarType(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_ErrBarType[val];
	        }
	    }
	
	    DrawingReader.ReadCT_ErrBarType = ReadCT_ErrBarType;
	
	    function ReadCT_ErrValType(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_ErrValType[val];
	        }
	    }
	
	    DrawingReader.ReadCT_ErrValType = ReadCT_ErrValType;
	
	    function ReadCT_ErrBars(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "errDir":
	                    instance.errDir = ReadCT_ErrDir(reader);
	                    break;
	                case "errBarType":
	                    instance.errBarType = ReadCT_ErrBarType(reader);
	                    break;
	                case "errValType":
	                    instance.errValType = ReadCT_ErrValType(reader);
	                    break;
	                case "noEndCap":
	                    instance.noEndCap = ReadCT_Boolean(reader);
	                    break;
	                case "plus":
	                    instance.plus = ReadCT_NumDataSource(reader);
	                    break;
	                case "minus":
	                    instance.minus = ReadCT_NumDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_Double(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ErrBars = ReadCT_ErrBars;
	
	    function ReadCT_UpDownBar(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === CONST_SPPR) {
	                instance.spPr = ReadCT_ShapeProperties(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_UpDownBar = ReadCT_UpDownBar;
	
	    function ReadCT_UpDownBars(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_GAP_WIDTH:
	                    instance.gapWidth = ReadCT_GapAmount(reader);
	                    break;
	                case "upBars":
	                    instance.upBars = ReadCT_UpDownBar(reader);
	                    break;
	                case "downBars":
	                    instance.downBars = ReadCT_UpDownBar(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_UpDownBars = ReadCT_UpDownBars;
	
	    function setSerArrayProperties(instance, dPt, trendline, errBars) {
	        if (dPt.length > 0) {
	            instance.dPt = dPt;
	        }
	        if (errBars && errBars.length > 0) {
	            instance.errBars = errBars;
	        }
	        if (trendline && trendline.length > 0) {
	            instance.trendline = trendline;
	        }
	    }
	
	    function ReadCT_LineSer(reader) {
	       
	        var instance = {
	            seriesType: 2 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dPt = [], trendline = [], errBars = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Marker(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_TRENDLINE:
	                    trendline.push(ReadCT_Trendline(reader));
	                    break;
	                case CONST_ERR_BARS:
	                    errBars.push(ReadCT_ErrBars(reader));
	                    break;
	                case "cat":
	                    instance.cat = ReadCT_AxDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_NumDataSource(reader);
	                    break;
	                case "smooth":
	                    instance.smooth = ReadCT_Boolean(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt, trendline, errBars);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LineSer = ReadCT_LineSer;
	
	    function ReadCT_ScatterSer(reader) {
	       
	        var instance = {
	            seriesType: 5 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dPt = [], trendline = [], errBars = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Marker(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_TRENDLINE:
	                    trendline.push(ReadCT_Trendline(reader));
	                    break;
	                case CONST_ERR_BARS:
	                    errBars.push(ReadCT_ErrBars(reader));
	                    break;
	                case "xVal":
	                    instance.xVal = ReadCT_AxDataSource(reader);
	                    break;
	                case "yVal":
	                    instance.yVal = ReadCT_NumDataSource(reader);
	                    break;
	                case "smooth":
	                    instance.smooth = ReadCT_Boolean(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt, trendline, errBars);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ScatterSer = ReadCT_ScatterSer;
	
	    function ReadCT_RadarSer(reader) {
	       
	        var instance = {
	            seriesType: 4 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dPt = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Marker(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case "cat":
	                    instance.cat = ReadCT_AxDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_NumDataSource(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RadarSer = ReadCT_RadarSer;
	
	    function ReadCT_BarSer(reader) {
	       
	        var instance = {
	            seriesType: 0 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dPt = [], trendline = [], errBars = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_INVERT_IF_NEGATIVE:
	                    instance.invertIfNegative = ReadCT_Boolean(reader);
	                    break;
	                case CONST_PICTURE_OPTIONS:
	                    instance.pictureOptions = ReadCT_PictureOptions(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_TRENDLINE:
	                    trendline.push(ReadCT_Trendline(reader));
	                    break;
	                case CONST_ERR_BARS:
	                    errBars.push(ReadCT_ErrBars(reader));
	                    break;
	                case "cat":
	                    instance.cat = ReadCT_AxDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_NumDataSource(reader);
	                    break;
	                case "shape":
	                    instance.shape = ReadCT_ShapeBox(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt, trendline, errBars);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BarSer = ReadCT_BarSer;
	
	    function ReadCT_AreaSer(reader) {
	       
	        var instance = {
	            seriesType: 1 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dPt = [], trendline = [], errBars = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_PICTURE_OPTIONS:
	                    instance.pictureOptions = ReadCT_PictureOptions(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_TRENDLINE:
	                    trendline.push(ReadCT_Trendline(reader));
	                    break;
	                case CONST_ERR_BARS:
	                    errBars.push(ReadCT_ErrBars(reader));
	                    break;
	                case "cat":
	                    instance.cat = ReadCT_AxDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_NumDataSource(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt, trendline, errBars);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AreaSer = ReadCT_AreaSer;
	
	    function ReadCT_PieSer(reader) {
	       
	        var instance = {
	            seriesType: 3 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	        var dPt = [];
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case "explosion":
	                    instance.explosion = ReadCT_UnsignedInt(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case "cat":
	                    instance.cat = ReadCT_AxDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_NumDataSource(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PieSer = ReadCT_PieSer;
	
	    function ReadCT_BubbleSer(reader) {
	       
	        var instance = {
	            seriesType: 6 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var dPt = [], trendline = [], errBars = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_INVERT_IF_NEGATIVE:
	                    instance.invertIfNegative = ReadCT_Boolean(reader);
	                    break;
	                case "dPt":
	                    dPt.push(ReadCT_DPt(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_TRENDLINE:
	                    trendline.push(ReadCT_Trendline(reader));
	                    break;
	                case CONST_ERR_BARS:
	                    errBars.push(ReadCT_ErrBars(reader));
	                    break;
	                case "xVal":
	                    instance.xVal = ReadCT_AxDataSource(reader);
	                    break;
	                case "yVal":
	                    instance.yVal = ReadCT_NumDataSource(reader);
	                    break;
	                case "bubbleSize":
	                    instance.bubbleSize = ReadCT_NumDataSource(reader);
	                    break;
	                case CONST_BUBBLE_3D:
	                    instance.bubble3D = ReadCT_Boolean(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        setSerArrayProperties(instance, dPt, trendline, errBars);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BubbleSer = ReadCT_BubbleSer;
	
	    function ReadCT_SurfaceSer(reader) {
	       
	        var instance = {seriesType: 7 };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_ORDER:
	                    instance.order = ReadCT_UnsignedInt(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_SerTx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case "cat":
	                    instance.cat = ReadCT_AxDataSource(reader);
	                    break;
	                case CONST_VAL:
	                    instance.val = ReadCT_NumDataSource(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SurfaceSer = ReadCT_SurfaceSer;
	
	    function ReadCT_Grouping(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'standard' );
	        return Charts.ST_Grouping[val];
	    }
	
	    DrawingReader.ReadCT_Grouping = ReadCT_Grouping;
	
	    function ReadCT_ChartLines(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SPPR, ReadCT_ShapeProperties);
	    }
	
	    DrawingReader.ReadCT_ChartLines = ReadCT_ChartLines;
	
	    function ReadCT_LineChart(reader) {
	        var instance = {
	            chartType: 8,
	            ser: [],
	            axId: []
	        };//new Charts.CT_LineChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_GROUPING:
	                    instance.grouping = ReadCT_Grouping(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_LineSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_DROP_LINES:
	                    instance.dropLines = ReadCT_ChartLines(reader);
	                    break;
	                case "hiLowLines":
	                    instance.hiLowLines = ReadCT_ChartLines(reader);
	                    break;
	                case "upDownBars":
	                    instance.upDownBars = ReadCT_UpDownBars(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Boolean(reader);
	                    break;
	                case "smooth":
	                    instance.smooth = ReadCT_Boolean(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LineChart = ReadCT_LineChart;
	
	    function ReadCT_Line3DChart(reader) {
	        var instance = {
	            chartType: 9,
	            ser: [],
	            axId: []
	        };//new Charts.CT_Line3DChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_GROUPING:
	                    instance.grouping = ReadCT_Grouping(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_LineSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_DROP_LINES:
	                    instance.dropLines = ReadCT_ChartLines(reader);
	                    break;
	                case "gapDepth":
	                    instance.gapDepth = ReadCT_GapAmount(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Line3DChart = ReadCT_Line3DChart;
	
	    function ReadCT_StockChart(reader) {
	        var instance = {
	            chartType: 0,
	            ser: [],
	            axId: []
	        };//new Charts.CT_StockChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SER:
	                    instance.ser.push(ReadCT_LineSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_DROP_LINES:
	                    instance.dropLines = ReadCT_ChartLines(reader);
	                    break;
	                case "hiLowLines":
	                    instance.hiLowLines = ReadCT_ChartLines(reader);
	                    break;
	                case "upDownBars":
	                    instance.upDownBars = ReadCT_UpDownBars(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_StockChart = ReadCT_StockChart;
	
	    function ReadCT_ScatterStyle(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'marker' );
	        return Charts.ST_ScatterStyle[val];
	    }
	
	    DrawingReader.ReadCT_ScatterStyle = ReadCT_ScatterStyle;
	
	    function ReadCT_ScatterChart(reader) {
	        var instance = {
	            chartType: 1,
	            ser: [],
	            axId: []
	        };//new Charts.CT_ScatterChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "scatterStyle":
	                    instance.scatterStyle = ReadCT_ScatterStyle(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_ScatterSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ScatterChart = ReadCT_ScatterChart;
	
	    function ReadCT_RadarStyle(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'standard' );
	        return Charts.ST_RadarStyle[val];
	    }
	
	    DrawingReader.ReadCT_RadarStyle = ReadCT_RadarStyle;
	
	    function ReadCT_RadarChart(reader) {
	        var instance = {
	            chartType: 2,
	            ser: [],
	            axId: []
	        };//new Charts.CT_RadarChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "radarStyle":
	                    instance.radarStyle = ReadCT_RadarStyle(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_RadarSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RadarChart = ReadCT_RadarChart;
	
	    function ReadCT_BarGrouping(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if(!isNullOrUndefined(val)) {
	            return Charts.ST_BarGrouping[val];
	        }
	    }
	
	    DrawingReader.ReadCT_BarGrouping = ReadCT_BarGrouping;
	
	    function ReadCT_BarDir(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_BarDir[val];
	        }
	    }
	
	    DrawingReader.ReadCT_BarDir = ReadCT_BarDir;
	
	    function ReadCT_ShapeBox(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'box' );
	       
	        return Charts.ST_Shape[val];
	    }
	
	    DrawingReader.ReadCT_ShapeBox = ReadCT_ShapeBox;
	
	    function ReadCT_BarChart(reader) {
	        var instance = {
	            chartType: 6,
	            ser: [],
	            serLines: [],
	            axId: []
	        };//new Charts.CT_BarChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "barDir":
	                    instance.barDir = ReadCT_BarDir(reader);
	                    break;
	                case CONST_GROUPING:
	                    instance.grouping = ReadCT_BarGrouping(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_BarSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_GAP_WIDTH:
	                    instance.gapWidth = ReadCT_GapAmount(reader);
	                    break;
	                case "overlap":
	                    instance.overlap = ReadCT_Overlap(reader);
	                    break;
	                case "serLines":
	                    instance.serLines.push(ReadCT_ChartLines(reader));
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BarChart = ReadCT_BarChart;
	
	    function ReadCT_Bar3DChart(reader) {
	        var instance = {
	            chartType: 7,
	            ser: [],
	            axId: []
	        };//new Charts.CT_Bar3DChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "barDir":
	                    instance.barDir = ReadCT_BarDir(reader);
	                    break;
	                case CONST_GROUPING:
	                    instance.grouping = ReadCT_BarGrouping(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_BarSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_GAP_WIDTH:
	                    instance.gapWidth = ReadCT_GapAmount(reader);
	                    break;
	                case "gapDepth":
	                    instance.gapDepth = ReadCT_GapAmount(reader);
	                    break;
	                case "shape":
	                    instance.shape = ReadCT_ShapeBox(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Bar3DChart = ReadCT_Bar3DChart;
	
	    function ReadCT_AreaChart(reader) {
	        var instance = {
	            chartType: 4,
	            ser: [],
	            axId: []
	        };//new Charts.CT_AreaChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_GROUPING:
	                    instance.grouping = ReadCT_Grouping(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_AreaSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_DROP_LINES:
	                    instance.dropLines = ReadCT_ChartLines(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AreaChart = ReadCT_AreaChart;
	
	    function ReadCT_Area3DChart(reader) {
	        var instance = {
	            chartType: 5,
	            ser: [],
	            axId: []
	        };//new Charts.CT_Area3DChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_GROUPING:
	                    instance.grouping = ReadCT_Grouping(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_AreaSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_DROP_LINES:
	                    instance.dropLines = ReadCT_ChartLines(reader);
	                    break;
	                case "gapDepth":
	                    instance.gapDepth = ReadCT_GapAmount(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Area3DChart = ReadCT_Area3DChart;
	
	    function ReadCT_PieChart(reader) {
	        var instance = {
	            chartType: 10,
	            ser: [],
	            axId: []
	        };//new Charts.CT_PieChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_PieSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case "firstSliceAng":
	                    instance.firstSliceAng = ReadCT_FirstSliceAng(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PieChart = ReadCT_PieChart;
	
	    function ReadCT_Pie3DChart(reader) {
	        var instance = {
	            chartType: 11,
	            ser: [],
	            axId: []
	        };//new Charts.CT_Pie3DChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_PieSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Pie3DChart = ReadCT_Pie3DChart;
	
	    function ReadCT_DoughnutChart(reader) {
	        var instance = {
	            chartType: 12,
	            ser: [],
	            axId: []
	        };//new Charts.CT_DoughnutChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_PieSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case "firstSliceAng":
	                    instance.firstSliceAng = ReadCT_FirstSliceAng(reader);
	                    break;
	                case "holeSize":
	                    instance.holeSize = ReadCT_HoleSize(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DoughnutChart = ReadCT_DoughnutChart;
	
	    function ReadCT_OfPieType(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_OfPieType[val];
	        }
	    }
	
	    DrawingReader.ReadCT_OfPieType = ReadCT_OfPieType;
	
	    function ReadCT_OfPieChart(reader) {
	        var instance = {
	            chartType: 13,
	            ser: [],
	            serLines: [],
	            axId: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "ofPieType":
	                    instance.ofPieType = ReadCT_OfPieType(reader);
	                    break;
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_PieSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_GAP_WIDTH:
	                    instance.gapWidth = ReadCT_GapAmount(reader);
	                    break;
	                case "splitType":
	                    instance.splitType = ReadCT_SplitType(reader);
	                    break;
	                case "splitPos":
	                    instance.splitPos = ReadCT_Double(reader);
	                    break;
	                case "custSplit":
	                    instance.custSplit = ReadCT_CustSplit(reader);
	                    break;
	                case "secondPieSize":
	                    instance.secondPieSize = ReadCT_SecondPieSize(reader);
	                    break;
	                case "serLines":
	                    instance.serLines.push(ReadCT_ChartLines(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_OfPieChart = ReadCT_OfPieChart;
	
	    function ReadCT_BubbleChart(reader) {
	        var instance = {
	            chartType: 3,
	            ser: [],
	            axId: []
	        };//new Charts.CT_BubbleChart()
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_VARY_COLORS:
	                    instance.varyColors = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SER:
	                    instance.ser.push(ReadCT_BubbleSer(reader));
	                    break;
	                case COSNT_DLBLS:
	                    instance.dLbls = ReadCT_DLbls(reader);
	                    break;
	                case CONST_BUBBLE_3D:
	                    instance.bubble3D = ReadCT_Boolean(reader);
	                    break;
	                case "bubbleScale":
	                    instance.bubbleScale = ReadCT_BubbleScale(reader);
	                    break;
	                case "showNegBubbles":
	                    instance.showNegBubbles = ReadCT_Boolean(reader);
	                    break;
	                case "sizeRepresents":
	                    instance.sizeRepresents = ReadCT_SizeRepresents(reader);
	                    break;
	                case CONST_AXID:
	                    instance.axId.push(ReadCT_Int(reader));
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BubbleChart = ReadCT_BubbleChart;
	
	    function ReadCT_BandFmt(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_IDX) {
	                instance.idx = ReadCT_UnsignedInt(reader);
	            } else if (elementName === CONST_SPPR) {
	                instance.spPr = ReadCT_ShapeProperties(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BandFmt = ReadCT_BandFmt;
	
	    function ReadCT_BandFmts(reader) {
	        var instance = {bandFmt: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "bandFmt") {
	                instance.bandFmt.push(ReadCT_BandFmt(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BandFmts = ReadCT_BandFmts;
	
	    function ReadCT_SurfaceChart(reader) {
	        var instance = {
	            chartType: 14,
	            ser: [],
	            axId: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSurfaceChartSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_SurfaceChart = ReadCT_SurfaceChart;
	
	    function ReadCT_Surface3DChart(reader) {
	        var instance = {
	            chartType: 15,
	            ser: [],
	            axId: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSurfaceChartSubElement(reader, instance);
	    }
	
	    DrawingReader.ReadCT_Surface3DChart = ReadCT_Surface3DChart;
	
	    function ReadCT_AxPos(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_AxPos[val];
	        }
	    }
	
	    DrawingReader.ReadCT_AxPos = ReadCT_AxPos;
	
	    function ReadCT_Crosses(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return ChartHelper.ToAxisCrosses(Charts.ST_Crosses[val]);
	        }
	    }
	
	    DrawingReader.ReadCT_Crosses = ReadCT_Crosses;
	
	    function ReadCT_CrossBetween(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return Charts.ST_CrossBetween[val];
	        }
	    }
	
	    DrawingReader.ReadCT_CrossBetween = ReadCT_CrossBetween;
	
	    function ReadCT_TickMark(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_TickMark[val];
	        }
	    }
	
	    DrawingReader.ReadCT_TickMark = ReadCT_TickMark;
	
	    function ReadCT_TickLblPos(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'nextTo' );
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_TickLblPos[val];
	        }
	    }
	
	    DrawingReader.ReadCT_TickLblPos = ReadCT_TickLblPos;
	
	    function ReadCT_Skip(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_Skip = ReadCT_Skip;
	
	    function ReadCT_TimeUnit(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'days' );
	       
	        return Charts.ST_TimeUnit[val];
	    }
	
	    DrawingReader.ReadCT_TimeUnit = ReadCT_TimeUnit;
	
	    function ReadCT_AxisUnit(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
	    }
	
	    DrawingReader.ReadCT_AxisUnit = ReadCT_AxisUnit;
	
	    function ReadCT_BuiltInUnit(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_BuiltInUnit[val];
	        }
	    }
	
	    DrawingReader.ReadCT_BuiltInUnit = ReadCT_BuiltInUnit;
	
	    function ReadCT_PictureFormat(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_PictureFormat[val];
	        }
	    }
	
	    DrawingReader.ReadCT_PictureFormat = ReadCT_PictureFormat;
	
	    function ReadCT_PictureStackUnit(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
	    }
	
	    DrawingReader.ReadCT_PictureStackUnit = ReadCT_PictureStackUnit;
	
	    function ReadCT_PictureOptions(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementNameObj = {
	            "applyToFront": true,
	            "applyToSides": true,
	            "applyToEnd": true
	        };
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementNameObj[elementName]) {
	                instance[elementName] = ReadCT_Boolean(reader);
	            } else if(elementName === "pictureFormat") {
	                instance.pictureFormat = ReadCT_PictureFormat(reader);
	            } else if(elementName === "pictureStackUnit") {
	                instance.pictureStackUnit = ReadCT_PictureStackUnit(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PictureOptions = ReadCT_PictureOptions;
	
	    function ReadCT_DispUnitsLbl(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "tx":
	                    instance.tx = ReadCT_Tx(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DispUnitsLbl = ReadCT_DispUnitsLbl;
	
	    function ReadCT_DispUnits(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "custUnit":
	                    instance.custUnit = ReadCT_Double(reader);
	                    break;
	                case "builtInUnit":
	                    instance.builtInUnit = ReadCT_BuiltInUnit(reader);
	                    break;
	                case "dispUnitsLbl":
	                    instance.dispUnitsLbl = ReadCT_DispUnitsLbl(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DispUnits = ReadCT_DispUnits;
	
	    function ReadCT_Orientation(reader) {
	       
	        var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'minMax' );
	        return Charts.ST_Orientation[val];
	    }
	
	    DrawingReader.ReadCT_Orientation = ReadCT_Orientation;
	
	    function ReadCT_LogBase(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
	    }
	
	    DrawingReader.ReadCT_LogBase = ReadCT_LogBase;
	
	    function ReadCT_Scaling(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "logBase":
	                    instance.logBase = ReadCT_LogBase(reader);
	                    break;
	                case "orientation":
	                    instance.orientation = ReadCT_Orientation(reader);
	                    break;
	                case "max":
	                    instance.max = ReadCT_Double(reader);
	                    break;
	                case "min":
	                    instance.min = ReadCT_Double(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Scaling = ReadCT_Scaling;
	
	    function ReadCT_LblOffset(reader) {
	       
	        return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
	    }
	
	    DrawingReader.ReadCT_LblOffset = ReadCT_LblOffset;
	
	    var Default_spPrs = {
	        majorGridlines: { "ln": { "w": 1, "cap": 2, "cmpd": 0, "algn": 0, "solidFill": { "schemeClr": { "val": 1, "lumMod": [15000], "lumOff": [85000] } }, "round": true }, "effectLst": {} },
	        minorGridlines: { "ln": { "w": 1, "cap": 2, "cmpd": 0, "algn": 0, "solidFill": { "schemeClr": { "val": 1, "lumMod": [5000], "lumOff": [95000] } }, "round": true }, "effectLst": {} },
	        axis: { "noFill": true, "ln": { "w": 1, "cap": 2, "cmpd": 0, "algn": 0, "solidFill": { "schemeClr": { "val": 1, "lumMod": [15000], "lumOff": [85000] } }, "round": true }, "effectLst": {} },
	        plotArea: { "noFill": true, "ln": { "noFill": true }, "effectLst": {} }
	    };
	    function adjust_spPr(obj, name) {
	        if (obj && !obj.spPr) {
	            obj.spPr = Default_spPrs[name];
	        }
	    }
	    function ReadCT_CatAx(reader) {
	        var instance = {axisType: 0};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_AXID:
	                    instance.axId = ReadCT_Int(reader);
	                    break;
	                case CONST_SCALING:
	                    instance.scaling = ReadCT_Scaling(reader);
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_AX_POS:
	                    instance.axPos = ReadCT_AxPos(reader);
	                    break;
	                case CONST_MAJOR_GRIDLINES:
	                    instance.majorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.majorGridlines, "majorGridlines");
	                    break;
	                case CONST_MINOR_GRIDLINES:
	                    instance.minorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.minorGridlines, "minorGridlines");
	                    break;
	                case CONST_TITLE:
	                    instance.title = ReadCT_Title(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_MAJOR_TICK_MARK:
	                    instance.majorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_MINOR_TICK_MARK:
	                    instance.minorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_TICK_LBLPOS:
	                    instance.tickLblPos = ReadCT_TickLblPos(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_CROSSAX:
	                    instance.crossAx = ReadCT_Int(reader);
	                    break;
	                case CONST_CROSSES:
	                    instance.crosses = ReadCT_Crosses(reader);
	                    break;
	                case CONST_CROSSAT:
	                    instance.crossesAt = ReadCT_Double(reader);
	                    break;
	                case "auto":
	                    instance.auto = ReadCT_Boolean(reader);
	                    break;
	                case "lblAlgn":
	                    instance.lblAlgn = ReadCT_LblAlgn(reader);
	                    break;
	                case "lblOffset":
	                    instance.lblOffset = ReadCT_LblOffset(reader);
	                    break;
	                case "tickLblSkip":
	                    instance.tickLblSkip = ReadCT_Skip(reader);
	                    break;
	                case "tickMarkSkip":
	                    instance.tickMarkSkip = ReadCT_Skip(reader);
	                    break;
	                case "noMultiLvlLbl":
	                    instance.noMultiLvlLbl = ReadCT_Boolean(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        adjust_spPr(instance, "axis");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CatAx = ReadCT_CatAx;
	
	    function ReadCT_DateAx(reader) {
	        var instance = {axisType: 1};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_AXID:
	                    instance.axId = ReadCT_Int(reader);
	                    break;
	                case CONST_SCALING:
	                    instance.scaling = ReadCT_Scaling(reader);
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_AX_POS:
	                    instance.axPos = ReadCT_AxPos(reader);
	                    break;
	                case CONST_MAJOR_GRIDLINES:
	                    instance.majorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.majorGridlines, "majorGridlines");
	                    break;
	                case CONST_MINOR_GRIDLINES:
	                    instance.minorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.minorGridlines, "minorGridlines");
	                    break;
	                case CONST_TITLE:
	                    instance.title = ReadCT_Title(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_MAJOR_TICK_MARK:
	                    instance.majorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_MINOR_TICK_MARK:
	                    instance.minorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_TICK_LBLPOS:
	                    instance.tickLblPos = ReadCT_TickLblPos(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_CROSSAX:
	                    instance.crossAx = ReadCT_Int(reader);
	                    break;
	                case CONST_CROSSES:
	                    instance.crosses = ReadCT_Crosses(reader);
	                    break;
	                case CONST_CROSSAT:
	                    instance.crossesAt = ReadCT_Double(reader);
	                    break;
	                case "auto":
	                    instance.auto = ReadCT_Boolean(reader);
	                    break;
	                case "lblOffset":
	                    instance.lblOffset = ReadCT_LblOffset(reader);
	                    break;
	                case "baseTimeUnit":
	                    instance.baseTimeUnit = ReadCT_TimeUnit(reader);
	                    break;
	                case "majorUnit":
	                    instance.majorUnit = ReadCT_AxisUnit(reader);
	                    break;
	                case "majorTimeUnit":
	                    instance.majorTimeUnit = ReadCT_TimeUnit(reader);
	                    break;
	                case "minorUnit":
	                    instance.minorUnit = ReadCT_AxisUnit(reader);
	                    break;
	                case "minorTimeUnit":
	                    instance.minorTimeUnit = ReadCT_TimeUnit(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        adjust_spPr(instance, "axis");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DateAx = ReadCT_DateAx;
	
	    function ReadCT_SerAx(reader) {
	        var instance = {axisType: 2};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_AXID:
	                    instance.axId = ReadCT_Int(reader);
	                    break;
	                case CONST_SCALING:
	                    instance.scaling = ReadCT_Scaling(reader);
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_AX_POS:
	                    instance.axPos = ReadCT_AxPos(reader);
	                    break;
	                case CONST_MAJOR_GRIDLINES:
	                    instance.majorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.majorGridlines, "majorGridlines");
	                    break;
	                case CONST_MINOR_GRIDLINES:
	                    instance.minorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.minorGridlines, "minorGridlines");
	                    break;
	                case CONST_TITLE:
	                    instance.title = ReadCT_Title(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_MAJOR_TICK_MARK:
	                    instance.majorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_MINOR_TICK_MARK:
	                    instance.minorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_TICK_LBLPOS:
	                    instance.tickLblPos = ReadCT_TickLblPos(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_CROSSAX:
	                    instance.crossAx = ReadCT_Int(reader);
	                    break;
	                case CONST_CROSSES:
	                    instance.crosses = ReadCT_Crosses(reader);
	                    break;
	                case CONST_CROSSAT:
	                    instance.crossesAt = ReadCT_Double(reader);
	                    break;
	                case "tickLblSkip":
	                    instance.tickLblSkip = ReadCT_Skip(reader);
	                    break;
	                case "tickMarkSkip":
	                    instance.tickMarkSkip = ReadCT_Skip(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        adjust_spPr(instance, "axis");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SerAx = ReadCT_SerAx;
	
	    function ReadCT_ValAx(reader) {
	        var instance = {axisType: 3};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_AXID:
	                    instance.axId = ReadCT_Int(reader);
	                    break;
	                case CONST_SCALING:
	                    instance.scaling = ReadCT_Scaling(reader);
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_AX_POS:
	                    instance.axPos = ReadCT_AxPos(reader);
	                    break;
	                case CONST_MAJOR_GRIDLINES:
	                    instance.majorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.majorGridlines, "majorGridlines");
	                    break;
	                case CONST_MINOR_GRIDLINES:
	                    instance.minorGridlines = ReadCT_ChartLines(reader);
	                    adjust_spPr(instance.minorGridlines, "minorGridlines");
	                    break;
	                case CONST_TITLE:
	                    instance.title = ReadCT_Title(reader);
	                    break;
	                case CONST_NUMFMT:
	                    instance.numFmt = ReadCT_NumFmt(reader);
	                    break;
	                case CONST_MAJOR_TICK_MARK:
	                    instance.majorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_MINOR_TICK_MARK:
	                    instance.minorTickMark = ReadCT_TickMark(reader);
	                    break;
	                case CONST_TICK_LBLPOS:
	                    instance.tickLblPos = ReadCT_TickLblPos(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_CROSSAX:
	                    instance.crossAx = ReadCT_Int(reader);
	                    break;
	                case CONST_CROSSES:
	                    instance.crosses = ReadCT_Crosses(reader);
	                    break;
	                case CONST_CROSSAT:
	                    instance.crossesAt = ReadCT_Double(reader);
	                    break;
	                case "crossBetween":
	                    instance.crossBetween = ReadCT_CrossBetween(reader);
	                    break;
	                case "majorUnit":
	                    instance.majorUnit = ReadCT_AxisUnit(reader);
	                    break;
	                case "minorUnit":
	                    instance.minorUnit = ReadCT_AxisUnit(reader);
	                    break;
	                case "dispUnits":
	                    instance.dispUnits = ReadCT_DispUnits(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        adjust_spPr(instance, "axis");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ValAx = ReadCT_ValAx;
	
	    function ReadCT_PlotArea(reader) {
	        var instance = {
	            chartGroups: [],
	            axes: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "areaChart":
	                    instance.chartGroups.push(ReadCT_AreaChart(reader));
	                    break;
	                case "area3DChart":
	                    instance.chartGroups.push(ReadCT_Area3DChart(reader));
	                    break;
	                case "barChart":
	                    instance.chartGroups.push(ReadCT_BarChart(reader));
	                    break;
	                case "bar3DChart":
	                    instance.chartGroups.push(ReadCT_Bar3DChart(reader));
	                    break;
	                case "lineChart":
	                    instance.chartGroups.push(ReadCT_LineChart(reader));
	                    break;
	                case "line3DChart":
	                    instance.chartGroups.push(ReadCT_Line3DChart(reader));
	                    break;
	                case "stockChart":
	                    instance.chartGroups.push(ReadCT_StockChart(reader));
	                    break;
	                case "radarChart":
	                    instance.chartGroups.push(ReadCT_RadarChart(reader));
	                    break;
	                case "scatterChart":
	                    instance.chartGroups.push(ReadCT_ScatterChart(reader));
	                    break;
	                case "pieChart":
	                    instance.chartGroups.push(ReadCT_PieChart(reader));
	                    break;
	                case "pie3DChart":
	                    instance.chartGroups.push(ReadCT_Pie3DChart(reader));
	                    break;
	                case "doughnutChart":
	                    instance.chartGroups.push(ReadCT_DoughnutChart(reader));
	                    break;
	                case "ofPieChart":
	                    instance.chartGroups.push(ReadCT_OfPieChart(reader));
	                    break;
	                case "surfaceChart":
	                    instance.chartGroups.push(ReadCT_SurfaceChart(reader));
	                    break;
	                case "surface3DChart":
	                    instance.chartGroups.push(ReadCT_Surface3DChart(reader));
	                    break;
	                case "bubbleChart":
	                    instance.chartGroups.push(ReadCT_BubbleChart(reader));
	                    break;
	                case "catAx":
	                    instance.axes.push(ReadCT_CatAx(reader));
	                    break;
	                case "valAx":
	                    instance.axes.push(ReadCT_ValAx(reader));
	                    break;
	                case "dateAx":
	                    instance.axes.push(ReadCT_DateAx(reader));
	                    break;
	                case "serAx":
	                    instance.axes.push(ReadCT_SerAx(reader));
	                    break;
	                case "dTable":
	                    instance.dTable = ReadCT_DTable(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        adjust_spPr(instance, "plotArea");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PlotArea = ReadCT_PlotArea;
	
	    function ReadCT_PivotFmt(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Marker(reader);
	                    break;
	                case "dLbl":
	                    instance.dLbl = ReadCT_DLbl(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PivotFmt = ReadCT_PivotFmt;
	
	    function ReadCT_PivotFmts(reader) {
	        var instance = {pivotFmt: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "pivotFmt") {
	                instance.pivotFmt.push(ReadCT_PivotFmt(reader));
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PivotFmts = ReadCT_PivotFmts;
	
	    function ReadCT_LegendPos(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	            return ChartHelper.ToLegendPosition(Charts.ST_LegendPos[val]);
	        }
	    }
	
	    DrawingReader.ReadCT_LegendPos = ReadCT_LegendPos;
	
	    function ReadCT_LegendEntry(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_IDX:
	                    instance.idx = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_DELETE:
	                    instance.delete = ReadCT_Boolean(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LegendEntry = ReadCT_LegendEntry;
	
	    function ReadCT_Legend(reader) {
	        var legendEntry = [];
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "legendPos":
	                    instance.legendPos = ReadCT_LegendPos(reader);
	                    break;
	                case "legendEntry":
	                    legendEntry.push(ReadCT_LegendEntry(reader));
	                    break;
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "overlay":
	                    instance.overlay = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        if (legendEntry.length > 0) {
	            instance.legendEntry = legendEntry;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Legend = ReadCT_Legend;
	
	    function ReadCT_DispBlanksAs(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	            return Charts.ST_DispBlanksAs[val];
	        }
	    }
	
	    DrawingReader.ReadCT_DispBlanksAs = ReadCT_DispBlanksAs;
	
	    function ReadCT_Chart(reader) {
	        var instance = {pivotFmts: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_TITLE:
	                    instance.title = ReadCT_Title(reader);
	                    break;
	                case "autoTitleDeleted":
	                    instance.autoTitleDeleted = ReadCT_Boolean(reader);
	                    break;
	                case "pivotFmt":
	                    instance.pivotFmts.push(ReadCT_PivotFmt(reader));
	                    break;
	                case "view3D":
	                    instance.view3D = ReadCT_View3D(reader);
	                    break;
	                case "floor":
	                    instance.floor = ReadCT_Surface(reader);
	                    break;
	                case "sideWall":
	                    instance.sideWall = ReadCT_Surface(reader);
	                    break;
	                case "backWall":
	                    instance.backWall = ReadCT_Surface(reader);
	                    break;
	                case "plotArea":
	                    instance.plotArea = ReadCT_PlotArea(reader);
	                    break;
	                case "legend":
	                    instance.legend = ReadCT_Legend(reader);
	                    break;
	                case "plotVisOnly":
	                    instance.plotVisOnly = ReadCT_Boolean(reader);
	                    break;
	                case "dispBlanksAs":
	                    instance.dispBlanksAs = ReadCT_DispBlanksAs(reader);
	                    break;
	                case "showDLblsOverMax":
	                    instance.showDLblsOverMax = ReadCT_Boolean(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Chart = ReadCT_Chart;
	
	    function ReadCT_Style(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL);
	    }
	
	    DrawingReader.ReadCT_Style = ReadCT_Style;
	
	    function ReadCT_PivotSource(reader) {
	        var instance = {extLst: []};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_NAME:
	                    instance.name = reader.readElementContentAsString();
	                    break;
	                case "fmtId":
	                    instance.fmtId = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst.push(ReadCT_ExtensionList(reader));
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PivotSource = ReadCT_PivotSource;
	
	    function ReadCT_Protection(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementNameObj = {
	            "chartObject": true,
	            "data": true,
	            "formatting": true,
	            "selection": true,
	            "userInterface": true
	        };
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementNameObj[elementName]) {
	                instance[elementName] = ReadCT_Boolean(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Protection = ReadCT_Protection;
	
	    function ReadCT_HeaderFooter(reader) {
	        var instance = {alignWithMargins: true};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "alignWithMargins" || attrName === "differentOddEven" || attrName === "differentFirst") {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementNameObj = {
	            "oddHeader": true,
	            "oddFooter": true,
	            "evenHeader": true,
	            "evenFooter": true,
	            "firstHeader": true,
	            "firstFooter": true
	        };
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementNameObj[elementName]) {
	                instance[elementName] = reader.readElementContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_HeaderFooter = ReadCT_HeaderFooter;
	
	    function ReadCT_PageMargins(reader) {
	        var instance = {};
	       
	        var attrNameObj = {"l": true, "r": true, "t": true, "b": true, "header": true, "footer": true};
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsDouble();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PageMargins = ReadCT_PageMargins;
	
	    function ReadCT_ExternalData(reader) {
	       
	       
	        var instance = {};
	        instance.id = readSingleAttributeNode(reader, "id");
	       
	        return readSingleSubElementNode(reader, "autoUpdate", ReadCT_Boolean, instance);
	    }
	
	    DrawingReader.ReadCT_ExternalData = ReadCT_ExternalData;
	
	    function ReadCT_PageSetup(reader) {
	        var instance = {
	            paperSize: 1,
	            firstPageNumber: 1,
	            orientation: 0 ,
	            blackAndWhite: false,
	            draft: false,
	            useFirstPageNumber: false,
	            horizontalDpi: 600,
	            verticalDpi: 600,
	            copies: 1
	        } ;
	       
	        var intAttrNameObj = {
	                "paperSize": true,
	                "firstPageNumber": true,
	                "horizontalDpi": true,
	                "verticalDpi": true,
	                "copies": true
	            },
	            boolAttrNameObj = {"blackAndWhite": true, "draft": true, "useFirstPageNumber": true};
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(intAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(boolAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            } else if(attrName === "orientation") {
	                instance.orientation = Charts.ST_PageSetupOrientation[reader.readContentAsString()];
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PageSetup = ReadCT_PageSetup;
	
	    function ReadCT_PrintSettings(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "headerFooter":
	                    instance.headerFooter = ReadCT_HeaderFooter(reader);
	                    break;
	                case "pageMargins":
	                    instance.pageMargins = ReadCT_PageMargins(reader);
	                    break;
	                case "pageSetup":
	                    instance.pageSetup = ReadCT_PageSetup(reader);
	                    break;
	                case "legacyDrawingHF":
	                    instance.legacyDrawingHF = ReadCT_RelId(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PrintSettings = ReadCT_PrintSettings;
	
	    function ReadCT_ChartSpace(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "roundedCorners":
	                    instance.roundedCorners = ReadCT_Boolean(reader);
	                    break;
	                case CONST_STYLE:
	                    instance.style = ReadCT_Style(reader);
	                    break;
	                case "clrMapOvr":
	                    instance.clrMapOvr = ReadCT_ColorMapping(reader);
	                    break;
	                case "pivotSource":
	                    instance.pivotSource = ReadCT_PivotSource(reader);
	                    break;
	                case "protection":
	                    instance.protection = ReadCT_Protection(reader);
	                    break;
	                case "chart":
	                    instance.chart = ReadCT_Chart(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_TXPR:
	                    instance.txPr = ReadCT_TextBody(reader);
	                    break;
	                case "externalData":
	                    instance.externalData = ReadCT_ExternalData(reader);
	                    break;
	                case "printSettings":
	                    instance.printSettings = ReadCT_PrintSettings(reader);
	                    break;
	                case "userShapes":
	                    instance.userShapes = ReadCT_UserShapes(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_ExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ChartSpace = ReadCT_ChartSpace;
	
	    function ReadCT_DLblExtensionList(reader) {
	        var instance = {ext: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_EXT) {
	                instance.ext.push(ReadCT_DLblExt(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DLblExtensionList = ReadCT_DLblExtensionList;
	
	    function ReadCT_DLblExt(reader) {
	       
	       
	        var instance = {};
	        instance.uri = readSingleAttributeNode(reader, "uri");
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "dlblFieldTable":
	                    instance.dlblFieldTable = ReadCT_DataLabelFieldTable(reader);
	                    break;
	                case "showDataLabelsRange":
	                    instance.showDataLabelsRange = ReadCT_Boolean(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DLblExt = ReadCT_DLblExt;
	
	    function ReadCT_DLblsExtensionList(reader) {
	        var instance = {ext: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_EXT) {
	                instance.ext.push(ReadCT_DLblsExt(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DLblsExtensionList = ReadCT_DLblsExtensionList;
	
	    function ReadCT_DLblsExt(reader) {
	        var instance = {} ;
	       
	        instance.uri = getValidValue(readSingleAttributeNode(reader, "uri"), '{CE6537A1-D6FC-4f65-9D91-7224C49458BB}');
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_LAYOUT:
	                    instance.layout = ReadCT_Layout(reader);
	                    break;
	                case "showLeaderLines":
	                    instance.showLeaderLines = ReadCT_Boolean(reader);
	                    break;
	                case "showDataLabelsRange":
	                    instance.showDataLabelsRange = ReadCT_Boolean(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DLblsExt = ReadCT_DLblsExt;
	
	    function ReadCT_UserShapes(reader) {
	       
	       
	        var instance = {};
	        instance.id = readSingleAttributeNode(reader, "id");
	       
	         return readSingleSubElementNode(reader, "userShapes", ReadCT_ChartDrawing, instance);
	    }
	
	    DrawingReader.ReadCT_UserShapes = ReadCT_UserShapes;
	
	    function ReadCT_InvertSolidFillFmt(reader) {
	       
	        var instance = {extDataType: 0 };
	        return readSingleSubElementNode(reader, CONST_SPPR, ReadCT_ShapeProperties, instance);
	    }
	
	    DrawingReader.ReadCT_InvertSolidFillFmt = ReadCT_InvertSolidFillFmt;
	
	    function ReadCT_FullRef(reader) {
	       
	        return readSubSqrefElement(reader);
	    }
	
	    DrawingReader.ReadCT_FullRef = ReadCT_FullRef;
	
	    function ReadCT_LevelRef(reader) {
	       
	        return readSubSqrefElement(reader);
	    }
	
	    DrawingReader.ReadCT_LevelRef = ReadCT_LevelRef;
	
	    function ReadCT_FormulaRef(reader) {
	       
	        return readSubSqrefElement(reader);
	    }
	
	    DrawingReader.ReadCT_FormulaRef = ReadCT_FormulaRef;
	
	    function ReadCT_FilteredSeriesTitle(reader) {
	       
	        return readSingleSubElementNode(reader, "tx", ReadCT_Tx);
	    }
	
	    DrawingReader.ReadCT_FilteredSeriesTitle = ReadCT_FilteredSeriesTitle;
	
	    function ReadCT_FilteredCategoryTitle(reader) {
	       
	        return readSingleSubElementNode(reader, "cat", ReadCT_AxDataSource);
	    }
	
	    DrawingReader.ReadCT_FilteredCategoryTitle = ReadCT_FilteredCategoryTitle;
	
	    function ReadCT_FilteredBarSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_BarSer);
	    }
	
	    DrawingReader.ReadCT_FilteredBarSer = ReadCT_FilteredBarSer;
	
	    function ReadCT_FilteredLineSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_LineSer);
	    }
	
	    DrawingReader.ReadCT_FilteredLineSer = ReadCT_FilteredLineSer;
	
	    function ReadCT_FilteredScatterSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_ScatterSer);
	    }
	
	    DrawingReader.ReadCT_FilteredScatterSer = ReadCT_FilteredScatterSer;
	
	    function ReadCT_FilteredAreaSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_AreaSer);
	    }
	
	    DrawingReader.ReadCT_FilteredAreaSer = ReadCT_FilteredAreaSer;
	
	    function ReadCT_FilteredPieSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_PieSer);
	    }
	
	    DrawingReader.ReadCT_FilteredPieSer = ReadCT_FilteredPieSer;
	
	    function ReadCT_FilteredBubbleSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_BubbleSer);
	    }
	
	    DrawingReader.ReadCT_FilteredBubbleSer = ReadCT_FilteredBubbleSer;
	
	    function ReadCT_FilteredRadarSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_RadarSer);
	    }
	
	    DrawingReader.ReadCT_FilteredRadarSer = ReadCT_FilteredRadarSer;
	
	    function ReadCT_FilteredSurfaceSer(reader) {
	       
	        return readSingleSubElementNode(reader, CONST_SER, ReadCT_SurfaceSer);
	    }
	
	    DrawingReader.ReadCT_FilteredSurfaceSer = ReadCT_FilteredSurfaceSer;
	
	    function ReadCT_SeriesDataLabelsRange(reader) {
	       
	        var instance = {extDataType: 1 };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "f") {
	                instance.f = xmlDecode(reader.readElementContentAsString());
	            } else if (elementName === "dlblRangeCache") {
	                instance.dlblRangeCache = ReadCT_StrData(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SeriesDataLabelsRange = ReadCT_SeriesDataLabelsRange;
	
	    function ReadCT_CategoryFilterException(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SQREF:
	                    instance.sqref = reader.readElementContentAsString();
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case "explosion":
	                    instance.explosion = ReadCT_UnsignedInt(reader);
	                    break;
	                case CONST_INVERT_IF_NEGATIVE:
	                    instance.invertIfNegative = ReadCT_Boolean(reader);
	                    break;
	                case CONST_BUBBLE_3D:
	                    instance.bubble3D = ReadCT_Boolean(reader);
	                    break;
	                case CONST_MARKER:
	                    instance.marker = ReadCT_Marker(reader);
	                    break;
	                case "dLbl":
	                    instance.dLbl = ReadCT_DLbl(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CategoryFilterException = ReadCT_CategoryFilterException;
	
	    function ReadCT_CategoryFilterExceptions(reader) {
	        var instance = {categoryFilterException: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "categoryFilterException") {
	                 instance.categoryFilterException.push(ReadCT_CategoryFilterException(reader));
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CategoryFilterExceptions = ReadCT_CategoryFilterExceptions;
	
	    function ReadCT_DataLabelFieldTableEntry(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "txfldGUID":
	                    instance.txfldGUID = reader.readElementContentAsString();
	                    break;
	                case "f":
	                    instance.f = xmlDecode(reader.readElementContentAsString());
	                    break;
	                case "dlblFieldTableCache":
	                    instance.dlblFieldTableCache = ReadCT_StrData(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DataLabelFieldTableEntry = ReadCT_DataLabelFieldTableEntry;
	
	    function ReadCT_DataLabelFieldTable(reader) {
	        var instance = {dlblFTEntry: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "dlblFTEntry") {
	                instance.dlblFTEntry.push(ReadCT_DataLabelFieldTableEntry(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DataLabelFieldTable = ReadCT_DataLabelFieldTable;
	
	    function ReadCT_GraphicFrameNonVisual(reader) {
	       
	        return readGraphicFrameNonVisualSubElement(reader);
	    }
	
	    DrawingReader.ReadCT_GraphicFrameNonVisual = ReadCT_GraphicFrameNonVisual;
	
	    function ReadCT_CdrPosition(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "x" || elementName === "y") {
	                instance[elementName] = reader.readElementContentAsDouble();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CdrPosition = ReadCT_CdrPosition;
	
	    function ReadCT_RelSizeAnchor(reader) {
	        var instance = {anchorType: 3 } ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "from":
	                    instance.startPoint = ReadCT_CdrPosition(reader);
	                    break;
	                case "to":
	                    instance.endPoint = ReadCT_CdrPosition(reader);
	                    break;
	                case "sp":
	                    instance.sp = ReadCT_Shape(reader);
	                    break;
	                case CONST_GRPSP:
	                    instance.grpSp = ReadCT_GroupShape(reader);
	                    break;
	                case CONST_GRAPHIC_FRAME:
	                    instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
	                    break;
	                case CONST_CXNSP:
	                    instance.cxnSp = ReadCT_Connector(reader);
	                    break;
	                case "pic":
	                    instance.pic = ReadCT_Picture(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RelSizeAnchor = ReadCT_RelSizeAnchor;
	
	    function ReadCT_AbsSizeAnchor(reader) {
	        var instance = {anchorType: 4 } ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "from":
	                    instance.startPoint = ReadCT_CdrPosition(reader);
	                    break;
	                case CONST_EXT:
	                    var extData = ReadCT_PositiveSize2D(reader, true);
	                    instance.width = extData.cx;
	                    instance.height = extData.cy;
	                    break;
	                case "sp":
	                    instance.sp = ReadCT_Shape(reader);
	                    break;
	                case CONST_GRPSP:
	                    instance.grpSp = ReadCT_GroupShape(reader);
	                    break;
	                case CONST_GRAPHIC_FRAME:
	                    instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
	                    break;
	                case CONST_CXNSP:
	                    instance.cxnSp = ReadCT_Connector(reader);
	                    break;
	                case "pic":
	                    instance.pic = ReadCT_Picture(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AbsSizeAnchor = ReadCT_AbsSizeAnchor;
	
	    function ReadCT_ChartDrawing(reader) {
	        var instance = {
	            relSizeAnchor: [],
	            absSizeAnchor: []
	        } ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "relSizeAnchor") {
	                instance.relSizeAnchor.push(ReadCT_RelSizeAnchor(reader));
	            } else if (elementName === "absSizeAnchor") {
	                instance.absSizeAnchor.push(ReadCT_AbsSizeAnchor(reader));
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ChartDrawing = ReadCT_ChartDrawing;
	
	    function ReadCT_ConnectorLocking(reader) {
	        var instance = {
	            noGrp: false,
	            noSelect: false,
	            noRot: false,
	            noChangeAspect: false,
	            noMove: false,
	            noResize: false,
	            noEditPoints: false,
	            noAdjustHandles: false,
	            noChangeArrowheads: false,
	            noChangeShapeType: false
	        } ;
	       
	        var attrNameObj = {
	            "noGrp": true,
	            "noSelect": true,
	            "noRot": true,
	            "noChangeAspect": true,
	            "noMove": true,
	            "noResize": true,
	            "noEditPoints": true,
	            "noAdjustHandles": true,
	            "noChangeArrowheads": true,
	            "noChangeShapeType": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
	    }
	
	    DrawingReader.ReadCT_ConnectorLocking = ReadCT_ConnectorLocking;
	
	    function ReadCT_ShapeLocking(reader) {
	        var instance = {
	            noGrp: false,
	            noSelect: false,
	            noRot: false,
	            noChangeAspect: false,
	            noMove: false,
	            noResize: false,
	            noEditPoints: false,
	            noAdjustHandles: false,
	            noChangeArrowheads: false,
	            noChangeShapeType: false,
	            noTextEdit: false
	        } ;
	       
	        var attrNameObj = {
	            "noGrp": true,
	            "noSelect": true,
	            "noRot": true,
	            "noChangeAspect": true,
	            "noMove": true,
	            "noResize": true,
	            "noEditPoints": true,
	            "noAdjustHandles": true,
	            "noChangeArrowheads": true,
	            "noChangeShapeType": true,
	            "noTextEdit": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
	    }
	
	    DrawingReader.ReadCT_ShapeLocking = ReadCT_ShapeLocking;
	
	    function ReadCT_PictureLocking(reader) {
	        var instance = {};
	       
	        var attrNameObj = {
	            "noGrp": true,
	            "noSelect": true,
	            "noRot": true,
	            "noChangeAspect": true,
	            "noMove": true,
	            "noResize": true,
	            "noEditPoints": true,
	            "noAdjustHandles": true,
	            "noChangeArrowheads": true,
	            "noChangeShapeType": true,
	            "noCrop": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
	    }
	
	    DrawingReader.ReadCT_PictureLocking = ReadCT_PictureLocking;
	
	    function ReadCT_GroupLocking(reader) {
	        var instance = {
	            noGrp: false,
	            noUngrp: false,
	            noSelect: false,
	            noRot: false,
	            noChangeAspect: false,
	            noMove: false,
	            noResize: false
	        } ;
	       
	        var attrNameObj = {
	            "noGrp": true,
	            "noUngrp": true,
	            "noSelect": true,
	            "noRot": true,
	            "noChangeAspect": true,
	            "noMove": true,
	            "noResize": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
	    }
	
	    DrawingReader.ReadCT_GroupLocking = ReadCT_GroupLocking;
	
	    function ReadCT_GraphicalObjectFrameLocking(reader) {
	        var instance = {
	            noGrp: false,
	            noDrilldown: false,
	            noSelect: false,
	            noChangeAspect: false,
	            noMove: false,
	            noResize: false
	        } ;
	       
	        var attrNameObj = {
	            "noGrp": true,
	            "noDrilldown": true,
	            "noSelect": true,
	            "noChangeAspect": true,
	            "noMove": true,
	            "noResize": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
	    }
	
	    DrawingReader.ReadCT_GraphicalObjectFrameLocking = ReadCT_GraphicalObjectFrameLocking;
	
	    function ReadCT_NonVisualDrawingProps(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            switch (attrName) {
	                case "id":
	                    instance.id = reader.readContentAsInt();
	                    break;
	                case CONST_NAME:
	                    instance.name = xmlDecode(reader.readContentAsString());
	                    break;
	                case CONST_TITLE:
	                    instance.title = reader.readContentAsString();
	                    break;
	                case "descr":
	                    instance.descr = reader.readContentAsString();
	                    break;
	                case "hidden":
	                    instance.hidden = reader.readContentAsBoolean();
	                    break;
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "hlinkClick" || elementName === "hlinkHover") {
	                instance[elementName] = ReadCT_Hyperlink(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NonVisualDrawingProps = ReadCT_NonVisualDrawingProps;
	
	    function ReadCT_NonVisualDrawingShapeProps(reader) {
	        var instance = {} ;
	       
	        instance.txBox = getValidValue(readSingleAttributeNode(reader, "txBox", getAttrValueOrDefaultOfBooleanType), false);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "spLocks") {
	                instance.spLocks = ReadCT_ShapeLocking(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NonVisualDrawingShapeProps = ReadCT_NonVisualDrawingShapeProps;
	
	    function ReadCT_NonVisualConnectorProperties(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "cxnSpLocks":
	                    instance.cxnSpLocks = ReadCT_ConnectorLocking(reader);
	                    break;
	                case "stCxn":
	                    instance.stCxn = ReadCT_Connection(reader);
	                    break;
	                case "endCxn":
	                    instance.endCxn = ReadCT_Connection(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NonVisualConnectorProperties = ReadCT_NonVisualConnectorProperties;
	
	    function ReadCT_NonVisualPictureProperties(reader) {
	       
	       
	        var instance = {};
	        instance.preferRelativeResize = readSingleAttributeNode(reader, "preferRelativeResize", getAttrValueOrDefaultOfBooleanType);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "picLocks") {
	                instance.picLocks = ReadCT_PictureLocking(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NonVisualPictureProperties = ReadCT_NonVisualPictureProperties;
	
	    function ReadCT_NonVisualGroupDrawingShapeProps(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "grpSpLocks") {
	                instance.grpSpLocks = ReadCT_GroupLocking(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NonVisualGroupDrawingShapeProps = ReadCT_NonVisualGroupDrawingShapeProps;
	
	    function ReadCT_NonVisualGraphicFrameProperties(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "graphicFrameLocks") {
	                instance.graphicFrameLocks = ReadCT_GraphicalObjectFrameLocking(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_NonVisualGraphicFrameProperties = ReadCT_NonVisualGraphicFrameProperties;
	
	    function ReadCT_GraphicalObjectDataContent(reader) {
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        var instance = {};
	        instance.id = readSingleAttributeNode(reader, "id");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GraphicalObjectDataContent = ReadCT_GraphicalObjectDataContent;
	
	    function ReadCT_GraphicalObjectData(reader) {
	        var instance = {} ;
	       
	       
	       
	       
	       
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "chart") {
	                instance.chart = ReadCT_GraphicalObjectDataContent(reader);
	            }
	           
	           
	           
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GraphicalObjectData = ReadCT_GraphicalObjectData;
	
	    function ReadCT_GraphicalObject(reader) {
	       
	        return readSingleSubElementNode(reader, "graphicData", ReadCT_GraphicalObjectData);
	    }
	
	    DrawingReader.ReadCT_GraphicalObject = ReadCT_GraphicalObject;
	
	    function NormalizeSignificantWhitespaceFromXml(stringWithSignificantWhitespace) {
	        return stringWithSignificantWhitespace.replace(/&#xA/g, '\n').replace(/&#xD/g, '\r');
	    }
	
	    DrawingReader.NormalizeSignificantWhitespaceFromXml = NormalizeSignificantWhitespaceFromXml;
	
	    function ReadCT_Slicer(reader) {
	        var instance = {name: ''} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_NAME) {
	                instance.name = NormalizeSignificantWhitespaceFromXml(reader.ReadContentAsString());
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Slicer = ReadCT_Slicer;
	
	    function ReadCT_Camera(reader) {
	        var instance = {zoom: 100000};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "fov" || attrName === "zoom") {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(attrName === CONST_PRST) {
	               
	                instance.prst = Charts.ST_PresetCameraType[reader.readContentAsString()];
	            }
	        }
	       
	         return readSingleSubElementNode(reader, "rot", ReadCT_SphereCoords, instance);
	    }
	
	    DrawingReader.ReadCT_Camera = ReadCT_Camera;
	
	    function ReadCT_LightRig(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "rig") {
	               
	                instance.rig = Charts.ST_LightRigType[reader.readContentAsString()];
	            } else if(attrName === "dir") {
	                instance.dir = Charts.ST_LightRigDirection[reader.readContentAsString()];
	            }
	        }
	       
	         return readSingleSubElementNode(reader, "rot", ReadCT_SphereCoords, instance);
	    }
	
	    DrawingReader.ReadCT_LightRig = ReadCT_LightRig;
	
	    function ReadCT_Scene3D(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "camera":
	                    instance.camera = ReadCT_Camera(reader);
	                    break;
	                case "lightRig":
	                    instance.lightRig = ReadCT_LightRig(reader);
	                    break;
	                case "backdrop":
	                    instance.backdrop = ReadCT_Backdrop(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Scene3D = ReadCT_Scene3D;
	
	    function ReadCT_Backdrop(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "anchor":
	                    instance.anchor = ReadCT_Point3D(reader);
	                    break;
	                case "norm":
	                    instance.norm = ReadCT_Vector3D(reader);
	                    break;
	                case "up":
	                    instance.up = ReadCT_Vector3D(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Backdrop = ReadCT_Backdrop;
	
	    function ReadCT_Bevel(reader) {
	        var instance = {w: 76200, h: 76200, prst: 1 };
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "w" || attrName === "h") {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(attrName === CONST_PRST) {
	                instance.prst = Charts.ST_BevelPresetType[reader.readContentAsString()];
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Bevel = ReadCT_Bevel;
	
	    function ReadCT_Shape3D(reader) {
	        var instance = {
	           
	           
	           
	           
	        };
	       
	        var value;
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "z" || attrName === "extrusionH" || attrName === "contourW") {
	                value = reader.readContentAsInt();
	                instance[attrName] = emuToPixles(value); 
	            } else if(attrName === "prstMaterial") {
	                instance.prstMaterial = Charts.ST_PresetMaterialType[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "bevelT" || elementName === "bevelB") {
	                instance[elementName] = ReadCT_Bevel(reader);
	            } else if(elementName === "extrusionClr" || elementName === "contourClr") {
	                instance[elementName] = ReadCT_Color(reader);
	            } else if(elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Shape3D = ReadCT_Shape3D;
	
	    function ReadCT_FlatText(reader) {
	        var instance = {} ;
	       
	        instance.z = getValidValue(readSingleAttributeNode(reader, "z", getAttributeValueOrDefaultOfIntType), 0);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_FlatText = ReadCT_FlatText;
	
	    function ReadCT_AlphaBiLevelEffect(reader) {
	       
	       
	        var instance = {};
	        instance.thresh = readSingleAttributeNode(reader, "thresh", getAttributeValueOrDefaultOfIntType);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AlphaBiLevelEffect = ReadCT_AlphaBiLevelEffect;
	
	    function ReadCT_AlphaCeilingEffect() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_AlphaCeilingEffect = ReadCT_AlphaCeilingEffect;
	
	    function ReadCT_AlphaFloorEffect() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_AlphaFloorEffect = ReadCT_AlphaFloorEffect;
	
	    function ReadCT_AlphaInverseEffect(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_AlphaInverseEffect = ReadCT_AlphaInverseEffect;
	
	    function ReadCT_AlphaModulateFixedEffect(reader) {
	        var instance = {} ;
	       
	        instance.amt = getValidValue(readSingleAttributeNode(reader, "amt", getAttributeValueOrDefaultOfIntType), 100000);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AlphaModulateFixedEffect = ReadCT_AlphaModulateFixedEffect;
	
	    function ReadCT_AlphaOutsetEffect(reader) {
	        var instance = {} ;
	       
	        instance.rad = getValidValue(readSingleAttributeNode(reader, "rad", getAttributeValueOrDefaultOfIntType), 0);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AlphaOutsetEffect = ReadCT_AlphaOutsetEffect;
	
	    function ReadCT_AlphaReplaceEffect(reader) {
	       
	       
	        var instance = {};
	        instance.a = readSingleAttributeNode(reader, "a", getAttributeValueOrDefaultOfIntType);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AlphaReplaceEffect = ReadCT_AlphaReplaceEffect;
	
	    function ReadCT_BiLevelEffect(reader) {
	       
	       
	        var instance = {};
	        instance.thresh = readSingleAttributeNode(reader, "thresh", getAttributeValueOrDefaultOfIntType);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BiLevelEffect = ReadCT_BiLevelEffect;
	
	    function ReadCT_BlurEffect(reader) {
	        var instance = {
	            rad: 0,
	            grow: true
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === "rad") {
	                instance.rad = reader.readContentAsInt();
	            } else if (attrName === "grow") {
	                instance.grow = reader.readContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BlurEffect = ReadCT_BlurEffect;
	
	    function ReadCT_ColorChangeEffect(reader) {
	        var instance = {};
	       
	        instance.useA = getValidValue(readSingleAttributeNode(reader, "useA", getAttrValueOrDefaultOfBooleanType), true);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "clrFrom" || elementName === "clrTo") {
	                instance[elementName] = ReadCT_Color(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ColorChangeEffect = ReadCT_ColorChangeEffect;
	
	    function ReadCT_ColorReplaceEffect(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_ColorReplaceEffect = ReadCT_ColorReplaceEffect;
	
	    function ReadCT_DuotoneEffect(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_DuotoneEffect = ReadCT_DuotoneEffect;
	
	    function ReadCT_GlowEffect(reader) {
	        var instance = {} ;
	       
	        instance.rad = getValidValue(readSingleAttributeNode(reader, "rad", getAttributeValueOrDefaultOfIntType), 0);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_GlowEffect = ReadCT_GlowEffect;
	
	    function ReadCT_GrayscaleEffect() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_GrayscaleEffect = ReadCT_GrayscaleEffect;
	
	    function ReadCT_HSLEffect(reader) {
	        var instance = {
	            hue: 0,
	            sat: 0,
	            lum: 0
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "hue" || attrName === "sat" || attrName === "lum") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_HSLEffect = ReadCT_HSLEffect;
	
	    function ReadCT_InnerShadowEffect(reader) {
	        var instance = {blurRad: 0, dist: 0, dir: 0};
	        instance.shadowEffectType = 1 ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "blurRad" || attrName === "dist" || attrName === "dir") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_InnerShadowEffect = ReadCT_InnerShadowEffect;
	
	    function ReadCT_LuminanceEffect(reader) {
	        var instance = {bright: 0, contrast: 0};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "bright" || attrName === "contrast") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LuminanceEffect = ReadCT_LuminanceEffect;
	
	    function ReadCT_OuterShadowEffect(reader) {
	        var instance = {
	            blurRad: 0,
	            dist: 0,
	            dir: 0,
	            sx: 100000,
	            sy: 100000,
	            kx: 0,
	            ky: 0,
	            algn: 7 ,
	            rotWithShape: true
	        };
	        instance.shadowEffectType = 0 ;
	       
	        var attrNameObj = {
	            "blurRad": true,
	            "dist": true,
	            "dir": true,
	            "sx": true,
	            "sy": true,
	            "kx": true,
	            "ky": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(attrName === "algn") {
	               
	                instance.algn = Charts.ST_RectAlignment[reader.readContentAsString()];
	            } else if(attrName === CONST_TOT_WITH_SHAPE) {
	                instance.rotWithShape = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_OuterShadowEffect = ReadCT_OuterShadowEffect;
	
	    function ReadCT_PresetShadowEffect(reader) {
	        var instance = {
	            dist: 0,
	            dir: 0,
	            shadowEffectType: 2 
	        };
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "dist" || attrName === "dir") {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(attrName === CONST_PRST) {
	               
	                instance.prst = Charts.ST_PresetShadowVal[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_PresetShadowEffect = ReadCT_PresetShadowEffect;
	
	    function ReadCT_ReflectionEffect(reader) {
	        var instance = {
	            blurRad: 0,
	            stA: 100000,
	            stPos: 0,
	            endA: 0,
	            endPos: 100000,
	            dist: 0,
	            dir: 0,
	            fadeDir: 5400000,
	            sx: 100000,
	            sy: 100000,
	            kx: 0,
	            ky: 0,
	            algn: 7 ,
	            rotWithShape: true
	        } ;
	       
	        var attrNameObj = {
	            "blurRad": true,
	            "stA": true,
	            "stPos": true,
	            "endA": true,
	            "endPos": true,
	            "dist": true,
	            "dir": true,
	            "fadeDir": true,
	            "sx": true,
	            "sy": true,
	            "kx": true,
	            "ky": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(attrName === "algn") {
	               
	                instance.algn = Charts.ST_RectAlignment[reader.readContentAsString()];
	            } else if(attrName === CONST_TOT_WITH_SHAPE) {
	                instance.rotWithShape = reader.readContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ReflectionEffect = ReadCT_ReflectionEffect;
	
	    function ReadCT_RelativeOffsetEffect(reader) {
	        var instance = {
	            tx: 0,
	            ty: 0
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "tx" || attrName === "ty") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RelativeOffsetEffect = ReadCT_RelativeOffsetEffect;
	
	    function ReadCT_SoftEdgesEffect(reader) {
	       
	       
	        var instance = {};
	        instance.rad = readSingleAttributeNode(reader, "rad", getAttributeValueOrDefaultOfIntType);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_SoftEdgesEffect = ReadCT_SoftEdgesEffect;
	
	    function ReadCT_TintEffect(reader) {
	        var instance = {
	            hue: 0,
	            amt: 0
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "hue" || attrName === "amt") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TintEffect = ReadCT_TintEffect;
	
	    function ReadCT_TransformEffect(reader) {
	        var instance = {
	            sx: 100000,
	            sy: 100000,
	            kx: 0,
	            ky: 0,
	            tx: 0,
	            ty: 0
	        } ;
	       
	        var attrNameObj = {
	            sx: true,
	            sy: true,
	            kx: true,
	            ky: true,
	            tx: true,
	            ty: true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TransformEffect = ReadCT_TransformEffect;
	
	    function ReadCT_NoFillProperties() {
	        return true;
	    }
	
	    DrawingReader.ReadCT_NoFillProperties = ReadCT_NoFillProperties;
	
	    function ReadCT_SolidColorFillProperties(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_SolidColorFillProperties = ReadCT_SolidColorFillProperties;
	
	    function ReadCT_LinearShadeProperties(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === "ang") {
	                instance.ang = reader.readContentAsInt();
	            } else if (attrName === "scaled") {
	                instance.scaled = reader.readContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LinearShadeProperties = ReadCT_LinearShadeProperties;
	
	    function ReadCT_PathShadeProperties(reader) {
	       
	       
	        var instance = {};
	        var path = readSingleAttributeNode(reader, "path");
	        if (!isNullOrUndefined(path)) {
	            instance.path = Charts.ST_PathShadeType[path];
	        }
	       
	         return readSingleSubElementNode(reader, "fillToRect", ReadCT_RelativeRect, instance);
	    }
	
	    DrawingReader.ReadCT_PathShadeProperties = ReadCT_PathShadeProperties;
	
	    function ReadCT_GradientStop(reader) {
	       
	       
	        var instance = {};
	        instance.pos = readSingleAttributeNode(reader, "pos", getAttributeValueOrDefaultOfIntType);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readSubColorElements(reader, instance);
	    }
	
	    DrawingReader.ReadCT_GradientStop = ReadCT_GradientStop;
	
	    function ReadCT_GradientStopList(reader) {
	        var instance = {
	            gs: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "gs") {
	                instance.gs.push(ReadCT_GradientStop(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GradientStopList = ReadCT_GradientStopList;
	
	    function ReadCT_GradientFillProperties(reader) {
	        var instance = {
	            rotWithShape: true
	        };
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === "flip") {
	                instance.flip = Charts.ST_TileFlipMode[reader.readContentAsString()];
	            } else if (attrName === CONST_TOT_WITH_SHAPE) {
	                instance.rotWithShape = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "gsLst":
	                    instance.gsLst = ReadCT_GradientStopList(reader);
	                    break;
	                case "lin":
	                    instance.lin = ReadCT_LinearShadeProperties(reader);
	                    break;
	                case "path":
	                    instance.path = ReadCT_PathShadeProperties(reader);
	                    break;
	                case "tileRect":
	                    instance.tileRect = ReadCT_RelativeRect(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GradientFillProperties = ReadCT_GradientFillProperties;
	
	    function ReadCT_TileInfoProperties(reader) {
	        var instance = {} ;
	       
	        var attrNameObj = {
	            "tx": true,
	            "ty": true,
	            "sx": true,
	            "sy": true
	        };
	        var namesInEmu = {
	            "tx": true,
	            "ty": true
	        };
	        var value;
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                value = reader.readContentAsInt();
	                if (namesInEmu[attrName]) {
	                    value = emuToPixles(value);
	                }
	                instance[attrName] = value; 
	            } else if(attrName === "flip") {
	                instance.flip = Charts.ST_TileFlipMode[reader.readContentAsString()];
	            } else if(attrName === "algn") {
	               
	                instance.algn = Charts.ST_RectAlignment[reader.readContentAsString()];
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TileInfoProperties = ReadCT_TileInfoProperties;
	
	    function ReadCT_StretchInfoProperties(reader) {
	       
	        return readSingleSubElementNode(reader, "fillRect", ReadCT_RelativeRect);
	    }
	
	    DrawingReader.ReadCT_StretchInfoProperties = ReadCT_StretchInfoProperties;
	
	    function ReadCT_Blip(reader) {
	        var instance = {cstate: 4};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "embed" || attrName === "link") {
	                instance[attrName] = reader.readContentAsString();
	            } else if(attrName === "cstate") {
	                instance.cstate = Charts.ST_BlipCompression[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "alphaBiLevel":
	                    instance.alphaBiLevel = ReadCT_AlphaBiLevelEffect(reader);
	                    break;
	                case "alphaCeiling":
	                    instance.alphaCeiling = ReadCT_AlphaCeilingEffect();
	                    break;
	                case "alphaFloor":
	                    instance.alphaFloor = ReadCT_AlphaFloorEffect();
	                    break;
	                case "alphaInv":
	                    instance.alphaInv = ReadCT_AlphaInverseEffect(reader);
	                    break;
	                case "alphaMod":
	                    instance.alphaMod = ReadCT_AlphaModulateEffect(reader);
	                    break;
	                case "alphaModFix":
	                    instance.alphaModFix = ReadCT_AlphaModulateFixedEffect(reader);
	                    break;
	                case "alphaRepl":
	                    instance.alphaRepl = ReadCT_AlphaReplaceEffect(reader);
	                    break;
	                case "biLevel":
	                    instance.biLevel = ReadCT_BiLevelEffect(reader);
	                    break;
	                case "blur":
	                    instance.blur = ReadCT_BlurEffect(reader);
	                    break;
	                case "clrChange":
	                    instance.clrChange = ReadCT_ColorChangeEffect(reader);
	                    break;
	                case "clrRepl":
	                    instance.clrRepl = ReadCT_ColorReplaceEffect(reader);
	                    break;
	                case "duotone":
	                    instance.duotone = ReadCT_DuotoneEffect(reader);
	                    break;
	                case "fillOverlay":
	                    instance.fillOverlay = ReadCT_FillOverlayEffect(reader);
	                    break;
	                case "grayscl":
	                    instance.grayscl = ReadCT_GrayscaleEffect();
	                    break;
	                case "hsl":
	                    instance.hsl = ReadCT_HSLEffect(reader);
	                    break;
	                case "lum":
	                    instance.lum = ReadCT_LuminanceEffect(reader);
	                    break;
	                case "tint":
	                    instance.tint = ReadCT_TintEffect(reader);
	                    break;
	                case "blipBlob":
	                    instance.blipBlob = ReadCT_BlipBlob(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Blip = ReadCT_Blip;
	
	    function ReadCT_BlipBlob(reader) {
	        var instance = {};
	       
	        var type = getValidValue(readSingleAttributeNode(reader, CONST_TYPE), 0);
	        if (!isNullOrUndefined(type)) {
	           
	            instance.type = Charts.ST_BobType[type];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "blob") {
	                instance.blob = reader.readElementContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BlipBlob = ReadCT_BlipBlob;
	
	    function ReadCT_BlipFillProperties(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === "dpi") {
	                instance.dpi = reader.readContentAsInt();
	            } else if (attrName === CONST_TOT_WITH_SHAPE) {
	                instance.rotWithShape = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "blip":
	                    instance.blip = ReadCT_Blip(reader);
	                    break;
	                case "srcRect":
	                    instance.srcRect = ReadCT_RelativeRect(reader);
	                    break;
	                case "tile":
	                    instance.tile = ReadCT_TileInfoProperties(reader);
	                    break;
	                case "stretch":
	                    instance.stretch = ReadCT_StretchInfoProperties(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BlipFillProperties = ReadCT_BlipFillProperties;
	
	    function ReadCT_PatternFillProperties(reader) {
	        var instance = {};
	       
	        var prst = readSingleAttributeNode(reader, CONST_PRST);
	        if (!isNullOrUndefined(prst)) {
	            instance.prst = ChartHelper.ToPatternType(Charts.ST_PresetPatternVal[prst]);
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "fgClr" || elementName === "bgClr") {
	                instance[elementName] = ReadCT_Color(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PatternFillProperties = ReadCT_PatternFillProperties;
	
	    function ReadCT_GroupFillProperties() {
	        return {};
	    }
	
	    DrawingReader.ReadCT_GroupFillProperties = ReadCT_GroupFillProperties;
	
	    function ReadCT_FillProperties(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readFillProperties(reader, instance);
	    }
	
	    DrawingReader.ReadCT_FillProperties = ReadCT_FillProperties;
	
	    function ReadCT_FillEffect(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readFillProperties(reader, instance);
	    }
	
	    DrawingReader.ReadCT_FillEffect = ReadCT_FillEffect;
	
	    function ReadCT_FillOverlayEffect(reader) {
	       
	       
	        var instance = {};
	        var blend = readSingleAttributeNode(reader, "blend");
	        if (!isNullOrUndefined(blend)) {
	            instance.blend = Charts.ST_BlendMode[blend];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readFillProperties(reader, instance);
	    }
	
	    DrawingReader.ReadCT_FillOverlayEffect = ReadCT_FillOverlayEffect;
	
	    function ReadCT_EffectReference(reader) {
	       
	       
	        var instance = {};
	        instance.ref = readSingleAttributeNode(reader, "ref");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EffectReference = ReadCT_EffectReference;
	
	    function ReadCT_EffectContainer(reader) {
	        var instance = {type: 0 } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_TYPE) {
	                instance.type = Charts.ST_EffectContainerType[reader.readContentAsString()];
	            } else if (attrName === CONST_NAME) {
	                instance.name = reader.readContentAsString();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "cont":
	                    instance.cont = ReadCT_EffectContainer(reader);
	                    break;
	                case "effect":
	                    instance.effect = ReadCT_EffectReference(reader);
	                    break;
	                case "alphaBiLevel":
	                    instance.alphaBiLevel = ReadCT_AlphaBiLevelEffect(reader);
	                    break;
	                case "alphaCeiling":
	                    instance.alphaCeiling = ReadCT_AlphaCeilingEffect();
	                    break;
	                case "alphaFloor":
	                    instance.alphaFloor = ReadCT_AlphaFloorEffect();
	                    break;
	                case "alphaInv":
	                    instance.alphaInv = ReadCT_AlphaInverseEffect(reader);
	                    break;
	                case "alphaMod":
	                    instance.alphaMod = ReadCT_AlphaModulateEffect(reader);
	                    break;
	                case "alphaModFix":
	                    instance.alphaModFix = ReadCT_AlphaModulateFixedEffect(reader);
	                    break;
	                case "alphaOutset":
	                    instance.alphaOutset = ReadCT_AlphaOutsetEffect(reader);
	                    break;
	                case "alphaRepl":
	                    instance.alphaRepl = ReadCT_AlphaReplaceEffect(reader);
	                    break;
	                case "biLevel":
	                    instance.biLevel = ReadCT_BiLevelEffect(reader);
	                    break;
	                case "blend":
	                    instance.blend = ReadCT_BlendEffect(reader);
	                    break;
	                case "blur":
	                    instance.blur = ReadCT_BlurEffect(reader);
	                    break;
	                case "clrChange":
	                    instance.clrChange = ReadCT_ColorChangeEffect(reader);
	                    break;
	                case "clrRepl":
	                    instance.clrRepl = ReadCT_ColorReplaceEffect(reader);
	                    break;
	                case "duotone":
	                    instance.duotone = ReadCT_DuotoneEffect(reader);
	                    break;
	                case "fill":
	                    instance.fill = ReadCT_FillEffect(reader);
	                    break;
	                case "fillOverlay":
	                    instance.fillOverlay = ReadCT_FillOverlayEffect(reader);
	                    break;
	                case "glow":
	                    instance.glow = ReadCT_GlowEffect(reader);
	                    break;
	                case "grayscl":
	                    instance.grayscl = ReadCT_GrayscaleEffect();
	                    break;
	                case "hsl":
	                    instance.hsl = ReadCT_HSLEffect(reader);
	                    break;
	                case "innerShdw":
	                    instance.innerShdw = ReadCT_InnerShadowEffect(reader);
	                    break;
	                case "lum":
	                    instance.lum = ReadCT_LuminanceEffect(reader);
	                    break;
	                case "outerShdw":
	                    instance.outerShdw = ReadCT_OuterShadowEffect(reader);
	                    break;
	                case "prstShdw":
	                    instance.prstShdw = ReadCT_PresetShadowEffect(reader);
	                    break;
	                case "reflection":
	                    instance.reflection = ReadCT_ReflectionEffect(reader);
	                    break;
	                case "relOff":
	                    instance.relOff = ReadCT_RelativeOffsetEffect(reader);
	                    break;
	                case "softEdge":
	                    instance.softEdge = ReadCT_SoftEdgesEffect(reader);
	                    break;
	                case "tint":
	                    instance.tint = ReadCT_TintEffect(reader);
	                    break;
	                case "xfrm":
	                    instance.xfrm = ReadCT_TransformEffect(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EffectContainer = ReadCT_EffectContainer;
	
	    function ReadCT_AlphaModulateEffect(reader) {
	       
	        return readSingleSubElementNode(reader, "cont", ReadCT_EffectContainer);
	    }
	
	    DrawingReader.ReadCT_AlphaModulateEffect = ReadCT_AlphaModulateEffect;
	
	    function ReadCT_BlendEffect(reader) {
	       
	       
	        var instance = {};
	        var blend = readSingleAttributeNode(reader, "blend");
	        if (!isNullOrUndefined(blend)) {
	            instance.blend = Charts.ST_BlendMode[blend];
	        }
	       
	         return readSingleSubElementNode(reader, "cont", ReadCT_EffectContainer, instance);
	    }
	
	    DrawingReader.ReadCT_BlendEffect = ReadCT_BlendEffect;
	
	    function ReadCT_EffectList(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "blur":
	                    instance.blur = ReadCT_BlurEffect(reader);
	                    break;
	                case "fillOverlay":
	                    instance.fillOverlay = ReadCT_FillOverlayEffect(reader);
	                    break;
	                case "glow":
	                    instance.glow = ReadCT_GlowEffect(reader);
	                    break;
	                case "innerShdw":
	                    instance.innerShdw = ReadCT_InnerShadowEffect(reader);
	                    break;
	                case "outerShdw":
	                    instance.outerShdw = ReadCT_OuterShadowEffect(reader);
	                    break;
	                case "prstShdw":
	                    instance.prstShdw = ReadCT_PresetShadowEffect(reader);
	                    break;
	                case "reflection":
	                    instance.reflection = ReadCT_ReflectionEffect(reader);
	                    break;
	                case "softEdge":
	                    instance.softEdge = ReadCT_SoftEdgesEffect(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EffectList = ReadCT_EffectList;
	
	    function ReadCT_EffectProperties(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_EFFECTLST) {
	                instance.effectLst = ReadCT_EffectList(reader);
	            } else if (elementName === CONST_EFFECT_DAG) {
	                instance.effectDag = ReadCT_EffectContainer(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_EffectProperties = ReadCT_EffectProperties;
	
	    function ReadCT_GeomGuide(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === CONST_NAME || attrName === "fmla") {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GeomGuide = ReadCT_GeomGuide;
	
	    function ReadCT_GeomGuideList(reader) {
	        var instance = {gd: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "gd") {
	                instance.gd.push(ReadCT_GeomGuide(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GeomGuideList = ReadCT_GeomGuideList;
	
	    function ReadCT_AdjPoint2D(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "x" || attrName === "y") {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AdjPoint2D = ReadCT_AdjPoint2D;
	
	    function ReadCT_GeomRect(reader) {
	        var instance = {} ;
	       
	        var attrNameObj = {
	            l: true,
	            t: true,
	            r: true,
	            b: true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GeomRect = ReadCT_GeomRect;
	
	    function ReadCT_XYAdjustHandle(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "gdRefX" || attrName === "gdRefY") {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, "pos", ReadCT_AdjPoint2D, instance);
	    }
	
	    DrawingReader.ReadCT_XYAdjustHandle = ReadCT_XYAdjustHandle;
	
	    function ReadCT_PolarAdjustHandle(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "gdRefR" || attrName === "gdRefAng") {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	       
	         return readSingleSubElementNode(reader, "pos", ReadCT_AdjPoint2D, instance);
	    }
	
	    DrawingReader.ReadCT_PolarAdjustHandle = ReadCT_PolarAdjustHandle;
	
	    function ReadCT_ConnectionSite(reader) {
	       
	       
	        var instance = {};
	        instance.ang = readSingleAttributeNode(reader, "ang");
	       
	         return readSingleSubElementNode(reader, "pos", ReadCT_AdjPoint2D, instance);
	    }
	
	    DrawingReader.ReadCT_ConnectionSite = ReadCT_ConnectionSite;
	
	    function ReadCT_AdjustHandleList(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "ahXY") {
	                instance.ahXY = ReadCT_XYAdjustHandle(reader);
	            } else if (elementName === "ahPolar") {
	                instance.ahPolar = ReadCT_PolarAdjustHandle(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AdjustHandleList = ReadCT_AdjustHandleList;
	
	    function ReadCT_ConnectionSiteList(reader) {
	        var instance = {cxn: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "cxn") {
	                instance.cxn.push(ReadCT_ConnectionSite(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ConnectionSiteList = ReadCT_ConnectionSiteList;
	
	    function ReadCT_Connection(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "id" || attrName === CONST_IDX) {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Connection = ReadCT_Connection;
	
	    function ReadCT_PathToList(reader, pathToType) {
	        var instance = {PtList: [], typeName: Charts.CT_PathType.CT_PathToList} ;
	        instance.pathToType = pathToType;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "pt") {
	                 instance.PtList.push(ReadCT_AdjPoint2D(reader));
	            }
	        }
	        return instance;
	    }
	
	    function ReadCT_Path2DArcTo() {
	        return {
	            typeName: Charts.CT_PathType.CT_Path2DArcTo
	        } ;
	    }
	
	    DrawingReader.ReadCT_Path2DArcTo = ReadCT_Path2DArcTo;
	
	    function ReadCT_Path2DClose() {
	        return {
	            typeName: Charts.CT_PathType.CT_Path2DClose
	        } ;
	    }
	
	    DrawingReader.ReadCT_Path2DClose = ReadCT_Path2DClose;
	
	    function ReadCT_Path2D(reader) {
	        var instance = {
	            quadBezTo: [],
	            cubicBezTo: [],
	            w: 0,
	            h: 0,
	            fill: 1 ,
	            stroke: true,
	            extrusionOk: true,
	            pathToList: []
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "w" || attrName === "h") {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(attrName === "stroke" || attrName === "extrusionOk") {
	                instance[attrName] = reader.readContentAsBoolean();
	            } else if(attrName === "fill") {
	                instance.fill = Charts.ST_PathFillMode[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "close":
	                    instance.pathToList.push(ReadCT_Path2DClose());
	                    break;
	                case "moveTo":
	                    instance.pathToList.push(ReadCT_PathToList(reader, 1 ));
	                    break;
	                case "lnTo":
	                    instance.pathToList.push(ReadCT_PathToList(reader, 0 ));
	                    break;
	                case "arcTo":
	                    instance.pathToList.push(ReadCT_Path2DArcTo());
	                    break;
	                case "quadBezTo":
	                    instance.pathToList.push(ReadCT_PathToList(reader, 2 ));
	                    break;
	                case "cubicBezTo":
	                    instance.pathToList.push(ReadCT_PathToList(reader, 3 ));
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Path2D = ReadCT_Path2D;
	
	    function ReadCT_Path2DList(reader) {
	        var instance = [];
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "path") {
	                 instance.push(ReadCT_Path2D(reader));
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Path2DList = ReadCT_Path2DList;
	
	    function ReadCT_PresetGeometry2D(reader) {
	       
	       
	        var instance = {};
	        var prst = readSingleAttributeNode(reader, CONST_PRST);
	        if (!isNullOrUndefined(prst)) {
	            instance.prst = ChartHelper.ToAutoShapeType(Charts.ST_ShapeType[prst]);
	        }
	       
	         return readSingleSubElementNode(reader, "avLst", ReadCT_GeomGuideList, instance);
	    }
	
	    DrawingReader.ReadCT_PresetGeometry2D = ReadCT_PresetGeometry2D;
	
	    function ReadCT_PresetTextShape(reader) {
	       
	       
	        var instance = {};
	        var prst = readSingleAttributeNode(reader, CONST_PRST);
	        if (!isNullOrUndefined(prst)) {
	            instance.prst = Charts.ST_TextShapeType[prst];
	        }
	       
	         return readSingleSubElementNode(reader, "avLst", ReadCT_GeomGuideList, instance);
	    }
	
	    DrawingReader.ReadCT_PresetTextShape = ReadCT_PresetTextShape;
	
	    function ReadCT_CustomGeometry2D(reader) {
	        var instance = {pathLst: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "avLst":
	                    instance.avLst = ReadCT_GeomGuideList(reader);
	                    break;
	                case "gdLst":
	                    instance.gdLst = ReadCT_GeomGuideList(reader);
	                    break;
	                case "ahLst":
	                    instance.ahLst = ReadCT_AdjustHandleList(reader);
	                    break;
	                case "cxnLst":
	                    instance.cxnLst = ReadCT_ConnectionSiteList(reader);
	                    break;
	                case "rect":
	                    instance.rect = ReadCT_GeomRect(reader);
	                    break;
	                case "pathLst":
	                    instance.pathLst = ReadCT_Path2DList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_CustomGeometry2D = ReadCT_CustomGeometry2D;
	
	    function ReadCT_LineEndProperties(reader) {
	        var instance = {
	            w: 1,
	            len: 1
	        };
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            switch (attrName) {
	                case CONST_TYPE:
	                   
	                    instance.type = Charts.ST_LineEndType[reader.readContentAsString()];
	                    break;
	                case "w":
	                   
	                    instance.w = Charts.ST_LineEndWidth[reader.readContentAsString()];
	                    break;
	                case "len":
	                    instance.len = Charts.ST_LineEndLength[reader.readContentAsString()];
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LineEndProperties = ReadCT_LineEndProperties;
	
	    function ReadCT_LineJoinBevel() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_LineJoinBevel = ReadCT_LineJoinBevel;
	
	    function ReadCT_LineJoinRound() {
	        return true ;
	    }
	
	    DrawingReader.ReadCT_LineJoinRound = ReadCT_LineJoinRound;
	
	    function ReadCT_LineJoinMiterProperties(reader) {
	       
	       
	        var instance = {};
	        instance.lim = readSingleAttributeNode(reader, "lim", getAttributeValueOrDefaultOfIntType);
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LineJoinMiterProperties = ReadCT_LineJoinMiterProperties;
	
	    function ReadCT_PresetLineDashProperties(reader) {
	       
	       
	        var val = readSingleAttributeNode(reader, CONST_VAL);
	        if (!isNullOrUndefined(val)) {
	           
	           return Charts.ST_PresetLineDashVal[val];
	        }
	    }
	
	    DrawingReader.ReadCT_PresetLineDashProperties = ReadCT_PresetLineDashProperties;
	
	    function ReadCT_DashStop(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "d" || attrName === "sp") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DashStop = ReadCT_DashStop;
	
	    function ReadCT_DashStopList(reader) {
	        var instance = {ds: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "ds") {
	                instance.ds.push(ReadCT_DashStop(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DashStopList = ReadCT_DashStopList;
	
	    function ReadCT_LineProperties(reader) {
	        var instance = {};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            switch (attrName) {
	                case "w":
	                    instance.w = emuToPixles(reader.readContentAsInt());
	                    break;
	                case "cap":
	                    instance.cap = Charts.ST_LineCap[reader.readContentAsString()];
	                    break;
	                case "cmpd":
	                   
	                    instance.cmpd = Charts.ST_CompoundLine[reader.readContentAsString()];
	                    break;
	                case "algn":
	                    instance.algn = Charts.ST_PenAlignment[reader.readContentAsString()];
	                    break;
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_NO_FILL:
	                    instance.noFill = ReadCT_NoFillProperties();
	                    break;
	                case CONST_SOLID_FILL:
	                    instance.solidFill = ReadCT_SolidColorFillProperties(reader);
	                    break;
	                case CONST_GRAD_FILL:
	                    instance.gradFill = ReadCT_GradientFillProperties(reader);
	                    break;
	                case CONST_PATT_FILL:
	                    instance.pattFill = ReadCT_PatternFillProperties(reader);
	                    break;
	                case "prstDash":
	                    instance.prstDash = ReadCT_PresetLineDashProperties(reader);
	                    break;
	                case "custDash":
	                    instance.custDash = ReadCT_DashStopList(reader);
	                    break;
	                case "round":
	                    instance.round = ReadCT_LineJoinRound();
	                    break;
	                case "bevel":
	                    instance.bevel = ReadCT_LineJoinBevel();
	                    break;
	                case "miter":
	                    instance.miter = ReadCT_LineJoinMiterProperties(reader);
	                    break;
	                case "headEnd":
	                    instance.headEnd = ReadCT_LineEndProperties(reader);
	                    break;
	                case "tailEnd":
	                    instance.tailEnd = ReadCT_LineEndProperties(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	       
	        if (instance.w === 0 && !instance.noFill) {
	            instance.w = 1;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_LineProperties = ReadCT_LineProperties;
	
	    function ReadCT_ShapeProperties(reader) {
	        var instance = {};
	       
	        var bwMode = readSingleAttributeNode(reader, "bwMode");
	        if (!isNullOrUndefined(bwMode)) {
	            instance.bwMode = Charts.ST_BlackWhiteMode[bwMode];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "xfrm":
	                    instance.xfrm = ReadCT_Transform2D(reader);
	                    break;
	                case "custGeom":
	                    instance.custGeom = ReadCT_CustomGeometry2D(reader);
	                    break;
	                case "prstGeom":
	                    instance.prstGeom = ReadCT_PresetGeometry2D(reader);
	                    break;
	                case CONST_NO_FILL:
	                    instance.noFill = ReadCT_NoFillProperties();
	                    break;
	                case CONST_SOLID_FILL:
	                    instance.solidFill = ReadCT_SolidColorFillProperties(reader);
	                    break;
	                case CONST_GRAD_FILL:
	                    instance.gradFill = ReadCT_GradientFillProperties(reader);
	                    break;
	                case CONST_BLIP_FILL:
	                    instance.blipFill = ReadCT_BlipFillProperties(reader);
	                    break;
	                case CONST_PATT_FILL:
	                    instance.pattFill = ReadCT_PatternFillProperties(reader);
	                    break;
	                case CONST_GRP_FILL:
	                    instance.grpFill = ReadCT_GroupFillProperties();
	                    break;
	                case "ln":
	                    instance.ln = ReadCT_LineProperties(reader);
	                    break;
	                case CONST_EFFECTLST:
	                    instance.effectLst = ReadCT_EffectList(reader);
	                    break;
	                case CONST_EFFECT_DAG:
	                    instance.effectDag = ReadCT_EffectContainer(reader);
	                    break;
	                case CONST_SCENE_3D:
	                    instance.scene3d = ReadCT_Scene3D(reader);
	                    break;
	                case "sp3d":
	                    instance.sp3d = ReadCT_Shape3D(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ShapeProperties = ReadCT_ShapeProperties;
	
	    function ReadCT_GroupShapeProperties(reader) {
	       
	       
	        var instance = {};
	        var bwMode = readSingleAttributeNode(reader, "bwMode");
	        if (!isNullOrUndefined(bwMode)) {
	            instance.bwMode = Charts.ST_BlackWhiteMode[bwMode];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "xfrm":
	                    instance.xfrm = ReadCT_GroupTransform2D(reader);
	                    break;
	                case CONST_NO_FILL:
	                    instance.noFill = ReadCT_NoFillProperties();
	                    break;
	                case CONST_SOLID_FILL:
	                    instance.solidFill = ReadCT_SolidColorFillProperties(reader);
	                    break;
	                case CONST_GRAD_FILL:
	                    instance.gradFill = ReadCT_GradientFillProperties(reader);
	                    break;
	                case CONST_BLIP_FILL:
	                    instance.blipFill = ReadCT_BlipFillProperties(reader);
	                    break;
	                case CONST_PATT_FILL:
	                    instance.pattFill = ReadCT_PatternFillProperties(reader);
	                    break;
	                case CONST_GRP_FILL:
	                    instance.grpFill = ReadCT_GroupFillProperties();
	                    break;
	                case CONST_EFFECTLST:
	                    instance.effectLst = ReadCT_EffectList(reader);
	                    break;
	                case CONST_EFFECT_DAG:
	                    instance.effectDag = ReadCT_EffectContainer(reader);
	                    break;
	                case CONST_SCENE_3D:
	                    instance.scene3d = ReadCT_Scene3D(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GroupShapeProperties = ReadCT_GroupShapeProperties;
	
	    function ReadCT_StyleMatrixReference(reader) {
	        var instance = {ColorProp: {}};
	       
	        instance[CONST_IDX] = readSingleAttributeNode(reader, CONST_IDX, getAttributeValueOrDefaultOfIntType);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SCRGBCLR:
	                    instance.ColorProp.scrgbClr = ReadCT_ScRgbColor(reader);
	                    break;
	                case CONST_SRGBCLR:
	                    instance.ColorProp.srgbClr = ReadCT_SRgbColor(reader);
	                    break;
	                case CONST_HSLCLR:
	                    instance.ColorProp.hslClr = ReadCT_HslColor(reader);
	                    break;
	                case CONST_SYSCLR:
	                    instance.ColorProp.sysClr = ReadCT_SystemColor(reader);
	                    break;
	                case CONST_SCHEMECLR:
	                    instance.ColorProp.schemeClr = ReadCT_SchemeColor(reader);
	                    break;
	                case CONST_PRSTCLR:
	                    instance.ColorProp.prstClr = ReadCT_PresetColor(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_StyleMatrixReference = ReadCT_StyleMatrixReference;
	
	    function ReadCT_FontReference(reader) {
	        var instance = {TextCharacterProperties: {}};
	       
	        instance[CONST_IDX] = readSingleAttributeNode(reader, CONST_IDX);
	        if (instance.idx) {
	            instance.idx = Charts.ST_FontCollectionIndex[instance.idx];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	        var solidFill = instance.TextCharacterProperties.solidFill = {};
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SCRGBCLR:
	                    solidFill.scrgbClr = ReadCT_ScRgbColor(reader);
	                    break;
	                case CONST_SRGBCLR:
	                    solidFill.srgbClr = ReadCT_SRgbColor(reader);
	                    break;
	                case CONST_HSLCLR:
	                    solidFill.hslClr = ReadCT_HslColor(reader);
	                    break;
	                case CONST_SYSCLR:
	                    solidFill.sysClr = ReadCT_SystemColor(reader);
	                    break;
	                case CONST_SCHEMECLR:
	                    solidFill.schemeClr = ReadCT_SchemeColor(reader);
	                    break;
	                case CONST_PRSTCLR:
	                    solidFill.prstClr = ReadCT_PresetColor(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_FontReference = ReadCT_FontReference;
	
	    function ReadCT_ShapeStyle(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "lnRef" || elementName === "fillRef" || elementName === "effectRef") {
	                instance[elementName] = ReadCT_StyleMatrixReference(reader);
	            } else if(elementName === "fontRef") {
	                instance.fontRef = ReadCT_FontReference(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ShapeStyle = ReadCT_ShapeStyle;
	
	    function ReadCT_AnchorClientData(reader) {
	        var instance = {fLocksWithSheet: true, fPrintsWithSheet: true};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "fLocksWithSheet" || attrName === "fPrintsWithSheet") {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AnchorClientData = ReadCT_AnchorClientData;
	
	    function ReadCT_ShapeNonVisual(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_CNVPR) {
	                instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
	            } else if (elementName === "cNvSpPr") {
	                instance.cNvSpPr = ReadCT_NonVisualDrawingShapeProps(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ShapeNonVisual = ReadCT_ShapeNonVisual;
	
	    function ReadCT_Shape(reader) {
	        var instance = {shapeType: 5};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === CONST_MACRO || attrName === "textlink") {
	                instance[attrName] = reader.readContentAsString();
	            } else if(attrName === "fLocksText" || attrName === CONST_FPUBLISHED) {
	                instance[attrName] = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "nvSpPr":
	                    instance.nvSpPr = ReadCT_ShapeNonVisual(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_STYLE:
	                    instance.style = ReadCT_ShapeStyle(reader);
	                    break;
	                case "txBody":
	                    instance.txBody = ReadCT_TextBody(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Shape = ReadCT_Shape;
	
	    function ReadCT_ConnectorNonVisual(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_CNVPR) {
	                instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
	            } else if (elementName === "cNvCxnSpPr") {
	                instance.cNvCxnSpPr = ReadCT_NonVisualConnectorProperties(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ConnectorNonVisual = ReadCT_ConnectorNonVisual;
	
	    function ReadCT_Connector(reader) {
	        var instance = {shapeType: 4};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_MACRO) {
	                instance.macro = reader.readContentAsString();
	            } else if (attrName === CONST_FPUBLISHED) {
	                instance.fPublished = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "nvCxnSpPr":
	                    instance.nvCxnSpPr = ReadCT_ConnectorNonVisual(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_STYLE:
	                    instance.style = ReadCT_ShapeStyle(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Connector = ReadCT_Connector;
	
	    function ReadCT_PictureNonVisual(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_CNVPR) {
	                instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
	            } else if (elementName === "cNvPicPr") {
	                instance.cNvPicPr = ReadCT_NonVisualPictureProperties(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_PictureNonVisual = ReadCT_PictureNonVisual;
	
	    function ReadCT_Picture(reader) {
	        var instance = {shapeType: 1};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_MACRO) {
	                instance.macro = reader.readContentAsString();
	            } else if (attrName === CONST_FPUBLISHED) {
	                instance.fPublished = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "nvPicPr":
	                    instance.nvPicPr = ReadCT_PictureNonVisual(reader);
	                    break;
	                case CONST_BLIP_FILL:
	                    instance.blipFill = ReadCT_BlipFillProperties(reader);
	                    break;
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case CONST_STYLE:
	                    instance.style = ReadCT_ShapeStyle(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Picture = ReadCT_Picture;
	
	    function ReadCT_GraphicalObjectFrameNonVisual(reader) {
	       
	        return readGraphicFrameNonVisualSubElement(reader);
	    }
	
	    DrawingReader.ReadCT_GraphicalObjectFrameNonVisual = ReadCT_GraphicalObjectFrameNonVisual;
	
	    function ReadCT_GraphicalObjectFrame(reader) {
	        var instance = {shapeType: 2};
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_MACRO) {
	                instance.macro = reader.readContentAsString();
	            } else if (attrName === CONST_FPUBLISHED) {
	                instance.fPublished = reader.readContentAsBoolean();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "nvGraphicFramePr":
	                    instance.nvGraphicFramePr = ReadCT_GraphicalObjectFrameNonVisual(reader);
	                    break;
	               
	               
	               
	                case "graphic":
	                    instance.graphic = ReadCT_GraphicalObject(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GraphicalObjectFrame = ReadCT_GraphicalObjectFrame;
	
	    function ReadCT_GroupShapeNonVisual(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_CNVPR) {
	                instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
	            } else if (elementName === "cNvGrpSpPr") {
	                instance.cNvGrpSpPr = ReadCT_NonVisualGroupDrawingShapeProps(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GroupShapeNonVisual = ReadCT_GroupShapeNonVisual;
	
	    function ReadCT_GroupShape(reader) {
	        var instance = {
	            shapeType: 3,
	            sp: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var notNeedRead = false;
	        while (notNeedRead || reader.read()) {
	            notNeedRead = false;
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "nvGrpSpPr":
	                    instance.nvGrpSpPr = ReadCT_GroupShapeNonVisual(reader);
	                    break;
	                case "grpSpPr":
	                    instance.grpSpPr = ReadCT_GroupShapeProperties(reader);
	                    break;
	                case "sp":
	                    instance.sp.push(ReadCT_Shape(reader));
	                    break;
	                case CONST_GRPSP:
	                    instance.sp.push(ReadCT_GroupShape(reader));
	                    break;
	                case CONST_GRAPHIC_FRAME:
	                    instance.sp.push(ReadCT_GraphicalObjectFrame(reader));
	                    break;
	                case CONST_CXNSP:
	                    instance.sp.push(ReadCT_Connector(reader));
	                    break;
	                case "pic":
	                    instance.sp.push(ReadCT_Picture(reader));
	                    break;
	                case "AlternateContent":
	                    var content = ReadCT_AlternateContent(reader);
	                    if (IsSlicer(content)) {
	                        instance.sp.push(content);
	                    }
	                    notNeedRead = true;
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_GroupShape = ReadCT_GroupShape;
	
	    function IsSlicer(content) {
	        return !!(content.Choice && content.Choice.GraphicalObjectFrame &&
	        content.Choice.GraphicalObjectFrame.graphic &&
	        content.Choice.GraphicalObjectFrame.graphic.graphicData &&
	        content.Choice.GraphicalObjectFrame.graphic.graphicData.slicer);
	    }
	
	    function ReadCT_Position(reader) {
	        var instance = {};
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementNameObj = {
	            col: true,
	            row: true
	        };
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementNameObj[elementName]) {
	                instance[elementName] = reader.readElementContentAsInt();
	            } else if(elementName === "rowOff") {
	                instance.rowOffset = emuToPixles(reader.readElementContentAsInt());
	            } else if(elementName === "colOff") {
	                instance.colOffset = emuToPixles(reader.readElementContentAsInt());
	            } 
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Position = ReadCT_Position;
	
	    function ReadCT_TwoCellAnchor(reader) {
	        var instance = {anchorType: 0 };
	       
	        var editAs = readSingleAttributeNode(reader, "editAs");
	        if (!isNullOrUndefined(editAs)) {
	            instance.editAs = Charts.ST_EditAs[editAs];
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var notNeedRead = false;
	        while (notNeedRead || reader.read()) {
	            notNeedRead = false;
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "from":
	                    instance.startPoint = ReadCT_Position(reader);
	                    break;
	                case "to":
	                    instance.endPoint = ReadCT_Position(reader);
	                    break;
	                case "sp":
	                    instance.sp = ReadCT_Shape(reader);
	                    break;
	                case CONST_GRPSP:
	                    instance.grpSp = ReadCT_GroupShape(reader);
	                    break;
	                case CONST_GRAPHIC_FRAME:
	                    instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
	                    break;
	                case CONST_CXNSP:
	                    instance.cxnSp = ReadCT_Connector(reader);
	                    break;
	                case "pic":
	                    instance.pic = ReadCT_Picture(reader);
	                    break;
	                case "AlternateContent":
	                    instance.AlternateContent = ReadCT_AlternateContent(reader);
	                    notNeedRead = true;
	                    break;
	                case "clientData":
	                    instance.clientData = ReadCT_AnchorClientData(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TwoCellAnchor = ReadCT_TwoCellAnchor;
	
	    function NormalizeSignificantWhitespaceToXml(stringWithSignificantWhitespace) {
	        return stringWithSignificantWhitespace.replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
	    }
	
	    function ReadCT_AlternateContent(reader) {
	        var instance = {shapeType: 0};
	        instance.AlternateContent = NormalizeSignificantWhitespaceToXml(reader.readContentAsString());
	       
	        
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "Choice") {
	                instance.Choice = ReadCT_Choice(reader);
	            } else if(elementName === "Fallback") {
	                instance.Fallback = {};
	                instance.Fallback.Shape = ReadCT_Shape(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AlternateContent = ReadCT_AlternateContent;
	
	    function ReadCT_Choice(reader) {
	       
	       
	        var instance = {};
	        instance.Requires = readSingleAttributeNode(reader, "Requires", getAttrValueOrDefaultOfBooleanType);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_GRAPHIC_FRAME) {
	                 instance.GraphicalObjectFrame = ReadCT_GraphicalObjectFrame(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Choice = ReadCT_Choice;
	
	    function ReadCT_OneCellAnchor(reader) {
	        var instance = {anchorType: 1 };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var notNeedRead = false;
	        while (notNeedRead || reader.read()) {
	            notNeedRead = false;
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "from":
	                    instance.startPoint = ReadCT_Position(reader);
	                    break;
	                case CONST_EXT:
	                    var extData = ReadCT_PositiveSize2D(reader, true);
	                    instance.width = extData.cx;
	                    instance.height = extData.cy;
	                    break;
	                case "sp":
	                    instance.sp = ReadCT_Shape(reader);
	                    break;
	                case CONST_GRPSP:
	                    instance.grpSp = ReadCT_GroupShape(reader);
	                    break;
	                case CONST_GRAPHIC_FRAME:
	                    instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
	                    break;
	                case CONST_CXNSP:
	                    instance.cxnSp = ReadCT_Connector(reader);
	                    break;
	                case "pic":
	                    instance.pic = ReadCT_Picture(reader);
	                    break;
	                case "AlternateContent":
	                    instance.AlternateContent = ReadCT_AlternateContent(reader);
	                    notNeedRead = true;
	                    break;
	                case "clientData":
	                    instance.clientData = ReadCT_AnchorClientData(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_OneCellAnchor = ReadCT_OneCellAnchor;
	
	    function ReadCT_AbsoluteAnchor(reader) {
	        var instance = {anchorType: 2 };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var notNeedRead = false;
	        while (notNeedRead || reader.read()) {
	            notNeedRead = false;
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "pos":
	                    var posData = ReadCT_Point2D(reader, true);
	                    instance.x = posData.x;
	                    instance.y = posData.y;
	                    break;
	                case CONST_EXT:
	                    var extData = ReadCT_PositiveSize2D(reader, true);
	                    instance.width = extData.cx;
	                    instance.height = extData.cy;
	                    break;
	                case "sp":
	                    instance.sp = ReadCT_Shape(reader);
	                    break;
	                case CONST_GRPSP:
	                    instance.grpSp = ReadCT_GroupShape(reader);
	                    break;
	                case CONST_GRAPHIC_FRAME:
	                    instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
	                    break;
	                case CONST_CXNSP:
	                    instance.cxnSp = ReadCT_Connector(reader);
	                    break;
	                case "pic":
	                    instance.pic = ReadCT_Picture(reader);
	                    break;
	                case "AlternateContent":
	                    instance.AlternateContent = ReadCT_AlternateContent(reader);
	                    notNeedRead = true;
	                    break;
	                case "clientData":
	                    instance.clientData = ReadCT_AnchorClientData(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_AbsoluteAnchor = ReadCT_AbsoluteAnchor;
	
	    function ReadCT_Drawing(reader) {
	        var instance = {
	            twoCellAnchor: [],
	            oneCellAnchor: [],
	            absoluteAnchor: [],
	            AnchorBaseList: []
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            var anchorBase = keyword_null;
	            switch (elementName) {
	                case "twoCellAnchor":
	                    anchorBase = ReadCT_TwoCellAnchor(reader);
	                    break;
	                case "oneCellAnchor":
	                    anchorBase = ReadCT_OneCellAnchor(reader);
	                    break;
	                case "absoluteAnchor":
	                    anchorBase = ReadCT_AbsoluteAnchor(reader);
	                    break;
	            }
	            if (anchorBase && IsSupportShape(anchorBase)) {
	                instance.AnchorBaseList.push(anchorBase);
	                if (anchorBase.AlternateContent) {
	                    delete anchorBase.AlternateContent;
	                }
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_Drawing = ReadCT_Drawing;
	
	    function IsSupportShape(anchorBase) {
	        var alternateContent = anchorBase.AlternateContent;
	        if (alternateContent && !IsSlicer(alternateContent)) {
	            return false;
	        }
	        var graphicFrame = anchorBase.graphicFrame,
	            graphicData = graphicFrame && graphicFrame.graphic && graphicFrame.graphic.graphicData;
	        if (graphicData && !graphicData.chart && !graphicData.slicer) {
	            return false;
	        }
	        return true;
	    }
	
	    function ReadCT_DefaultShapeDefinition(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_SPPR:
	                    instance.spPr = ReadCT_ShapeProperties(reader);
	                    break;
	                case "bodyPr":
	                    instance.bodyPr = ReadCT_TextBodyProperties(reader);
	                    break;
	                case "lstStyle":
	                    instance.lstStyle = ReadCT_TextListStyle(reader);
	                    break;
	                case CONST_STYLE:
	                    instance.style = ReadCT_ShapeStyle(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_DefaultShapeDefinition = ReadCT_DefaultShapeDefinition;
	
	    function ReadCT_ObjectStyleDefaults(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if(elementName === "spDef" || elementName === "lnDef" || elementName === "txDef") {
	                instance[elementName] = ReadCT_DefaultShapeDefinition(reader);
	            } else if (elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ObjectStyleDefaults = ReadCT_ObjectStyleDefaults;
	
	    function ReadCT_EmptyElement() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_EmptyElement = ReadCT_EmptyElement;
	
	    function ReadCT_ColorMapping(reader) {
	        var instance = {} ;
	       
	        var attrNameObj = {
	            "bg1": true,
	            "tx1": true,
	            "bg2": true,
	            "tx2": true,
	            "accent1": true,
	            "accent2": true,
	            "accent3": true,
	            "accent4": true,
	            "accent5": true,
	            "accent6": true,
	            "hlink": true,
	            "folHlink": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = Charts.ST_ColorSchemeIndex[reader.readContentAsString()];
	            }
	        }
	       
	         return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
	    }
	
	    DrawingReader.ReadCT_ColorMapping = ReadCT_ColorMapping;
	
	    function ReadCT_ColorMappingOverride(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "masterClrMapping") {
	                instance.masterClrMapping = ReadCT_EmptyElement();
	            } else if (elementName === "overrideClrMapping") {
	                instance.overrideClrMapping = ReadCT_ColorMapping(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ColorMappingOverride = ReadCT_ColorMappingOverride;
	
	    function ReadCT_ColorSchemeAndMapping(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === CONST_CLR_SCHEME) {
	                instance.clrScheme = ReadCT_ColorScheme(reader);
	            } else if (elementName === "clrMap") {
	                instance.clrMap = ReadCT_ColorMapping(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ColorSchemeAndMapping = ReadCT_ColorSchemeAndMapping;
	
	    function ReadCT_ColorSchemeList(reader) {
	        var instance = {extraClrScheme: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "extraClrScheme") {
	                instance.extraClrScheme.push(ReadCT_ColorSchemeAndMapping(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ColorSchemeList = ReadCT_ColorSchemeList;
	
	    function ReadCT_OfficeStyleSheet(reader) {
	       
	       
	        var instance = {};
	        instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "themeElements":
	                    instance.themeElements = ReadCT_BaseStyles(reader);
	                    break;
	                case "objectDefaults":
	                    instance.objectDefaults = ReadCT_ObjectStyleDefaults(reader);
	                    break;
	                case "extraClrSchemeLst":
	                    instance.extraClrSchemeLst = ReadCT_ColorSchemeList(reader);
	                    break;
	                case "custClrLst":
	                    instance.custClrLst = ReadCT_CustomColorList(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_OfficeStyleSheet = ReadCT_OfficeStyleSheet;
	
	    function ReadCT_BaseStylesOverride(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case CONST_CLR_SCHEME:
	                    instance.clrScheme = ReadCT_ColorScheme(reader);
	                    break;
	                case CONST_FONT_SCHEME:
	                    instance.fontScheme = ReadCT_FontScheme(reader);
	                    break;
	                case CONST_FMT_SCHEME:
	                    instance.fmtScheme = ReadCT_StyleMatrix(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_BaseStylesOverride = ReadCT_BaseStylesOverride;
	
	    function ReadCT_ClipboardStyleSheet(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "themeElements") {
	                instance.themeElements = ReadCT_BaseStyles(reader);
	            } else if (elementName === "clrMap") {
	                instance.clrMap = ReadCT_ColorMapping(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_ClipboardStyleSheet = ReadCT_ClipboardStyleSheet;
	
	    function ReadCT_TextParagraph(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elements = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "pPr":
	                    instance.pPr = ReadCT_TextParagraphProperties(reader);
	                    break;
	                case "r":
	                    elements.push(DrawingReader.ReadCT_RegularTextRun(reader));
	                    break;
	                case "br":
	                    elements.push(DrawingReader.ReadCT_TextLineBreak(reader));
	                    break;
	                case "fld":
	                    elements.push(DrawingReader.ReadCT_TextField(reader));
	                    break;
	                case "endParaRPr":
	                    instance.endParaRPr = ReadCT_TextCharacterProperties(reader);
	                    break;
	            }
	        }
	        if (elements.length > 0) {
	            instance.elements = elements;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextParagraph = ReadCT_TextParagraph;
	
	    function ReadCT_TextListStyle(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var elementNameObj = {
	            "defPPr": true,
	            "lvl1pPr": true,
	            "lvl2pPr": true,
	            "lvl3pPr": true,
	            "lvl4pPr": true,
	            "lvl5pPr": true,
	            "lvl6pPr": true,
	            "lvl7pPr": true,
	            "lvl8pPr": true,
	            "lvl9pPr": true
	        };
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementNameObj[elementName]) {
	                instance[elementName] = ReadCT_TextParagraphProperties(reader);
	            } else if(elementName === CONST_EXTLST) {
	                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextListStyle = ReadCT_TextListStyle;
	
	    function ReadCT_TextNormalAutofit(reader) {
	        var instance = {
	            fontScale: 100000,
	            lnSpcReduction: 0
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "fontScale" || attrName === "lnSpcReduction") {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextNormalAutofit = ReadCT_TextNormalAutofit;
	
	    function ReadCT_TextShapeAutofit() {
	        return true ;
	    }
	
	    DrawingReader.ReadCT_TextShapeAutofit = ReadCT_TextShapeAutofit;
	
	    function ReadCT_TextNoAutofit() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextNoAutofit = ReadCT_TextNoAutofit;
	
	    function getRotationDegree(rotation) {
	       
	        return rotation / 60000;
	    }
	    function ReadCT_TextBodyProperties(reader) {
	        var instance = {} ;
	       
	        var intAttrNameObj = {
	            "lIns": true,
	            "tIns": true,
	            "rIns": true,
	            "bIns": true,
	            "numCol": true,
	            "spcCol": true
	        };
	        var booleanAttrNameObj = {
	            "spcFirstLastPara": true,
	            "rtlCol": true,
	            "fromWordArt": true,
	            "anchorCtr": true,
	            "forceAA": true,
	            "upright": true,
	            "compatLnSpc": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(intAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(booleanAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            } else if(attrName === "rot") {
	                var rotValue = reader.readContentAsInt();
	                if(rotValue && rotValue !== -60000000) {   
	                    instance.rot = getRotationDegree(rotValue);
	                }
	            } else if(attrName === "vertOverflow") {
	                instance.vertOverflow = Charts.ST_TextVertOverflowType[reader.readContentAsString()];
	            } else if(attrName === "horzOverflow") {
	                instance.horzOverflow = Charts.ST_TextHorzOverflowType[reader.readContentAsString()];
	            } else if(attrName === "vert") {
	                instance.vert = Charts.ST_TextVerticalType[reader.readContentAsString()];
	            } else if(attrName === "wrap") {
	                instance.wrap = Charts.ST_TextWrappingType[reader.readContentAsString()];
	            } else if(attrName === "anchor") {
	                instance.anchor = Charts.ST_TextAnchoringType[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "prstTxWarp":
	                    instance.prstTxWarp = ReadCT_PresetTextShape(reader);
	                    break;
	                case "noAutofit":
	                    instance.noAutofit = ReadCT_TextNoAutofit();
	                    break;
	                case "normAutofit":
	                    instance.normAutofit = ReadCT_TextNormalAutofit(reader);
	                    break;
	                case "spAutoFit":
	                    instance.spAutoFit = ReadCT_TextShapeAutofit();
	                    break;
	                case CONST_SCENE_3D:
	                    instance.scene3d = ReadCT_Scene3D(reader);
	                    break;
	                case "sp3d":
	                    instance.sp3d = ReadCT_Shape3D(reader);
	                    break;
	                case "flatTx":
	                    instance.flatTx = ReadCT_FlatText(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextBodyProperties = ReadCT_TextBodyProperties;
	
	    function ReadCT_TextBody(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        var p = [];
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "bodyPr":
	                    instance.bodyPr = ReadCT_TextBodyProperties(reader);
	                    break;
	                case "lstStyle":
	                    instance.lstStyle = ReadCT_TextListStyle(reader);
	                    break;
	                case "p":
	                    p.push(ReadCT_TextParagraph(reader));
	                    break;
	            }
	        }
	        if (p.length > 0) {
	            instance.p = p;
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextBody = ReadCT_TextBody;
	
	    function ReadCT_TextBulletColorFollowText() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextBulletColorFollowText = ReadCT_TextBulletColorFollowText;
	
	    function ReadCT_TextBulletSizeFollowText() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextBulletSizeFollowText = ReadCT_TextBulletSizeFollowText;
	
	    function ReadCT_TextBulletSizePercent(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_TextBulletSizePercent = ReadCT_TextBulletSizePercent;
	
	    function ReadCT_TextBulletSizePoint(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_TextBulletSizePoint = ReadCT_TextBulletSizePoint;
	
	    function ReadCT_TextBulletTypefaceFollowText() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextBulletTypefaceFollowText = ReadCT_TextBulletTypefaceFollowText;
	
	    function ReadCT_TextAutonumberBullet(reader) {
	        var instance = {
	            startAt: 1
	        } ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === CONST_TYPE) {
	                instance.type = Charts.ST_TextAutonumberScheme[reader.readContentAsString()];
	            } else if (attrName === "startAt") {
	                instance.startAt = reader.readContentAsInt();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextAutonumberBullet = ReadCT_TextAutonumberBullet;
	
	    function ReadCT_TextCharBullet(reader) {
	       
	       
	        var instance = {};
	        instance.char = readSingleAttributeNode(reader, "char");
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextCharBullet = ReadCT_TextCharBullet;
	
	    function ReadCT_TextBlipBullet(reader) {
	       
	        return readSingleSubElementNode(reader, "blip", ReadCT_Blip);
	    }
	
	    DrawingReader.ReadCT_TextBlipBullet = ReadCT_TextBlipBullet;
	
	    function ReadCT_TextNoBullet() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextNoBullet = ReadCT_TextNoBullet;
	
	    function ReadCT_TextFont(reader) {
	        var instance = {
	            pitchFamily: 0,
	            charset: 1
	        } ;
	       
	        var attrNameObj = {
	            "typeface": true,
	            "panose": true,
	            "pitchFamily": true,
	            "charset": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsString();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextFont = ReadCT_TextFont;
	
	    function ReadCT_TextUnderlineLineFollowText() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextUnderlineLineFollowText = ReadCT_TextUnderlineLineFollowText;
	
	    function ReadCT_TextUnderlineFillFollowText() {
	        return {} ;
	    }
	
	    DrawingReader.ReadCT_TextUnderlineFillFollowText = ReadCT_TextUnderlineFillFollowText;
	
	    function ReadCT_TextUnderlineFillGroupWrapper(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        return readFillProperties(reader, instance);
	    }
	
	    DrawingReader.ReadCT_TextUnderlineFillGroupWrapper = ReadCT_TextUnderlineFillGroupWrapper;
	
	    function ReadCT_TextCharacterProperties(reader) {
	        var instance = {} ;
	       
	        var intAttrNameObj = {
	            "kern": true,
	            "spc": true,
	            "baseline": true,
	            "smtId": true
	        };
	        var booleanAttrNameObj = {
	            "kumimoji": true,
	            "normalizeH": true,
	            "noProof": true,
	            "dirty": true,
	            "err": true,
	            "smtClean": true
	        };
	        var stringAttrNameObj = {
	           
	            "altLang": true,
	            "bmk": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(intAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(booleanAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            } else if(stringAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsString();
	            } else if(attrName === "sz") {
	                instance.sz = UnitHelper.pointToPixel(reader.readContentAsInt() / 100);
	            } else if (attrName === "b") {
	                instance.b = reader.readContentAsBoolean();
	            } else if (attrName === "i") {
	                instance.i = reader.readContentAsBoolean();
	            } else if(attrName === "u") {
	               
	                instance.u = Charts.ST_TextUnderlineType[reader.readContentAsString()];
	            } else if(attrName === "strike") {
	                instance.strike = Charts.ST_TextStrikeType[reader.readContentAsString()];
	            } else if(attrName === "cap") {
	                instance.cap = Charts.ST_TextCapsType[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "ln":
	                    instance.ln = ReadCT_LineProperties(reader);
	                    break;
	                case CONST_NO_FILL:
	                    instance.noFill = ReadCT_NoFillProperties();
	                    break;
	                case CONST_SOLID_FILL:
	                    instance.solidFill = ReadCT_SolidColorFillProperties(reader);
	                    break;
	                case CONST_GRAD_FILL:
	                    instance.gradFill = ReadCT_GradientFillProperties(reader);
	                    break;
	                case CONST_BLIP_FILL:
	                    instance.blipFill = ReadCT_BlipFillProperties(reader);
	                    break;
	                case CONST_PATT_FILL:
	                    instance.pattFill = ReadCT_PatternFillProperties(reader);
	                    break;
	                case CONST_GRP_FILL:
	                    instance.grpFill = ReadCT_GroupFillProperties();
	                    break;
	                case CONST_EFFECTLST:
	                    instance.effectLst = ReadCT_EffectList(reader);
	                    break;
	                case CONST_EFFECT_DAG:
	                    instance.effectDag = ReadCT_EffectContainer(reader);
	                    break;
	                case "highlight":
	                    instance.highlight = ReadCT_Color(reader);
	                    break;
	                case "uLnTx":
	                    instance.uLnTx = ReadCT_TextUnderlineLineFollowText();
	                    break;
	                case "uLn":
	                    instance.uLn = ReadCT_LineProperties(reader);
	                    break;
	                case "uFillTx":
	                    instance.uFillTx = ReadCT_TextUnderlineFillFollowText();
	                    break;
	                case "uFill":
	                    instance.uFill = ReadCT_TextUnderlineFillGroupWrapper(reader);
	                    break;
	                case "latin":
	                    instance.latin = ReadCT_TextFont(reader);
	                    break;
	                case "ea":
	                    instance.ea = ReadCT_TextFont(reader);
	                    break;
	                case "cs":
	                    instance.cs = ReadCT_TextFont(reader);
	                    break;
	                case "sym":
	                    instance.sym = ReadCT_TextFont(reader);
	                    break;
	                case "hlinkClick":
	                    instance.hlinkClick = ReadCT_Hyperlink(reader);
	                    break;
	                case "hlinkMouseOver":
	                    instance.hlinkMouseOver = ReadCT_Hyperlink(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextCharacterProperties = ReadCT_TextCharacterProperties;
	
	    function ReadCT_TextSpacingPercent(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_TextSpacingPercent = ReadCT_TextSpacingPercent;
	
	    function ReadCT_TextSpacingPoint(reader) {
	       
	       
	        return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
	    }
	
	    DrawingReader.ReadCT_TextSpacingPoint = ReadCT_TextSpacingPoint;
	
	    function ReadCT_TextTabStop(reader) {
	        var instance = {} ;
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if (attrName === "pos") {
	                instance.pos = reader.readContentAsInt();
	            } else if (attrName === "algn") {
	                instance.algn = Charts.ST_TextTabAlignType[reader.readContentAsString()];
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextTabStop = ReadCT_TextTabStop;
	
	    function ReadCT_TextTabStopList(reader) {
	        var instance = {tab: []} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "tab") {
	                instance.tab.push(ReadCT_TextTabStop(reader));
	            } else if (elementName === CONST_DUMY) {
	                instance.dumy = reader.readElementContentAsBoolean();
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextTabStopList = ReadCT_TextTabStopList;
	
	    function ReadCT_TextLineBreak(reader) {
	       
	        var instance = {
	            elementType: 1 
	        };
	        return readSingleSubElementNode(reader, "rPr", ReadCT_TextCharacterProperties, instance);
	    }
	
	    DrawingReader.ReadCT_TextLineBreak = ReadCT_TextLineBreak;
	
	    function ReadCT_TextSpacing(reader) {
	        var instance = {} ;
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "spcPct") {
	                instance.spcPct = ReadCT_TextSpacingPercent(reader);
	            } else if (elementName === "spcPts") {
	                instance.spcPts = ReadCT_TextSpacingPoint(reader);
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextSpacing = ReadCT_TextSpacing;
	
	    function ReadCT_TextParagraphProperties(reader) {
	        var instance = {};
	       
	        var intAttrNameObj = {
	            "marL": true,
	            "marR": true,
	            "lvl": true,
	            "indent": true,
	            "defTabSz": true
	        };
	        var booleanAttrNameObj = {
	            "rtl": true,
	            "eaLnBrk": true,
	            "latinLnBrk": true,
	            "hangingPunct": true
	        };
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(intAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsInt();
	            } else if(booleanAttrNameObj[attrName]) {
	                instance[attrName] = reader.readContentAsBoolean();
	            } else if(attrName === "fontAlgn") {
	                instance.fontAlgn = Charts.ST_TextFontAlignType[reader.readContentAsString()];
	            } else if(attrName === "algn") {
	                instance.algn = Charts.ST_TextAlignType[reader.readContentAsString()];
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "lnSpc":
	                    instance.lnSpc = ReadCT_TextSpacing(reader);
	                    break;
	                case "spcBef":
	                    instance.spcBef = ReadCT_TextSpacing(reader);
	                    break;
	                case "spcAft":
	                    instance.spcAft = ReadCT_TextSpacing(reader);
	                    break;
	                case "buClrTx":
	                    instance.buClrTx = ReadCT_TextBulletColorFollowText();
	                    break;
	                case "buClr":
	                    instance.buClr = ReadCT_Color(reader);
	                    break;
	                case "buSzTx":
	                    instance.buSzTx = ReadCT_TextBulletSizeFollowText();
	                    break;
	                case "buSzPct":
	                    instance.buSzPct = ReadCT_TextBulletSizePercent(reader);
	                    break;
	                case "buSzPts":
	                    instance.buSzPts = ReadCT_TextBulletSizePoint(reader);
	                    break;
	                case "buFontTx":
	                    instance.buFontTx = ReadCT_TextBulletTypefaceFollowText();
	                    break;
	                case "buFont":
	                    instance.buFont = ReadCT_TextFont(reader);
	                    break;
	                case "buNone":
	                    instance.buNone = ReadCT_TextNoBullet();
	                    break;
	                case "buAutoNum":
	                    instance.buAutoNum = ReadCT_TextAutonumberBullet(reader);
	                    break;
	                case "buChar":
	                    instance.buChar = ReadCT_TextCharBullet(reader);
	                    break;
	                case "buBlip":
	                    instance.buBlip = ReadCT_TextBlipBullet(reader);
	                    break;
	                case "tabLst":
	                    instance.tabLst = ReadCT_TextTabStopList(reader);
	                    break;
	                case "defRPr":
	                    instance.defRPr = ReadCT_TextCharacterProperties(reader);
	                    break;
	                case CONST_EXTLST:
	                    instance.extLst = ReadCT_OfficeArtExtensionList(reader);
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextParagraphProperties = ReadCT_TextParagraphProperties;
	
	    function ReadCT_TextField(reader) {
	       
	        var instance = {
	            elementType: 2 
	        };
	       
	        while (reader.moveToNextAttribute()) {
	            var attrName = getAttributeName(reader);
	            if(attrName === "id" || attrName === CONST_TYPE) {
	                instance[attrName] = reader.readContentAsInt();
	            }
	        }
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            switch (elementName) {
	                case "rPr":
	                    instance.rPr = ReadCT_TextCharacterProperties(reader);
	                    break;
	                case "pPr":
	                    instance.pPr = ReadCT_TextParagraphProperties(reader);
	                    break;
	                case "t":
	                    instance.t = reader.readElementContentAsString();
	                    break;
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_TextField = ReadCT_TextField;
	
	    function ReadCT_RegularTextRun(reader) {
	       
	        var instance = {
	            elementType: 0 
	        };
	       
	        if (reader.elementType === 3 ) {
	            return instance;
	        }
	       
	        var startDepth = reader.depth;
	        while (reader.read()) {
	            var currentDepth = reader.depth, elementType = reader.elementType;
	            if (currentDepth === startDepth && elementType === 2 ) {
	                break;
	            }
	            if (currentDepth > startDepth + 1 || elementType === 2 ) {
	                continue;
	            }
	            var elementName = getElementName(reader);
	            if (elementName === "rPr") {
	                instance.rPr = ReadCT_TextCharacterProperties(reader);
	            } else if (elementName === "t") {
	                instance.t = xmlDecode(reader.readElementContentAsString());
	            }
	        }
	        return instance;
	    }
	
	    DrawingReader.ReadCT_RegularTextRun = ReadCT_RegularTextRun;
	
	    module.exports = DrawingReader;
	
	}());

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Charts = __webpack_require__(24);
	    var ST_SystemColorVal = Charts.ST_SystemColorVal,
	        ST_SchemeColorVal = Charts.ST_SchemeColorVal,
	        ST_SplitType = Charts.ST_SplitType,
	        ST_MarkerStyle = Charts.ST_MarkerStyle;
	
	    var ChartHelper = (function () {
	        function ChartHelper() {
	        }
	
	        ChartHelper.ToKnownColor = function (sysColor) {
	            var result = null;
	            switch (sysColor) {
	                case ST_SystemColorVal.scrollBar:
	                    result = 0x17;
	                    break;
	                case ST_SystemColorVal.activeCaption:
	                    result = 2;
	                    break;
	                case ST_SystemColorVal.inactiveCaption:
	                    result = 0x11;
	                    break;
	                case ST_SystemColorVal.menu:
	                    result = 0x15;
	                    break;
	                case ST_SystemColorVal.window:
	                    result = 0x18;
	                    break;
	                case ST_SystemColorVal.windowFrame:
	                    result = 0x19;
	                    break;
	                case ST_SystemColorVal.menuText:
	                    result = 0x16;
	                    break;
	                case ST_SystemColorVal.windowText:
	                    result = 0x1a;
	                    break;
	                case ST_SystemColorVal.activeBorder:
	                    result = 1;
	                    break;
	                case ST_SystemColorVal.inactiveBorder:
	                    result = 0x10;
	                    break;
	                case ST_SystemColorVal.appWorkspace:
	                    result = 4;
	                    break;
	                case ST_SystemColorVal.highlight:
	                    result = 13;
	                    break;
	                case ST_SystemColorVal.highlightText:
	                    result = 14;
	                    break;
	                case ST_SystemColorVal.btnFace:
	                    result = 0xa8;
	                    break;
	                case ST_SystemColorVal.btnShadow:
	                    result = 170;
	                    break;
	                case ST_SystemColorVal.grayText:
	                    result = 12;
	                    break;
	                case ST_SystemColorVal.inactiveCaptionText:
	                    result = 0x12;
	                    break;
	                case ST_SystemColorVal.btnHighlight:
	                    result = 0xa9;
	                    break;
	                case ST_SystemColorVal.infoText:
	                    result = 20;
	                    break;
	                case ST_SystemColorVal.infoBk:
	                    result = 0x13;
	                    break;
	                case ST_SystemColorVal.gradientActiveCaption:
	                    result = 0xab;
	                    break;
	                case ST_SystemColorVal.gradientInactiveCaption:
	                    result = 0xac;
	                    break;
	                case ST_SystemColorVal.menuHighlight:
	                    result = 0xae;
	                    break;
	                case ST_SystemColorVal.menuBar:
	                    result = 0xad;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_SystemColorVal = function (knowColor) {
	            var result = null;
	            switch (knowColor) {
	                case 1:
	                    result = ST_SystemColorVal.activeBorder;
	                    break;
	                case 2:
	                    result = ST_SystemColorVal.activeCaption;
	                    break;
	                case 0xa8:
	                    result = ST_SystemColorVal.btnFace;
	                    break;
	                case 0xa9:
	                    result = ST_SystemColorVal.btnHighlight;
	                    break;
	                case 170:
	                    result = ST_SystemColorVal.btnShadow;
	                    break;
	                case 0xab:
	                    result = ST_SystemColorVal.gradientActiveCaption;
	                    break;
	                case 0xac:
	                    result = ST_SystemColorVal.gradientInactiveCaption;
	                    break;
	                case 12:
	                    result = ST_SystemColorVal.grayText;
	                    break;
	                case 13:
	                    result = ST_SystemColorVal.highlight;
	                    break;
	                case 14:
	                    result = ST_SystemColorVal.highlightText;
	                    break;
	                case 0x10:
	                    result = ST_SystemColorVal.inactiveBorder;
	                    break;
	                case 0x11:
	                    result = ST_SystemColorVal.inactiveCaption;
	                    break;
	                case 0x12:
	                    result = ST_SystemColorVal.inactiveCaptionText;
	                    break;
	                case 20:
	                    result = ST_SystemColorVal.infoText;
	                    break;
	                case 0x15:
	                    result = ST_SystemColorVal.menu;
	                    break;
	                case 0xad:
	                    result = ST_SystemColorVal.menuBar;
	                    break;
	                case 0xae:
	                    result = ST_SystemColorVal.menuHighlight;
	                    break;
	                case 0x16:
	                    result = ST_SystemColorVal.menuText;
	                    break;
	                case 0x18:
	                    result = ST_SystemColorVal.window;
	                    break;
	                case 0x19:
	                    result = ST_SystemColorVal.windowFrame;
	                    break;
	                case 0x1a:
	                    result = ST_SystemColorVal.windowText;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_SchemeColorVal = function (schemeIndex) {
	            var result = ST_SchemeColorVal.accent1;
	            switch (schemeIndex) {
	                case 4:
	                    result = ST_SchemeColorVal.accent1;
	                    break;
	                case 5:
	                    result = ST_SchemeColorVal.accent2;
	                    break;
	                case 6:
	                    result = ST_SchemeColorVal.accent3;
	                    break;
	                case 7:
	                    result = ST_SchemeColorVal.accent4;
	                    break;
	                case 8:
	                    result = ST_SchemeColorVal.accent5;
	                    break;
	                case 9:
	                    result = ST_SchemeColorVal.accent6;
	                    break;
	                case 0:
	                    result = ST_SchemeColorVal.bg1;
	                    break;
	                case 2:
	                    result = ST_SchemeColorVal.bg2;
	                    break;
	                case 11:
	                    result = ST_SchemeColorVal.folHlink;
	                    break;
	                case 10:
	                    result = ST_SchemeColorVal.hlink;
	                    break;
	                case -4142:
	                    result = ST_SchemeColorVal.accent1;
	                    break;
	                case 1:
	                    result = ST_SchemeColorVal.tx1;
	                    break;
	                case 3:
	                    result = ST_SchemeColorVal.tx2;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToColorSchemeIndex = function (schemeIndex ) {
	            var result = 4;
	            switch (schemeIndex) {
	                case ST_SchemeColorVal.bg1:
	                    result = 0;
	                    break;
	                case ST_SchemeColorVal.tx1:
	                    result = 1;
	                    break;
	                case ST_SchemeColorVal.bg2:
	                    result = 2;
	                    break;
	                case ST_SchemeColorVal.tx2:
	                    result = 3;
	                    break;
	                case ST_SchemeColorVal.accent1:
	                    result = 4;
	                    break;
	                case ST_SchemeColorVal.accent2:
	                    result = 5;
	                    break;
	                case ST_SchemeColorVal.accent3:
	                    result = 6;
	                    break;
	                case ST_SchemeColorVal.accent4:
	                    result = 7;
	                    break;
	                case ST_SchemeColorVal.accent5:
	                    result = 8;
	                    break;
	                case ST_SchemeColorVal.accent6:
	                    result = 9;
	                    break;
	                case ST_SchemeColorVal.hlink:
	                    result = 10;
	                    break;
	                case ST_SchemeColorVal.folHlink:
	                    result = 11;
	                    break;
	                case ST_SchemeColorVal.phClr:
	                    result = -4142;
	                    break;
	                case ST_SchemeColorVal.dk1:
	                    result = 1;
	                    break;
	                case ST_SchemeColorVal.lt1:
	                    result = 0;
	                    break;
	                case ST_SchemeColorVal.dk2:
	                    result = 3;
	                    break;
	                case ST_SchemeColorVal.lt2:
	                    result = 2;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_PresetLineDashVal = function (value) {
	            if(value === 11 ) {
	                value = 1 ;
	            }
	           
	            return value;
	        };
	        ChartHelper.ToAutoShapeType = function (type ) {
	            var result = 0 ;
	            switch (type) {
	                case 2 :
	                    result = 7 ;
	                    break;
	                case 3 :
	                    result = 8 ;
	                    break;
	                case 4 :
	                    result = 1 ;
	                    break;
	                case 5 :
	                    result = 4 ;
	                    break;
	                case 6 :
	                    result = 2 ;
	                    break;
	                case 7 :
	                    result = 3 ;
	                    break;
	                case 25 :
	                    result = 5 ;
	                    break;
	                case 12 :
	                    result = 6 ;
	                    break;
	                case 34 :
	                    result = 9 ;
	                    break;
	                case 10 :
	                    result = 10 ;
	                    break;
	                case 130 :
	                    result = 11 ;
	                    break;
	                case 9 :
	                    result = 12 ;
	                    break;
	                case 73 :
	                    result = 13 ;
	                    break;
	                case 72 :
	                    result = 14 ;
	                    break;
	                case 82 :
	                    result = 15 ;
	                    break;
	                case 81 :
	                    result = 16 ;
	                    break;
	                case 78 :
	                    result = 17 ;
	                    break;
	                case 41 :
	                    result = 18 ;
	                    break;
	                case 42 :
	                    result = 19 ;
	                    break;
	                case 40 :
	                    result = 20 ;
	                    break;
	                case 75 :
	                    result = 21 ;
	                    break;
	                case 74 :
	                    result = 22 ;
	                    break;
	                case 76 :
	                    result = 23 ;
	                    break;
	                case 77 :
	                    result = 24 ;
	                    break;
	                case 88 :
	                    result = 25 ;
	                    break;
	                case 93 :
	                    result = 26 ;
	                    break;
	                case 94 :
	                    result = 27 ;
	                    break;
	                case 33 :
	                    result = 28 ;
	                    break;
	                case 89 :
	                    result = 29 ;
	                    break;
	                case 90 :
	                    result = 30 ;
	                    break;
	                case 91 :
	                    result = 31 ;
	                    break;
	                case 92 :
	                    result = 32 ;
	                    break;
	                case 43 :
	                    result = 33 ;
	                    break;
	                case 44 :
	                    result = 34 ;
	                    break;
	                case 45 :
	                    result = 35 ;
	                    break;
	                case 46 :
	                    result = 36 ;
	                    break;
	                case 50 :
	                    result = 37 ;
	                    break;
	                case 51 :
	                    result = 38 ;
	                    break;
	                case 54 :
	                    result = 39 ;
	                    break;
	                case 53 :
	                    result = 40 ;
	                    break;
	                case 62 :
	                    result = 41 ;
	                    break;
	                case 63 :
	                    result = 42 ;
	                    break;
	                case 52 :
	                    result = 43 ;
	                    break;
	                case 49 :
	                    result = 44 ;
	                    break;
	                case 67 :
	                    result = 45 ;
	                    break;
	                case 68 :
	                    result = 46 ;
	                    break;
	                case 69 :
	                    result = 47 ;
	                    break;
	                case 70 :
	                    result = 48 ;
	                    break;
	                case 47 :
	                    result = 49 ;
	                    break;
	                case 48 :
	                    result = 50 ;
	                    break;
	                case 36 :
	                    result = 51 ;
	                    break;
	                case 37 :
	                    result = 52 ;
	                    break;
	                case 56 :
	                    result = 53 ;
	                    break;
	                case 55 :
	                    result = 54 ;
	                    break;
	                case 57 :
	                    result = 55 ;
	                    break;
	                case 58 :
	                    result = 56 ;
	                    break;
	                case 59 :
	                    result = 57 ;
	                    break;
	                case 60 :
	                    result = 58 ;
	                    break;
	                case 61 :
	                    result = 59 ;
	                    break;
	                case 64 :
	                    result = 60 ;
	                    break;
	                case 131 :
	                    result = 61 ;
	                    break;
	                case 158 :
	                    result = 62 ;
	                    break;
	                case 132 :
	                    result = 63 ;
	                    break;
	                case 133 :
	                    result = 64 ;
	                    break;
	                case 134 :
	                    result = 65 ;
	                    break;
	                case 135 :
	                    result = 66 ;
	                    break;
	                case 136 :
	                    result = 67 ;
	                    break;
	                case 137 :
	                    result = 68 ;
	                    break;
	                case 138 :
	                    result = 69 ;
	                    break;
	                case 139 :
	                    result = 70 ;
	                    break;
	                case 140 :
	                    result = 71 ;
	                    break;
	                case 141 :
	                    result = 72 ;
	                    break;
	                case 142 :
	                    result = 73 ;
	                    break;
	                case 159 :
	                    result = 74 ;
	                    break;
	                case 143 :
	                    result = 75 ;
	                    break;
	                case 144 :
	                    result = 76 ;
	                    break;
	                case 145 :
	                    result = 77 ;
	                    break;
	                case 146 :
	                    result = 78 ;
	                    break;
	                case 147 :
	                    result = 79 ;
	                    break;
	                case 148 :
	                    result = 80 ;
	                    break;
	                case 149 :
	                    result = 81 ;
	                    break;
	                case 150 :
	                    result = 82 ;
	                    break;
	                case 152 :
	                    result = 83 ;
	                    break;
	                case 157 :
	                    result = 84 ;
	                    break;
	                case 153 :
	                    result = 85 ;
	                    break;
	                case 154 :
	                    result = 86 ;
	                    break;
	                case 155 :
	                    result = 87 ;
	                    break;
	                case 156 :
	                    result = 88 ;
	                    break;
	                case 79 :
	                    result = 89 ;
	                    break;
	                case 80 :
	                    result = 90 ;
	                    break;
	                case 15 :
	                    result = 91 ;
	                    break;
	                case 16 :
	                    result = 92 ;
	                    break;
	                case 19 :
	                    result = 93 ;
	                    break;
	                case 22 :
	                    result = 94 ;
	                    break;
	                case 23 :
	                    result = 95 ;
	                    break;
	                case 24 :
	                    result = 96 ;
	                    break;
	                case 121 :
	                    result = 98 ;
	                    break;
	                case 122 :
	                    result = 97 ;
	                    break;
	                case 123 :
	                    result = 100 ;
	                    break;
	                case 124 :
	                    result = 99 ;
	                    break;
	                case 126 :
	                    result = 101 ;
	                    break;
	                case 127 :
	                    result = 102 ;
	                    break;
	                case 128 :
	                    result = 103 ;
	                    break;
	                case 129 :
	                    result = 104 ;
	                    break;
	                case 116 :
	                    result = 105 ;
	                    break;
	                case 117 :
	                    result = 106 ;
	                    break;
	                case 118 :
	                    result = 107 ;
	                    break;
	                case 119 :
	                    result = 108 ;
	                    break;
	                case 110 :
	                    result = 109 ;
	                    break;
	                case 111 :
	                    result = 111 ;
	                    break;
	                case 112 :
	                    result = 112 ;
	                    break;
	                case 104 :
	                    result = 113 ;
	                    break;
	                case 105 :
	                    result = 119 ;
	                    break;
	                case 106 :
	                    result = 120 ;
	                    break;
	                case 107 :
	                    result = 114 ;
	                    break;
	                case 108 :
	                    result = 115 ;
	                    break;
	                case 109 :
	                    result = 116 ;
	                    break;
	                case 113 :
	                    result = 122 ;
	                    break;
	                case 114 :
	                    result = 123 ;
	                    break;
	                case 115 :
	                    result = 124 ;
	                    break;
	                case 160 :
	                    result = 125 ;
	                    break;
	                case 161 :
	                    result = 126 ;
	                    break;
	                case 162 :
	                    result = 127 ;
	                    break;
	                case 163 :
	                    result = 128 ;
	                    break;
	                case 164 :
	                    result = 130 ;
	                    break;
	                case 165 :
	                    result = 129 ;
	                    break;
	                case 166 :
	                    result = 132 ;
	                    break;
	                case 167 :
	                    result = 131 ;
	                    break;
	                case 168 :
	                    result = 133 ;
	                    break;
	                case 169 :
	                    result = 134 ;
	                    break;
	                case 170 :
	                    result = 135 ;
	                    break;
	                case 171 :
	                    result = 136 ;
	                    break;
	                case 151 :
	                    result = 138 ;
	                    break;
	                case 125 :
	                    result = 139 ;
	                    break;
	                case 86 :
	                    result = 140 ;
	                    break;
	                case 39 :
	                    result = 141 ;
	                    break;
	                case 8 :
	                    result = 142 ;
	                    break;
	                case 13 :
	                    result = 143 ;
	                    break;
	                case 11 :
	                    result = 144 ;
	                    break;
	                case 14 :
	                    result = 145 ;
	                    break;
	                case 17 :
	                    result = 146 ;
	                    break;
	                case 18 :
	                    result = 147 ;
	                    break;
	                case 20 :
	                    result = 148 ;
	                    break;
	                case 21 :
	                    result = 149 ;
	                    break;
	                case 26 :
	                    result = 150 ;
	                    break;
	                case 27 :
	                    result = 151 ;
	                    break;
	                case 28 :
	                    result = 152 ;
	                    break;
	                case 29 :
	                    result = 153 ;
	                    break;
	                case 30 :
	                    result = 154 ;
	                    break;
	                case 31 :
	                    result = 155 ;
	                    break;
	                case 32 :
	                    result = 156 ;
	                    break;
	                case 83 :
	                    result = 157 ;
	                    break;
	                case 84 :
	                    result = 158 ;
	                    break;
	                case 35 :
	                    result = 159 ;
	                    break;
	                case 87 :
	                    result = 160 ;
	                    break;
	                case 85 :
	                    result = 161 ;
	                    break;
	                case 175 :
	                    result = 162 ;
	                    break;
	                case 176 :
	                    result = 163 ;
	                    break;
	                case 177 :
	                    result = 164 ;
	                    break;
	                case 178 :
	                    result = 165 ;
	                    break;
	                case 179 :
	                    result = 166 ;
	                    break;
	                case 180 :
	                    result = 167 ;
	                    break;
	                case 181 :
	                    result = 168 ;
	                    break;
	                case 182 :
	                    result = 169 ;
	                    break;
	                case 183 :
	                    result = 170 ;
	                    break;
	                case 172 :
	                    result = 171 ;
	                    break;
	                case 173 :
	                    result = 172 ;
	                    break;
	                case 174 :
	                    result = 173 ;
	                    break;
	                case 38 :
	                    result = 174 ;
	                    break;
	                case 65 :
	                    result = 175 ;
	                    break;
	                case 66 :
	                    result = 176 ;
	                    break;
	                case 71 :
	                    result = 177 ;
	                    break;
	                case 120 :
	                    result = 178 ;
	                    break;
	                case 184 :
	                    result = 179 ;
	                    break;
	                case 185 :
	                    result = 180 ;
	                    break;
	                case 186 :
	                    result = 181 ;
	                    break;
	                case 1 :
	                    result = 182 ;
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_ShapeType = function (type ) {
	            var result  = 0 ;
	            switch (type) {
	                case 1 :
	                    result = 4 ;
	                    break;
	                case 2 :
	                    result = 6 ;
	                    break;
	                case 3 :
	                    result = 7 ;
	                    break;
	                case 4 :
	                    result = 5 ;
	                    break;
	                case 5 :
	                    result = 25 ;
	                    break;
	                case 6 :
	                    result = 12 ;
	                    break;
	                case 7 :
	                    result = 2 ;
	                    break;
	                case 8 :
	                    result = 3 ;
	                    break;
	                case 9 :
	                    result = 34 ;
	                    break;
	                case 10 :
	                    result = 10 ;
	                    break;
	                case 11 :
	                    result = 130 ;
	                    break;
	                case 12 :
	                    result = 9 ;
	                    break;
	                case 13 :
	                    result = 73 ;
	                    break;
	                case 14 :
	                    result = 72 ;
	                    break;
	                case 15 :
	                    result = 82 ;
	                    break;
	                case 16 :
	                    result = 81 ;
	                    break;
	                case 17 :
	                    result = 78 ;
	                    break;
	                case 18 :
	                    result = 41 ;
	                    break;
	                case 19 :
	                    result = 42 ;
	                    break;
	                case 20 :
	                    result = 40 ;
	                    break;
	                case 21 :
	                    result = 75 ;
	                    break;
	                case 22 :
	                    result = 74 ;
	                    break;
	                case 23 :
	                    result = 76 ;
	                    break;
	                case 24 :
	                    result = 77 ;
	                    break;
	                case 25 :
	                    result = 88 ;
	                    break;
	                case 26 :
	                    result = 93 ;
	                    break;
	                case 27 :
	                    result = 94 ;
	                    break;
	                case 28 :
	                    result = 33 ;
	                    break;
	                case 29 :
	                    result = 89 ;
	                    break;
	                case 30 :
	                    result = 90 ;
	                    break;
	                case 31 :
	                    result = 91 ;
	                    break;
	                case 32 :
	                    result = 92 ;
	                    break;
	                case 33 :
	                    result = 43 ;
	                    break;
	                case 34 :
	                    result = 44 ;
	                    break;
	                case 35 :
	                    result = 45 ;
	                    break;
	                case 36 :
	                    result = 46 ;
	                    break;
	                case 37 :
	                    result = 50 ;
	                    break;
	                case 38 :
	                    result = 51 ;
	                    break;
	                case 39 :
	                    result = 54 ;
	                    break;
	                case 40 :
	                    result = 53 ;
	                    break;
	                case 41 :
	                    result = 64 ;
	                    break;
	                case 42 :
	                    result = 63 ;
	                    break;
	                case 43 :
	                    result = 52 ;
	                    break;
	                case 44 :
	                    result = 49 ;
	                    break;
	                case 45 :
	                    result = 67 ;
	                    break;
	                case 46 :
	                    result = 68 ;
	                    break;
	                case 47 :
	                    result = 69 ;
	                    break;
	                case 48 :
	                    result = 70 ;
	                    break;
	                case 49 :
	                    result = 47 ;
	                    break;
	                case 50 :
	                    result = 48 ;
	                    break;
	                case 51 :
	                    result = 36 ;
	                    break;
	                case 52 :
	                    result = 37 ;
	                    break;
	                case 53 :
	                    result = 56 ;
	                    break;
	                case 54 :
	                    result = 55 ;
	                    break;
	                case 55 :
	                    result = 57 ;
	                    break;
	                case 56 :
	                    result = 58 ;
	                    break;
	                case 57 :
	                    result = 59 ;
	                    break;
	                case 58 :
	                    result = 60 ;
	                    break;
	                case 59 :
	                    result = 61 ;
	                    break;
	                case 60 :
	                    result = 64 ;
	                    break;
	                case 61 :
	                    result = 131 ;
	                    break;
	                case 62 :
	                    result = 158 ;
	                    break;
	                case 63 :
	                    result = 132 ;
	                    break;
	                case 64 :
	                    result = 133 ;
	                    break;
	                case 65 :
	                    result = 134 ;
	                    break;
	                case 66 :
	                    result = 135 ;
	                    break;
	                case 67 :
	                    result = 136 ;
	                    break;
	                case 68 :
	                    result = 137 ;
	                    break;
	                case 69 :
	                    result = 138 ;
	                    break;
	                case 70 :
	                    result = 139 ;
	                    break;
	                case 71 :
	                    result = 140 ;
	                    break;
	                case 72 :
	                    result = 141 ;
	                    break;
	                case 73 :
	                    result = 142 ;
	                    break;
	                case 74 :
	                    result = 159 ;
	                    break;
	                case 75 :
	                    result = 143 ;
	                    break;
	                case 76 :
	                    result = 144 ;
	                    break;
	                case 77 :
	                    result = 145 ;
	                    break;
	                case 78 :
	                    result = 146 ;
	                    break;
	                case 79 :
	                    result = 147 ;
	                    break;
	                case 80 :
	                    result = 148 ;
	                    break;
	                case 81 :
	                    result = 149 ;
	                    break;
	                case 82 :
	                    result = 150 ;
	                    break;
	                case 83 :
	                    result = 152 ;
	                    break;
	                case 84 :
	                    result = 157 ;
	                    break;
	                case 85 :
	                    result = 153 ;
	                    break;
	                case 86 :
	                    result = 154 ;
	                    break;
	                case 87 :
	                    result = 155 ;
	                    break;
	                case 88 :
	                    result = 156 ;
	                    break;
	                case 89 :
	                    result = 79 ;
	                    break;
	                case 90 :
	                    result = 80 ;
	                    break;
	                case 91 :
	                    result = 15 ;
	                    break;
	                case 92 :
	                    result = 16 ;
	                    break;
	                case 93 :
	                    result = 19 ;
	                    break;
	                case 94 :
	                    result = 22 ;
	                    break;
	                case 95 :
	                    result = 32 ;
	                    break;
	                case 96 :
	                    result = 24 ;
	                    break;
	                case 97 :
	                    result = 122 ;
	                    break;
	                case 98 :
	                    result = 121 ;
	                    break;
	                case 99 :
	                    result = 124 ;
	                    break;
	                case 100 :
	                    result = 123 ;
	                    break;
	                case 101 :
	                    result = 126 ;
	                    break;
	                case 102 :
	                    result = 127 ;
	                    break;
	                case 103 :
	                    result = 128 ;
	                    break;
	                case 104 :
	                    result = 129 ;
	                    break;
	                case 105 :
	                    result = 116 ;
	                    break;
	                case 106 :
	                    result = 117 ;
	                    break;
	                case 107 :
	                    result = 118 ;
	                    break;
	                case 108 :
	                    result = 119 ;
	                    break;
	                case 109 :
	                    result = 110 ;
	                    break;
	                case 110 :
	                    result = 110 ;
	                    break;
	                case 111 :
	                    result = 111 ;
	                    break;
	                case 112 :
	                    result = 112 ;
	                    break;
	                case 113 :
	                    result = 104 ;
	                    break;
	                case 114 :
	                    result = 107 ;
	                    break;
	                case 115 :
	                    result = 108 ;
	                    break;
	                case 116 :
	                    result = 109 ;
	                    break;
	                case 117 :
	                    result = 104 ;
	                    break;
	                case 118 :
	                    result = 104 ;
	                    break;
	                case 119 :
	                    result = 105 ;
	                    break;
	                case 120 :
	                    result = 106 ;
	                    break;
	                case 121 :
	                    result = 110 ;
	                    break;
	                case 122 :
	                    result = 113 ;
	                    break;
	                case 123 :
	                    result = 114 ;
	                    break;
	                case 124 :
	                    result = 115 ;
	                    break;
	                case 125 :
	                    result = 160 ;
	                    break;
	                case 126 :
	                    result = 161 ;
	                    break;
	                case 127 :
	                    result = 162 ;
	                    break;
	                case 128 :
	                    result = 163 ;
	                    break;
	                case 129 :
	                    result = 164 ;
	                    break;
	                case 130 :
	                    result = 165 ;
	                    break;
	                case 131 :
	                    result = 166 ;
	                    break;
	                case 132 :
	                    result = 167 ;
	                    break;
	                case 133 :
	                    result = 168 ;
	                    break;
	                case 134 :
	                    result = 169 ;
	                    break;
	                case 135 :
	                    result = 170 ;
	                    break;
	                case 136 :
	                    result = 171 ;
	                    break;
	                case 137 :
	                    result = 117 ;
	                    break;
	                case 138 :
	                    result = 151 ;
	                    break;
	                case 139 :
	                    result = 125 ;
	                    break;
	                case 140 :
	                    result = 86 ;
	                    break;
	                case 141 :
	                    result = 39 ;
	                    break;
	                case 142 :
	                    result = 8 ;
	                    break;
	                case 143 :
	                    result = 13 ;
	                    break;
	                case 144 :
	                    result = 11 ;
	                    break;
	                case 145 :
	                    result = 14 ;
	                    break;
	                case 146 :
	                    result = 17 ;
	                    break;
	                case 147 :
	                    result = 18 ;
	                    break;
	                case 148 :
	                    result = 20 ;
	                    break;
	                case 149 :
	                    result = 21 ;
	                    break;
	                case 150 :
	                    result = 26 ;
	                    break;
	                case 151 :
	                    result = 27 ;
	                    break;
	                case 152 :
	                    result = 28 ;
	                    break;
	                case 153 :
	                    result = 29 ;
	                    break;
	                case 154 :
	                    result = 30 ;
	                    break;
	                case 155 :
	                    result = 31 ;
	                    break;
	                case 156 :
	                    result = 32 ;
	                    break;
	                case 157 :
	                    result = 83 ;
	                    break;
	                case 158 :
	                    result = 84 ;
	                    break;
	                case 159 :
	                    result = 35 ;
	                    break;
	                case 160 :
	                    result = 87 ;
	                    break;
	                case 161 :
	                    result = 85 ;
	                    break;
	                case 162 :
	                    result = 175 ;
	                    break;
	                case 163 :
	                    result = 176 ;
	                    break;
	                case 164 :
	                    result = 177 ;
	                    break;
	                case 165 :
	                    result = 178 ;
	                    break;
	                case 166 :
	                    result = 179 ;
	                    break;
	                case 167 :
	                    result = 180 ;
	                    break;
	                case 168 :
	                    result = 181 ;
	                    break;
	                case 169 :
	                    result = 182 ;
	                    break;
	                case 170 :
	                    result = 183 ;
	                    break;
	                case 171 :
	                    result = 172 ;
	                    break;
	                case 172 :
	                    result = 173 ;
	                    break;
	                case 173 :
	                    result = 174 ;
	                    break;
	                case 174 :
	                    result = 38 ;
	                    break;
	                case 175 :
	                    result = 65 ;
	                    break;
	                case 176 :
	                    result = 66 ;
	                    break;
	                case 177 :
	                    result = 71 ;
	                    break;
	                case 178 :
	                    result = 120 ;
	                    break;
	                case 179 :
	                    result = 184 ;
	                    break;
	                case 180 :
	                    result = 185 ;
	                    break;
	                case 181 :
	                    result = 186 ;
	                    break;
	                case 182 :
	                    result = 1 ;
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToPatternType = function (type ) {
	            var result = 0 ;
	            switch (type) {
	                case 0:
	                    result = 1 ;
	                    break;
	                case 1:
	                    result = 2 ;
	                    break;
	                case 2:
	                    result = 3 ;
	                    break;
	                case 3:
	                    result = 4 ;
	                    break;
	                case 4:
	                    result = 5 ;
	                    break;
	                case 5:
	                    result = 6 ;
	                    break;
	                case 6:
	                    result = 7 ;
	                    break;
	                case 7:
	                    result = 8 ;
	                    break;
	                case 8:
	                    result = 9 ;
	                    break;
	                case 9:
	                    result = 10 ;
	                    break;
	                case 10:
	                    result = 11 ;
	                    break;
	                case 11:
	                    result = 12 ;
	                    break;
	                case 16:
	                    result = 13 ;
	                    break;
	                case 17:
	                    result = 14 ;
	                    break;
	                case 27:
	                    result = 15 ;
	                    break;
	                case 28:
	                    result = 16 ;
	                    break;
	                case 34:
	                    result = 17 ;
	                    break;
	                case 52:
	                    result = 18 ;
	                    break;
	                case 14:
	                    result = 19 ;
	                    break;
	                case 15:
	                    result = 20 ;
	                    break;
	                case 25:
	                    result = 21 ;
	                    break;
	                case 26:
	                    result = 22 ;
	                    break;
	                case 36:
	                    result = 23 ;
	                    break;
	                case 45:
	                    result = 24 ;
	                    break;
	                case 29:
	                    result = 25 ;
	                    break;
	                case 30:
	                    result = 26 ;
	                    break;
	                case 32:
	                    result = 27 ;
	                    break;
	                case 31:
	                    result = 28 ;
	                    break;
	                case 19:
	                    result = 29 ;
	                    break;
	                case 18:
	                    result = 30 ;
	                    break;
	                case 21:
	                    result = 31 ;
	                    break;
	                case 20:
	                    result = 32 ;
	                    break;
	                case 40:
	                    result = 33 ;
	                    break;
	                case 37:
	                    result = 34 ;
	                    break;
	                case 41:
	                    result = 35 ;
	                    break;
	                case 35:
	                    result = 36 ;
	                    break;
	                case 39:
	                    result = 37 ;
	                    break;
	                case 53:
	                    result = 38 ;
	                    break;
	                case 43:
	                    result = 39 ;
	                    break;
	                case 42:
	                    result = 40 ;
	                    break;
	                case 44:
	                    result = 41 ;
	                    break;
	                case 46:
	                    result = 42 ;
	                    break;
	                case 47:
	                    result = 43 ;
	                    break;
	                case 48:
	                    result = 44 ;
	                    break;
	                case 38:
	                    result = 45 ;
	                    break;
	                case 49:
	                    result = 46 ;
	                    break;
	                case 50:
	                    result = 47 ;
	                    break;
	                case 51:
	                    result = 48 ;
	                    break;
	                case 12:
	                    result = 49 ;
	                    break;
	                case 13:
	                    result = 50 ;
	                    break;
	                case 22:
	                    result = 51 ;
	                    break;
	                case 23:
	                    result = 52 ;
	                    break;
	                case 24:
	                    result = 53 ;
	                    break;
	                case 33:
	                    result = 54 ;
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_PresetPatternVal = function (type ) {
	            var result = 0;
	            switch (type) {
	                case 1 :
	                    result = 0;
	                    break;
	                case 2 :
	                    result = 1;
	                    break;
	                case 3 :
	                    result = 2;
	                    break;
	                case 4 :
	                    result = 3;
	                    break;
	                case 5 :
	                    result = 4;
	                    break;
	                case 6 :
	                    result = 5;
	                    break;
	                case 7 :
	                    result = 6;
	                    break;
	                case 8 :
	                    result = 7;
	                    break;
	                case 9 :
	                    result = 8;
	                    break;
	                case 10 :
	                    result = 9;
	                    break;
	                case 11 :
	                    result = 10;
	                    break;
	                case 12 :
	                    result = 11;
	                    break;
	                case 13 :
	                    result = 16;
	                    break;
	                case 14 :
	                    result = 17;
	                    break;
	                case 15 :
	                    result = 27;
	                    break;
	                case 16 :
	                    result = 28;
	                    break;
	                case 17 :
	                    result = 34;
	                    break;
	                case 18 :
	                    result = 52;
	                    break;
	                case 19 :
	                    result = 14;
	                    break;
	                case 20 :
	                    result = 15;
	                    break;
	                case 21 :
	                    result = 25;
	                    break;
	                case 22 :
	                    result = 26;
	                    break;
	                case 23 :
	                    result = 36;
	                    break;
	                case 24 :
	                    result = 45;
	                    break;
	                case 25 :
	                    result = 29;
	                    break;
	                case 26 :
	                    result = 30;
	                    break;
	                case 27 :
	                    result = 32;
	                    break;
	                case 28 :
	                    result = 31;
	                    break;
	                case 29 :
	                    result = 19;
	                    break;
	                case 30 :
	                    result = 18;
	                    break;
	                case 31 :
	                    result = 21;
	                    break;
	                case 32 :
	                    result = 20;
	                    break;
	                case 33 :
	                    result = 40;
	                    break;
	                case 34 :
	                    result = 37;
	                    break;
	                case 35 :
	                    result = 41;
	                    break;
	                case 36 :
	                    result = 35;
	                    break;
	                case 37 :
	                    result = 39;
	                    break;
	                case 38 :
	                    result = 53;
	                    break;
	                case 39 :
	                    result = 43;
	                    break;
	                case 40 :
	                    result = 42;
	                    break;
	                case 41 :
	                    result = 44;
	                    break;
	                case 42 :
	                    result = 46;
	                    break;
	                case 43 :
	                    result = 47;
	                    break;
	                case 44 :
	                    result = 48;
	                    break;
	                case 45 :
	                    result = 38;
	                    break;
	                case 46 :
	                    result = 49;
	                    break;
	                case 47 :
	                    result = 50;
	                    break;
	                case 48 :
	                    result = 51;
	                    break;
	                case 49 :
	                    result = 12;
	                    break;
	                case 50 :
	                    result = 13;
	                    break;
	                case 51 :
	                    result = 22;
	                    break;
	                case 52 :
	                    result = 23;
	                    break;
	                case 53 :
	                    result = 24;
	                    break;
	                case 54 :
	                    result = 33;
	                    break;
	            }
	
	            return result;
	        };
	        ChartHelper.ToST_PresetShadowVal = function (type ) {
	            if(type > 19 ) {
	                return 0 ;
	            }
	           
	            return type;
	        };
	        ChartHelper.ToST_SplitType = function (splitType) {
	            var result = ST_SplitType.pos;
	            switch (splitType) {
	                case 0:
	                    result = ST_SplitType.pos;
	                    break;
	                case 1:
	                    result = ST_SplitType.val;
	                    break;
	                case 2:
	                    result = ST_SplitType.percent;
	                    break;
	                case 3:
	                    result = ST_SplitType.cust;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToChartSplitType = function (splitType ) {
	            var result = 0;
	            switch (splitType) {
	                case ST_SplitType.auto:
	                    result = 0;
	                    break;
	                case ST_SplitType.cust:
	                    result = 3;
	                    break;
	                case ST_SplitType.percent:
	                    result = 2;
	                    break;
	                case ST_SplitType.pos:
	                    result = 0;
	                    break;
	                case ST_SplitType.val:
	                    result = 1;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_LightRigDirection = function (type ) {
	            var result = 1;
	            switch (type) {
	                case 0 :
	                    result = 1;
	                    break;
	                case 1 :
	                    result = 4;
	                    break;
	                case 2 :
	                    result = 6;
	                    break;
	                case 3 :
	                    result = 1;
	                    break;
	                case 4 :
	                    result = 1;
	                    break;
	                case 5 :
	                    result = 6;
	                    break;
	                case 6 :
	                    result = 1;
	                    break;
	                case 7 :
	                    result = 3;
	                    break;
	                case 8 :
	                    result = 6;
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_MarkerStyle = function (style) {
	            if (style === 11) {
	                style = ST_MarkerStyle.circle;
	            }
	           
	            return style;
	        };
	        ChartHelper.ToST_LegendPos = function (position ) {
	            var result = 0;
	            switch (position) {
	                case 0 :
	                    break;
	                case 1 :
	                    result = 4;
	                    break;
	                case 2 :
	                    result = 3;
	                    break;
	                case 3 :
	                    result = 2;
	                    break;
	                case 4 :
	                    result = 0;
	                    break;
	                case 5 :
	                    result = 1;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToLegendPosition = function (position ) {
	            var result = 4 ;
	            switch (position) {
	                case 0:
	                    result = 4 ;
	                    break;
	                case 1:
	                    result = 5 ;
	                    break;
	                case 2:
	                    result = 3 ;
	                    break;
	                case 3:
	                    result = 2 ;
	                    break;
	                case 4:
	                    result = 1 ;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToST_PresetCameraType = function (value) {
	            if(value === 62 ) {
	                value = 0 ;
	            }
	           
	            return value;
	        };
	        ChartHelper.ToST_BuiltInUnit = function (value) {
	            if(value > 8 ) {
	                value = 0 ;
	            }
	           
	            return value;
	        };
	        ChartHelper.ToST_Crosses = function (crosses )  {
	            var result  = 0 ;
	            switch (crosses) {
	                case 0 :
	                    break;
	                case 1 :
	                    result = 0 ;
	                    break;
	                case 2 :
	                    result = 1 ;
	                    break;
	                case 3 :
	                    result = 2 ;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	        ChartHelper.ToAxisCrosses = function (crosses ) {
	            var result = 1 ;
	            switch (crosses) {
	                case 0 :
	                    result = 1 ;
	                    break;
	                case 1 :
	                    result = 2 ;
	                    break;
	                case 2 :
	                    result = 3 ;
	                    break;
	                default:
	                    break;
	            }
	            return result;
	        };
	
	        return ChartHelper;
	    })();
	    exports._ChartHelper = ChartHelper;
	
	}());

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    
	    var excel = __webpack_require__(21);
	    var nodeHelper = __webpack_require__(11);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var common = __webpack_require__(4);
	    var XmlNodeHelper = __webpack_require__(11);
	    var RelationshipConstants = excel._RelationshipConstants;
	    var getAsArray = nodeHelper._getAsArray;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var excelStyle = __webpack_require__(12);
	    var UnitHelper = excelStyle.UnitHelper;
	    var emuToPixles = UnitHelper.emuToPixles;
	    var readAnchorPoint = nodeHelper._readAnchorPoint;
	    var excelHelper = __webpack_require__(23);
	    var getBounds = excelHelper.getBounds;
	    var Util = common._Util;
	    
	    var SlicerStyleName = {
	        "selectedItemWithData": "selectedItemWithDataStyle",
	        "selectedItemWithNoData": "selectedItemWithNoDataStyle",
	        "unselectedItemWithData": "unSelectedItemWithDataStyle",
	        "unselectedItemWithNoData": "unSelectedItemWithNoDataStyle",
	        "hoveredSelectedItemWithData": "hoveredSelectedItemWithDataStyle",
	        "hoveredSelectedItemWithNoData": "hoveredSelectedItemWithNoDataStyle",
	        "hoveredUnselectedItemWithData": "hoveredUnSelectedItemWithDataStyle",
	        "hoveredUnselectedItemWithNoData": "hoveredUnSelectedItemWithNoDataStyle",
	        "wholeTable": "wholeSlicerStyle",
	        "headerRow": "headerStyle"
	    };
	    var LineBorderWidth = {
	        9 : 1,
	        1 : 1,
	        3 : 1,
	        4 : 1,
	        7 : 1,
	        11 : 1,
	        2 : 2,
	        10 : 2,
	        12 : 2,
	        8 : 2,
	        13 : 2,
	        5 : 3,
	        6 : 3
	    };
	    function getWebBorderStyle(style) {
	        switch (style) {
	            case 6: 
	                return "double";
	            case 9: 
	            case 11: 
	            case 4: 
	            case 13: 
	            case 10: 
	            case 12: 
	                return "dotted";
	            case 2: 
	            case 3: 
	            case 8: 
	                return "dashed";
	            default:
	                return "solid";
	        }
	    }
	    function getSlicerBorderStyle(borderStyle) {
	        if (!borderStyle) {
	            return;
	        }
	        var style = {};
	        if (borderStyle.style) {
	            style.borderWidth = LineBorderWidth[borderStyle.style] || 1;
	            style.borderStyle = getWebBorderStyle(borderStyle.style);
	        }
	        if (borderStyle.color) {
	            style.borderColor = borderStyle.color;
	        }
	        return style;
	    }
	    function getConvertedSlicerStyle(slicerStyle) {
	        if (!slicerStyle) {
	            return;
	        }
	        for (var prop in slicerStyle) {
	            if (slicerStyle.hasOwnProperty(prop) && prop.indexOf('border') >= 0) {
	                var borderStyle = slicerStyle[prop];
	                if (borderStyle) {
	                    slicerStyle[prop] = getSlicerBorderStyle(borderStyle);
	                } else if (borderStyle === null) {
	                    slicerStyle[prop] = void 0;
	                }
	            }
	        }
	        return slicerStyle;
	    }
	    
	    function readSlicers(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData, workbookFile) {
	        if (relationFiles) {
	           
	            var slicerFiles = [];
	            var slicerDrawingFiles = [];
	            for (var key in relationFiles) {
	                if (key !== 'count') {
	                    var relationFile = relationFiles[key];
	                    if (relationFile) {
	                        var fileType = relationFile.fileType;
	                        if (fileType === RelationshipConstants._relationshipSlicerType) {
	                            slicerFiles.push(relationFile);
	                        } else if (fileType === RelationshipConstants._relationshipDrawingType
	                            || fileType === RelationshipConstants._relationshipDrawingType2) {
	                            slicerDrawingFiles.push(relationFile);
	                        }
	                    }
	                }
	            }
	            var slicerStylesFile = readSlicerStyleFile(workbookFile);
	            var slicerCacheFiles = readSlicerCacheFiles(workbookFile);
	           
	            if (slicerFiles.length) {
	                var slicers = readSlicersFromFile(slicerFiles, getFileDataAndCleanData);
	                var sheet = readerDataModel._spread.sheets[sheetName];
	                readSlicerCachesFromFile(slicers, slicerCacheFiles, getFileDataAndCleanData);
	                readSlicerDrawingsFromFile(slicers, slicerDrawingFiles, getFileDataAndCleanData, sheet);
	                readSlicerStyleFromFile(slicers, slicerStylesFile, getFileDataAndCleanData, readerDataModel);
	                readerDataModel._addSlicers(slicers, sheetName);
	            }
	        }
	    }
	    
	    function readSlicer(dataString, slicers) {
	        var obj = parseXmlToObject(dataString);
	        var root = obj['slicers'];
	
	        if (root) {
	            var slicerArray = getAsArray(root['slicer']);
	            if (!isNullOrUndefined(slicerArray)) {
	                slicerArray.forEach(function (slicerNode) {
	                    var slicerInfo = {};
	                    var attr = slicerNode._attr;
	                    if (!isNullOrUndefined(attr)) {
	                        if (!isNullOrUndefined(attr.name)) {
	                            slicerInfo.name = Util._xmlDecode(Util._replaceAll(attr.name, '_x000a_', '\n'));
	                        }
	                        if (!isNullOrUndefined(attr.cache)) {
	                            slicerInfo.nameInFormula = attr.cache;
	                        }
	                        if (!isNullOrUndefined(attr.caption)) {
	                            slicerInfo.captionName = attr.caption;
	                        }
	                        if (!isNullOrUndefined(attr.columnCount)) {
	                            slicerInfo.columnCount = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.columnCount, 1);
	                        }
	                        if (!isNullOrUndefined(attr.showCaption)) {
	                            slicerInfo.showHeader = attr.showCaption !== '0';
	                        }
	                        slicerInfo.style = {name: attr.style};
	                        if (!isNullOrUndefined(attr.lockedPosition)) {
	                            slicerInfo.disableResizingAndMoving = attr.lockedPosition === '1';
	                        }
	                        if (!isNullOrUndefined(attr.rowHeight)) {
	                            slicerInfo.itemHeight = emuToPixles(parseInt(attr.rowHeight));
	                        }
	                    }
	                    slicers.push(slicerInfo);
	                });
	            }
	        }
	    }
	    
	    function readSlicersFromFile(slicerFiles, getFileDataAndCleanData) {
	        var slicers = [];
	        slicerFiles.forEach(function (file) {
	            var dataString = getFileDataAndCleanData(file.fileName);
	            if (dataString) {
	                readSlicer(dataString, slicers);
	            }
	        });
	        return slicers;
	    }
	    function readSlicerCache(slicers, dataString) {
	        var obj = parseXmlToObject(dataString);
	        var root = obj['slicerCacheDefinition'];
	        if (root) {
	            var attr = root._attr;
	            var name = attr.name;
	            var associateSlicers = [];
	            slicers.forEach(function (slicer) {
	                if (slicer.nameInFormula === name) {
	                    associateSlicers.push(slicer);
	                }
	            });
	            if (!associateSlicers.length) {
	                return;
	            }
	            var sourceName = attr.sourceName;
	            var tableId = null, columnId = null;
	            var sortState = null;
	            var showNoDataItems = true, visuallyNoDataItems = true, showNoDataItemsInLast = true;
	            var extLstNode = root.extLst;
	            if (extLstNode) {
	                var extNodes = getAsArray(extLstNode['x:ext']);
	                extNodes.forEach(function (extNode) {
	                    var extNodeAttr = extNode._attr;
	                    var uri = extNodeAttr.uri;
	                    var crossFilter = null;
	                    switch (uri) {
	                        case "{03082B11-2C62-411c-B77F-237D8FCFBE4C}":
	                            break;
	                        case "{2F2917AC-EB37-4324-AD4E-5DD8C200BD13}":
	                            var tableSlicerCaches = getAsArray(extNode['x15:tableSlicerCache']);
	                            tableSlicerCaches.forEach(function (tableSlicerCache) {
	                                var tableSlicerCacheAttr = tableSlicerCache._attr;
	                                tableId = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableSlicerCacheAttr.tableId, 0);
	                                columnId = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableSlicerCacheAttr.column, 0);
	                                sortState = tableSlicerCacheAttr["sortOrder"];
	                                crossFilter = tableSlicerCacheAttr["crossFilter"];
	                            });
	                            break;
	                        case "{470722E0-AACD-4C17-9CDC-17EF765DBC7E}":
	                            var slicerHideItemsWithNoDataCaches = getAsArray(extNode['x15:slicerCacheHideItemsWithNoData']);
	                            if(slicerHideItemsWithNoDataCaches && slicerHideItemsWithNoDataCaches.length > 0) {
	                                showNoDataItems = false;
	                            }
	                            break;
	                    }
	                    switch (crossFilter) {
	                        case "none":
	                            visuallyNoDataItems = false;
	                            break;
	                        case "showItemsWithNoData":
	                            showNoDataItemsInLast = false;
	                            break;
	                    }
	                });
	            }
	
	            associateSlicers.forEach(function (slicer) {
	                slicer.sourceName = sourceName;
	                slicer.tableId = tableId;
	                slicer.columnId = columnId;
	                if (sortState === 'descending') {
	                    slicer.sortState = 2 ;
	                }
	                slicer.showNoDataItems = showNoDataItems;
	                slicer.visuallyNoDataItems = visuallyNoDataItems;
	                slicer.showNoDataItemsInLast = showNoDataItemsInLast;
	            });
	        }
	    }
	    function readSlicerCachesFromFile(slicers, slicerCacheFiles, getFileDataAndCleanData) {
	        slicerCacheFiles.forEach(function (slicerCacheFile) {
	            var dataString = getFileDataAndCleanData(slicerCacheFile.fileName, true);
	            if (dataString) {
	                readSlicerCache(slicers, dataString);
	            }
	        });
	    }
	    function readSlicerStyleFromFile(slicers, slicerStylesFile, getFileDataAndCleanData, readerDataModel) {
	        var dataString = getFileDataAndCleanData(slicerStylesFile.fileName, true);
	        if (dataString) {
	            var obj = parseXmlToObject(dataString);
	            var root = obj['styleSheet'];
	            var slicerStyles = {};
	            var slicerStylesNode = readerDataModel._slicerStylesNode;
	    
	           
	            if (!isNullOrUndefined(slicerStylesNode)) {
	                var slicerStyleNodes = getAsArray(slicerStylesNode['x14:slicerStyle']);
	                slicerStyleNodes.forEach(function (slicerStyleNode) {
	                    var slicerStyleNodeAttr = slicerStyleNode._attr;
	                    var name = slicerStyleNodeAttr["name"];
	                    var slicerStyle = {name: name};
	                    var slicerStyleElementsNodes = getAsArray(slicerStyleNode['x14:slicerStyleElements']);
	                    slicerStyleElementsNodes.forEach(function (slicerStyleElementsNode) {
	                        var slicerStyleElementNodes = getAsArray(slicerStyleElementsNode['x14:slicerStyleElement']);
	                        slicerStyleElementNodes.forEach(function (slicerStyleElementNode) {
	                            var slicerStyleElementNodeAttr = slicerStyleElementNode._attr;
	                            var type = slicerStyleElementNodeAttr["type"];
	                            var dxfId = slicerStyleElementNodeAttr["dxfId"];
	                            var styleName = SlicerStyleName[type];
	                            if (!isNullOrUndefined(dxfId) && styleName) {
	                               
	                                var styleInfo = readerDataModel._getExtStyleByDxfId(dxfId);
	                                slicerStyle[styleName] = getConvertedSlicerStyle(styleInfo);
	                            }
	                        });
	                    });
	                    slicerStyles[name] = slicerStyle;
	                });
	            }
	    
	            var tableStylesNode = root['tableStyles'];
	           
	            if (!isNullOrUndefined(tableStylesNode)) {
	                var tableStyleNodes = getAsArray(tableStylesNode['tableStyle']);
	                tableStyleNodes.forEach(function (tableStyleNode) {
	                    var tableStyleNodeAttr = tableStyleNode._attr;
	                    var name = tableStyleNodeAttr.name;
	                    var slicerStyle = slicerStyles[name];
	                    if (!slicerStyle) {
	                        return;
	                    }
	                    var tableStyleElementNodes = getAsArray(tableStyleNode['tableStyleElement']);
	                    tableStyleElementNodes.forEach(function (tableStyleElementNode) {
	                        var tableStyleElementNodeAttr = tableStyleElementNode._attr;
	                        var type = tableStyleElementNodeAttr["type"];
	                        var dxfId = tableStyleElementNodeAttr["dxfId"];
	                        var styleInfo = readerDataModel._getStyleByDxfId(dxfId);
	                        var styleName = SlicerStyleName[type];
	                        if (!isNullOrUndefined(dxfId) && styleName) {
	                           
	                            slicerStyle[styleName] = getConvertedSlicerStyle(styleInfo);
	                        }
	                    });
	                });
	            }
	    
	            var defaultSlicerStyleName = slicerStylesNode._attr["defaultSlicerStyle"];
	            slicers.forEach(function (slicer) {
	                var styleName = slicer.style.name;
	                if (!styleName) {
	                    slicer.style.name = defaultSlicerStyleName;
	                    styleName = defaultSlicerStyleName;
	                }
	                if (slicerStyles[styleName]) {
	                    slicer.style = slicerStyles[styleName];
	                }
	            });
	        }
	    }
	    function getSlicer(slicers, slicerName) {
	        var result = null;
	        slicers.forEach(function (slicer) {
	            if (slicer.name === slicerName) {
	                result = slicer;
	            }
	        });
	        return result;
	    }
	    function readSlicerDrawing(slicers, dataString, sheet) {
	        var obj = parseXmlToObject(dataString);
	        var root = obj['xdr:wsDr'];
	        var slicerDrawingNodes = getSlicerDrawingNodes(getAsArray(root['xdr:twoCellAnchor']));
	        slicerDrawingNodes.forEach(function (slicerDrawingNode) {
	            var slicerDrawingNodeAttr = slicerDrawingNode._attr;
	            var dynamicMove = true, dynamicSize = true;
	            var moveResizeProperty = slicerDrawingNodeAttr["editAs"];
	            if (moveResizeProperty === "absolute") {
	                dynamicMove = false;
	                dynamicSize = false;
	            } else if (moveResizeProperty === "oneCell") {
	                dynamicMove = true;
	                dynamicSize = false;
	            }
	            var isLocked = true;
	            var clientDataNode = slicerDrawingNode['clientData'];
	            var startPoint = readAnchorPoint(slicerDrawingNode['xdr:from']);
	            var endPoint = readAnchorPoint(slicerDrawingNode['xdr:to']);
	            var bounds = getBounds(sheet, startPoint, endPoint);
	            if (clientDataNode) {
	                var fLocksWithSheet = clientDataNode._attr['fLocksWithSheet'];
	                if (fLocksWithSheet === "0") {
	                    isLocked = false;
	                }
	            }
	            var slicerName = Util._xmlDecode(Util._replaceAll(slicerDrawingNode.slicerName, '&#xA;', '\n'));
	            var excelSlicer = getSlicer(slicers, slicerName);
	            if (!isNullOrUndefined(excelSlicer)) {
	                excelSlicer.dynamicMove = dynamicMove;
	                excelSlicer.dynamicSize = dynamicSize;
	                excelSlicer.x = bounds.x;
	                excelSlicer.y = bounds.y;
	                excelSlicer.width = bounds.width;
	                excelSlicer.height = bounds.height;
	                excelSlicer.isLocked = isLocked;
	                excelSlicer.endPoint = endPoint;
	            }
	        });
	    }
	    function readSlicerDrawingsFromFile(slicers, slicerDrawingFiles, getFileDataAndCleanData, sheet) {
	        slicerDrawingFiles.forEach(function (slicerDrawingFile) {
	            var dataString = getFileDataAndCleanData(slicerDrawingFile.fileName, true);
	            if (dataString) {
	                readSlicerDrawing(slicers, dataString, sheet);
	            }
	        });
	    }
	    
	    function readSlicerCacheFiles(workbookFile) {
	        var relationFiles = workbookFile.relationFiles;
	        var slicerCacheFiles = [];
	        for (var key in relationFiles) {
	            if (key !== 'count') {
	                var relationFile = relationFiles[key];
	                if (relationFile) {
	                    var fileType = relationFile.fileType;
	                    if (fileType === RelationshipConstants._relationshipSlicerCacheType) {
	                        slicerCacheFiles.push(relationFile);
	                    }
	                }
	            }
	        }
	        return slicerCacheFiles;
	    }
	    function readSlicerStyleFile(workbookFile) {
	        var slicerStylesFile = workbookFile._getFileByType(RelationshipConstants._relationshipStylesType);
	        if (!slicerStylesFile) {
	            slicerStylesFile = workbookFile._getFileByType(RelationshipConstants._relationshipStylesType2);
	        }
	        if (!slicerStylesFile) {
	            return;
	        }
	        return slicerStylesFile;
	    }
	    
	    function getSlicerDrawingNodes(nodes) {
	        var path = ["mc:AlternateContent", "mc:Choice", "xdr:graphicFrame", "a:graphic", "a:graphicData"];
	        var slicerDrawingNodes = [];
	        nodes.forEach(function (node) {
	            var currentNode = node;
	            for (var i = 0; i < path.length; i++) {
	    
	                var find = false;
	                if (currentNode && currentNode[path[i]]) {
	                    find = true;
	                    currentNode = currentNode[path[i]];
	                }
	            }
	            if (find) {
	                var graphicDatanNode = currentNode;
	                var uri = graphicDatanNode._attr["uri"];
	                if (uri === "http://schemas.microsoft.com/office/drawing/2010/slicer") {
	                    var sleSlicers = getAsArray(graphicDatanNode['sle:slicer']);
	                    sleSlicers.forEach(function (sleSlicer) {
	                        var sleSlicerAttr = sleSlicer._attr;
	                        var slicerName = sleSlicerAttr["name"];
	                        node.slicerName = slicerName;
	                        slicerDrawingNodes.push(node);
	                    });
	                }
	            }
	        });
	        return slicerDrawingNodes;
	    }
	    exports._readSlicers = readSlicers;
	    
	
	}());

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excel = __webpack_require__(21);
	    var common = __webpack_require__(4);
	    var parseXmlToObject = __webpack_require__(7)._parseXmlToObject;
	    var XmlNodeHelper = __webpack_require__(11);
	    var nodeHelper = __webpack_require__(11);
	    var getRangesFromString = __webpack_require__(26)._getRangesFromString;
	    var readAutoFilter = __webpack_require__(33)._readAutoFilter;
	    var readSortInfo = __webpack_require__(33)._readSortInfo;
	    var RelationshipConstants = excel._RelationshipConstants;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var getAsArray = nodeHelper._getAsArray;
	    var getValueFromObject = XmlNodeHelper._getValueFromObject;
	    var Util = common._Util;
	    
	    function getNodeValue(obj, key, subkey) {
	        return Util._xmlDecode(getValueFromObject(obj, key, subkey));
	    }
	    
	    var ExcelTableThemeType2SpreadJSThemeType = {
	        wholeTable: 'wholeTableStyle',
	        headerRow: 'headerRowStyle',
	        totalRow: 'footerRowStyle',
	        firstColumn: 'highlightFirstColumnStyle',
	        lastColumn: 'highlightLastColumnStyle',
	        firstRowStripe: 'firstRowStripStyle',
	        secondRowStripe: 'secondRowStripStyle',
	        firstColumnStripe: 'firstColumnStripStyle',
	        secondColumnStripe: 'secondColumnStripStyle',
	        firstHeaderCell: 'firstHeaderCellStyle',
	        lastHeaderCell: 'lastHeaderCellStyle',
	        firstTotalCell: 'firstFooterCellStyle',
	        lastTotalCell: 'lastFooterCellStyle'
	    };
	    function generateTableTheme() {
	        var retValue = {};
	        for (var i = 1; i <= 28; i++) {
	            if (i <= 21) {
	                retValue['TABLESTYLELIGHT' + i] = true;
	            }
	            if (i <= 11) {
	                retValue['TABLESTYLEDARK' + i] = true;
	            }
	            retValue['TABLESTYLEMEDIUM' + i] = true;
	        }
	        return retValue;
	    }
	    var BuiltInTableThemeNames = generateTableTheme();
	    
	    function readTables(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
	        if (relationFiles) {
	            var tableFile;
	            var tables = [];
	            for (var key in relationFiles) {
	                if (key !== 'count') {
	                    var relationFile = relationFiles[key];
	                    if (relationFile) {
	                        var fileType = relationFile.fileType;
	                        if (fileType === RelationshipConstants._relationshipTableType) {
	                            tableFile = relationFile;
	                        }
	                        if (tableFile) {
	                            var sheetTable = readTablesFromFile(tableFile, getFileDataAndCleanData, readerDataModel, sheetName);
	                            if (!isNullOrUndefined(sheetTable)) {
	                                tables.push(sheetTable);
	                            }
	                        }
	                    }
	                }
	            }
	            readerDataModel._setTables(tables, sheetName);
	        }
	    }
	    
	    function readTablesFromFile(tableFile, getFileDataAndCleanData, readerDataModel, sheetName) {
	        var dataString = getFileDataAndCleanData(tableFile.fileName);
	        if (dataString) {
	            return readTable(dataString, readerDataModel, sheetName);
	        }
	    }
	    
	    function readTable(dataString, readerDataModel, sheetName) {
	        var tableObj = parseXmlToObject(dataString);
	        var sheetTable = {};
	        var tableAttr = tableObj && tableObj.table && tableObj.table._attr;
	        if (!isNullOrUndefined(tableAttr)) {
	            sheetTable.id = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableAttr.id, 0);
	            sheetTable.name = tableAttr.name;
	            var refStr = tableAttr.ref;
	            if (!isNullOrUndefined(refStr)) {
	                var range = getRangesFromString(refStr)[0];
	                sheetTable.row = range.row;
	                sheetTable.col = range.col;
	                sheetTable.rowCount = range.rowCount;
	                sheetTable.colCount = range.colCount;
	            }
	            var headerRowCount = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableAttr.headerRowCount, 1);
	            if (headerRowCount >= 1) {
	                sheetTable.showHeader = true;
	            } else {
	                sheetTable.showHeader = false;
	            }
	            sheetTable.showFooter = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(tableAttr.totalsRowShown, true);
	            var totalRowCount = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableAttr.totalsRowCount, -1);
	            if (totalRowCount < 1) {
	                sheetTable.showFooter = false;
	            } else {
	                sheetTable.showFooter = true;
	            }
	    
	            var tableNode = tableObj && tableObj.table;
	            var autoFilter, sortInfo;
	            if (!isNullOrUndefined(tableNode)) {
	                for (var element in tableNode) {
	                    if (tableNode.hasOwnProperty(element) && !isNullOrUndefined(tableNode[element])) {
	                        switch (element) {
	                            case 'autoFilter':
	                                autoFilter = readAutoFilter(tableNode[element]);
	                                break;
	                            case 'sortState' :
	                                sortInfo = readSortInfo(tableNode[element]);
	                                break;
	                            case 'tableColumns':
	                                sheetTable.columns = readTableColumns(tableNode[element]);
	                                break;
	                            case 'tableStyleInfo':
	                                readTableStyleInfo(tableNode[element], sheetTable, readerDataModel);
	                                break;
	                        }
	                    }
	                }
	            }
	            var filter = autoFilter || {};
	            sheetTable.rowFilter = readerDataModel._convertAutoFilterToJSON(filter, sheetName) || {};
	            sheetTable.rowFilter.sortInfo = sortInfo;
	            sheetTable.rowFilter.showFilterButton = true;
	            sheetTable.rowFilter.filterButtonVisibleInfo = {};
	            for (var i = 0; i < sheetTable.colCount; i++) {
	                sheetTable.rowFilter.filterButtonVisibleInfo[i] = true;
	            }
	            if (!sheetTable.rowFilter.range) {
	                if (!sheetTable.rowFilter.sortInfo) {
	                    sheetTable.rowFilter.showFilterButton = false;
	                    sheetTable.rowFilter.filterButtonVisibleInfo = {};
	                    for (i = 0; i < sheetTable.colCount; i++) {
	                        sheetTable.rowFilter.filterButtonVisibleInfo[i] = false;
	                    }
	                }
	                sheetTable.rowFilter.range = {
	                    row: sheetTable.row + 1,
	                    col: sheetTable.col,
	                    rowCount: sheetTable.rowCount - 1,
	                    colCount: sheetTable.colCount
	                };
	                if (sheetTable.showFooter) {
	                    sheetTable.rowFilter.range.rowCount--;
	                }
	            }
	            if (sheetTable.rowFilter.filteredColumns && sheetTable.rowFilter.filteredColumns.length > 0) { 
	                if (filter.filterColumns[0].hiddenButton || sheetTable.rowFilter.showFilterButton === false) {
	                    sheetTable.rowFilter.showFilterButton = false;
	                    sheetTable.rowFilter.filterButtonVisibleInfo = {};
	                    for (i = 0; i < sheetTable.colCount; i++) {
	                        sheetTable.rowFilter.filterButtonVisibleInfo[i] = false;
	                    }
	                }
	            }
	            if (sheetTable.showHeader === false) {
	                sheetTable.rowFilter.showFilterButton = false;
	            }
	        }
	        return sheetTable;
	    }
	    
	    function readTableColumns(columnsNode) {
	        var columns = [];
	        var columnsArray = getAsArray(columnsNode.tableColumn);
	        if (!isNullOrUndefined(columnsArray)) {
	            columnsArray.forEach(function (columnNode) {
	                var tableColumnInfo = {};
	                tableColumnInfo.footerFormula = null;
	                tableColumnInfo.footerValue = null;
	                var attr = columnNode._attr;
	                if (!isNullOrUndefined(attr)) {
	                    if (!isNullOrUndefined(attr.id)) {
	                        tableColumnInfo.id = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.id, 0);
	                    }
	                    if (!isNullOrUndefined(attr.name)) {
	                        tableColumnInfo.name = Util._xmlDecode(Util._replaceAll(attr.name, '_x000a_', '\n'));
	                    }
	                    if (!isNullOrUndefined(attr.totalsRowLabel)) {
	                        tableColumnInfo.footerValue = attr.totalsRowLabel;
	                    }
	                    if (!isNullOrUndefined(attr.totalsRowFunction)) {
	                        if (attr.totalsRowFunction === 'custom') {
	                            tableColumnInfo.footerFormula = getNodeValue(columnNode, 'totalsRowFormula');
	                        } else {
	                            tableColumnInfo.footerFormula = attr.totalsRowFunction;
	                        }
	                    }
	                }
	                columns.push(tableColumnInfo);
	            });
	        }
	        return columns;
	    }
	    
	    function readTableStyleInfo(styleInfoNode, sheetTable, readerDataModel) {
	        var tableTheme = {};
	        var attr = styleInfoNode._attr;
	        if (!isNullOrUndefined(attr)) {
	            if (!isNullOrUndefined(attr.name)) {
	                readTableStyle(sheetTable, tableTheme, readerDataModel, attr.name);
	            }
	            if (!isNullOrUndefined(attr.showFirstColumn)) {
	                sheetTable.highlightFirstColumn = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showFirstColumn, false);
	            }
	            if (!isNullOrUndefined(attr.showLastColumn)) {
	                sheetTable.highlightLastColumn = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showLastColumn, false);
	            }
	            if (!isNullOrUndefined(attr.showRowStripes)) {
	                sheetTable.bandRows = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showRowStripes, false);
	            }
	            if (!isNullOrUndefined(attr.showColumnStripes)) {
	                sheetTable.bandColumns = XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showColumnStripes, false);
	            }
	        }
	    }
	    
	    function readTableStyle(sheetTable, tableTheme, readerDataModel, name) {
	        var isBuildInTableStyle = BuiltInTableThemeNames[name.toUpperCase()];
	        if (isBuildInTableStyle) {
	            tableTheme.buildInName = getBuiltInTableStyle(name);
	        } else {
	            var tableStylesObj = readerDataModel.tableStylesObj;
	            if (!isNullOrUndefined(tableStylesObj)) {
	                var attr = tableStylesObj._attr;
	                if (!isNullOrUndefined(attr)) {
	                    var tableStyleCount = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.count, 0);
	                    var styleNode;
	                    if (tableStyleCount > 0) {
	                        var tableStylesArray = getAsArray(tableStylesObj.tableStyle);
	                        if (!isNullOrUndefined(tableStylesArray)) {
	                            for (var i = 0; i < tableStylesArray.length; i++) {
	                                var styleName = tableStylesArray[i]._attr.name;
	                                if (name === styleName) {
	                                    styleNode = tableStylesArray[i];
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                    readCustomerStyle(sheetTable, tableTheme, styleNode, readerDataModel);
	                }
	            }
	        }
	        sheetTable.style = tableTheme;
	    }
	    
	    function readCustomerStyle(sheetTable, tableTheme, styleNode, readerDataModel) {
	        var customerStyleNode = styleNode;
	        var attr = customerStyleNode._attr;
	        tableTheme.name = attr.name;
	        if (attr.count && attr.count > 0) {
	            readTableStyleElement(sheetTable, tableTheme, styleNode, readerDataModel);
	        }
	    }
	    
	    function getBuiltInTableStyle(name) {
	        return name.substr(10);
	    }
	    
	    function readTableStyleElement(sheetTable, tableTheme, styleNode, readerDataModel) {
	        var styleElementArray = getAsArray(styleNode.tableStyleElement);
	        if (!isNullOrUndefined(styleElementArray)) {
	            styleElementArray.forEach(function (styleElementNode) {
	                var elementAttr = styleElementNode._attr;
	                if (!isNullOrUndefined(elementAttr)) {
	                    var elementType = elementAttr.type || 'wholeTable';
	                    var dxfid = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(elementAttr.dxfId) || 0;
	                    var stripSize = XmlNodeHelper._getAttributeValueOrDefaultOfIntType(elementAttr.size) || 1;
	                    var style = readerDataModel._getStyleByDxfId(dxfid);
	                    tableTheme[ExcelTableThemeType2SpreadJSThemeType[elementType]] = style;
	                    if (elementType === 'firstRowStripe' || elementType === 'secondRowStripe' || elementType === 'firstColumnStripe' || elementType === 'secondColumnStripe') {
	                        tableTheme[elementType.substr(0, elementType.length - 1) + 'Size'] = stripSize;
	                    }
	                }
	            });
	        }
	        sheetTable.style = tableTheme;
	    }
	    
	    
	    module.exports = readTables;
	
	}());

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    
	
	    var JSZip = __webpack_require__(2);
	    var excel = __webpack_require__(21);
	    var XFile = excel._XFile;
	
	    var common = __webpack_require__(4);
	    var Util = common._Util;
	    var isNullOrUndefined = common._isNullOrUndefined;
	
	    var XmlWriter = __webpack_require__(43);
	    var WriterDataModel = __webpack_require__(44);
	    var writeStyle = __webpack_require__(45)._writeStyle;
	    var writeWorksheet = __webpack_require__(47);
	    var writeSharedString = __webpack_require__(54);
	    var writeTheme = __webpack_require__(55);
	    var writeWorkbook = __webpack_require__(56);
	    var commentWriter = __webpack_require__(57);
	    var drawingWriter = __webpack_require__(58);
	    var writeTable = __webpack_require__(60);
	    var writeSlicer = __webpack_require__(50)._writeSlicer;
	    var writeSlicerCache = __webpack_require__(50)._writeSlicerCache;
	    var writeVmlDrawingFile = __webpack_require__(53)._writeVmlDrawingFile;
	    var DrawingWriterClass = __webpack_require__(59);
	    var getPictureInfo = __webpack_require__(23).getPictureInfo;
	    var writeDrawing = drawingWriter.writeDrawing;
	    var writeComments = commentWriter.writeComments;
	    var writeCommentShapes = commentWriter.writeCommentShapes;
	    var excelStyleHelper = __webpack_require__(12);
	    var RelationshipConstants = excel._RelationshipConstants;
	    var XFileConstants = excel._XFileConstants;
	    var keyword_undefined = void 0;
	
	    
	    function getImageFile(picture, index, pictureFile) {
	        var extension = picture.imageType || 'jpg';
	
	        var imageFileName = XFileConstants._imageFileNamePrefix + index + '.' + extension;
	        var imageFile = new XFile(XFileConstants._mediaFileFolder + '/' + imageFileName, RelationshipConstants._relationshipImageType);
	        imageFile.target = '../media/' + imageFileName;
	
	        var rid = pictureFile._addRelationFile(imageFile);
	        picture.rid = rid;
	
	        return imageFile;
	    }
	
	    var XlsxWriter = (function () {
	        function XlsxWriter(spread) {
	            var self = this;
	            self._styleOffset = 0;
	            self._writerDataModel = keyword_undefined;
	            self._xfMap = {};
	            self._sheetIDs = [];
	            self._isR1C1 = spread.referenceStyle === 1;
	            self._options = {};
	            self._zip = JSZip();
	            self._writerDataModel = new WriterDataModel(spread);
	            self._totalVmlDrawingCount = 0;
	            self._totalCommentCount = 0;
	            self._totalDrawingCount = 0;
	            self._imageIndex = 0;
	            self._totalSlicerCount = 0;
	            self._totalSlicerCacheCount = 0;
	            self._totalChartCount = 0;
	        }
	
	        XlsxWriter.prototype._save = function () {
	            var self = this;
	            var rootVirtualFile = new XFile('', '');
	            var workbookFile = new XFile(XFileConstants._workbook_default_fileName, RelationshipConstants._relationshipWorkbookType);
	            rootVirtualFile._addRelationFile(workbookFile);            
	
	            var sharedString = {
	                _sstTable: [],
	                _sstTableDict: {},
	                _sstTableCount: 0
	            };
	            var styleOffset = self._saveStyles(workbookFile);
	            self._saveWorksheets(workbookFile, styleOffset, sharedString);
	            self._saveStringTables(workbookFile, sharedString);
	            self._saveTheme(workbookFile);
	            self._saveWorkbook(workbookFile);
	            self._savePackageRelationFiles(rootVirtualFile);
	            self._saveContentTypes(rootVirtualFile, self._totalVmlDrawingCount > 0);
	            self._dispose();
	
	            self._zip.generateAsync({
	                type: self._options.useArrayBuffer ? 'arraybuffer' : 'blob',
	                compression: 'DEFLATE'
	            }).then(function (content) {
	                self.onZip(content);
	            }).catch(function () {
	                self.onError();
	            });
	           
	
	        };
	       
	       
	       
	        XlsxWriter.prototype._savePackageRelationFiles = function (xFile) {
	            if (isNullOrUndefined(xFile) || isNullOrUndefined(xFile.relationFiles) || xFile.relationFiles.count === 0) {
	                return;
	            }
	
	            var pathInfo = Util._parsePath(xFile.fileName),
	                path = pathInfo.dir, fileName = pathInfo.fileName;
	
	            var self = this;
	
	            var relationFiles = {};
	
	            for (var item in xFile.relationFiles) {
	                if (xFile.relationFiles.hasOwnProperty(item)) {
	                    var rel = xFile.relationFiles[item];
	                    if (rel && item !== 'count') {
	                        var targetAndType = [
	                            rel.target || rel.fileName.replace(path + '/', ''),
	                            rel.fileType
	                        ];
	
	                        relationFiles[item] = targetAndType;
	                        this._savePackageRelationFiles(rel);
	                    }
	                }
	            }
	
	            var writer = new XmlWriter();
	            writer.writeDocument();
	            writer.writeElement('Relationships', function () {
	                writer.writeAttributeString('xmlns', XFileConstants._relationshipNameSpace);
	            }, function () {
	                for (var key in relationFiles) {
	                    if (relationFiles.hasOwnProperty(key)) {
	                        var targetAndType = relationFiles[key];
	
	                        if (targetAndType && targetAndType.length >= 2) {
	                            writer.writeLeafElement('Relationship', function () {  
	                                writer.writeAttributeString('Id', key);
	                                writer.writeAttributeString('Type', targetAndType[1]);
	                                writer.writeAttributeString('Target', targetAndType[0]);
	                            });
	                        }
	                    }
	                }
	            });
	            var name = path + '/' + XFileConstants._relationshipFileFolder + '/' + fileName + '.' + XFileConstants._relsExtension;
	            self._zip.file(name.substring(1), writer.xml);
	        };
	        XlsxWriter.prototype._saveContentTypes = function (rootVirtualFile, withVmlDrawingFiles) {
	            var ctTypes = this._writerDataModel._getContentTypes(rootVirtualFile, withVmlDrawingFiles);
	            var writer = new XmlWriter();
	            writer.writeDocument();
	            writer.writeElement('Types', function () {
	                writer.writeAttributeString('xmlns', XFileConstants._contentTypeNameSpace);
	            }, function () {
	                for (var i = 0, len = ctTypes.length; i < len; i++) {
	                    var item = ctTypes[i];
	                    if (item instanceof excel._DefaultContentType) {
	                        writer.writeLeafElement('Default', function () { 
	                            writer.writeAttributeString('Extension', item.extension);
	                            writer.writeAttributeString('ContentType', item.contentType);
	                        });
	                    } else if (item instanceof excel._OverrideContentType) {
	                        writer.writeLeafElement('Override', function () { 
	                            writer.writeAttributeString('PartName', item.partName);
	                            writer.writeAttributeString('ContentType', item.contentType);
	                        });
	                    }
	                }
	            });
	            this._zip.file(XFileConstants._contentTypeFileName, writer.xml);
	        };
	        XlsxWriter.prototype._saveStyles = function (workbookFile) {
	            var self = this;
	            var stylesFile = new XFile(XFileConstants._style_fileName, RelationshipConstants._relationshipStylesType);
	            workbookFile._addRelationFile(stylesFile);
	            var styleResult = writeStyle(self._writerDataModel, self._xfMap);
	            self._zip.file(XFileConstants._style_fileName.substring(1), styleResult.xml);
	            return styleResult.styleOffset;
	        };
	        XlsxWriter.prototype._saveWorksheets = function (workbookFile, styleOffset, sharedString) {
	            var model = this._writerDataModel;
	            var sheetNames = model._getSheetsName(), sheetCount = sheetNames.length;
	
	           
	           
	            var id = 0;
	            var tables = model._getTables();
	            if (tables && tables.length > 0) {
	                tables.forEach(function (sheetTable) {
	                    sheetTable.id = ++id;
	                });
	            }
	
	            for (var index = 0; index < sheetCount; index++) {
	                var sheetName = sheetNames[index];
	                if (!sheetName) {
	                    continue;
	                }
	
	                var si = new excel._SheetInfo();
	                si.name = sheetName;
	                si.sheetId = index + 1;
	                si.index = index;
	
	                var sheetviewFile = new XFile(XFileConstants._worksheetFolder + '/' + XFileConstants._worksheetNamePrefix + si.sheetId + '.' + XFileConstants._xmlExtension, RelationshipConstants._relationshipWorksheetType);
	                si.rID = workbookFile._addRelationFile(sheetviewFile);
	                this._sheetIDs.push(si);
	
	                var extensions = {attributes: []};
	               
	                this._writeComments(model, sheetName, sheetviewFile, extensions, index);
	
	                var slicers = model._getSlicers(sheetName);
	                var pictures = model._getPictures(sheetName);
	                var charts = model._getCharts(sheetName);
	                var drawingFile = this._writeDrawings(sheetviewFile, extensions, pictures, slicers, charts);
	               
	                this._writeCharts(model, drawingFile, sheetName, charts);
	               
	                this._writeDrawingFiles(model, drawingFile, pictures, slicers, charts, extensions);
	
	               
	                this._writeTables(model, sheetviewFile, sheetName);
	               
	                this._writeSlicers(model, sheetviewFile, sheetName, workbookFile);
	               
	                this._writeVmlDrawing(model, sheetviewFile, sheetName, workbookFile);
	
	                this._writeSheet(si, styleOffset, sharedString, extensions);
	            }
	        };
	        XlsxWriter.prototype._saveStringTables = function (workbookFile, sharedString) {
	            var self = this;
	            if (sharedString._sstTable.length <= 0) {
	                return;
	            }
	            var ssFile = new XFile(XFileConstants._sharedStringsDefaultFileName, RelationshipConstants._relationshipSharedStringsType);
	            workbookFile._addRelationFile(ssFile);
	            var xml = writeSharedString(sharedString);
	            self._zip.file(XFileConstants._sharedStringsDefaultFileName.substring(1), xml);
	        };
	        XlsxWriter.prototype._saveTheme = function (workbookFile) {
	            var themeFile = new XFile(XFileConstants._themeDefaultFileName, RelationshipConstants._relationshipThemeType);
	            workbookFile._addRelationFile(themeFile);
	            var xml = writeTheme(this._writerDataModel);
	            this._zip.file(XFileConstants._theme_default_fileName.substring(1), xml);
	        };
	        XlsxWriter.prototype._saveWorkbook = function () {
	            var self = this;
	            var xml = writeWorkbook(self._writerDataModel, self._sheetIDs, self._isR1C1);
	            self._zip.file(XFileConstants._workbook_default_fileName.substring(1), xml);
	        };
	        XlsxWriter.prototype._writeSheet = function (si, styleOffset, shareString, extensions) {
	            var self = this;
	            var xml = writeWorksheet(self._writerDataModel, si.name, self._xfMap, styleOffset, self._options, shareString, extensions);
	            this._zip.file(XFileConstants._worksheetFilePath.substring(1) + '/sheet' + si.sheetId + '.' + XFileConstants._xmlExtension, xml);
	        };
	        XlsxWriter.prototype._writeComments = function (model, sheetName, sheetviewFile, extensions, sheetIndex) {
	            var comments = model._getComments(sheetName);
	            if (comments && comments.length > 0) {
	                this._totalCommentCount++;
	               
	                var commentFileName = XFileConstants._commentFileNamePrefix + this._totalCommentCount + '.' + XFileConstants._xmlExtension;
	                var commentFile = new XFile(XFileConstants._dataFileRootFolder + '/' + commentFileName, RelationshipConstants._relationshipCommentType);
	                commentFile.target = '../' + commentFileName;
	
	                sheetviewFile._addRelationFile(commentFile);
	
	               
	                this._totalVmlDrawingCount++;
	                var commentShapeFileName = XFileConstants._vmlDrawingsFileNamePrefix + this._totalVmlDrawingCount + '.' + XFileConstants._vmlExtension;
	                var commentShapeFile = new XFile(XFileConstants._drawingsFileFolder + '/' + commentShapeFileName, RelationshipConstants._relationshipVMLDrawingType);
	                commentShapeFile.target = '../drawings/' + commentShapeFileName;
	
	                var rid = sheetviewFile._addRelationFile(commentShapeFile);
	                extensions.legacyDrawingId = rid;
	                extensions.attributes.push({key: 'xmlns:xdr', value: XFileConstants._drawingNameSpace});
	
	                this._writeCommentFiles(model, sheetIndex, comments, commentFile.fileName, commentShapeFile.fileName);
	            }
	        };
	        XlsxWriter.prototype._writeCommentFiles = function (model, sheetIndex, comments, commentFileName, commentShapeFileName) {
	            var self = this, zip = self._zip;
	            var xml = writeComments(model, comments);
	            zip.file(commentFileName.substring(1), xml);
	
	            xml = writeCommentShapes(model, sheetIndex, comments);
	            zip.file(commentShapeFileName.substring(1), xml);
	        };
	        XlsxWriter.prototype._writeCharts = function (model, drawingFile, sheetName, charts) {
	            if (charts) {
	                var _this = this;
	                charts.forEach(function (chartItem) {
	                    _this._totalChartCount++;
	                    var chartFileName = XFileConstants._chartFileNamePrefix + _this._totalChartCount + '.' + XFileConstants._xmlExtension;
	                    var chartFile = new XFile(XFileConstants._chartsFileFolder + '/' + chartFileName, RelationshipConstants._relationshipChartType);
	                    chartFile.target = '../charts/' + chartFileName;
	                    chartItem.chartId = drawingFile._addRelationFile(chartFile);
	
	                    var chartSpace = chartItem.chartSpace;
	                    if(chartSpace) {
	                       
	                        _this._writeChartUserShapes(chartSpace, chartItem, chartFile);
	
	                       
	                        _this._writeChartEmbededImage(chartSpace, chartFile);
	
	                        var writer = new XmlWriter();
	                        writer.writeDocument();
	                        DrawingWriterClass.WriteCT_ChartSpace(writer, 'c', 'chartSpace', chartSpace);
	                        _this._zip.file(chartFile.fileName.substring(1), writer.xml);
	                    }
	                });
	            }
	        };
	        XlsxWriter.prototype._writeChartUserShapes = function (chartSpace, chart, chartFile) {
	            var _this = this;
	            var userShapes = chartSpace.userShapes;
	            var relSizeAnchor = userShapes && userShapes.relSizeAnchor;
	            if (relSizeAnchor && relSizeAnchor.length > 0) {
	                _this._totalDrawingCount++;
	                var chartDrawingFileName = XFileConstants._drawingFileNamePrefix + _this._totalDrawingCount + '.' + XFileConstants._xmlExtension;
	                var userShapeDrawingFile = new XFile(XFileConstants._drawingsFileFolder + '/' + chartDrawingFileName, RelationshipConstants._realationshipChartUserShapes);
	                userShapeDrawingFile.target = '../drawings/' + chartDrawingFileName;
	                chart.drawingFile = userShapeDrawingFile;
	                var drawingId = chartFile._addRelationFile(userShapeDrawingFile);
	                chartSpace.userShapes.id = drawingId;
	                relSizeAnchor.forEach(function (shapeItem) {
	                    if (shapeItem.typeName === '1' ) {
	                        _this._writePictureInChart(shapeItem, userShapeDrawingFile);
	                    } else if (shapeItem.typeName === '2' ) {
	                        _this._writeChartInChart(shapeItem, userShapeDrawingFile);
	                    }
	                });
	            }
	        };
	        XlsxWriter.prototype._writePictureInChart = function (pictureInChart, userShapeDrawingFile) {        
	            var chartEmbedImageString = pictureInChart.src;
	            if(chartEmbedImageString) {
	                var _this = this;
	                _this._imageIndex++;
	                var imageInfo = {};
	                getPictureInfo(chartEmbedImageString, imageInfo);
	                var imageFile = getImageFile(imageInfo, _this._imageIndex, userShapeDrawingFile);
	                _this._zip.file(imageFile.fileName.substring(1), imageInfo.base64Image, {base64: true});
	
	                pictureInChart.pic.blipFill = {
	                    blip: {
	                        embed: imageInfo.rid  
	                    }
	                };
	            }
	        };
	        XlsxWriter.prototype._writeChartInChart = function (chartInChart, userShapeDrawingFile) {
	            var _this = this;
	            _this._totalChartCount++;
	            var chartFileName = XFileConstants._chartFileNamePrefix + _this._totalChartCount + '.' + XFileConstants._xmlExtension;
	            var chartFile = new XFile(XFileConstants._chartsFileFolder + '/' + chartFileName, RelationshipConstants._relationshipChartType);
	            chartFile.target = '../charts/' + chartFileName;
	            var chartId = userShapeDrawingFile._addRelationFile(chartFile);
	
	            var chartSpace = chartInChart.chartSpace;
	            if (chartSpace) {
	                chartInChart.graphicFrame.graphic = {
	                    graphicData: {
	                        chart: {
	                            id: chartId,
	                            typeName: 'chartSpace'
	                        }
	                    }
	                };
	                var writer = new XmlWriter();
	                writer.writeDocument();
	                DrawingWriterClass.WriteCT_ChartSpace(writer, 'c', 'chartSpace', chartSpace);
	                _this._zip.file(chartFile.fileName.substring(1), writer.xml);
	            }
	        };
	        XlsxWriter.prototype._writeChartEmbededImage = function (chartSpace, chartFile) {
	            var _this = this;
	            var plotArea = chartSpace.chart.plotArea;
	           
	            plotArea.chartGroups.forEach(function (chart) {
	                if (chart && chart.ser) {
	                    chart.ser.forEach(function (serItem) {
	                        if (serItem.spPr) {
	                            _this._writeChartEmbedImageFile(chartFile, serItem.spPr);
	                        }
	                        if (serItem.dLbls && serItem.dLbls.spPr) {
	                            _this._writeChartEmbedImageFile(chartFile, serItem.dLbls.spPr);
	                        }
	                    });
	                }
	            });
	           
	            if (plotArea.spPr) {
	                _this._writeChartEmbedImageFile(chartFile, plotArea.spPr);
	            }
	           
	            if (chartSpace.spPr) {
	                _this._writeChartEmbedImageFile(chartFile, chartSpace.spPr);
	            }
	        };
	        XlsxWriter.prototype._writeChartEmbedImageFile = function (chartFile, blipFillContainer) {
	            var chartEmbedImageString = blipFillContainer && blipFillContainer.blipFill && blipFillContainer.blipFill.blip &&
	                    blipFillContainer.blipFill.blip.blipBlob && blipFillContainer.blipFill.blip.blipBlob.blob;
	            if(!chartEmbedImageString) {
	                return;
	            }
	            var _this = this;
	            _this._imageIndex++;
	            var imageInfo = {};
	            getPictureInfo(chartEmbedImageString, imageInfo);
	            var imageFile = getImageFile(imageInfo, _this._imageIndex, chartFile);
	            _this._zip.file(imageFile.fileName.substring(1), imageInfo.base64Image, {base64: true});
	
	            blipFillContainer.blipFill.blip.embed = imageInfo.rid;
	        };
	        XlsxWriter.prototype._writeDrawings = function (sheetviewFile, extensions, pictures, slicers, charts) {
	            if ((pictures && pictures.length > 0) || (slicers && slicers.length > 0) || (charts && charts.length > 0)) {
	                this._totalDrawingCount++;
	                var drawingFileName = XFileConstants._drawingFileNamePrefix + this._totalDrawingCount + '.' + XFileConstants._xmlExtension;
	                var drawingFile = new XFile(XFileConstants._drawingsFileFolder + '/' + drawingFileName, RelationshipConstants._relationshipDrawingType);
	                drawingFile.target = '../drawings/' + drawingFileName;
	                var rid = sheetviewFile._addRelationFile(drawingFile);
	                extensions.drawingId = rid;
	                return drawingFile;
	            }
	        };
	        XlsxWriter.prototype._writeDrawingFiles = function (model, pictureFile, pictures, slicers, charts, extensions) {
	            var _this = this, zip = _this._zip;
	            if (pictures && pictures.length > 0) {
	                pictures.forEach(function (picture) {
	                    _this._imageIndex++;
	                    var imageFile = getImageFile(picture, _this._imageIndex, pictureFile);
	                    zip.file(imageFile.fileName.substring(1), picture.base64Image, {base64: true});
	                });
	            }
	            if ((pictures && pictures.length > 0) || (slicers && slicers.length > 0) || (charts && charts.length > 0)) {
	                var xml = writeDrawing(model, pictures, slicers, charts, extensions);
	                zip.file(pictureFile.fileName.substring(1), xml);
	
	               
	                _this._writeChartUserShapesFile(charts);
	            }
	        };
	        XlsxWriter.prototype._writeChartUserShapesFile = function (charts) {
	            if (charts && charts.length > 0) {
	                var zip = this._zip;
	                charts.forEach(function (chart) {
	                    var chartSpace = chart.chartSpace;
	                    var userShapes = chartSpace && chartSpace.userShapes,
	                        relSizeAnchor = userShapes && userShapes.relSizeAnchor;
	                    if (relSizeAnchor && relSizeAnchor.length > 0) {
	                        var writer = new XmlWriter();
	                        writer.writeDocument(false);
	                        DrawingWriterClass.WriteCT_ChartDrawing(writer, '', 'userShapes', userShapes);
	                        zip.file(chart.drawingFile.fileName.substring(1), writer.xml);
	                    }
	                });
	            }
	        };
	        XlsxWriter.prototype._writeTables = function (model, sheetviewFile, sheetName) {
	            var self = this;
	            var tables = model._getTables(sheetName);
	            if (tables && tables.length > 0) {
	                tables.forEach(function (sheetTable) {
	                    var tableFileName = XFileConstants._tableFileNamePrefix + sheetTable.id + '.' + XFileConstants._xmlExtension;
	                    var tableFile = new XFile(XFileConstants._tableFilesFolder + '/' + tableFileName, RelationshipConstants._relationshipTableType);
	                    tableFile.target = '../tables/' + tableFileName;
	                    var rid = sheetviewFile._addRelationFile(tableFile);
	                    sheetTable.rid = rid;
	                    self._writeSheetTable(sheetTable, tableFile.fileName, model, sheetName);
	                });
	            }
	        };
	        XlsxWriter.prototype._writeSheetTable = function (sheetTable, tableFileName, model, sheetName) {
	            var self = this, zip = self._zip;
	            var xml = writeTable(sheetTable, model, sheetName);
	            zip.file(tableFileName.substring(1), xml);
	        };
	        XlsxWriter.prototype._writeSlicers = function (model, sheetviewFile, sheetName, workbookFile) {
	            var self = this;
	            var slicers = model._getSlicers(sheetName);
	            if (slicers && slicers.length > 0) {
	                self._writeSlicersFile(model, sheetviewFile, sheetName, slicers);
	                self._writeSliceCachesFile(model, sheetviewFile, sheetName, slicers, workbookFile);
	
	            }
	        };
	        XlsxWriter.prototype._writeSlicersFile = function (model, sheetviewFile, sheetName, slicers) {
	            var self = this;
	            self._totalSlicerCount++;
	            var slicerFileName = XFileConstants._slicerFileNamePrefix + self._totalSlicerCount + '.' + XFileConstants._xmlExtension;
	            var slicerFile = new XFile(XFileConstants._slicerFilesFolder + '/' + slicerFileName, RelationshipConstants._relationshipSlicerType);
	            slicerFile.target = '../slicers/' + slicerFileName;
	            var rid = sheetviewFile._addRelationFile(slicerFile);
	            slicers[0].rid = rid;
	            var zip = self._zip;
	            var xml = writeSlicer(slicers, model, sheetName);
	            zip.file(slicerFile.fileName.substring(1), xml);
	        };
	        XlsxWriter.prototype._writeSliceCachesFile = function (model, sheetviewFile, sheetName, slicers, workbookFile) {
	            var self = this;
	            var _savedSlicerCacheIDs = {};
	            var tables = model._getTables();
	            slicers.forEach(function (slicer) {
	                var keys = Object.keys(_savedSlicerCacheIDs);
	                if (keys.length === 0 || !_savedSlicerCacheIDs[slicer.nameInFormula]) {
	                    self._totalSlicerCacheCount++;
	                    var slicerCacheFileName = XFileConstants._slicerCacheFileNamePrefix + self._totalSlicerCacheCount + '.' + XFileConstants._xmlExtension;
	                    var slicerCacheFile = new XFile(XFileConstants._slicerCacheFilesFolder + '/' + slicerCacheFileName, RelationshipConstants._relationshipSlicerCacheType);
	                    slicerCacheFile.target = 'slicerCaches/' + slicerCacheFileName;
	                    var rid = workbookFile._addRelationFile(slicerCacheFile);
	                    _savedSlicerCacheIDs[slicer.nameInFormula] = rid;
	                    slicer.cacheRid = rid;
	                    var zip = self._zip;
	                    var xml = writeSlicerCache(slicer, tables);
	                    zip.file(slicerCacheFile.fileName.substring(1), xml);
	                }
	            });
	
	        };
	        XlsxWriter.prototype._writeVmlDrawing = function (model, sheetviewFile, sheetName) {
	            var headerFooterImages = model._getPrintHeaderFooterImage(sheetName);
	            if (headerFooterImages && headerFooterImages.length > 0) {
	                this._totalVmlDrawingCount++;
	
	                var vmlDrawFileName = XFileConstants._vmlDrawingsFileNamePrefix + this._totalVmlDrawingCount + "." + XFileConstants._vmlExtension;
	                var vmlDrawingFile = new XFile(XFileConstants._drawingsFileFolder + '/' + vmlDrawFileName, RelationshipConstants._relationshipVMLDrawingType);
	                vmlDrawingFile.target = '../drawings/' + vmlDrawFileName;
	
	                this._writePrintImages(headerFooterImages, vmlDrawingFile);
	
	                var rid = sheetviewFile._addRelationFile(vmlDrawingFile);
	                model._legacyDrawingHFId = rid;
	                var xml = writeVmlDrawingFile(headerFooterImages);
	                this._zip.file(vmlDrawingFile.fileName.substring(1), xml);
	            }
	        };
	        XlsxWriter.prototype._writePrintImages = function (headerFooterImages, vmlDrawingFile) {
	            var self = this;
	            headerFooterImages.forEach(function (image) {
	                self._imageIndex++;
	                var imageFile = getImageFile(image, self._imageIndex, vmlDrawingFile);
	                self._zip.file(imageFile.fileName.substring(1), image.base64Image, {base64: true});
	                vmlDrawingFile.relationFiles[image.rid] = imageFile;
	            });
	        };
	        XlsxWriter.prototype._dispose = function () {
	            excelStyleHelper.clearCache();
	            this._writerDataModel = keyword_undefined;
	        };
	        return XlsxWriter;
	    })();
	    module.exports = XlsxWriter;
	
	}());

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    var XmlWriter = (function () {
	        function XmlWriter() {
	            this.xml = '';
	        }
	    
	        XmlWriter.prototype.writeDocument = function (noStandalone) {
	            this.xml += '<?xml version="1.0" encoding="UTF-8" ' + (noStandalone ? '' : 'standalone="yes"') + '?>\r\n';
	        };
	        XmlWriter.prototype.writeElement = function (elementName, writeAttr, writeContent) {
	            if (writeContent === undefined) {
	                writeContent = writeAttr;
	                writeAttr = void 0;
	            }
	            this.xml += '<' + elementName;
	            if (typeof writeAttr === 'function') {
	                writeAttr();
	            }
	            this.xml += '>';
	            if (typeof writeContent === 'function') {
	                writeContent();
	            }
	            this.xml += '</' + elementName + '>';
	        };
	        XmlWriter.prototype.writeValue = function (value) {
	            this.xml += value;
	        };
	        XmlWriter.prototype.writeLeafElement = function (elementName, writeAttr) {
	            this.xml += '<' + elementName;
	            if (typeof writeAttr === 'function') {
	                writeAttr();
	            }
	            this.xml += '/>';
	        };
	        XmlWriter.prototype.writeAttributeString = function (attrName, attrValue) {
	            this.xml += ' ' + attrName;
	            if (attrName === 'style') {
	                this.xml += "='" + attrValue + "'";
	            } else {
	                this.xml += '="' + attrValue + '"';
	            }
	        };
	        XmlWriter.prototype.writeElementString = function (elementName, writeContent) {
	            this.xml += '<' + elementName + '>' + writeContent + '</' + elementName + '>';
	        };
	        return XmlWriter;
	    })();
	    module.exports = XmlWriter;
	    
	
	}());

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var excel = __webpack_require__(21);
	    var excelStyle = __webpack_require__(12);
	    var excelhelper = __webpack_require__(23);
	    var Tuple = __webpack_require__(14);
	    var datetimeHelper = __webpack_require__(25);
	
	    var convertToExcelComment = excelhelper.convertToExcelComment;
	    var convertToExcelPicture = excelhelper.convertToExcelPicture;
	    var convertToExcelChart = excelhelper.convertToExcelChart;
	    var convertToExcelSlicer = excelhelper.convertToExcelSlicer;
	    var StyleHelper = common._StyleHelper;
	    var DefaultSize = excel._DefaultSize;
	    var UnitHelper = excelStyle.UnitHelper;
	    var StringEx = common._StringEx;
	    var RelationshipConstants = excel._RelationshipConstants;
	    var XFileConstants = excel._XFileConstants;
	    var ConverterHelper = excelStyle.ConverterHelper;
	    var ColorHelper = excelStyle.ColorHelper;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var ExcelConstants = excel._ExcelConstants;
	    var IndexHelper = common._IndexHelper;
	    var Util = common._Util;
	    var ExcelStyle = excelStyle.ExcelStyle;
	    var ExcelColor = excelStyle.ExcelColor;
	    var Range = common._Range;
	    var fromColorToExcelColor = ColorHelper.fromColorToExcelColor;
	    var toExcelColor = ColorHelper.toExcelColor;
	    var isBorderEqual = excelhelper.isBorderEaual;
	    var isEqualObject = Util._isEqualObject;
	    var isExternalRange = Util._isExternalRange;
	    var getPictureInfo = excelhelper.getPictureInfo;
	    var fromProtectionOptions = excelhelper.fromProtectionOptions;
	
	    var keyword_undefined = void 0, keyword_null = null, const_builtInStyle = '__builtInStyle',
	        const_builtInValidatorStyle = '__builtInValidatorStyle', const_builtInTableStyle = '__builtInTableStyle';
	
	    function isString(value) {
	        return typeof value === 'string';
	    }
	
	    function isObject(value) {
	        return typeof value === 'object';
	    }
	
	    function isBuiltInTableStyle(name) {
	        return name.substring(0, 19) === const_builtInTableStyle;
	    }
	
	    function isBuiltInValidatorStyle(name) {
	        return name.substring(0, 23) === const_builtInValidatorStyle;
	    }
	
	    function getDateConditionFormula(condition) {
	        var formula = condition.formula;
	        if (isNullOrUndefined(formula)) {
	            formula = condition.expected;
	            if (isString(formula)) {
	                formula = "\"" + formula + "\"";
	            }
	        }
	        return formula;
	    }
	
	    function convertToExcelOADate(value) {
	        if (isString(value)) {
	            var startIndex = value.indexOf('/OADate(') + 1, endIndex = value.indexOf(')');
	            if (startIndex !== 0 && endIndex > startIndex) {
	                var oaDateFloat = parseFloat(value.substring(startIndex + 7, endIndex));
	                if (!isNaN(oaDateFloat)) {
	                    var oaDate = datetimeHelper._fromOADate(oaDateFloat);
	                    value = '' + datetimeHelper._toExcelOADate(oaDate);
	                }
	            }
	        }
	        return value;
	    }
	
	    function addNamedStyleToStyleCache(context, styleName, styleInfo) {
	        if(!context._namedStyleCache) {
	            context._namedStyleCache = {};
	        }
	        context._namedStyleCache[styleName] = styleInfo;
	    }
	
	   
	    function getParentStyleByCompositiveName(spread, name) {
	        var style;
	        if (isBuiltInTableStyle(name)) {
	            var pos = name.indexOf(const_builtInStyle);
	            var validatorPos = name.indexOf(const_builtInValidatorStyle);
	            if (pos >= 0) {
	                return name.substring(pos);
	            } else if (validatorPos >= 0) {
	                name = name.substring(validatorPos);
	            }
	        }
	        if (isBuiltInValidatorStyle(name)) {
	            if(spread._namedStyleCache && spread._namedStyleCache[name]) {
	                style = spread._namedStyleCache[name];
	            } else {
	                style = StyleHelper._getByName(spread.namedStyles, name);
	                addNamedStyleToStyleCache(spread, name, style);
	            }
	            return style.parentName;
	        }
	        return keyword_null;
	    }
	
	    function getActualStyleName(spread, style) {
	        if (!style) {
	            return keyword_null;
	        }
	        var parentStyleName;
	        var styleObject = style, styleName = keyword_null;
	        if (isString(styleObject)) {
	            parentStyleName = getParentStyleByCompositiveName(spread, styleObject);
	            if (parentStyleName) {
	                return parentStyleName;
	            }
	            styleName = styleObject;
	        } else if (isObject(styleObject) && styleObject.parentName) {
	            parentStyleName = getParentStyleByCompositiveName(spread, styleObject.parentName);
	            if (parentStyleName) {
	                return parentStyleName;
	            }
	        }
	        return styleName;
	    }
	
	    function isCommunityBuyeStyleInfo(style, comparedStyle) {
	        if (!style && !comparedStyle) {
	            return true;
	        }
	        if (!style || !comparedStyle) {
	            return false;
	        }
	        var styleFormat = ConverterHelper.toExtendedFormat(style),
	            comparedStyleFormat = ConverterHelper.toExtendedFormat(comparedStyle);
	        return styleFormat.equals(comparedStyleFormat);
	    }
	
	    function getEqualStyle(style, styleArray) {
	        for (var i = 0; i < styleArray.length; i++) {
	            if (isCommunityBuyeStyleInfo(style, styleArray[i])) {
	                return styleArray[i];
	            }
	        }
	        return keyword_null;
	    }
	
	   
	
	   
	   
	   
	   
	   
	   
	    function getSheetDefaultRowHeight(sheet) {
	        return sheet.defaults ? sheet.defaults.rowHeight : DefaultSize._defaultRowHeight;
	    }
	
	    function getSheetDefaultColumnWidth(sheet) {
	        return sheet.defaults ? sheet.defaults.colWidth : DefaultSize._defaultColumnWidth;
	    }
	
	    function getCellData(sheet, row, col) {
	        var rowData = sheet.data.dataTable[row];
	        if (rowData && rowData[col]) {
	            return rowData[col].value;
	        }
	    }
	
	    function getFilterRange(sheet, range) {
	        var row = range.row, col = range.col, rowCount = range.rowCount, colCount = range.colCount;
	        if (row === -1) {
	            row = 0;
	            rowCount = sheet.rowCount;
	        }
	        if (col === -1) {
	            col = 0;
	            colCount = sheet.columnCount;
	        }
	       
	        if (row <= 0) {
	            row = 0;
	        } else {
	            row--;
	            rowCount += 1;
	        }
	        return new Range(row, col, rowCount, colCount);
	    }
	
	    function removeFormulaSymbolIfExists(expression) {
	        if (isNullOrUndefined(expression)) {
	            return expression;
	        }
	        if (expression.length >= 2 && expression[0] === '=') {
	            return expression.substring(1);
	        } else if (expression === "=") {
	            return "";
	        }
	        return expression;
	    }
	
	    function getMaxOrMinValue(sheet, rank, range, isMax) {
	        if (range.colCount !== 1) {
	            return;
	        }
	        var dataArray = [], data;
	        for (var row = range.row; row < range.row + range.rowCount; row++) {
	            data = getCellData(sheet, row, range.col);
	            if (!isNullOrUndefined(data)) {
	                dataArray.push(data);
	            }
	        }
	        dataArray.sort(function (v1, v2) {
	            return isMax ? (v2 - v1) : (v1 - v2);
	        });
	        return dataArray[rank - 1];
	    }
	
	    function getTop10Filter(sheet, condition, filterRange) {
	        var top10Filter = {filterType: 1 };
	        top10Filter.isBottom = condition.type === 1 ;
	        if (condition.percent) {
	            top10Filter.percent = true;
	        }
	        var rank = condition.expected;
	        if (!isNullOrUndefined(rank)) {
	            top10Filter.value = rank;
	            if (top10Filter.percent) {
	                rank = Math.ceil(filterRange.rowCount % rank / 100.0);
	            }
	            if (!isNullOrUndefined(filterRange)) {
	                top10Filter.filterValue = getMaxOrMinValue(sheet, rank, filterRange, !top10Filter.isBottom);
	            } else {
	                top10Filter.filterValue = NaN;
	            }
	            return top10Filter;
	        }
	    }
	
	    function getAverageFilter(sheet, condition, filterRange) {
	        var dynamicFilter = {filterType: 2 };
	        if (condition.type === 0 ) {
	            dynamicFilter.type = 100;
	        } else if (condition.type === 1 ) {
	            dynamicFilter.type = 101;
	        }
	        if (filterRange === keyword_null) {
	            return keyword_null;
	        }
	        var sum = 0, count = 0;
	        for (var i = 0; i < filterRange.rowCount; i++) {
	            var d = parseFloat(getCellData(sheet, filterRange.row + i, filterRange.col));
	            if (!isNaN(d)) {
	                sum += d;
	                count++;
	            }
	        }
	        if (count > 0) {
	            dynamicFilter.value = sum / count;
	        }
	        return dynamicFilter;
	    }
	
	    function getDateExConditionRange(dateOccurringType) {
	        var currentDate = new Date(), weekday = currentDate.getDay(), currrenDay = currentDate.getDate();
	        var from = new Date(currentDate), to = new Date(currentDate);
	        switch (dateOccurringType) {
	            case 3: 
	                from.setDate(currrenDay - 6);
	                break;
	            case 1: 
	                from.setDate(currrenDay - 1);
	                break;
	            case 0: 
	                break;
	            case 2: 
	                from.setDate(currrenDay + 1);
	                break;
	            case 8: 
	                from.setDate(currrenDay - weekday - 7);
	                to.setDate(currrenDay - weekday - 1);
	                break;
	            case 7: 
	                from.setDate(currrenDay - weekday);
	                to.setDate(currrenDay - weekday + 6);
	                break;
	            case 9: 
	                from.setDate(currrenDay - weekday + 7);
	                to.setDate(currrenDay - weekday + 13);
	                break;
	            case 5: 
	                from.setDate(1);
	                from.setMonth(from.getMonth() - 1);
	                to.setDate(0);
	                break;
	            case 4: 
	                from.setDate(1);
	                to.setMonth(to.getMonth() + 1);
	                to.setDate(0);
	                break;
	            case 6: 
	                from.setDate(1);
	                from.setMonth(from.getMonth() + 1);
	                to.setMonth(to.getMonth() + 2);
	                to.setDate(0);
	                break;
	        }
	        from.setHours(0);
	        from.setMinutes(0);
	        from.setSeconds(0);
	        to.setHours(23);
	        to.setMinutes(59);
	        to.setSeconds(59);
	        return {from: from, to: to};
	    }
	
	    function getDateExFilter(condition) {
	        var expectedType = condition.expected;
	        var dynamicFilter = {filterType: 2 , type: expectedType, conType : condition.conType, expectTypeId : condition.expectTypeId};
	        if (expectedType >= 0 && expectedType <= 15 || expectedType >= 21 && expectedType <= 32) {
	            var conditionRange = getDateExConditionRange(expectedType);
	            if (conditionRange.from && conditionRange.to) {
	                dynamicFilter.value = conditionRange.from;
	                dynamicFilter.maxValue = conditionRange.to;
	            }
	        }else {
	            dynamicFilter.type = -1 ;
	        }
	        return dynamicFilter;
	    }
	
	    function getCellValueFilter(condition) {
	        if (!isNullOrUndefined(condition.compareType)) {
	            var filters = {filterType: 4 };
	            filters.filter1 = {};
	            filters.filter1.operator = condition.compareType;
	            if (!isNullOrUndefined(condition.expected)) {
	                filters.filter1.value = condition.expected;
	            } else {
	                filters.filter1.value = removeFormulaSymbolIfExists(condition.formula);
	            }
	            return filters;
	        }
	    }
	
	    function getTextFilter(condition) {
	        var expectedValue = condition.expected;
	        var op = -1 ;
	        switch (condition.compareType) {
	            case 0: 
	                return {filterType: 3 , filter: [expectedValue]};
	            case 1: 
	                op = 1 ;
	                break;
	            case 2: 
	                expectedValue += "*";
	                break;
	            case 3: 
	                op = 1 ;
	                expectedValue += "*";
	                break;
	            case 4: 
	                expectedValue = "*" + expectedValue;
	                break;
	            case 5: 
	                op = 1 ;
	                expectedValue = "*" + expectedValue;
	                break;
	            case 6: 
	                expectedValue = "*" + expectedValue + "*";
	                break;
	            case 7: 
	                op = 1 ;
	                expectedValue = "*" + expectedValue + "*";
	                break;
	            default:
	                break;
	        }
	        return {filterType: 4 , filter1: {operator: op, value: expectedValue}};
	    }
	
	    function getDateGroupItem(condition, filters) {
	        var expectedTime = new Date(condition.expected);
	        filters.dateGroupItem = filters.dateGroupItem || [];
	        filters.dateGroupItem.push({
	            year: expectedTime.getFullYear(),
	            month: expectedTime.getMonth() + 1,
	            day: expectedTime.getDate(),
	            hour: expectedTime.getHours(),
	            minute: expectedTime.getMinutes(),
	            second: expectedTime.getSeconds(),
	            dateTimeGrouping: 2 
	        });
	    }
	
	    function getDateFilter(condition) {
	        if (condition.compareType === 0 ) {
	            var filters = {filterType: 3 };
	            getDateGroupItem(condition, filters);
	            return filters;
	        }
	        var op = -1 ;
	        switch (condition.compareType) {
	            case 0: 
	                break;
	            case 1: 
	                op = 1 ;
	                break;
	            case 2: 
	                op = 4 ;
	                break;
	            case 3: 
	                op = 5 ;
	                break;
	            case 4: 
	                op = 2 ;
	                break;
	            case 5: 
	                op = 3 ;
	                break;
	            default:
	                break;
	        }
	        if (op !== -1 ) {
	            var formula = getDateConditionFormula(condition);
	            formula = convertToExcelOADate(formula);
	            return {filterType: 4 , filter1: {operator: op, value: formula}};
	        }
	    }
	
	    function expandRelationCondition(relationCondtion) {
	        var result = [], conditions = [];
	        conditions.push(relationCondtion);
	        while (conditions.length > 0) {
	            var cond = conditions.shift();
	            if (cond.conType === 0 ) {
	                var relCond = cond;
	                if (!isNullOrUndefined(relCond.item1)) {
	                    conditions.push(relCond.item1);
	                }
	                if (!isNullOrUndefined(relCond.item2)) {
	                    conditions.push(relCond.item2);
	                }
	            } else {
	                result.push(cond);
	            }
	        }
	        return result;
	    }
	
	    function getTextConditonOperator(compareType) {
	        var op = -1 ;
	        switch (compareType) {
	            case 0: 
	            case 2: 
	            case 4: 
	            case 6: 
	                op = 0 ;
	                break;
	            case 1: 
	            case 3: 
	            case 5: 
	            case 7: 
	                op = 1 ;
	                break;
	            default:
	                op = 0 ;
	                break;
	        }
	        return op;
	    }
	
	    function getTextConditionValue(originalValue, compareType) {
	        switch (compareType) {
	            case 0: 
	            case 1: 
	                return originalValue;
	            case 2: 
	            case 3: 
	                return originalValue.concat("*");
	            case 4: 
	            case 5: 
	                return "*".concat(originalValue);
	            case 6: 
	            case 7: 
	                return "*".concat(originalValue).concat("*");
	            default:
	                return originalValue;
	        }
	    }
	
	    function getCellValueConditionValue(conditions) {
	        var filters = {filterType: 3 , filter: []};
	        conditions.forEach(function (cellValueCondtion) {
	            if (!isNullOrUndefined(cellValueCondtion.expected)) {
	                filters.filter.push(cellValueCondtion.expected);
	            }
	        });
	        return filters;
	    }
	
	    function isAllSpecificCondition(conditionArray, conType) {
	        return conditionArray.every(function (item) {
	            return item.conType === conType;
	        });
	    }
	
	    function getRelationFilter(relationCondtion, sheet, filterRange) {
	        var conditions, filters, op, customFilters;
	        if (relationCondtion.compareType === 0 ) {
	            conditions = expandRelationCondition(relationCondtion);
	            if (isAllSpecificCondition(conditions, 5 )) {
	                filters = {filterType: 3 };
	                conditions.forEach(function (dateCondtion) {
	                    getDateGroupItem(dateCondtion, filters);
	                });
	                return filters;
	            }
	            if (isAllSpecificCondition(conditions, 2 )) {
	                var isCustomFilter = false;
	                if (conditions.length <= 2) {
	                    for (var i = 0; i < conditions.length; i++) {
	                        if (conditions[i].compareType !== 0 ) {
	                            isCustomFilter = true;
	                            break;
	                        }
	                    }
	                }
	                if (isCustomFilter) {
	                    customFilters = {filterType: 4 };
	                    var textCondition = conditions[0];
	                    op = getTextConditonOperator(textCondition.compareType);
	                    customFilters.filter1 = {};
	                    customFilters.filter1.operator = op;
	                    if (!isNullOrUndefined(textCondition.expected)) {
	                        customFilters.filter1.value = getTextConditionValue(textCondition.expected, textCondition.compareType);
	                    } else {
	                        customFilters.filter1.value = removeFormulaSymbolIfExists(textCondition.formula);
	                    }
	                    if (conditions.length === 2) {
	                        textCondition = conditions[1];
	                        op = getTextConditonOperator(textCondition.compareType);
	                        customFilters.filter2 = {};
	                        customFilters.filter2.operator = op;
	                        if (!isNullOrUndefined(textCondition.expected)) {
	                            customFilters.filter2.value = getTextConditionValue(textCondition.expected, textCondition.compareType);
	                        } else {
	                            customFilters.filter2.value = removeFormulaSymbolIfExists(textCondition.formula);
	                        }
	                    }
	                    customFilters.and = false;
	                    return customFilters;
	                }
	                return getCellValueConditionValue(conditions);
	            }
	            if (isAllSpecificCondition(conditions, 11 )) {
	                var isFilters = true;
	                if (conditions.length <= 2) {
	                    isFilters = false;
	                }
	                if (isFilters) {
	                    return getCellValueConditionValue(conditions);
	                } else if (conditions.length > 0) {
	                    var cellValueConditon = conditions[0];
	                    customFilters = {filterType: 4 , filter1: {operator: cellValueConditon.compareType}};
	                    if (!isNullOrUndefined(cellValueConditon.expected)) {
	                        customFilters.filter1.value = cellValueConditon.expected;
	                    } else {
	                        customFilters.filter1.value = removeFormulaSymbolIfExists(cellValueConditon.formula);
	                    }
	                    if (conditions.length === 2) {
	                        cellValueConditon = conditions[1];
	                        customFilters.filter2 = {operator: cellValueConditon.compareType};
	                        if (!isNullOrUndefined(cellValueConditon.expected)) {
	                            customFilters.filter2.value = cellValueConditon.expected;
	                        } else {
	                            customFilters.filter2.value = removeFormulaSymbolIfExists(cellValueConditon.formula);
	                        }
	                    }
	                    customFilters.and = false;
	                    return customFilters;
	                }
	            }
	
	           
	            customFilters = {filterType: 4 , and: false};
	            var tempFilter1 = toExcelFilter(sheet, conditions[0], filterRange);
	            customFilters.filter1 = tempFilter1.filter1;
	           
	            if(conditions.length > 1) {
	                var tempFilter2 = toExcelFilter(sheet, conditions[1], filterRange);
	                customFilters.filter2 = tempFilter2.filter1;
	            }
	            return customFilters;
	
	        } else {
	            conditions = expandRelationCondition(relationCondtion);
	            if (conditions.length === 2) {
	                customFilters = {filterType: 4 };
	                customFilters.and = true;  
	                var filter1 = toExcelFilter(sheet, conditions[0], filterRange);
	                if (!isNullOrUndefined(filter1) && filter1.filter1) {
	                    customFilters.filter1 = filter1.filter1;
	                } else {
	                    return keyword_null;
	                }
	                var filter2 = toExcelFilter(sheet, conditions[1], filterRange);
	                if (!isNullOrUndefined(filter2) && filter2.filter1) {
	                    customFilters.filter2 = filter2.filter1;
	                } else {
	                    return keyword_null;
	                }
	                return customFilters;
	            }
	        }
	    }
	
	    function toExcelFilter(sheet, condition, filterRange) {
	        if (sheet === keyword_null) {
	            return keyword_null;
	        }
	        var conType = condition.conType;
	        if (conType === 3 ) {
	           
	        } else if (conType === 8 ) {
	            return getTop10Filter(sheet, condition, filterRange);
	        } else if (conType === 10 ) {
	            return getAverageFilter(sheet, condition, filterRange);
	        } else if (conType === 6 ) {
	            return getDateExFilter(condition);
	        } else if (conType === 11 || conType === 1) {
	            return getCellValueFilter(condition);
	        } else if (conType === 2 ) {
	            return getTextFilter(condition);
	        } else if (conType === 5 ) {
	            return getDateFilter(condition);
	        } else if (conType === 0 ) {
	            return getRelationFilter(condition, sheet, filterRange);
	        }
	    }
	
	   
	
	   
	    function unpackRelationCondition(condition) {
	        if (isNullOrUndefined(condition)) {
	            return keyword_null;
	        }
	
	        var item1 = keyword_null, item2 = keyword_null;
	        var op = 0 ;
	        if (condition.compareType === 1 ) {
	            op = 6 ;
	        } else {
	            op = 7 ;
	        }
	
	        if (condition.item1) {
	            if (condition.item1.conType === 0 ) {
	                item1 = unpackRelationCondition(condition.item1);
	            } else {
	                item1 = unpackConditionBack(condition.item1);
	            }
	        }
	        if (condition.item2) {
	            if (condition.item2.conType === 0 ) {
	                item2 = unpackRelationCondition(condition.item2);
	            } else {
	                item2 = unpackConditionBack(condition.item2);
	            }
	        }
	        return new Tuple(item1, item2, op);
	    }
	
	    function unpackConditionBack(condition) {
	        if (isNullOrUndefined(condition)) {
	            return;
	        }
	        var conType = condition.conType, op, item1;
	        if (conType === 0 ) {
	            return unpackRelationCondition(condition);
	        } else if (conType === 1 ) { 
	            op = condition.compareType;
	            item1 = condition.formula;
	            if (isNullOrUndefined(item1)) {
	                item1 = condition.expected;
	            }
	            return new Tuple(item1, keyword_null, op);
	        } else if (conType === 7 ) { 
	            op = condition.compareType;
	            item1 = condition.formula;
	            if (isNullOrUndefined(item1)) {
	                item1 = condition.expected;
	            }
	            return new Tuple(item1, keyword_null, op);
	        } else if (conType === 4 ) {
	            return new Tuple(isNullOrUndefined(condition.formula) ? condition.expected : condition.formula, keyword_null, 1 );
	        } else if (conType === 12  || conType === 5 ) {
	            item1 = getDateConditionFormula(condition);
	            return new Tuple(item1, keyword_null, 1 );
	        }
	        return keyword_null;
	    }
	
	    function getFormula(info) {
	        if (info instanceof Tuple) {
	            var complexObject = info;
	            if (!isNullOrUndefined(complexObject.item1)) {
	                return getFormula(complexObject.item1);
	            }
	        } else if (!isNullOrUndefined(info)) {
	            return removeFormulaSymbolIfExists(info.toString());
	        }
	        return '';
	    }
	
	    function toExcelDataValidation(dataValidator, sheetName, sheetNames) {
	        if (isNullOrUndefined(dataValidator)) {
	            return keyword_null;
	        }
	        var unpackedCondition = unpackConditionBack(dataValidator.condition);
	        var firstFormula = keyword_null, secondFormula = keyword_null;
	        if (!isNullOrUndefined(unpackedCondition)) {
	            if (!isNullOrUndefined(unpackedCondition.item1)) {
	                firstFormula = getFormula(unpackedCondition.item1);
	            }
	            if (!isNullOrUndefined(unpackedCondition.item2)) {
	                secondFormula = getFormula(unpackedCondition.item2);
	            }
	        }
	        var result = {};
	        if (isExternalRange(firstFormula, sheetName, sheetNames) || isExternalRange(secondFormula, sheetName, sheetNames)) {
	            result.external = true;
	        }
	        var validatorType = dataValidator.type;
	        result.type = validatorType;
	        result.firstFormula = firstFormula;
	        result.secondFormula = secondFormula;
	        if (validatorType === 4  || validatorType === 5 ) {
	            if (!isNullOrUndefined(result.firstFormula)) {
	                result.firstFormula = convertToExcelOADate(result.firstFormula);
	            }
	            if (!isNullOrUndefined(result.secondFormula)) {
	                result.secondFormula = convertToExcelOADate(result.secondFormula);
	            }
	        }
	
	        result.compareOperator = dataValidator.comparisonOperator;
	        result.allowBlank = dataValidator.ignoreBlank;
	        result.error = dataValidator.errorMessage;
	        result.errorTitle = dataValidator.errorTitle;
	        result.errorStyle = dataValidator.errorStyle;
	        result.prompt = dataValidator.inputMessage;
	        result.showPromptBox = dataValidator.inCellDropdown;
	        result.promptTitle = dataValidator.inputTitle;
	        result.showErrorBox = dataValidator.showErrorMessage;
	        result.showInputMessage = dataValidator.showInputMessage;
	        return result;
	    }
	
	    function getStyleByName(styleName, spread, sheet) {
	        if(sheet._namedStyleCache && sheet._namedStyleCache[styleName]) {
	            return sheet._namedStyleCache[styleName];
	        }
	        var retStyle = StyleHelper._getByName(sheet.namedStyles, styleName);
	        if(retStyle) {
	            addNamedStyleToStyleCache(sheet, styleName, retStyle);
	            return retStyle;
	        }
	        if(spread._namedStyleCache && spread._namedStyleCache[styleName]) {
	            return spread._namedStyleCache[styleName];
	        }
	        retStyle = StyleHelper._getByName(spread.namedStyles, styleName);
	        if(retStyle) {
	            addNamedStyleToStyleCache(spread, styleName, retStyle);
	        }
	        return retStyle;
	    }
	
	    function processDataValidator(validators, retValue, sheetName, sheetNames) {
	        validators.forEach(function (item) {
	            var excelValidator = toExcelDataValidation(item, sheetName, sheetNames);
	            excelValidator.ranges = item.ranges.split(", ").join(" ");
	            retValue.push(excelValidator);
	        });
	    }
	
	   
	
	   
	    var ExcelBorderStyle = {
	        "double": 6,
	        "dotted": 4,
	        "dashed": 3,
	        "solid": 1
	    };
	
	    function getExcelBorderStyle(slicerBorderStyle) {
	        if (!slicerBorderStyle) {
	            return;
	        }
	        var retStyle = {};
	        if (slicerBorderStyle.borderColor) {
	            retStyle.color = slicerBorderStyle.borderColor;
	        }
	        if (slicerBorderStyle.borderStyle) {
	            retStyle.style = ExcelBorderStyle[slicerBorderStyle.borderStyle];
	        }
	        return retStyle;
	    }
	
	    function getExcelSlicerStyle(slicerStyle, isSlicerHeader) {
	        if (!slicerStyle) {
	            return;
	        }
	        for (var prop in slicerStyle) {
	            if (slicerStyle.hasOwnProperty(prop) && prop.indexOf('border') >= 0) {
	                var borderStyle = slicerStyle[prop];
	                if (borderStyle) {
	                    slicerStyle[prop] = getExcelBorderStyle(borderStyle);
	                }
	            }
	        }
	        if (isSlicerHeader) {
	            slicerStyle.isSlicerHeader = true;
	        }
	        return slicerStyle;
	    }
	
	   
	
	    var WriterDataModel = (function () {
	        function WriterDataModel(spread) {
	            var self = this;
	            self._spread = spread;
	            self._namedStyleTable = {};
	
	            self._customerTableStyles = [];
	            self._customerTableStylesCache = {};
	            self._customerSlicerStyles = [];
	            self._customerSlicerStylesCache = {};
	           
	            self._styles = [];
	           
	            self._namedStyles = [];
	            self._workbookCells = {};
	
	            self._stylesForXfidCache = {};
	           
	            self._cellStyleTable = {};
	            self._rowStyleTable = {};
	            self._columnStyleTable = {};
	            self._autoRowHeight = {};
	            self._notEmptyRows = {};
	            self._dxfRecords = [];
	            self._dxfSlicerRecords = [];
	            self._preProcessWorkbook();
	
	           
	            setSheetDefaults(self._spread);
	        }
	
	        function setSheetDefaults(spread) {
	            var sheets = spread.sheets;
	            if (sheets) {
	                for (var sheetName in sheets) {
	                    if (sheets.hasOwnProperty(sheetName)) {
	                        var sheet = sheets[sheetName];
	
	                        sheet.defaults = sheet.defaults || common._getSheetDefaults();
	                    }
	                }
	            }
	        }
	
	        WriterDataModel.prototype._initStyle = function () {
	            var defaultStyle = excelStyle.DefaultStyle._getDefaultStyle(this._spread);
	            this._namedStyleTable['Normal'] = 0;
	            this._styles.push(defaultStyle);
	            this._namedStyles.push(defaultStyle);
	            this._stylesForXfidCache[defaultStyle.name] = this._styles.length - 1;
	        };
	        WriterDataModel.prototype._initCacheCollections = function (sheet) {
	            var sheetIndex = sheet.index;
	            if (!this._workbookCells[sheetIndex]) {
	                this._workbookCells[sheetIndex] = {};
	            }
	
	           
	            if (!this._cellStyleTable[sheetIndex]) {
	                this._cellStyleTable[sheetIndex] = {};
	            }
	            if (!this._rowStyleTable[sheetIndex]) {
	                this._rowStyleTable[sheetIndex] = {};
	            }
	            if (!this._columnStyleTable[sheetIndex]) {
	                this._columnStyleTable[sheetIndex] = {};
	            }
	            if (!this._autoRowHeight[sheetIndex]) {
	                this._autoRowHeight[sheetIndex] = {};
	            }
	        };
	        WriterDataModel.prototype._isCollapsed = function (index, group) {
	            if (!group || !group.itemsData) {
	                return false;
	            }
	            var itemsData = group.itemsData;
	            for (var i = 0, len = itemsData.length; i < len; i++) {
	                var itemData = itemsData[i];
	                if (itemData && itemData.info && itemData.info.collapsed && index < itemData.index + itemData.count - 1) {
	                    var endIndex = itemData.index - 1;
	                    for (var j = i - 1; j >= 0; j--) {
	                        var itemData1 = itemsData[j];
	                        if (itemData1 && itemData1.info && itemData1.info.level > itemData.info.level && itemData1.index + itemData1.count - 1 === endIndex) {
	                            endIndex = itemData1.index - 1;
	                        }
	                    }
	                    if (index > endIndex) {
	                        return true;
	                    }
	                }
	            }
	            return false;
	        };
	        WriterDataModel.prototype._updateFileList = function (types, xFile) {
	            if (!types || !xFile) {
	                return false;
	            }
	            var result = true;
	            if (!StringEx._isNullOrEmpty(xFile.fileName)) {
	                var type = this._convertRelationshipType2ContentType(xFile.fileType);
	                if (!StringEx._isNullOrEmpty(type)) {
	                    var overrideType = new excel._OverrideContentType();
	                    overrideType.partName = xFile.fileName;
	                    overrideType.contentType = type;
	                    var isExist = false;
	                    for (var i = 0, len = types.length; i < len; i++) {
	                        var item = types[i];
	                        if (item instanceof excel._OverrideContentType && item.contentType === overrideType.contentType && item.partName === overrideType.partName) {
	                            isExist = true;
	                            break;
	                        }
	                    }
	                    if (!isExist) {
	                        types.push(overrideType);
	                    }
	                }
	            }
	            if (xFile.relationFiles && xFile.relationFiles.count > 0) {
	                for (var key in xFile.relationFiles) {
	                    if (xFile.relationFiles.hasOwnProperty(key) && key !== 'count') {
	                        result = result && this._updateFileList(types, xFile.relationFiles[key]);
	                    }
	                }
	            }
	            return result;
	        };
	        WriterDataModel.prototype._convertRelationshipType2ContentType = function (relationType) {
	            if (StringEx._isNullOrEmpty(relationType)) {
	                return '';
	            }
	            switch (relationType) {
	                case RelationshipConstants._relationshipSharedStringsType:
	                    return XFileConstants._sharedStringType;
	                case RelationshipConstants._relationshipStylesType:
	                    return XFileConstants._stylesType;
	                case RelationshipConstants._relationshipThemeType:
	                    return XFileConstants._themeType;
	                case RelationshipConstants._relationshipWorkbookType:
	                    return XFileConstants._workbookType;
	                case RelationshipConstants._relationshipWorksheetType:
	                    return XFileConstants._worksheetType;
	                case RelationshipConstants._relationshipExternalLinkType:
	                    return XFileConstants._externalLinkType;
	                case RelationshipConstants._relationshipTableType:
	                    return XFileConstants._tableType;
	                case RelationshipConstants._relationshipCommentType:
	                    return XFileConstants._commentsType;
	                case RelationshipConstants._relationshipDrawingType:
	                    return XFileConstants._drawingType;
	                case RelationshipConstants._relationshipSlicerType:
	                    return XFileConstants._slicerType;
	                case RelationshipConstants._relationshipSlicerCacheType:
	                    return XFileConstants._slicerCacheType;
	                case RelationshipConstants._relationshipChartType:
	                    return XFileConstants._chartType;                
	                case RelationshipConstants._realationshipChartUserShapes:
	                    return XFileConstants._chartShapes;
	                default:
	                    return '';
	            }
	        };
	        WriterDataModel.prototype._preProcessWorkbook = function () {
	            var self = this, spread = self._spread;
	            self._initStyle();
	            self._preProcessNamedStyle();
	
	            for (var sheetName in spread.sheets) {
	                if (spread.sheets.hasOwnProperty(sheetName)) {
	                    var sheet = spread.sheets[sheetName];
	                    if (!sheet) {
	                        continue;
	                    }
	                    self._setDefaultValue(sheet);
	                    self._initCacheCollections(sheet);
	                    self._preProcessCells(sheet);
	                    self._preprocessRowsVisibleInfo(sheet);
	                    self._preprocessColumnVisibleInfo(sheet);
	                    self._preProcessColumnStyles(sheet);
	                    self._preProcessDifferentConditionalFormats(sheet);
	                }
	            }
	        };
	        WriterDataModel.prototype._preProcessDifferentConditionalFormats = function (sheet) {
	            var rules = sheet.conditionalFormats && sheet.conditionalFormats.rules;
	            if (rules) {
	                for (var i = 0; i < rules.length; i++) {
	                    var rule = rules[i];
	                    if (rule.style) {
	                        rule.style.isPartFontStyle = true;
	                        rule.dxfId = this._addDifferentConditionalFormat(rule.style);
	                    }
	                }
	            }
	           
	            sheet._colorFilterColumns = this._getColorFilter(sheet);
	           
	           
	            this._preProcessTableStyle(sheet);
	            this._preProcessSortInfo(sheet);
	           
	            this._preProcessSlicerStyle(sheet);
	        };
	        WriterDataModel.prototype._addDifferentConditionalFormat = function (style) {
	            var self = this;
	            var index = self._dxfRecords.indexOf(style);
	            if (index === -1) {
	                index = self._dxfRecords.length;
	                self._dxfRecords.push(style);
	            }
	            return index;
	        };
	        WriterDataModel.prototype._addDifferentConditionalFormatSlicer = function (style) {
	            var self = this;
	            var index = self._dxfSlicerRecords.indexOf(style);
	            if (index === -1) {
	                index = self._dxfSlicerRecords.length;
	                self._dxfSlicerRecords.push(style);
	            }
	            return index;
	        };
	        function getTableId(tableName, tables) {
	            var tableId = null;
	            tables.forEach(function (table) {
	                if (table.name === tableName) {
	                    tableId = table.id;
	                }
	            });
	            return tableId;
	        }
	        WriterDataModel.prototype._preProcessSlicerStyle = function (sheet) {
	            var self = this;
	            var slicers = sheet.slicers;
	            var tables = self._getTables();
	            if (slicers && slicers.length > 0) {
	                slicers.forEach(function (slicer) {
	                    var slicerTheme = slicer && slicer.style;
	                    if (!isNullOrUndefined(slicerTheme.name)) {
	                        if (!hasThemeExist(self._customerTableStylesCache, slicerTheme)) {
	                            var customerTableStyle = {
	                                styleElements: [],
	                                name: getDifferentStyleName(self._customerTableStylesCache, slicerTheme.name)
	                            };
	                            slicerTheme.name = customerTableStyle.name;
	                            for (var styleType in slicerTheme) {
	                                if (slicerTheme.hasOwnProperty(styleType) && styleType !== 'name' && !isNullOrUndefined(slicerTheme[styleType])) {
	                                    switch (styleType) {
	                                        case 'headerStyle':
	                                        case 'wholeSlicerStyle':
	                                            var styleElement = {};
	                                            styleElement.type = styleType;
	                                            styleElement.dxfId = self._addDifferentConditionalFormat(getExcelSlicerStyle(slicerTheme[styleType], styleType === 'headerStyle'));
	                                            styleElement.tableId = getTableId(slicer.tableName, tables);
	                                            customerTableStyle.styleElements.push(styleElement);
	                                    }
	                                }
	                            }
	                            self._customerTableStyles.push(customerTableStyle);
	                        }
	                        if (!hasThemeExist(self._customerSlicerStylesCache, slicerTheme)) {
	                            var customerSlicerStyle = {
	                                styleElements: [],
	                                name: getDifferentStyleName(self._customerTableStylesCache, slicerTheme.name)
	                            };
	                            slicerTheme.name = customerTableStyle.name;
	                            for (var type in slicerTheme) {
	                                if (slicerTheme.hasOwnProperty(type) && type !== 'name' && !isNullOrUndefined(slicerTheme[type])) {
	                                    switch (type) {
	                                        case "selectedItemWithDataStyle":
	                                        case "selectedItemWithNoDataStyle":
	                                        case "unSelectedItemWithDataStyle":
	                                        case "unSelectedItemWithNoDataStyle":
	                                        case "hoveredSelectedItemWithDataStyle":
	                                        case "hoveredSelectedItemWithNoDataStyle":
	                                        case "hoveredUnSelectedItemWithDataStyle":
	                                        case "hoveredUnSelectedItemWithNoDataStyle":
	                                            customerSlicerStyle.styleElements.push({
	                                                type: type,
	                                                dxfId: self._addDifferentConditionalFormatSlicer(getExcelSlicerStyle(slicerTheme[type]))
	                                            });
	                                            break;
	                                    }
	                                }
	                            }
	                            self._customerSlicerStyles.push(customerSlicerStyle);
	                            self._customerSlicerStylesCache[customerSlicerStyle.name] = slicerTheme;
	                        }
	                    }
	                });
	            }
	        };
	        WriterDataModel.prototype._preProcessTableStyle = function (sheet) {
	            var self = this;
	            var tables = sheet.tables;
	            if (tables && tables.length > 0) {
	                tables.forEach(function (sheetTable) {
	                    var tableTheme = sheetTable && sheetTable.style;
	                    if (!isNullOrUndefined(tableTheme && tableTheme.name)) {
	                        if (hasThemeExist(self._customerTableStylesCache, tableTheme)) {
	                            return;
	                        }
	                        var customerTableStyle = {styleElements: []};
	                        customerTableStyle.name = getDifferentStyleName(self._customerTableStylesCache, tableTheme.name);
	                        tableTheme.name = customerTableStyle.name;
	                        var firstRowStripSize, secondRowStripSize, firstColumnStripSize, secondColumnStripSize;
	                        for (var styleType in tableTheme) {
	                            if (tableTheme.hasOwnProperty(styleType) && styleType !== 'name' && tableTheme[styleType] !== undefined) {
	                                switch (styleType) {
	                                    case 'firstRowStripSize':
	                                        firstRowStripSize = tableTheme[styleType];
	                                        break;
	                                    case 'secondRowStripSize':
	                                        secondRowStripSize = tableTheme[styleType];
	                                        break;
	                                    case 'firstColumnStripSize':
	                                        firstColumnStripSize = tableTheme[styleType];
	                                        break;
	                                    case 'secondColumnStripSize':
	                                        secondColumnStripSize = tableTheme[styleType];
	                                        break;
	                                    default:
	                                        var styleElement = {};
	                                        styleElement.type = styleType;
	                                        tableTheme[styleType].isPartFontStyle = true;
	                                        styleElement.dxfId = self._addDifferentConditionalFormat(tableTheme[styleType]);
	                                        customerTableStyle.styleElements.push(styleElement);
	                                }
	                            }
	                        }
	                        setStripSizeByName(customerTableStyle, 'firstRowStripStyle', firstRowStripSize || 1);
	
	                        setStripSizeByName(customerTableStyle, 'secondRowStripStyle', secondRowStripSize || 1);
	
	                        setStripSizeByName(customerTableStyle, 'firstColumnStripStyle', firstColumnStripSize || 1);
	
	                        setStripSizeByName(customerTableStyle, 'secondColumnStripStyle', secondColumnStripSize || 1);
	
	                        self._customerTableStyles.push(customerTableStyle);
	                        self._customerTableStylesCache[customerTableStyle.name] = tableTheme;
	                    }
	                });
	            }
	        };
	        WriterDataModel.prototype._preProcessSortInfo = function (sheet) {
	            var tables = sheet.tables, len = tables ? tables.length : 0, tableSortInfo = {};
	            for( var i = 0; i < len; i++) {
	                tables[i].tableSortInfo = this._getSortInfo(tables[i].rowFilter);
	            }
	            sheet._tableSortInfo = tableSortInfo;
	            if(sheet.rowFilter) {
	                sheet.rowFilter.autoFilterSortInfo = this._getSortInfo(sheet.rowFilter);
	            }
	        };
	        WriterDataModel.prototype._preprocessRowsVisibleInfo = function (sheet) {
	            var self = this, rows = sheet.rows, defaultRowHeight = getSheetDefaultRowHeight(sheet);
	            sheet.rowsVisibleInfo = {};
	            for (var row = 0; row < sheet.rowCount; row++) {
	                sheet.rowsVisibleInfo[row] = {};
	                sheet.rowsVisibleInfo[row].size = rows && rows[row] && rows[row].size || defaultRowHeight;
	                sheet.rowsVisibleInfo[row].visible = self._getRowVisibleInfo(sheet, row);
	            }
	
	        };
	        WriterDataModel.prototype._preprocessColumnVisibleInfo = function (sheet) {
	            var self = this, columns = sheet.columns, defaultColumnWidth = getSheetDefaultColumnWidth(sheet),
	                colRangeGroup = sheet.columnOutlines;
	            sheet.columnVisibleInfo = {};
	            for (var col = 0; col < sheet.columnCount; col++) {
	                sheet.columnVisibleInfo[col] = {};
	                var column = columns && columns[col];
	                sheet.columnVisibleInfo[col].size = column && column.size || defaultColumnWidth;
	                if (column && column.visible === false) {
	                    sheet.columnVisibleInfo[col].visible = false;
	                }
	                if (self._isCollapsed(col, colRangeGroup)) {
	                    sheet.columnVisibleInfo[col].visible = false;
	                }
	            }
	        };
	
	        function setStripSizeByName(customerTableStyle, name, size) {
	            for (var i = 0; i < customerTableStyle.styleElements.length; i++) {
	                if (customerTableStyle.styleElements[i].type === name) {
	                    customerTableStyle.styleElements[i].size = size;
	                }
	            }
	        }
	
	        function isTableStyleEqual(tableStyle1, tableStyle2) {
	            return isEqualObject(tableStyle1, tableStyle2, isBorderEqual);
	        }
	
	        function hasThemeExist(stylesCache, tableStyle) {
	            return stylesCache[tableStyle.name] &&
	                isEqualObject(stylesCache[tableStyle.name], tableStyle, isTableStyleEqual);
	        }
	
	        function getDifferentStyleName(stylesCache, name) {
	            var diffName = name, index = 1;
	            while (stylesCache[diffName]) {
	                diffName = name + '_' + index;
	                index++;
	            }
	            return diffName;
	        }
	
	
	        WriterDataModel.prototype._setDefaultValue = function (sheet) {
	            if (sheet.rowCount === keyword_undefined) {
	                sheet.rowCount = 200;
	            }
	            if (sheet.columnCount === keyword_undefined) {
	                sheet.columnCount = 20;
	            }
	            if (sheet.activeRow === keyword_undefined) {
	                sheet.activeRow = 0;
	            }
	            if (sheet.activeCol === keyword_undefined) {
	                sheet.activeCol = 0;
	            }
	            if (sheet.visible === keyword_undefined) {
	                sheet.visible = true;
	            }
	        };
	        WriterDataModel.prototype._preProcessColumnStyles = function (sheet) {
	            var sheetIndex = sheet.index, columnStyleTable = this._columnStyleTable[sheetIndex],
	                columnCount = sheet.columnCount;
	            for (var col = 0; col < columnCount; col++) {
	                var styleObject = this._getStyleObject(sheet, -1, col);
	                var columnStyleName = getActualStyleName(this._spread, styleObject);
	
	                if (!StringEx._isNullOrEmpty(columnStyleName)) {
	                    if (this._namedStyleTable[columnStyleName] !== keyword_undefined) {
	                        columnStyleTable[col] = this._namedStyleTable[columnStyleName];
	                    }
	                } else if (styleObject) {
	                    var columnStyle = styleObject;
	                    if (columnStyle.parentName) {
	                        columnStyle = ConverterHelper.cloneSpreadJSStyle(columnStyle);
	                        var parentStyle = getStyleByName(columnStyle.parentName, this._spread, sheet);
	                        StyleHelper._composeStyle(columnStyle, parentStyle);
	                    }
	                    columnStyleTable[col] = this._getStyleIndex(columnStyle);
	                }
	            }
	        };
	        WriterDataModel.prototype._preProcessCells = function (sheet) {
	            var self = this, sheetIndex = sheet.index, dataTable = sheet.data && sheet.data.dataTable;
	            if (sheet.rowCount === 0) {
	                return;
	            }
	           
	            var columnCount = self._getLastNonNullColumn(dataTable, sheet) + 1;
	            var cellStyleTable = self._cellStyleTable[sheetIndex], rowStyleTable = self._rowStyleTable[sheetIndex];
	            var columnStyles = self._getColumnStyleInfos(sheet, columnCount),
	                columnNamedStyles = self._getColumnNamedStyleInfos(sheet, columnCount),
	                sheetRowAutoHeightCollection = self._autoRowHeight[sheetIndex];
	            var maxRow = self._getCurrentSheetMaxUsedRowIndex(sheet);
	            var defaultRowHeight = 57;
	            for (var row = 0; row <= maxRow && row >= 0; row++) {
	                var currentRowStyleName = keyword_null, currentRowStyle = keyword_null, maxRowHeight = defaultRowHeight;
	                var rowStyleObject = self._processRowStyle(sheet, rowStyleTable, row);
	                if (isString(rowStyleObject)) {
	                    currentRowStyleName = rowStyleObject;
	                } else if (rowStyleObject) {
	                    currentRowStyle = rowStyleObject;
	                }
	                for (var column = 0; column < columnCount && column >= 0; column++) {
	                    var styleKey = row * columnCount + column;
	                    var styleInfo, styleName, value = keyword_null, formula = keyword_null, arrayInfo = keyword_null, 
	                        cellData = dataTable && dataTable[row] && dataTable[row][column];
	                    if (cellData) {
	                        if (!isObject(cellData.value)) {
	                            value = cellData.value;
	                        }
	                        formula = cellData.formula;
	                        arrayInfo = cellData.arrayInfo;
	                    }
	                   
	                    var isInTable = false;
	                    var table = findTable(sheet, row, column);
	                    if (table) {
	                        isInTable = true;
	                        var span = findSpan(sheet, row, column);
	                        if (span) {
	                            removeSpan(sheet, span);
	                        }
	                    }
	                    var ret = self._getCellStyle(sheet, row, column, cellStyleTable, columnNamedStyles[column], columnStyles[column], currentRowStyleName, currentRowStyle, styleKey, value);
	                    styleName = ret.styleName;
	                    styleInfo = ret.styleInfo;
	                    if (isInTable) {
	                        if (table.showHeader !== false && row === table.row) {
	                            value = table.columns[column - table.col] && table.columns[column - table.col].name;
	                        }
	                        if (table.showFooter && row === table.row + table.rowCount - 1) {
	                            value = table.columns[column - table.col] && table.columns[column - table.col].footerValue;
	                        }
	                    }
	                    var ret1 = self._getRealCellValueForExcel(value);
	                    var cellValue = ret1.value;
	                    cellValue = convertToExcelOADate(cellValue);
	                    var cellType = ret1.cellType;
	                    if (styleInfo || formula || cellValue !== keyword_null || !StringEx._isNullOrEmpty(styleName)) {
	                        var cell = new excel._ExcelCell(row, column);
	                        cell.cellType = cellType;
	                        cell.value = cellValue;
	                        self._setCellStyle(cellStyleTable, styleKey, styleInfo, styleName, cell);
	                        self._setCellFormula(formula, arrayInfo, cell);
	                        self._addCellToCache(sheetIndex, row, cell);
	                    }
	                }
	                sheetRowAutoHeightCollection[row] = maxRowHeight;
	            }
	        };
	
	        function findTable(sheet, row, col) {
	            var table;
	            var tables = sheet.tables || [];
	            tables.every(function (sheetTable) {
	                if (sheetTable.row <= row && row <= sheetTable.row + sheetTable.rowCount - 1 && sheetTable.col <= col && col <= sheetTable.col + sheetTable.colCount - 1) {
	                    table = sheetTable;
	                    return false;
	                }
	                return true;
	            });
	            return table;
	        }
	
	        function findSpan(sheet, row, col) {
	            var span;
	            var spans = sheet.spans || [];
	            spans.every(function (tempSpan) {
	                if (tempSpan.row <= row && row <= tempSpan.row + tempSpan.rowCount - 1 && tempSpan.col <= col && col <= tempSpan.col + tempSpan.colCount - 1) {
	                    span = tempSpan;
	                    return false;
	                }
	                return true;
	            });
	            return span;
	        }
	
	        function removeSpan(sheet, span) {
	            var spans = sheet.spans || [];
	            for (var i = 0; i < spans.length; i++) {
	                if (span.row === spans[i].row && span.col === spans[i].col) {
	                    spans.splice(i, 1);
	                    break;
	                }
	            }
	        }
	
	        WriterDataModel.prototype._getCurrentSheetMaxUsedRowIndex = function (sheet) {
	            var notEmptyRows = this._getNotEmptyRows(sheet);
	            return Math.min(sheet.rowCount - 1, notEmptyRows.length > 0 ? notEmptyRows.length : 0);
	        };
	        WriterDataModel.prototype._processRowStyle = function (sheet, rowStyleTable, row) {
	            var styleObject = this._getStyleObject(sheet, row, -1);
	            var rowStyleName = getActualStyleName(this._spread, styleObject),
	                rowStyleObject = rowStyleName;
	
	           
	            if (!StringEx._isNullOrEmpty(rowStyleName)) {
	                if (this._namedStyleTable[rowStyleName] !== undefined) {
	                    rowStyleTable[row] = this._namedStyleTable[rowStyleName];
	                }
	            } else {
	                var rowStyle = this._getStyleInfo(sheet, row, -1);
	                rowStyleObject = rowStyle;
	                if (rowStyle) {
	                    if (rowStyle.parentName) {
	                        rowStyle = ConverterHelper.cloneSpreadJSStyle(rowStyle);
	                        var parentStyle = getStyleByName(rowStyle.parentName, this._spread, sheet);
	                        StyleHelper._composeStyle(rowStyle, parentStyle);
	                    }
	                    rowStyleTable[row] = this._getStyleIndex(rowStyle);
	                }
	            }
	            return rowStyleObject;
	        };
	        WriterDataModel.prototype._preProcessNamedStyle = function () {
	            var self = this, spread = self._spread, processedNamesStyle = {}, fakeNamedStyles = [];
	            processedNamesStyle['Normal'] = {};
	            var sheets = spread.sheets;
	            for (var sheetName in sheets) {
	                if (sheets.hasOwnProperty(sheetName)) {
	                    self._preProcessNamedStyles(sheets[sheetName].namedStyles, processedNamesStyle, fakeNamedStyles);
	                }
	            }
	           
	            self._preProcessNamedStyles(spread.namedStyles, processedNamesStyle, fakeNamedStyles);
	            var builtInStyles = excelStyle.BuiltInExcelStyles.getBuiltInStyles();
	            var builtInStyleCollection = [];
	            for (var i = 0, len = builtInStyles.length; i < len; i++) {
	                var item = builtInStyles[i];
	                var styleInfo = ConverterHelper.toCellStyle(item.format());
	                styleInfo.name = item.name;
	                builtInStyleCollection.push(styleInfo);
	            }
	            this._preProcessNamedStyles(builtInStyleCollection, processedNamesStyle, fakeNamedStyles);
	           
	            var style;
	            for (i = 0, len = self._namedStyles.length; i < len; i++) {
	                style = self._namedStyles[i];
	                if (style && style.parentName) {
	                    StyleHelper._setActualStyle(self._namedStyles, style);
	                }
	            }
	           
	            for (i = 0, len = self._styles.length; i < len; i++) {
	                style = self._styles[i];
	                var newStyle = ConverterHelper.cloneSpreadJSStyle(style);
	                newStyle.parentName = style.name;
	                newStyle.name = '';
	                self._namedStyleTable[style.name] = self._styles.length;
	                self._styles.push(newStyle);
	                var foundStyle = getEqualStyle(style, fakeNamedStyles);
	                if (foundStyle) {
	                    self._namedStyleTable[foundStyle.name] = self._namedStyleTable[style.name];
	                    foundStyle.added = true;
	                }
	            }
	           
	            var normalStyle = StyleHelper._getByName(spread.namedStyles, 'Normal');
	            for (i = 0, len = fakeNamedStyles.length; i < len; i++) {
	                var fakeStyle = fakeNamedStyles[i];
	               
	                if (!fakeStyle.added) {
	                    if (isCommunityBuyeStyleInfo(fakeStyle, normalStyle)) {
	                        self._namedStyleTable[fakeStyle.name] = 0;     
	                    } else {
	                        self._namedStyleTable[fakeStyle.name] = self._styles.length;
	                        self._styles.push(fakeStyle);
	                    }
	                }
	            }
	        };
	        WriterDataModel.prototype._preProcessNamedStyles = function (namedStyles, processedNamesStyle, fakeNamedStyles) {
	            if (!namedStyles) {
	                return;
	            }
	            for (var i = 0, len = namedStyles.length; i < len; i++) {
	                var namedStyle = namedStyles[i], styleName = namedStyle.name;
	                if (!processedNamesStyle[styleName]) {
	                    processedNamesStyle[styleName] = {};
	                   
	                    if (!isBuiltInValidatorStyle(styleName) && !isBuiltInTableStyle(styleName)) {
	                        if (styleName.substring(0, 14) === const_builtInStyle) {
	                            fakeNamedStyles.push(namedStyle);
	                        } else {
	                            this._styles.push(namedStyle);
	                            this._namedStyles.push(namedStyle);
	                            this._stylesForXfidCache[namedStyle.name] = this._styles.length - 1;
	                        }
	                    }
	                }
	            }
	        };
	        WriterDataModel.prototype._getStyleObject = function (sheet, row, col) {
	            var data = sheet.data, style = keyword_null;
	            if (!data) {
	                return keyword_null;
	            }
	            if (row < 0 && col >= 0) {
	                style = (data.columnDataArray && data.columnDataArray[col]) ? data.columnDataArray[col].style : keyword_null;
	            } else if (row >= 0 && col < 0) {
	                style = (data.rowDataArray && data.rowDataArray[row]) ? data.rowDataArray[row].style : keyword_null;
	            } else if (row >= 0 && col >= 0) {
	                style = (data.dataTable && data.dataTable[row] && data.dataTable[row][col]) ? sheet.data.dataTable[row][col].style : keyword_null;
	            }
	            return style;
	        };
	        WriterDataModel.prototype._getStyleInfo = function (sheet, row, col) {
	            var style = this._getStyleObject(sheet, row, col);
	            if (isString(style)) {
	                var styleName = style, tempStyle;
	                var spread = this._spread;
	                if (sheet.namedStyles) {
	                    if(sheet._namedStyleCache && sheet._namedStyleCache[styleName]) {
	                        return sheet._namedStyleCache[styleName];
	                    }
	                    tempStyle = StyleHelper._getByName(sheet.namedStyles, style);
	                    if(tempStyle) {
	                        addNamedStyleToStyleCache(sheet, styleName, tempStyle);
	                    }
	                    return tempStyle;
	                } else if (spread.namedStyles) {
	                    if(spread._namedStyleCache && spread._namedStyleCache[styleName]) {
	                        return spread._namedStyleCache[styleName];
	                    }
	                    tempStyle = StyleHelper._getByName(this._spread.namedStyles, style);
	                    if(tempStyle) {
	                        addNamedStyleToStyleCache(spread, styleName, tempStyle);
	                    }
	                    return tempStyle;
	                }
	            }
	            return style;
	        };
	        WriterDataModel.prototype._getTheme = function () {
	            var spread = this._spread, theme = keyword_null;
	            for (var sheetName in spread.sheets) {
	                if (spread.sheets.hasOwnProperty(sheetName)) {
	                    var sheet = spread.sheets[sheetName];
	                    if (sheet && sheet.theme) {
	                        theme = sheet.theme;
	                        break;
	                    }
	                }
	            }
	            if (!theme) {
	                return keyword_null;
	            }
	            if (isString(theme)) {
	                return theme;
	            }
	            var themeName = theme.name;
	            if (StringEx._isNullOrWhiteSpace(themeName)) {
	                return keyword_null;
	            }
	            if (themeName.toUpperCase() === 'OFFICE') {
	                themeName = 'Office Theme';
	            }
	            return new excel._ExcelTheme(themeName, this._getThemeColorScheme(theme), this._getFontScheme(theme));
	        };
	        WriterDataModel.prototype._getThemeColorScheme = function (theme) {
	            var colors = [];
	            colors.push(fromColorToExcelColor(theme.themeColor.background1));
	            colors.push(fromColorToExcelColor(theme.themeColor.text1));
	            colors.push(fromColorToExcelColor(theme.themeColor.background2));
	            colors.push(fromColorToExcelColor(theme.themeColor.text2));
	            colors.push(fromColorToExcelColor(theme.themeColor.accent1));
	            colors.push(fromColorToExcelColor(theme.themeColor.accent2));
	            colors.push(fromColorToExcelColor(theme.themeColor.accent3));
	            colors.push(fromColorToExcelColor(theme.themeColor.accent4));
	            colors.push(fromColorToExcelColor(theme.themeColor.accent5));
	            colors.push(fromColorToExcelColor(theme.themeColor.accent6));
	            colors.push(fromColorToExcelColor(theme.themeColor.hyperlink));
	            colors.push(fromColorToExcelColor(theme.themeColor.followedHyperlink));
	            return new excel._ColorScheme(theme.themeColor.name, colors);
	        };
	        WriterDataModel.prototype._getFontScheme = function (theme) {
	            var majorFonts = new excel._ThemeFonts([new excel._RunFormatting(0 , theme.headingFont)], []);
	            var minorFonts = new excel._ThemeFonts([new excel._RunFormatting(0 , theme.bodyFont)], []);
	            return new excel._FontScheme(theme.name, majorFonts, minorFonts);
	        };
	        WriterDataModel.prototype._getColumnIndexInA1LetterForm = function (column) {
	            column = Math.min(column, ExcelConstants._openXmlMaxColumn);
	            return IndexHelper._getColumnIndexInA1Letter(column);
	        };
	        WriterDataModel.prototype._getContentTypes = function (rootVirtualFile, withVmlDrawingFiles) {
	            var types = [];
	            var defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._binExtension;
	            defaultType.contentType = XFileConstants._binType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._relsExtension;
	            defaultType.contentType = XFileConstants._relsType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._xmlExtension;
	            defaultType.contentType = XFileConstants._xmlType;
	            types.push(defaultType);
	            if (withVmlDrawingFiles) {
	                defaultType = new excel._DefaultContentType();
	                defaultType.extension = XFileConstants._vmlExtension;
	                defaultType.contentType = XFileConstants._vmlDrawingsType;
	                types.push(defaultType);
	            }
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._jpgExtension;
	            defaultType.contentType = XFileConstants._jpgType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._jpegExtension;
	            defaultType.contentType = XFileConstants._jpegType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._pngExtension;
	            defaultType.contentType = XFileConstants._pngType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._bmpExtension;
	            defaultType.contentType = XFileConstants._bmpType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._gifExtension;
	            defaultType.contentType = XFileConstants._gifType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._emfExtension;
	            defaultType.contentType = XFileConstants._emfType;
	            types.push(defaultType);
	            defaultType = new excel._DefaultContentType();
	            defaultType.extension = XFileConstants._wmfExtension;
	            defaultType.contentType = XFileConstants._wmfType;
	            types.push(defaultType);
	            var result = this._updateFileList(types, rootVirtualFile);
	            if (!result) {
	                return keyword_null;
	            }
	            return types;
	        };
	        WriterDataModel.prototype._getCells = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return this._workbookCells[sheet.index];
	        };
	        WriterDataModel.prototype._getNonEmptyRows = function (sheetName) {
	            var self = this, result = [], spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var notEmptyRows = self._getNotEmptyRows(sheet), maxRow = Math.min(sheet.rowCount - 1, notEmptyRows.length);
	            var maxRowRangeLevel = self._getMaxLevel(sheet.rowOutlines);
	            for (var row = 0; row <= maxRow; row++) {
	                if (notEmptyRows[row]) {
	                    var excelRow = self._getRow(sheet, row, maxRowRangeLevel);
	                    if (excelRow || excelRow.collapsed ||
	                        (!isNullOrUndefined(excelRow.outLineLevel) && excelRow.outLineLevel !== 0) ||
	                        excelRow.visible === false || excelRow.formatId >= 0) {
	                        excelRow.customHeight = !isNaN(excelRow.height);
	                        result.push(excelRow);
	                    }
	                } else if (sheet.rowFilter && self._isRowFilteredOut(sheet.rowFilter, row)) {   
	                    excelRow = new excel._ExcelRow(row);
	                    excelRow.visible = false;
	                    result.push(excelRow);
	                }
	            }
	            return result;
	        };
	        WriterDataModel.prototype._isRowFilteredOut = function (rowFilter, row) {
	            var result = false;
	            if (rowFilter) {
	                var filteredOutRows = rowFilter.filteredOutRows;
	                if (filteredOutRows) {
	                    for (var i = 0; i < filteredOutRows.length; i++) {
	                        var rowItem = filteredOutRows[i];
	                        if (row === rowItem) {
	                            result = true;
	                            break;
	                        }
	                    }
	                }
	            }
	            return result;
	        };
	        WriterDataModel.prototype._getRowVisibleInfo = function (sheet, row) {
	            var self = this, rows = sheet.rows, rowRangeGroup = sheet.rowOutlines;
	            if (rows && rows[row] && rows[row].visible === false) {
	                return false;
	            }
	            if (self._isCollapsed(row, rowRangeGroup)) {
	                return false;
	            }
	            var rowFilter = sheet.rowFilter;
	            if (rowFilter && row > 0 && self._isRowFilteredOut(rowFilter, row)) {
	                return false;
	            }
	            var tables = sheet.tables;
	            if (tables) {
	                for (var i = 0; i < tables.length; i++) {
	                    var table = tables[i];
	                    if (self._isRowFilteredOut(table.rowFilter, row)) {
	                        return false;
	                    }
	                }
	            }
	            return true;
	        };
	        WriterDataModel.prototype._getRow = function (sheet, row, rowRangeGroupMaxLevel) {
	            var self = this;
	            var result = new excel._ExcelRow(row), rowRangeGroup = sheet.rowOutlines,
	                sheetRow = sheet.rows && sheet.rows[row];
	            result.height = UnitHelper.pixelToPoint(sheetRow && sheetRow.size !== undefined ? sheetRow.size : getSheetDefaultRowHeight(sheet));
	
	           
	            if (rowRangeGroupMaxLevel >= 0) {
	                result.collapsed = this._getCollapsed(row, rowRangeGroup);
	                var outLineLevel = this._getLevelInternal(row, rowRangeGroup);
	                result.outLineLevel = outLineLevel === -1 ? 0 : outLineLevel;
	            }
	            if (row < sheet.rowCount) {
	                result.visible = self._getRowVisibleInfo(sheet, row);
	            }
	            if (!isNullOrUndefined(this._rowStyleTable[sheet.index])) {
	                var formatId = this._rowStyleTable[sheet.index][row];
	                result.formatId = isNullOrUndefined(formatId) ? -1 : formatId;
	            }
	            return result;
	        };
	        WriterDataModel.prototype._getNotEmptyRows = function (sheet) {
	            var result = this._notEmptyRows[sheet.index];
	            if (result !== undefined) {
	                return result;
	            }
	            result = [];
	            var rows = sheet.rows, rowDataArray = sheet.data && sheet.data.rowDataArray,
	                dataTable = sheet.data && sheet.data.dataTable;
	            if (rows) {
	                for (var i = 0, len = rows.length; i < len; i++) {
	                    if (rows[i]) {
	                        result[i] = true;
	                    }
	                }
	            }
	            if (rowDataArray) {
	                for (i = 0, len = rowDataArray.length; i < len; i++) {
	                    if (rowDataArray[i]) {
	                        result[i] = true;
	                    }
	                }
	            }
	            if (dataTable) {
	                for (var row in dataTable) {
	                    if (dataTable[row] && dataTable.hasOwnProperty(row)) {
	                        result[row] = true;
	                    }
	                }
	            }
	           
	            var tables = sheet.tables;
	            if (tables) {
	                tables.forEach(function (sheetTable) {
	                    var start = sheetTable.row;
	                    var end = sheetTable.row + sheetTable.rowCount;
	                    for (i = start; i < end; i++) {
	                        result[i] = true;
	                    }
	                });
	            }
	
	            var spans = sheet.spans;
	            if (spans) {
	                len = spans.length;
	                for (var index = 0; index < len; index++) {
	                    var span = spans[index];
	                    for (var rowIndex = span.row; rowIndex < span.row + span.rowCount; rowIndex++) {
	                        result[rowIndex] = true;
	                    }
	                }
	            }
	            var itemsData = sheet.rowOutlines && sheet.rowOutlines.itemsData;
	            if (itemsData) {
	                for (i = 0, len = itemsData.length; i < len; i++) {
	                    var item = itemsData[i];
	                    for (row = item.index; row < item.index + item.count; row++) {
	                        result[row] = true;
	                    }
	                }
	            }
	            this._notEmptyRows[sheet.index] = result;
	            return result;
	        };
	        WriterDataModel.prototype._getNonEmptyColumns = function (sheetName) {
	            var result = [], spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var maxLevel = this._getMaxLevel(sheet.columnOutlines), columnCount = sheet.columnCount;
	            for (var column = 0; column < columnCount; column++) {
	                var excelColumn = this._getColumn(sheet, column, maxLevel);
	                if (excelColumn &&
	                    (Math.abs(excelColumn.width - this._getDefaultColumnWidth(sheetName)) > 0.0001 ||
	                        excelColumn.collapsed ||
	                        (excelColumn.outLineLevel !== undefined && excelColumn.outLineLevel !== keyword_null && excelColumn.outLineLevel !== 0) ||
	                        excelColumn.visible === false || excelColumn.formatId >= 0)) {
	                    result.push(excelColumn);
	                }
	            }
	            return result;
	        };
	        WriterDataModel.prototype._getLevelInternal = function (index, group) {
	            if (!group || !group.itemsData) {
	                return 0;
	            }
	            var itemsData = group.itemsData;
	            for (var i = 0, len = itemsData.length; i < len; i++) {
	                var itemData = itemsData[i];
	                if (index >= itemData.index && index < itemData.index + itemData.count) {
	                    return itemData.info ? itemData.info.level + 1 : 1;
	                }
	            }
	            return 0;
	        };
	        WriterDataModel.prototype._getCollapsed = function (index, group) {
	            if (!group || !group.itemsData) {
	                return false;
	            }
	            var itemsData = group.itemsData;
	            for (var i = 0, len = itemsData.length; i < len; i++) {
	                var itemData = itemsData[i];
	                if (index >= itemData.index && index < itemData.index + itemData.count) {
	                    return itemData.info ? !!itemData.info.collapsed : false;
	                }
	            }
	            return false;
	        };
	        WriterDataModel.prototype._getColumn = function (sheet, column, columnRangeGroupMaxLevel) {
	            var result = new excel._ExcelColumn(column), colRangeGroup = sheet.columnOutlines,
	                sheetColumn = sheet.columns && sheet.columns[column];
	            result.width = this.calcColumnWidth(sheetColumn && sheetColumn.size !== undefined ? sheetColumn.size : getSheetDefaultColumnWidth(sheet));
	            if (columnRangeGroupMaxLevel >= 0 && column < sheet.columnCount) {
	                result.collapsed = this._getCollapsed(column, colRangeGroup);
	                var outLineLevel = this._getLevelInternal(column, colRangeGroup);
	                result.outLineLevel = outLineLevel === -1 ? 0 : outLineLevel;
	            }
	            if (column < sheet.columnCount) {
	                if (sheetColumn && sheetColumn.visible === false) {
	                    result.visible = false;
	                }
	                if (this._isCollapsed(column, colRangeGroup)) {
	                    result.visible = false;
	                }
	            }
	            if (!isNullOrUndefined(this._columnStyleTable[sheet.index])) {
	                var formatId = this._columnStyleTable[sheet.index][column];
	                result.formatId = isNullOrUndefined(formatId) ? -1 : formatId;
	            }
	            return result;
	        };
	        WriterDataModel.prototype._getMaxLevel = function (group) {
	            if (!group || !group.itemsData) {
	                return -1;
	            }
	            var maxRowLevel = -1;
	            for (var i = 0, len = group.itemsData.length; i < len; i++) {
	                var itemsData = group.itemsData[i];
	                if (itemsData.info && itemsData.info.level > maxRowLevel) {
	                    maxRowLevel = itemsData.info.level;
	                }
	            }
	            return maxRowLevel;
	        };
	        WriterDataModel.prototype._getGutters = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var rowMaxOutLineLevel = 0, columnMaxOutLineLevel = 0;
	            var maxRowLevel = -1, rowRangeGroup = sheet.rowOutlines;
	            if (rowRangeGroup) {
	                maxRowLevel = this._getMaxLevel(rowRangeGroup);
	            }
	            if (maxRowLevel !== -1) {
	                rowMaxOutLineLevel = maxRowLevel + 2;
	            }
	            var maxColumnLevel = -1, colRangeGroup = sheet.columnOutlines;
	            if (colRangeGroup) {
	                maxColumnLevel = this._getMaxLevel(colRangeGroup);
	            }
	            if (maxColumnLevel !== -1) {
	                columnMaxOutLineLevel = maxColumnLevel + 2;
	            }
	            return {
	                outlineLevelRow: rowMaxOutLineLevel,
	                outlineLevelColumn: columnMaxOutLineLevel
	            };
	        };
	        WriterDataModel.prototype._getDefaultRowHeight = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var height = UnitHelper.pixelToPoint(sheet.defaults ? sheet.defaults.rowHeight : getSheetDefaultRowHeight(sheet));
	            var customHeight = false;
	            var calculatedHeight = 57;
	            customHeight = Math.abs(calculatedHeight - height) >= 2;
	            return {
	                height: height,
	                customHeight: customHeight
	            };
	        };
	        WriterDataModel.prototype._getDefaultColumnWidth = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return this.calcColumnWidth(sheet.defaults ? sheet.defaults.colWidth : getSheetDefaultColumnWidth(sheet));
	        };
	        WriterDataModel.prototype.calcColumnWidth = function (actualWidth) {
	            if (actualWidth === 0) {
	                return 0;
	            }
	            var defaultStyle = WriterDataModel._getDefaultStyle(this._spread);
	           
	            var maxDigitWidth = Math.round(this._getMaxiumDigitWidth(defaultStyle.font));
	            var characters = Math.floor((actualWidth - 5) / maxDigitWidth * 100 + 0.5) / 100;
	            return Math.floor((characters * maxDigitWidth + 5) / maxDigitWidth * 256) / 256;
	        };
	        WriterDataModel.prototype._getMaxiumDigitWidth = function (font) {
	            if (this._maxiumDigitWidth === keyword_undefined) {
	                this._maxiumDigitWidth = UnitHelper.getMaxiumDigitWidth(font);
	            }
	            return this._maxiumDigitWidth;
	        };
	        WriterDataModel.prototype._getSelectionList = function (sheetName, selectionList, activeCell, panelIndex) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet) {
	                return false;
	            }
	            var frozenRowCount = sheet.frozenRowCount, frozenColumnCount = sheet.frozenColCount;
	            activeCell.col = sheet.activeCol >= 0 ? sheet.activeCol : 0;
	            activeCell.row = sheet.activeRow >= 0 ? sheet.activeRow : 0;
	            var hasFrozenRow = frozenRowCount > 0, hasFrozenColumn = frozenColumnCount > 0;
	            if (panelIndex === 0 ) {
	                if (!hasFrozenRow || !hasFrozenColumn) {
	                    return false;
	                }
	            } else if (panelIndex === 1 ) {
	                if (!hasFrozenColumn) {
	                    return false;
	                }
	                if (hasFrozenRow) {
	                    activeCell.col = frozenColumnCount;
	                    activeCell.row = 0;
	                }
	            } else if (panelIndex === 2 ) {
	                if (!hasFrozenRow) {
	                    return false;
	                }
	                if (hasFrozenColumn) {
	                    activeCell.col = 0;
	                    activeCell.row = frozenRowCount;
	                }
	               
	            }
	            activeCell.col = Math.min(ExcelConstants._openXmlMaxColumn, activeCell.col);
	            activeCell.row = Math.min(ExcelConstants._openXmlMaxRow, activeCell.row);
	            if (selectionList) {
	                var rect;
	                if (sheet.selections) {
	                    for (var i = 0; i < sheet.selections.length; i++) {
	                        var range = sheet.selections[i];
	                        if (isObject(range)) {
	                            rect = new Range(range.row > 0 ? range.row : 0, range.col > 0 ? range.col : 0, range.rowCount > 0 ? range.rowCount : ExcelConstants._openXmlMaxRow, range.colCount > 0 ? range.colCount : ExcelConstants._openXmlMaxColumn);
	                            selectionList.push(rect);
	                        }
	                    }
	                } else {
	                    selectionList.push(new Range(activeCell.row, activeCell.col, 1, 1));
	                }
	            }
	            return true;
	        };
	        WriterDataModel.prototype._addCellToCache = function (sheetIndex, row, cell) {
	            if (isNullOrUndefined(this._workbookCells[sheetIndex][row])) {
	                this._workbookCells[sheetIndex][row] = [];
	            }
	            this._workbookCells[sheetIndex][row].push(cell);
	        };
	        WriterDataModel.prototype._addDataTimeFormatterIfValueIsDate = function (value, styleInfo) {
	            if (isString(value) && value.substring(0, 7) === '/OADate' && styleInfo && !styleInfo.formatter) {
	                var startIndex = value.indexOf('('), endIndex = value.indexOf(')');
	                if (startIndex !== -1 && endIndex !== -1) {
	                    var dataNumber = parseInt(value.substring(startIndex + 1, endIndex));
	                    if (dataNumber < 1) {
	                        styleInfo.formatter = 'h:mm:ss';
	                    } else if (dataNumber > 1) {
	                        styleInfo.formatter = 'M/d/yyyy';
	                    }
	                }
	            }
	        };
	        WriterDataModel.prototype._setCellStyle = function (cellStyleTable, styleKey, styleInfo, styleName, cell) {
	            if (!StringEx._isNullOrEmpty(styleName)) {
	                var id;
	                if ((id = this._namedStyleTable[styleName]) !== undefined) {
	                    cell.formatId = id;
	                } else {
	                    cell.formatId = -1;
	                }
	            } else if (styleInfo) {
	                if ((id = cellStyleTable[styleKey]) !== undefined) {
	                    cell.formatId = id;
	                } else {
	                    cell.formatId = -1;
	                }
	            } else {
	                cell.formatId = -1;
	            }
	        };
	        WriterDataModel.prototype._setCellFormula = function (formula, arrayInfo, cell) {
	            if (!StringEx._isNullOrWhiteSpace(formula)) {
	                cell.formula = formula;
	                if (arrayInfo) {
	                    cell.isArrayFormula = true;
	                    cell.cellType = 8 ;
	                    cell.arrayFormulaRange = arrayInfo;
	                } else {
	                    cell.cellType = 3 ;
	                }
	            }
	        };
	        WriterDataModel.prototype._getRealCellValueForExcel = function (value) {
	            var cellType = 0 ;
	            if (isNullOrUndefined(value)) {
	                value = keyword_null;
	            } else if (value._error) {
	                cellType = 7 ;
	                return {
	                    value: value._error,
	                    cellType: cellType
	                };
	            } else if (typeof value === 'number') {
	                cellType = 1 ;
	                if (isNaN(value)) {
	                    value = 0;
	                }
	            } else if (typeof value === 'boolean') {
	                cellType = 5 ;
	            } else if (isString(value) && value.substring(0, 7) === '/OADate') {
	                cellType = 6 ;
	            } else if (isString(value)) {
	                cellType = 2 ;
	            } else {
	                cellType = 2 ;
	                value = value.toString();
	            }
	            return {
	                value: value,
	                cellType: cellType
	            };
	        };
	
	
	        WriterDataModel.prototype._getCellStyle = function (sheet, row, column, cellStyleTable, currentColumnNamedStyle, currentColumnStyle, currentRowNamedStyle, currentRowStyle, styleKey, value) {
	            var namedStyleIndex, styleInfo;
	            var namedStyleTable = this._namedStyleTable;
	            var styleObject = this._getStyleObject(sheet, row, column);
	            var styleName = getActualStyleName(this._spread, styleObject);
	
	            if (!StringEx._isNullOrEmpty(styleName) && styleName !== currentRowNamedStyle && styleName !== currentColumnNamedStyle && (namedStyleIndex = this._namedStyleTable[styleName]) !== undefined) {
	                cellStyleTable[styleKey] = namedStyleIndex;
	                styleInfo = getStyleByName(styleName, this._spread, sheet);
	            } else {
	                if (styleObject && isObject(styleObject)) {
	                    styleInfo = styleObject;
	                }
	               
	               
	               
	               
	               
	                if (styleInfo) {
	                   
	                    if (styleInfo.parentName) {
	                        styleInfo = ConverterHelper.cloneSpreadJSStyle(styleInfo);
	                        var parentStyle = getStyleByName(styleInfo.parentName, this._spread, sheet);
	                        StyleHelper._composeStyle(styleInfo, parentStyle);
	                    }
	                    if (StyleHelper._isEmptyStyleInfo(styleInfo) && (currentColumnNamedStyle || currentRowNamedStyle || currentColumnStyle || currentRowStyle)) {
	                        styleInfo = this._getStyleInfo(sheet, row, column);
	                    }
	                    this._addDataTimeFormatterIfValueIsDate(value, styleInfo);
	                    cellStyleTable[styleKey] = this._getStyleIndex(styleInfo);
	                } else if (value !== keyword_null && value !== undefined) {
	                   
	                    if (isString(value) && value.substring(0, 7) === '/OADate') {
	                        styleInfo = this._getStyleInfo(sheet, row, column);
	                        if (!styleInfo) {
	                            styleInfo = {};
	                        }
	                        this._addDataTimeFormatterIfValueIsDate(value, styleInfo);
	                        cellStyleTable[styleKey] = this._getStyleIndex(styleInfo);
	                    } else if (!StringEx._isNullOrWhiteSpace(currentRowNamedStyle) && (namedStyleIndex = namedStyleTable[currentRowNamedStyle]) !== undefined) {
	                        cellStyleTable[styleKey] = namedStyleIndex;
	                        styleInfo = getStyleByName(currentRowNamedStyle, this._spread, sheet);
	                    } else if (currentRowStyle && !StyleHelper._isEmptyStyleInfo(currentRowStyle)) {
	                        styleInfo = currentRowStyle;
	                        cellStyleTable[styleKey] = this._getStyleIndex(styleInfo);
	                    } else if (!StringEx._isNullOrWhiteSpace(currentColumnNamedStyle) && (namedStyleIndex = namedStyleTable[currentColumnNamedStyle]) !== undefined) {
	                        cellStyleTable[styleKey] = namedStyleIndex;
	                        styleInfo = getStyleByName(currentColumnNamedStyle, this._spread, sheet);
	                    } else if (currentColumnStyle && !StyleHelper._isEmptyStyleInfo(currentColumnStyle)) {
	                        styleInfo = currentColumnStyle;
	                        cellStyleTable[styleKey] = this._getStyleIndex(styleInfo);
	                    } else {
	                        styleInfo = keyword_null;
	                    }
	                } else {
	                    styleInfo = keyword_null;
	                }
	            }
	            return {
	                styleName: styleName,
	                styleInfo: styleInfo
	            };
	        };
	        WriterDataModel.prototype._getStyleIndex = function (style) {
	            var styles = this._styles;
	            if (!style) {
	                return 0;
	            }
	            if (!StringEx._isNullOrWhiteSpace(style.name)) {
	                var newStyle = ConverterHelper.cloneSpreadJSStyle(style);
	                newStyle.name = keyword_undefined;
	                newStyle.parentName = style.name;
	                for (var i = styles.length - 1; i >= 0; i--) {
	                    if (Util._isJSONEqual(styles[i], newStyle)) {
	                        return i;
	                    }
	                }
	                styles.push(newStyle);
	                return styles.length - 1;
	            }
	            for (i = styles.length - 1; i >= 0; i--) {
	                if (Util._isJSONEqual(styles[i], style)) {
	                    return i;
	                }
	            }
	            styles.push(style);    
	            return styles.length - 1;
	        };
	        WriterDataModel.prototype._getLastNonNullRow = function (dataTable) {
	            if (!dataTable) {
	                return 0;
	            }
	            var maxRow = 0;
	            for (var row in dataTable) {
	                if (dataTable.hasOwnProperty(row) && parseInt(row) > maxRow) {
	                    maxRow = parseInt(row);
	                }
	            }
	            return maxRow;
	        };
	        WriterDataModel.prototype._getLastNonNullColumn = function (dataTable, sheet) {
	            var maxColumn = 0;
	            if (dataTable) {
	                for (var row in dataTable) {
	                    if (dataTable.hasOwnProperty(row)) {
	                        for (var col in dataTable[row]) {
	                            if (parseInt(col) > maxColumn) {
	                                maxColumn = parseInt(col);
	                            }
	                        }
	                    }
	                }
	            }
	
	           
	            var tables = sheet.tables;
	            if (tables) {
	                tables.forEach(function (sheetTable) {
	                    if (sheetTable.col + sheetTable.colCount > maxColumn) {
	                        maxColumn = sheetTable.col + sheetTable.colCount;
	                    }
	                });
	            }
	
	            return maxColumn;
	        };
	        WriterDataModel.prototype._nextNonNullRow = function (dataTable, rowCount, row) {
	            row++;
	
	            while (row >= 0 && row < rowCount) {
	                if (dataTable[row]) {
	                    break;
	                }
	                row++;
	            }
	
	            if (row < rowCount) {
	                return row;
	            }
	
	            return -1;
	        };
	        WriterDataModel.prototype._nextNonNullColumn = function (dataTable, rowCount, colCount, row, col) {
	            var dr = keyword_null;
	            if (row >= 0 && row < rowCount) {
	                dr = dataTable[row];
	            }
	
	            if (!dr) {
	                return -1;
	            }
	
	            col++;
	            while (col >= 0 && col < colCount) {
	                if (dr[col]) {
	                    break;
	                }
	                col++;
	            }
	
	            if (col < colCount) {
	                return col;
	            }
	
	            return -1;
	        };
	        WriterDataModel.prototype._getColumnStyleInfos = function (sheet, columnCount) {
	            var columnStyles = [], sheetColumnCount = sheet.columnCount;
	            if (!sheet.data || !sheet.data.columnDataArray) {
	                return columnStyles;
	            }
	            for (var column = 0; column < columnCount; column++) {
	                if (column < sheetColumnCount) {
	                    var columnStyle = this._getStyleInfo(sheet, -1, column);
	                    columnStyles.push(columnStyle);
	                } else {
	                    columnStyles.push(keyword_null);
	                }
	            }
	            return columnStyles;
	        };
	        WriterDataModel.prototype._getColumnNamedStyleInfos = function (sheet, columnCount) {
	            var columnNamesStyles = [], sheetColumnCount = sheet.columnCount;
	            if (!sheet.data || !sheet.data.columnDataArray) {
	                return columnNamesStyles;
	            }
	            for (var column = 0; column < columnCount; column++) {
	                if (column < sheetColumnCount) {
	                    var columnStyle = this._getStyleObject(sheet, -1, column);
	                    if (isString(columnStyle)) {
	                        columnNamesStyles.push(columnStyle);
	                    } else {
	                        columnNamesStyles.push('');
	                    }
	                } else {
	                    columnNamesStyles.push('');
	                }
	            }
	            return columnNamesStyles;
	        };
	        WriterDataModel.prototype._getExcelCellFormats = function () {
	            var self = this, results = [], styleParentIndexMapping = {count: 0};
	            for (var i = 0, len = self._styles.length; i < len; i++) {
	                var style = self._styles[i];
	                var format = ConverterHelper.toExtendedFormat(style);
	                if (style.name && !(style.name.substring(0, const_builtInStyle.length) === const_builtInStyle)) {
	                    if (!styleParentIndexMapping[style.name]) {
	                        styleParentIndexMapping[style.name] = styleParentIndexMapping.count;
	                        styleParentIndexMapping.count++;
	                    }
	                    format.isStyleFormat = true;
	                } else {
	                    var parentID = 0;
	                    if (styleParentIndexMapping[style.parentName] !== undefined && styleParentIndexMapping[style.parentName] !== keyword_null) {
	                        parentID = styleParentIndexMapping[style.parentName];
	                    }
	                    format.parentFormatID = parentID;
	                }
	                results.push(format);
	            }
	            return results;
	        };
	        WriterDataModel.prototype._getExcelDefaultFormat = function () {
	            var defaultStyle = ConverterHelper.cloneSpreadJSStyle(WriterDataModel._getDefaultStyle(this._spread));
	            var result = ConverterHelper.toExtendedFormat(defaultStyle);
	            result.parentFormatID = 0;
	            return result;
	        };
	        WriterDataModel.prototype._getExcelStyles = function () {
	            var self = this, result = [], normalStyle = keyword_null;
	            for (var i = 0, len = self._namedStyles.length; i < len; i++) {
	                var nameStyle = self._namedStyles[i];
	                if (nameStyle.name === 'Normal') {
	                    var style = new ExcelStyle();
	                    style.name = 'Normal';
	                    style.format(ConverterHelper.toExtendedFormat(nameStyle));
	                    style.format().isStyleFormat = true;
	                    style.builtInStyle = 0 ;
	                    normalStyle = style;
	                    self._normalStyleInfo = nameStyle;
	                    break;
	                }
	            }
	            if (!normalStyle) {
	                var normal = new ExcelStyle();
	                normal.name = 'Normal';
	                normal.format(ConverterHelper.toExtendedFormat(WriterDataModel._getDefaultStyle(this._spread)));
	                normal.format().font.fontSize = 14.67;
	                normal.format().isStyleFormat = true;
	                normal.builtInStyle = 0 ;
	                result.push(normal);
	            }
	            for (i = 0, len = self._namedStyles.length; i < len; i++) {
	                var item = self._namedStyles[i];
	                if (item.name) {
	                    if (WriterDataModel._builtInStyle[item.name] !== undefined) {
	                        style = new ExcelStyle();
	                        style.name = item.name;
	                        style.format(ConverterHelper.toExtendedFormat(item));
	                        style.format().isStyleFormat = true;
	                        style.builtInStyle = WriterDataModel._builtInStyle[item.name];
	                        if ((item.name.substring(0, 'RowLevel_'.length) === 'RowLevel_' || item.name.substring(0, 'ColLevel_'.length) === 'ColLevel_') && item.name.length > 9) {
	                            style.outLineLevel = parseInt(item.name.substring(9)) - 1;
	                        }
	                        result.push(style);
	                    } else {
	                        var style1 = new excelStyle.CustomExcelStyle();
	                        style1.name = item.name;
	                        style1.format(ConverterHelper.toExtendedFormat(item));
	                        style1.format().isStyleFormat = true;
	                        result.push(style1);
	                    }
	                }
	            }
	            return result;
	        };
	        WriterDataModel.prototype._getSheetsName = function () {
	            var ret = [], sheets = this._spread.sheets;
	            for (var sheetName in sheets) {
	                if (sheets.hasOwnProperty(sheetName)) {
	                    var sheet = sheets[sheetName];
	                    ret[sheet.index] = sheetName;
	                }
	            }
	            return ret;
	        };
	        WriterDataModel.prototype._getOutlineDirection = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet) {
	                return {};
	            }
	            return {
	                colsSumRight: !(sheet.columnOutlines && sheet.columnOutlines.direction === 0),
	                rowsSumBelow: !(sheet.rowOutlines && sheet.rowOutlines.direction === 0)
	            };
	        };
	        WriterDataModel.prototype._getSheetTabColor = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet) {
	                return keyword_null;
	            }
	            return toExcelColor(sheet.sheetTabColor);
	        };
	        WriterDataModel.prototype._getDimensions = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (!sheet) {
	                return {};
	            }
	            return {
	                rowCount: sheet.rowCount,
	                columnCount: sheet.columnCount
	            };
	        };
	        WriterDataModel.prototype._getDisplayElements = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var ret = {
	                showGridLine: true,
	                showRowColHeaders: true,
	                gridlineColor: keyword_null,
	                zoom: 1
	            };
	            if (!sheet) {
	                return ret;
	            }
	            if (sheet.gridline && (sheet.gridline.showVerticalGridline === false || sheet.gridline.showHorizontalGridline === false)) {
	                ret.showGridLine = false;
	            }
	            if (sheet.rowHeaderVisible === false && sheet.colHeaderVisible === false) {
	                ret.showRowColHeaders = false;
	            }
	            if (sheet.gridline && sheet.gridline.color) {
	                ret.gridlineColor = ColorHelper.toExcelIndexedColor(toExcelColor(sheet.gridline.color, 0xffd0d7e5));
	            }
	            ret.zoom = sheet.zoomFactor;
	            return ret;
	        };
	        WriterDataModel.prototype._getFrozen = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var ret = {
	                frozenRowCount: 0,
	                frozenColCount: 0
	            };
	            if (!sheet) {
	                return ret;
	            }
	            ret.frozenRowCount = sheet.frozenRowCount;
	            ret.frozenColCount = sheet.frozenColCount;
	            return ret;
	        };
	        WriterDataModel.prototype._getProtect = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet ? sheet.isProtected : false;
	        };
	        WriterDataModel.prototype._getProtectionOptions = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var protectionOptions = sheet.protectionOptions;
	            var result = {}, value;
	            for(var key in protectionOptions) {
	                if(protectionOptions.hasOwnProperty(key)) {
	                    value = protectionOptions[key];
	                    if(!((value && key === 'allowSelectLockCells') ||
	                        (value && key === 'allowSelectUnlockCells') ||
	                        (value && key === 'allowEditObjects'))) {
	                        result[fromProtectionOptions[key]] = protectionOptions[key];
	                    }
	                }
	            }
	            if(!protectionOptions) {
	                result.editObject = false;
	            }
	            return result;
	        };
	        WriterDataModel.prototype._getMergedCells = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet ? sheet.spans : [];
	        };
	        WriterDataModel.prototype._getTabsAndScroll = function () {
	            var spread = this._spread;
	            return {
	                showHorizontalScrollbar: spread.showHorizontalScrollbar,
	                showVerticalScrollbar: spread.showVerticalScrollbar,
	                tabStripVisible: spread.tabStripVisible,
	                tabStripRatio: spread.tabStripRatio,
	                startSheetIndex: spread.startSheetIndex,
	                activeSheetIndex: spread.activeSheetIndex
	            };
	        };
	        WriterDataModel.prototype._isSheetHidden = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet ? sheet.visible === false : true;
	        };
	        WriterDataModel.prototype._getDefinedNames = function () {
	            var definedNames = [], definedName;
	            if (this._spread.names) {
	                for (var i = 0; i < this._spread.names.length; i++) {
	                    definedName = this._spread.names[i];
	                    definedNames.push({
	                        name: definedName.name,
	                        localSheetId: -1,
	                        formula: definedName.formula,
	                        comment: definedName.comment
	                    });
	                }
	            }
	            var sheets = this._spread.sheets;
	            for (var sheetName in sheets) {
	                if (sheets.hasOwnProperty(sheetName)) {
	                    var sheet = sheets[sheetName];
	                    if (sheet.names) {
	                        for (i = 0; i < sheet.names.length; i++) {
	                            definedName = sheet.names[i];
	                            definedNames.push({
	                                name: definedName.name,
	                                localSheetId: sheet.index,
	                                formula: definedName.formula,
	                                comment: definedName.comment
	                            });
	                        }
	                    }
	                }
	            }
	
	            return definedNames;
	        };
	        WriterDataModel.prototype._getConditionalFormatting = function (sheetName) {
	            var self = this, sheet = self._spread.sheets && self._spread.sheets[sheetName];
	            return sheet.conditionalFormats;
	        };
	        WriterDataModel._builtInStyle = {
	            '20% - Accent1': 30,
	            '20% - Accent2': 34,
	            '20% - Accent3': 38,
	            '20% - Accent4': 42,
	            '20% - Accent5': 46,
	            '20% - Accent6': 50,
	            '40% - Accent1': 31,
	            '40% - Accent2': 35,
	            '40% - Accent3': 39,
	            '40% - Accent4': 43,
	            '40% - Accent5': 47,
	            '40% - Accent6': 51,
	            '60% - Accent1': 32,
	            '60% - Accent2': 36,
	            '60% - Accent3': 40,
	            '60% - Accent4': 44,
	            '60% - Accent5': 48,
	            '60% - Accent6': 52,
	            'Accent1': 29,
	            'Accent2': 33,
	            'Accent3': 37,
	            'Accent4': 41,
	            'Accent5': 45,
	            'Accent6': 49,
	            'Bad': 27,
	            'Calculation': 22,
	            'Check Cell': 23,
	            'Comma': 3,
	            'Comma [0]': 6,
	            'Currency': 4,
	            'Currency [0]': 7,
	            'Explanatory Text': 53,
	            'Good': 26,
	            'Heading 1': 16,
	            'Heading 2': 17,
	            'Heading 3': 18,
	            'Heading 4': 19,
	            'Input': 20,
	            'Linked Cell': 24,
	            'Neutral': 28,
	            'Normal': 0,
	            'Note': 10,
	            'Output': 21,
	            'Percent': 5,
	            'Title': 15,
	            'Total': 25,
	            'Warning Text': 11,
	            'Hyperlink': 8,
	            'FollowedHyperLink': 9,
	            'RowLevel_1': 1,
	            'RowLevel_2': 1,
	            'RowLevel_3': 1,
	            'RowLevel_4': 1,
	            'RowLevel_5': 1,
	            'RowLevel_6': 1,
	            'RowLevel_7': 1,
	            'ColLevel_1': 2,
	            'ColLevel_2': 2,
	            'ColLevel_3': 2,
	            'ColLevel_4': 2,
	            'ColLevel_5': 2,
	            'ColLevel_6': 2,
	            'ColLevel_7': 2
	        };
	
	        WriterDataModel._getDefaultStyle = function (workbook) {
	            var defaultStyle = {
	                foreColor: 'black',
	                font: 'normal normal normal 11pt/normal Calibri',
	                locked: true,
	                name: 'Normal',
	                textDecoration: 0,
	                hAlign: 3,
	                vAlign: 0,
	                formatter: 'General'
	            };
	            for (var sheetName in workbook.sheets) {
	                if (workbook.sheets.hasOwnProperty(sheetName)) {
	                    var sheet = workbook.sheets[sheetName];
	                    if (sheet.data && sheet.data.defaultDataNode && sheet.data.defaultDataNode.style) {
	                        var sheetDefaultStyle = sheet.data.defaultDataNode.style;
	                        for (var p in sheetDefaultStyle) {
	                            if (sheetDefaultStyle.hasOwnProperty(p) && !isNullOrUndefined(sheetDefaultStyle[p])) {
	                                defaultStyle[p] = sheetDefaultStyle[p];
	                            }
	                        }
	                        break;
	                    }
	                }
	            }
	            return defaultStyle;
	        };
	
	        WriterDataModel.prototype._getComments = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet.comments && sheet.comments.map(function (comment) {
	                    return convertToExcelComment(sheet, comment);
	                });
	        };
	
	        WriterDataModel.prototype._getPictures = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet.floatingObjects && sheet.floatingObjects.filter(function (item) {
	                    return item.typeName === '1'  &&
	                        item.src && item.src.indexOf(';base64,') !== -1;   
	                }).map(function (picture) {
	                    return convertToExcelPicture(sheet, picture);
	                });
	        };
	
	        WriterDataModel.prototype._getSparklineGroups = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet.sparklineGroups;
	        };
	        WriterDataModel.prototype._getColorFilter = function (sheet) {
	            var rowFilter = sheet.rowFilter, self = this;
	            if (rowFilter) {
	                var colorFilterColumns = [];
	                var filteredColumns = rowFilter.filteredColumns, filterItemMap = rowFilter.filterItemMap;
	                if (filterItemMap && filteredColumns && filteredColumns.length > 0) {
	                    filterItemMap.forEach(function (filterItem) {
	                        if(filteredColumns.indexOf(filterItem.index) < 0) {
	                            return;
	                        }
	                        var condition = filterItem.conditions[0];
	                        if (condition.conType === 3 ) {
	                            var isBackgroundColor = condition.compareType === 0 ;
	                            var fillObj = condition.expected ? {
	                                item1: 1,
	                                item2: toExcelColor(condition.expected),
	                                item3: isBackgroundColor ? toExcelColor('#000000') : toExcelColor('#FFFFFF')
	                            } : {
	                                item1: 0, 
	                                item2: new ExcelColor(1 , 64 , 0),
	                                item3: new ExcelColor(1 , 65 , 0)
	                            };
	                            colorFilterColumns.push({
	                                autoFilterColumnId: filterItem.index - getFilterRange(sheet, rowFilter.range).col,
	                                colorFilter: {
	                                    cellColor: isBackgroundColor,
	                                    dxfId: self._addDifferentConditionalFormat({
	                                        isColorFilter: true,
	                                        fill: fillObj
	                                    })
	                                }
	                            });
	                        }
	                    });
	                }
	                return colorFilterColumns;
	            }
	        };
	        WriterDataModel.prototype._getSortInfo = function (rowFilter) {
	            var sortInfo, autoFilterSortInfo = keyword_null;
	            if(rowFilter) {
	                sortInfo = rowFilter.sortInfo;
	                if (sortInfo && !isNullOrUndefined(sortInfo.ascending) && !isNullOrUndefined(sortInfo.index)) {
	                    autoFilterSortInfo = {
	                        range: new Range(rowFilter.range.row, sortInfo.index, rowFilter.range.rowCount, 1),
	                        descending: !sortInfo.ascending
	                    };
	                    if(sortInfo.color !== keyword_undefined) {
	                        var isBackColor = sortInfo.isBackColor, fillObj = sortInfo.color ? {
	                            item1: 1,
	                            item2: toExcelColor(sortInfo.color),
	                            item3: isBackColor ? toExcelColor('#000000') : toExcelColor('#FFFFFF')
	                        } : {
	                            item1: 0, 
	                            item2: new ExcelColor(1 , 64 , 0),
	                            item3: new ExcelColor(1 , 65 , 0)
	                        };
	                        autoFilterSortInfo.isBackColor = isBackColor;
	                        autoFilterSortInfo.dxfid = this._addDifferentConditionalFormat({
	                            isColorFilter: true,
	                            fill: fillObj
	                        });
	                    }
	                }
	            }
	            return autoFilterSortInfo;
	
	        };
	        WriterDataModel.prototype._convertAutoFilterFromJSON = function (sheetName, rowFilter, sortInfo) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            if (isNullOrUndefined(rowFilter) || isNullOrUndefined(rowFilter.range)) {
	                return keyword_null;
	            }
	            var rowFilterRange = rowFilter.range;
	            var autoFilter = {
	                range: getFilterRange(sheet, rowFilterRange),
	                filterColumns: []
	            };
	
	            if (sheet._colorFilterColumns && sheet._colorFilterColumns.length > 0) {
	                autoFilter.filterColumns = sheet._colorFilterColumns;
	            }
	            var filteredColumns = rowFilter.filteredColumns, filterItemMap = rowFilter.filterItemMap;
	            if (filterItemMap && filteredColumns && filteredColumns.length > 0) {
	                filterItemMap.forEach(function (filterItem) {
	                    if (filterItem.index < rowFilterRange.col || filterItem.index >= rowFilterRange.col + rowFilterRange.colCount ||
	                        filteredColumns.indexOf(filterItem.index) < 0) {
	                        return;
	                    }
	                    var conditionArray = filterItem.conditions, condition;
	                    condition = conditionArray[0];
	                    for (var i = 1; i < conditionArray.length; i++) {
	                        condition = {
	                            conType: 0 ,
	                            compareType: 0 ,
	                            item1: condition,
	                            item2: conditionArray[i]
	                        };
	                    }
	                    if (condition) {
	                        var filterColumn = {autoFilterColumnId: filterItem.index - autoFilter.range.col};
	                        var filterCondition = toExcelFilter(sheet, condition, new Range(autoFilter.range.row + 1, autoFilter.range.col, autoFilter.range.rowCount - 1, 1));
	                        if (!isNullOrUndefined(filterCondition)) {
	                            var filterType = filterCondition.filterType;
	                            if (filterType === 1 ) {
	                                filterColumn.top10 = filterCondition;
	                            } else if (filterType === 2 ) {
	                                filterColumn.dynamicFilter = filterCondition;
	                            } else if (filterType === 3 ) {
	                                filterColumn.filters = filterCondition;
	                            } else if (filterType === 4 ) {
	                                filterColumn.customFilters = filterCondition;
	                            }
	                            autoFilter.filterColumns.push(filterColumn);
	                        }
	                    }
	                });
	            }
	            autoFilter.sortInfo = sortInfo;
	            return autoFilter;
	        };
	        WriterDataModel.prototype._getAutoFilter = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName], sortInfo = keyword_null;
	            if(sheet.rowFilter) {
	                sortInfo = sheet.rowFilter.autoFilterSortInfo;
	            }
	            return this._convertAutoFilterFromJSON(sheetName, sheet.rowFilter, sortInfo);
	        };
	        WriterDataModel.prototype._getTables = function (sheetName) {
	            var tables = [], spread = this._spread;
	            if (sheetName) {
	                return spread.sheets[sheetName].tables;
	            }
	            for (var name in spread.sheets) {
	                if (spread.sheets[name].tables) {
	                    tables = tables.concat(spread.sheets[name].tables);
	                }
	            }
	            return tables;
	        };
	        WriterDataModel.prototype._getSlicers = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            return sheet.slicers && sheet.slicers.map(function (slicer) {
	                    return convertToExcelSlicer(sheet, slicer);
	                });
	        };
	        WriterDataModel.prototype._getCharts = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var id = 1;
	            return sheet.charts && sheet.charts.map(function (chart) {
	                return convertToExcelChart(sheet, chart, id++);
	            });
	        };
	
	        
	        WriterDataModel.prototype._getValidationData = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var result = [];
	            var validations = sheet.validations;
	            if (validations) {
	                var sheetNames = this._getSheetsName();
	                processDataValidator(validations, result, sheetName, sheetNames);
	            }
	            return result;
	        };
	        function getPageMarginInExcel(margin) {
	            return margin / 100;
	        }
	        WriterDataModel.prototype._getPrintPageMargin = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var printInfo = sheet.printInfo, margin = printInfo && printInfo.margin;
	            return margin ? {
	                bottom: getPageMarginInExcel(margin.bottom),
	                top: getPageMarginInExcel(margin.top),
	                left: getPageMarginInExcel(margin.left),
	                right: getPageMarginInExcel(margin.right),
	                header: getPageMarginInExcel(margin.header),
	                footer: getPageMarginInExcel(margin.footer)
	            } : keyword_null;
	        };
	        WriterDataModel.prototype._getPrintOptions = function (sheetName) {
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var printInfo = sheet.printInfo;
	            if (printInfo) {
	                var centering = printInfo.centering;
	                return {
	                    horizontalCentered: centering === 1  || centering === 3 ,
	                    verticalCentered: centering === 2  || centering === 3 ,
	                    printGridLine: printInfo.showGridLine,
	                    printRowColumnsHeaders: printInfo.showRowHeader === 2 
	                    && printInfo.showColumnHeader === 2 
	                };
	            }
	        };
	        WriterDataModel.prototype._getPrintPageSetting = function (sheetName, isUseSmartPrint) {
	            function buildExcelPrintHeader(left, center, right) {
	                left = left || '';
	                center = center || '';
	                right = right || '';
	                return "&L" + left + "&C" + center + "&R" + right;
	            }
	
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var printInfo = sheet.printInfo;
	            if (!printInfo) {
	                return keyword_null;
	            }
	            var excelSettings = {};
	            var fitPagesTall = printInfo.fitPagesTall, fitPagesWide = printInfo.fitPagesWide;
	            if (!isNullOrUndefined(fitPagesTall) && fitPagesTall !== -1 || !isNullOrUndefined(fitPagesWide) && fitPagesWide !== -1) {
	                excelSettings.useSmartPrint = true;
	                excelSettings.smartPrintPagesWidth = Math.max(1, fitPagesWide);
	                excelSettings.smartPrintPagesHeight = Math.max(1, fitPagesTall);
	            }
	            if (!isUseSmartPrint) {
	                if (printInfo.paperSize) {
	                    var paperKind = printInfo.paperSize.kind;
	                    if (paperKind !== 0 ) {
	                        excelSettings.paperSizeIndex = paperKind;
	                    }
	                }
	                excelSettings.copies = 1;
	                if (!isNullOrUndefined(printInfo.firstPageNumber)) {
	                    excelSettings.useCustomStartingPage = true;
	                    excelSettings.firstPageNumber = printInfo.firstPageNumber;
	                }
	                excelSettings.orientation = printInfo.orientation === 2  ? 2  : 1 ;
	                excelSettings.pageOrder = printInfo.pageOrder === 1  ? 1  : 2 ;
	                excelSettings.zoomFactor = parseFloat(printInfo.zoomFactor);
	                excelSettings.showColor = !printInfo.blackAndWhite;
	                var headerString = buildExcelPrintHeader(printInfo.headerLeft, printInfo.headerCenter, printInfo.headerRight);
	                var footerString = buildExcelPrintHeader(printInfo.footerLeft, printInfo.footerCenter, printInfo.footerRight);
	                excelSettings.advancedHeadFooterSetting = {
	                    headerEvenPage: headerString,
	                    headerOddPage: headerString,
	                    footerOddPage: footerString,
	                    footerEvenPage: footerString
	                };
	
	                var rows = sheet.rows, rowBreakLines = [];
	                if (rows && rows.length > 0) {
	                    rows.forEach(function (rowInfo, rowIndex) {
	                        if (rowInfo && rowInfo.pageBreak) {
	                            rowBreakLines.push(rowIndex);
	                        }
	                    });
	                }
	                var columns = sheet.columns, columnBreakLines = [];
	                if (columns && columns.length > 0) {
	                    columns.forEach(function (columnInfo, columnIndex) {
	                        if (columnInfo && columnInfo.pageBreak) {
	                            columnBreakLines.push(columnIndex);
	                        }
	                    });
	                }
	                if (rowBreakLines.length > 0) {
	                    excelSettings.rowBreakLines = rowBreakLines;
	                }
	                if (columnBreakLines.length > 0) {
	                    excelSettings.columnBreakLines = columnBreakLines;
	                }
	            }
	            return excelSettings;
	        };
	        WriterDataModel.prototype._getPrintInfo = function (sheetName) {
	            return this._spread.sheets && this._spread.sheets[sheetName].printInfo;
	        };
	        WriterDataModel.prototype._getPrintHeaderFooterImage = function (sheetName) {
	            function getPrintImage(name, imageString) {
	                var retValue = {name: name};
	                getPictureInfo(imageString, retValue);
	                return retValue;
	            }
	
	            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
	            var printInfo = sheet.printInfo, headerFooterImages = [];
	            if (printInfo) {
	                if (printInfo.headerLeftImage) {
	                    headerFooterImages.push(getPrintImage('LH', printInfo.headerLeftImage));
	                }
	                if (printInfo.headerCenterImage) {
	                    headerFooterImages.push(getPrintImage('CH', printInfo.headerCenterImage));
	                }
	                if (printInfo.headerRightImage) {
	                    headerFooterImages.push(getPrintImage('RH', printInfo.headerRightImage));
	                }
	                if (printInfo.footerLeftImage) {
	                    headerFooterImages.push(getPrintImage('LF', printInfo.footerLeftImage));
	                }
	                if (printInfo.footerCenterImage) {
	                    headerFooterImages.push(getPrintImage('CF', printInfo.footerCenterImage));
	                }
	                if (printInfo.footerRightImage) {
	                    headerFooterImages.push(getPrintImage('RF', printInfo.footerRightImage));
	                }
	            }
	            return headerFooterImages;
	        };
	        WriterDataModel.prototype._getExcelCellXfsStyles = function () {
	            return this._stylesForXfidCache;
	        };
	        return WriterDataModel;
	    })();
	    module.exports = WriterDataModel;
	
	
	}());

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var Tuple = __webpack_require__(14);
	    var excelStyle = __webpack_require__(12);
	    var common = __webpack_require__(4);
	    var writeColor = __webpack_require__(46).writeColor;
	
	    var XFileConstants = excel._XFileConstants;
	    var ExcelStyle = excelStyle.ExcelStyle;
	    var ExcelColor = excelStyle.ExcelColor;
	    var FontSchemeCategory = excelStyle.FontSchemeCategory;
	    var Util = common._Util;
	    var StringEx = common._StringEx;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var ExcelVerticalAlignment = excelStyle.ExcelVerticalAlignment;
	    var ConverterHelper = excelStyle.ConverterHelper;
	
	    var keyword_undefined = void 0;
	    var SpreadJSTableThemeType2ExcelThemeType = {
	        wholeSlicerStyle: 'wholeTable',
	        headerStyle: 'headerRow',
	        wholeTableStyle: 'wholeTable',
	        headerRowStyle: 'headerRow',
	        footerRowStyle: 'totalRow',
	        highlightFirstColumnStyle: 'firstColumn',
	        highlightLastColumnStyle: 'lastColumn',
	        firstRowStripStyle: 'firstRowStripe',
	        secondRowStripStyle: 'secondRowStripe',
	        firstColumnStripStyle: 'firstColumnStripe',
	        secondColumnStripStyle: 'secondColumnStripe',
	        firstHeaderCellStyle: 'firstHeaderCell',
	        lastHeaderCellStyle: 'lastHeaderCell',
	        firstFooterCellStyle: 'firstTotalCell',
	        lastFooterCellStyle: 'lastTotalCell'
	    };
	    var SpreadJSSlicerThemeType2ExcelThemeType = {
	        selectedItemWithDataStyle: 'selectedItemWithData',
	        selectedItemWithNoDataStyle: "selectedItemWithNoData",
	        unSelectedItemWithDataStyle: "unselectedItemWithData",
	        unSelectedItemWithNoDataStyle: "unselectedItemWithNoData",
	        hoveredSelectedItemWithDataStyle: "hoveredSelectedItemWithData",
	        hoveredSelectedItemWithNoDataStyle: "hoveredSelectedItemWithNoData",
	        hoveredUnSelectedItemWithDataStyle: "hoveredUnselectedItemWithData",
	        hoveredUnSelectedItemWithNoDataStyle: "hoveredUnselectedItemWithNoData"
	    };
	
	    function writeStyle(writerDataModel, xfMap) {
	        var styleObject = generateExcelStyle(writerDataModel, xfMap);
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('styleSheet', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._workbookNameSpace);
	            writer.writeAttributeString('xmlns:mc', XFileConstants._markupCompatibility);
	            writer.writeAttributeString('xmlns:x14ac', XFileConstants._ac);
	            writer.writeAttributeString('mc:Ignorable', XFileConstants._ignorable);
	        }, function () {
	            if (styleObject._numberFormats.count > 0) {
	                writer.writeElement('numFmts', function () {
	                    writer.writeAttributeString('count', styleObject._numberFormats.count.toString());
	                }, function () {
	                    for (var format in styleObject._numberFormats) {
	                        if (styleObject._numberFormats.hasOwnProperty(format) && format !== 'count') {
	                            writeNumFmt(writer, {key: format, value: styleObject._numberFormats[format]});
	                        }
	                    }
	                });
	            }
	            writer.writeElement('fonts', function () {
	                writer.writeAttributeString('count', styleObject._styleFonts.length.toString());
	            }, function () {
	                for (var i = 0, len = styleObject._styleFonts.length; i < len; i++) { 
	                    writeFont(writer, styleObject._styleFonts[i]);
	                }
	            });
	            writer.writeElement('fills', function () {
	                writer.writeAttributeString('count', styleObject._styleFills.length.toString());
	            }, function () {
	                writer.writeElement('fill', keyword_undefined, function () {
	                    writer.writeLeafElement('patternFill', function () {
	                        writer.writeAttributeString('patternType', 'none');
	                    });
	                });
	                writer.writeElement('fill', keyword_undefined, function () {
	                    writer.writeLeafElement('patternFill', function () {
	                        writer.writeAttributeString('patternType', 'gray125');
	                    });
	                });
	                for (var i = 2; i < styleObject._styleFills.length; i++) { 
	                    writeFill(writer, styleObject._styleFills[i]);
	                }
	            });
	            writer.writeElement('borders', function () {
	                writer.writeAttributeString('count', styleObject._styleBorders.length.toString());
	            }, function () {
	                for (var i = 0, len = styleObject._styleBorders.length; i < len; i++) { 
	                    writeBorder(writer, styleObject._styleBorders[i]);
	                }
	            });
	            writeXFs(writer, styleObject._styleXfs, 'cellStyleXfs', true, xfMap);
	            writeXFs(writer, styleObject._styleCellXfs, 'cellXfs', false, xfMap);
	            if (styleObject._styles.length === 0) {
	                writeDefaultNormalStyle(writer);
	            } else {
	                var usedStyles = [];
	                for (var i = 0, len = styleObject._styles.length; i < len; i++) {
	                    var item = styleObject._styles[i];
	                    usedStyles.push(new Tuple(styleObject._cellXfsStyles[item.name], item));
	                }
	                if (usedStyles.length === 0) {
	                    writeDefaultNormalStyle(writer);
	                } else {
	                    writer.writeElement('cellStyles', function () {
	                        writer.writeAttributeString('count', usedStyles.length.toString());
	                    }, function () {
	                        for (var i = 0, len = usedStyles.length; i < len; i++) { 
	                            var item = usedStyles[i]; 
	                            var style = item.item2;
	                            if (style) {
	                                writer.writeLeafElement('cellStyle', function () { 
	                                    writer.writeAttributeString('name', style.name);
	                                    writer.writeAttributeString('xfId', item.item1.toString());
	                                    if (style.isBuiltInStyle()) {
	                                        writer.writeAttributeString('builtinId', style.builtInStyle.toString());
	                                        if (style.isCustomBuiltin) {
	                                            writer.writeAttributeString('customBuiltin', '1');
	                                        }
	                                        if (style.builtInStyle === 1  || style.builtInStyle === 2 ) {
	                                            writer.writeAttributeString('iLevel', style.outLineLevel.toString());
	                                        }
	                                    }
	                                });
	                            } else {
	                                writer.writeLeafElement('cellStyle', function () { 
	                                    writer.writeAttributeString('name', style.name);
	                                    writer.writeAttributeString('xfId', item.item1.toString());
	                                });
	                            }
	                        }
	                    });
	                }
	
	            }
	           
	            writeDifferentialFormattings(writer, writerDataModel);
	
	           
	            if (writerDataModel._customerTableStyles.length > 0) {
	                writer.writeElement('tableStyles', function () {
	                    writer.writeAttributeString('count', writerDataModel._customerTableStyles.length);
	                    writer.writeAttributeString('defaultTableStyle', 'TableStyleMedium2');
	                    writer.writeAttributeString('defaultPivotStyle', 'PivotStyleMedium9');
	                }, function () {
	                    var customerTableStyles = writerDataModel._customerTableStyles;
	                    if (customerTableStyles) {
	                        customerTableStyles.forEach(function (customerTableStyle) {
	                            writer.writeElement('tableStyle', function () {
	                                writer.writeAttributeString('name', customerTableStyle.name);
	                                writer.writeAttributeString('pivot', '0');
	                                writer.writeAttributeString('count', customerTableStyle.styleElements.length);
	                                if (!isNullOrUndefined(customerTableStyle.tableId)) {
	                                    writer.writeAttributeString('table', customerTableStyle.tableId);
	                                }
	                            }, function () {
	                                if (customerTableStyle.styleElements && customerTableStyle.styleElements.length > 0) {
	                                    customerTableStyle.styleElements.forEach(function (styleElement) {
	                                        writer.writeLeafElement('tableStyleElement', function () {
	                                            writer.writeAttributeString('type', SpreadJSTableThemeType2ExcelThemeType[styleElement.type]);
	                                            writer.writeAttributeString('dxfId', styleElement.dxfId);
	                                            if (!isNullOrUndefined(styleElement.size)) {
	                                                writer.writeAttributeString('size', styleElement.size);
	                                            }
	                                        });
	                                    });
	                                }
	                            });
	                        });
	                    }
	                });
	            } else {
	                writer.writeLeafElement('tableStyles', function () {
	                    writer.writeAttributeString('count', '0');
	                    writer.writeAttributeString('defaultTableStyle', 'TableStyleMedium2');
	                    writer.writeAttributeString('defaultPivotStyle', 'PivotStyleLight16');
	                });
	            }
	           
	            if (writerDataModel._customerSlicerStyles.length > 0) {
	                writer.writeElement('extLst', function () {
	                    writeSlicerDxfs(writer, writerDataModel);
	                    writeSlicerStyles(writer, writerDataModel._customerSlicerStyles);
	                });
	            }
	        });
	        return {xml: writer.xml, styleOffset: styleObject._styleOffset};
	    }
	
	    function writeSlicerDxfs(writer, writerDataModel) {
	        writer.writeElement('ext', function () {
	            writer.writeAttributeString('uri', '{46F421CA-312F-682f-3DD2-61675219B42D}');
	            writer.writeAttributeString('xmlns:x14', XFileConstants._slicerNameSpace);
	        }, function () {
	            writeDifferentialFormattingsSlicer(writer, writerDataModel);
	        });
	    }
	
	    function writeSlicerStyles(writer, slicerStyles) {
	        writer.writeElement('ext', function () {
	            writer.writeAttributeString('uri', '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}');
	            writer.writeAttributeString('xmlns:x14', XFileConstants._slicerNameSpace);
	        }, function () {
	            writer.writeElement('x14:slicerStyles', function () {
	                writer.writeAttributeString('defaultSlicerStyle', 'SlicerStyleLight1');
	            }, function () {
	                if (slicerStyles && slicerStyles.length) {
	                    slicerStyles.forEach(function (slicerStyle) {
	                        writer.writeElement('x14:slicerStyle', function () {
	                            writer.writeAttributeString('name', slicerStyle.name);
	                        }, function () {
	                            if (slicerStyle.styleElements && slicerStyle.styleElements.length) {
	                                writer.writeElement('x14:slicerStyleElements', function () {
	                                    slicerStyle.styleElements.forEach(function (styleElement) {
	                                        writer.writeLeafElement('x14:slicerStyleElement', function () {
	                                            writer.writeAttributeString('type', SpreadJSSlicerThemeType2ExcelThemeType[styleElement.type]);
	                                            writer.writeAttributeString('dxfId', styleElement.dxfId);
	                                        });
	                                    });
	
	                                });
	                            }
	                        });
	                    });
	
	                }
	            });
	        });
	    }
	
	    function removeDoubleQuotationMarksIfNeeded(font) {
	        var fontName = font && font.fontName;
	        if (fontName) {
	            if (fontName.charAt(0) === '"') {
	                fontName = fontName.substr(1);
	            }
	            if (fontName.charAt(fontName.length - 1) === '"') {
	                fontName = fontName.substring(0, fontName.length - 1);
	            }
	            font.fontName = fontName;
	        }
	        return font;
	    }
	
	    function generateExcelStyle(writerDataModel, xfMap) {
	        var styleObject = {
	            _styleOffset: 0,
	            _styleFonts: [],
	            _styleFills: [],
	            _styleBorders: [],
	            _numberFormats: {count: 0},
	            _styleXfs: keyword_undefined,
	            _styles: keyword_undefined,
	            _cellXfsStyles: writerDataModel._getExcelCellXfsStyles()
	        };
	        var formats = writerDataModel._getExcelCellFormats();
	        var defaultCellFormat = writerDataModel._getExcelDefaultFormat();
	        var styles = writerDataModel._getExcelStyles();
	        if (!styles || styles.length === 0) {
	            if (defaultCellFormat) {
	                var defaultStyle = new ExcelStyle();
	                defaultStyle.builtInStyle = 0 ;
	                defaultStyle.name = 'Normal';
	                defaultStyle.format(defaultCellFormat);
	                styles = [];
	                styles.push(defaultStyle);
	            } else {
	                styles = [];
	                styles.push(excelStyle.BuiltInExcelStyles.getNormalStyle());
	            }
	        }
	        var normal = 'Normal';
	        if (styles) {
	            for (var i = 0, len = styles.length; i < len; i++) {
	                var item = styles[i];
	                if (item.isBuiltInStyle() && item.builtInStyle === 0 ) {
	                    normal = item.name;
	                }
	            }
	        }
	        styleObject._styles = styles;
	        var normalStyle = Util._firstOrDefault(styles, function (item) { 
	            return item.name === normal;
	        }, null);
	        var firstNoStyleFormat = Util._firstOrDefault(formats, function (item) { 
	            return !item.isStyleFormat;
	        }, null);
	        var firstStyleFormat = Util._firstOrDefault(formats, function (item) { 
	            return item.isStyleFormat;
	        }, null);
	
	        if (firstNoStyleFormat === null || !firstNoStyleFormat.equals(defaultCellFormat)) {
	            formats.splice(0, 0, defaultCellFormat);
	            styleObject._styleOffset += 1;
	        }
	        if (firstStyleFormat === null || !firstStyleFormat.equals(normalStyle.format())) {
	            formats.splice(0, 0, normalStyle.format());
	            styleObject._styleOffset += 1;
	        }
	        var fontId = 0, formatId = 0, fillId = 0, borderId = 0;
	
	        var font = removeDoubleQuotationMarksIfNeeded(normalStyle.format().font);
	       
	        styleObject._styleFonts.push(font);
	
	       
	        styleObject._styleFills.push(new Tuple(0 , ExcelColor.EmptyColor, ExcelColor.EmptyColor));
	        styleObject._styleFills.push(new Tuple(17 , ExcelColor.EmptyColor, ExcelColor.EmptyColor));
	
	       
	        styleObject._styleBorders.push(new excelStyle.ExcelBorder());
	        styleObject._styleCellXfs = [];
	        styleObject._styleXfs = [];
	        var index = 0;
	
	        for (i = 0, len = formats.length; i < len; i++) {
	            var style = formats[i];
	            if (style.font) {
	                fontId = Util._indexOf(styleObject._styleFonts, style.font);
	                if (fontId === -1) {
	                    styleObject._styleFonts.push(removeDoubleQuotationMarksIfNeeded(style.font));
	                    fontId = styleObject._styleFonts.length - 1;
	                }
	            }
	            if (style.numberFormat) {
	                formatId = style.numberFormat.numberFormatId;
	                if (styleObject._numberFormats[formatId] === undefined) {
	                    styleObject._numberFormats.count++;
	                }
	                styleObject._numberFormats[formatId] = style.numberFormat.numberFormatCode;
	            } else if (style.numberFormatIndex >= 0) {
	                formatId = style.numberFormatIndex;
	            }
	            if (style.border) {
	                borderId = Util._indexOf(styleObject._styleBorders, style.border);
	                if (borderId === -1) {
	                    styleObject._styleBorders.push(style.border);
	                    borderId = styleObject._styleBorders.length - 1;
	                }
	            }
	            if (style.fillPattern === 0 ) {
	                fillId = 0;
	            } else {
	                var fill = new Tuple(style.fillPattern, style.patternColor ? style.patternColor : ExcelColor.EmptyColor, style.patternBackgroundColor ? style.patternBackgroundColor : ExcelColor.EmptyColor);
	                fillId = Util._indexOf(styleObject._styleFills, fill);
	                if (fillId === -1) {
	                    styleObject._styleFills.push(fill);
	                    fillId = styleObject._styleFills.length - 1;
	                }
	            }
	            if (style.isStyleFormat) {
	                xfMap[index++] = styleObject._styleXfs.length.toString();
	                styleObject._styleXfs.push(new Tuple(formatId, fontId, fillId, borderId, 0, style, new Tuple(style.isHidden, style.isLocked)));
	            } else {
	                xfMap[index++] = styleObject._styleCellXfs.length.toString();
	                styleObject._styleCellXfs.push(new Tuple(formatId, fontId, fillId, borderId, 0, style, new Tuple(style.isHidden, style.isLocked)));
	            }
	        }
	        return styleObject;
	    }
	
	    function writeNumFmt(writer, format) {
	        if (format.key < 0) {
	            return;
	        }
	        writer.writeLeafElement('numFmt', function () {
	            writer.writeAttributeString('numFmtId', format.key.toString());
	            writer.writeAttributeString('formatCode', Util._xmlEncode(format.value.toString()));
	        });
	    }
	
	    function writeFont(writer, font, isPartFontStyle) {
	        if (!font) {
	            return;
	        }
	        writer.writeElement('font', keyword_undefined, function () {
	            if (font.isBold) {
	                writer.writeLeafElement('b');
	            }
	            if (font.isItalic) {
	                writer.writeLeafElement('i');
	            }
	            if (font.isStrikeOut) {
	                writer.writeLeafElement('strike');
	            }
	            if (font.underLineStyle !== 0 ) {
	                if (font.underLineStyle === 1 ) {
	                    writer.writeLeafElement('u');
	                } else {
	                    writer.writeLeafElement('u', function () {
	                        writer.writeAttributeString('val', excelStyle.UnderLineStyle[font.underLineStyle]);
	                    });
	                }
	            }
	            if (font.fontColor && font.fontColor !== ExcelColor.EmptyColor) {
	                writeColor(writer, 'color', font.fontColor);
	            }
	            if (!isPartFontStyle) {
	                if (font.verticalAlignRun !== 0 ) {
	                    writer.writeLeafElement('vertAlign', function () {
	                        writer.writeAttributeString('val', excelStyle.VerticalAlignRun[font.verticalAlignRun]);
	                    });
	                }
	                if (font.fontSize !== 0 || font.fontSize !== -1) {
	                    var result = font.fontSize;
	                    if (result > 0) {
	                        writer.writeLeafElement('sz', function () {
	                            writer.writeAttributeString('val', result.toString());
	                        });
	                    }
	                }
	                if (!StringEx._isNullOrWhiteSpace(font.fontName)) {
	                    writer.writeLeafElement('name', function () {
	                        writer.writeAttributeString('val', font.fontName);
	                    });
	                }
	                if (font.fontFamily !== 0 ) {
	                    writer.writeLeafElement('family', function () {
	                        writer.writeAttributeString('val', font.fontFamily.toString());
	                    });
	                }
	                if (font.charSetIndex > 0) {
	                    writer.writeLeafElement('charset', function () {
	                        writer.writeAttributeString('val', font.charSetIndex.toString());
	                    });
	                }
	                if (font.isShadowStyle) {
	                    writer.writeLeafElement('shadow', function () {
	                        writer.writeAttributeString('val', '1');
	                    });
	                }
	                if (font.isOutlineStyle) {
	                    writer.writeLeafElement('outline', function () {
	                        writer.writeAttributeString('val', '1');
	                    });
	                }
	                if (font.fontScheme !== 0 ) {
	                    writer.writeLeafElement('scheme', function () {
	                        writer.writeAttributeString('val', FontSchemeCategory[font.fontScheme]);
	                    });
	                }
	            }
	        });
	    }
	
	    function writeFill(writer, fill) {
	        writer.writeElement('fill', keyword_undefined, function () {
	            var hasPatternType = !isNullOrUndefined(fill.item1), 
	                hasFgColor = fill.item2 && fill.item2 !== ExcelColor.EmptyColor, 
	                hasBgColor = fill.item3 && fill.item3 !== ExcelColor.EmptyColor;
	
	            if (hasPatternType && !hasFgColor && !hasBgColor) {
	                writer.writeLeafElement('patternFill', function () {
	                    writer.writeAttributeString('patternType', excelStyle.FillPatternType[fill.item1]);
	                });
	            } else if (hasPatternType) {
	                writer.writeElement('patternFill', function () {
	                    writer.writeAttributeString('patternType', excelStyle.FillPatternType[fill.item1]);
	                }, function () {
	                    if (hasFgColor) {
	                        writeColor(writer, 'fgColor', fill.item2);
	                    }
	                    if (hasBgColor) {
	                        writeColor(writer, 'bgColor', fill.item3);
	                    }
	                });
	            }
	        });
	    }
	
	    function writeBorder(writer, border, isSlicerHeader) {
	        writer.writeElement('border', function () {
	            if (border.diagonalDown && border.diagonalDown.color && border.diagonalDown.lineStyle) {
	                writer.writeAttributeString('diagonalDown', 1);
	            }
	            if (border.diagonalUp && border.diagonalUp.color && border.diagonalUp.lineStyle) {
	                writer.writeAttributeString('diagonalUp', 1);
	            }
	        }, function () {
	            if (!isSlicerHeader || isSlicerHeader && border.left) {
	                writeBorderSide(writer, 'left', border.left);
	            }
	            if (!isSlicerHeader || isSlicerHeader && border.right) {
	                writeBorderSide(writer, 'right', border.right);
	            }
	            if (!isSlicerHeader || isSlicerHeader && border.top) {
	                writeBorderSide(writer, 'top', border.top);
	            }
	            if (!isSlicerHeader || isSlicerHeader && border.bottom) {
	                writeBorderSide(writer, 'bottom', border.bottom);
	            }
	            if (border.vertical) {
	                writeBorderSide(writer, 'vertical', border.vertical);
	            }
	            if (border.horizontal) {
	                writeBorderSide(writer, 'horizontal', border.horizontal);
	            }
	            var isDiagonalUpWrite = false;
	            if (border.diagonalUp && border.diagonalUp.color && border.diagonalUp.lineStyle) {
	                writeBorderSide(writer, 'diagonal', border.diagonalUp);
	                isDiagonalUpWrite = true;
	            }
	            if (border.diagonalDown && border.diagonalDown.color && border.diagonalDown.lineStyle && !isDiagonalUpWrite) {
	                writeBorderSide(writer, 'diagonal', border.diagonalDown);
	            }
	        });
	    }
	
	    function writeBorderSide(writer, node, side) {
	        if (!side) {
	            return;
	        }
	        if (side.lineStyle === 0  && !side.color) {
	            writer.writeLeafElement(node);
	        } else {
	            writer.writeElement(node, function () {
	                if (side.lineStyle !== 0 ) {
	                    writer.writeAttributeString('style', excelStyle.ExcelBorderStyle[side.lineStyle]);
	                }
	            }, function () {
	                if (side.color) {
	                    writeColor(writer, 'color', side.color);
	                }
	            });
	        }
	    }
	
	    function writeXFs(writer, xfs, root, isCellStyleXfs, xfMap) {
	        if (xfs.length === 0) {
	            writer.writeElement(root, function () {
	                writer.writeAttributeString('count', '1');
	            }, function () {
	                writer.writeLeafElement('xf', function () {
	                    writer.writeAttributeString('numFmtId', '0');
	                    writer.writeAttributeString('fontId', '0');
	                    writer.writeAttributeString('fillId', '0');
	                    writer.writeAttributeString('borderId', '0');
	                    if (!isCellStyleXfs) {
	                        writer.writeAttributeString('xfId', '0');
	                    }
	                });
	            });
	        } else {
	            writer.writeElement(root, function () {
	                writer.writeAttributeString('count', xfs.length.toString());
	            }, function () {
	                for (var i = 0, len = xfs.length; i < len; i++) {
	                    var item = xfs[i], item6 = item.item6, item7 = item.item7,
	                        hasAlignment = item6.horizontalAlign !== 0  ||
	                            item6.verticalAlign !== 2  || item6.rotation !== 0 ||
	                            item6.readingOrder !== 0  || item6.isWordWrap ||
	                            item6.isShrinkToFit || item6.isJustfyLastLine || item6.indent > 0,
	                        hasProtection = item7 && (item7.item1 || !item7.item2), method = 'writeElement';
	                    if (!hasAlignment && !hasProtection) {
	                        method = 'writeLeafElement';
	                    }
	                    writer[method]('xf', function () { 
	                        writer.writeAttributeString('numFmtId', item.item1.toString());
	                        writer.writeAttributeString('fontId', item.item2.toString());
	                        writer.writeAttributeString('fillId', item.item3.toString());
	                        writer.writeAttributeString('borderId', item.item4.toString());
	
	                        if (item6) {
	                            if (!isCellStyleXfs) {
	                                if (!item6.isStyleFormat && !isNullOrUndefined(item6.parentFormatID)) {
	                                    var id = xfMap[item6.parentFormatID];
	                                    if (!isNullOrUndefined(id)) {
	                                        writer.writeAttributeString('xfId', id.toString());
	                                    } else {
	                                        writer.writeAttributeString('xfId', '0');
	                                    }
	                                } else {
	                                    writer.writeAttributeString('xfId', '0');
	                                }
	                            }
	                            if (!isNullOrUndefined(item6.applyNumberFormat)) {
	                                writer.writeAttributeString('applyNumberFormat', item6.applyNumberFormat === true ? '1' : '0');
	                            }
	                            if (!isNullOrUndefined(item6.applyFont)) {
	                                writer.writeAttributeString('applyFont', item6.applyFont === true ? '1' : '0');
	                            }
	                            if (!isNullOrUndefined(item6.applyFill)) {
	                                writer.writeAttributeString('applyFill', item6.applyFill === true ? '1' : '0');
	                            }
	                            if (!isNullOrUndefined(item6.applyBorder)) {
	                                writer.writeAttributeString('applyBorder', item6.applyBorder === true ? '1' : '0');
	                            }
	                            if (!isNullOrUndefined(item6.applyAlignment)) {
	                                writer.writeAttributeString('applyAlignment', item6.applyAlignment === true ? '1' : '0');
	                            }
	                            if (!isNullOrUndefined(item6.applyProtection)) {
	                                writer.writeAttributeString('applyProtection', item6.applyProtection === true ? '1' : '0');
	                            }
	                            if (!isNullOrUndefined(item6.quotePrefix)) {
	                                writer.writeAttributeString('quotePrefix', item6.quotePrefix === true ? '1' : '0');
	                            }
	                        }
	                    }, function () { 
	                        if (hasAlignment) {
	                            writer.writeLeafElement('alignment', function () {
	                                if (item6.horizontalAlign !== 0 ) {
	                                    writer.writeAttributeString('horizontal', excelStyle.ExcelHorizontalAlignment[item6.horizontalAlign]);
	                                }
	                                if (item6.verticalAlign !== 2 ) {
	                                    writer.writeAttributeString('vertical', ExcelVerticalAlignment[item6.verticalAlign]);
	                                }
	                                if (item6.rotation !== 0) {
	                                    writer.writeAttributeString('textRotation', item6.rotation.toString());
	                                }
	                                if (item6.isVerticalText === true) {
	                                    writer.writeAttributeString('textRotation', 255);
	                                }
	                                if (item6.readingOrder !== 0 ) {
	                                    writer.writeAttributeString('readingOrder', excelStyle.TextDirection[item6.readingOrder]);
	                                }
	                                if (item6.isWordWrap) {
	                                    writer.writeAttributeString('wrapText', '1');
	                                }
	                                if (item6.isShrinkToFit) {
	                                    writer.writeAttributeString('shrinkToFit', '1');
	                                }
	                                if (item6.isJustfyLastLine) {
	                                    writer.writeAttributeString('justifyLastLine', '1');
	                                }
	                                if (item6.indent > 0) {
	                                    writer.writeAttributeString('indent', item6.indent.toString());
	                                }
	                            });
	                        }
	                        if (hasProtection) {
	                            writer.writeLeafElement('protection', function () {
	                                if (!item7.item2) {
	                                    writer.writeAttributeString('locked', '0');
	                                }
	                                if (item7.item1) {
	                                    writer.writeAttributeString('hidden', '1');
	                                }
	                            });
	                        }
	                    });
	                }
	            });
	        }
	    }
	
	    function writeDefaultNormalStyle(writer) {
	        writer.writeElement('cellStyles', function () {
	            writer.writeAttributeString('count', '1');
	        }, function () {
	            writer.writeLeafElement('cellStyle', function () {
	                writer.writeAttributeString('name', 'Normal');
	                writer.writeAttributeString('builtinId', '0');
	                writer.writeAttributeString('xfId', '0');
	            });
	        });
	    }
	
	    function writeDifferentialFormattings(writer, writerDataModel, dxfRecords) {
	        var dxfs = (dxfRecords ? dxfRecords : writerDataModel._dxfRecords);
	        if (dxfs.length === 0) {
	            writer.writeLeafElement('dxfs', function () {
	                writer.writeAttributeString('count', '0');
	            });
	        } else {
	            writer.writeElement('dxfs', function () {
	                writer.writeAttributeString('count', dxfs.length);
	            }, function () {
	                for (var i = 0; i < dxfs.length; i++) {
	                    writeDxf(writer, dxfs[i], 'dxf');
	                }
	            });
	        }
	    }
	
	    function writeDifferentialFormattingsSlicer(writer, writerDataModel) {
	        var dxfs = writerDataModel._dxfSlicerRecords;
	        if (dxfs.length === 0) {
	            writer.writeLeafElement('x14:dxfs', function () {
	                writer.writeAttributeString('count', '0');
	            });
	        } else {
	            writer.writeElement('x14:dxfs', function () {
	                writer.writeAttributeString('count', dxfs.length);
	            }, function () {
	                for (var i = 0; i < dxfs.length; i++) {
	                    writeDxf(writer, dxfs[i], 'dxf');
	                }
	            });
	        }
	    }
	
	    function writeDxf(writer, dxf, rootName) {
	        writer.writeElement(rootName, function () {
	            var style = dxf.isColorFilter ? dxf : ConverterHelper.toDifferentialFormatting(dxf);
	            if (style.font) {
	                writeFont(writer, style.font, style.isPartFontStyle);
	            }
	            if (style.numberFormat || style.numberFormatIndex >= 0) {
	                var id, formatCode;
	                if (style.numberFormat) {
	                    id = style.numberFormat.numberFormatId;
	                    formatCode = style.numberFormat.numberFormatCode;
	                } else {
	                    id = style.numberFormatIndex;
	                    formatCode = style.numberFormatCode;
	                }
	                writeNumFmt(writer, {key: id, value: formatCode});
	            }
	            if (style.fill) {
	                writeFill(writer, style.fill);
	            }
	            if (style.border) {
	                writeBorder(writer, style.border, style.isSlicerHeader);
	            }
	        });
	    }
	
	    exports._writeStyle = writeStyle;
	    exports._writeDxf = writeDxf;
	
	
	}());

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excelStyle = __webpack_require__(12);
	    var ConverterHelper = excelStyle.ConverterHelper;
	    var ColorHelper = excelStyle.ColorHelper;
	    
	    function writeColor(writer, node, color) {
	        if (!color) {
	            return;
	        }
	        writer.writeLeafElement(node, function () {
	            if (color.isAutoColor()) {
	                writer.writeAttributeString('auto', '1');
	                return;
	            }
	            if (color.isIndexedColor()) {
	                writer.writeAttributeString('indexed', color.value().toString());
	            } else if (color.isThemeColor()) {
	                writer.writeAttributeString('theme', color.value().toString());
	                if (color.tint() !== 0.0) {
	                    writer.writeAttributeString('tint', color.tint().toString());
	                }
	            } else if (color.isRGBColor()) {
	                var colorStr = color.value().toString(16);
	                writer.writeAttributeString('rgb', colorStr.toUpperCase());
	                if (color.tint() !== 0.0) {
	                    writer.writeAttributeString('tint', color.tint().toString());
	                }
	            }
	        });
	    }
	    
	    function writeColorScheme(writer, node, color) {
	        if (!color) {
	            return;
	        }
	        writer.writeElement(node, undefined, function () {
	            if (node === 'a:dk1') {
	                writer.writeLeafElement('a:sysClr', function () {
	                    writer.writeAttributeString('val', 'windowText');
	                    writer.writeAttributeString('lastClr', '000000');
	                });
	            } else if (node === 'a:lt1') {
	                writer.writeLeafElement('a:sysClr', function () {
	                    writer.writeAttributeString('val', 'window');
	                    writer.writeAttributeString('lastClr', 'FFFFFF');
	                });
	            } else if (color.colorType() === 2 ) {
	                writer.writeLeafElement('a:srgbClr', function () {
	                    writer.writeAttributeString('val', color.value().toString(16).substring(2));
	                });
	            } else if (color.colorType() === 3 ) {
	                writer.writeLeafElement('a:schemeClr', function () {
	                    writer.writeAttributeString('val', ConverterHelper.toSchemeClrValue(color.value()));
	                });
	            } else if (color.colorType() === 1 ) {
	                var rgbColor = ColorHelper.toExcelIndexedColor(color);
	                writer.writeLeafElement('a:srgbClr', function () {
	                    writer.writeAttributeString('val', rgbColor && rgbColor.value ? rgbColor.value().toString(16) : '0');
	                });
	            }
	        });
	    }
	    
	    module.exports = {
	        writeColor: writeColor,
	        writeColorScheme: writeColorScheme
	    };
	
	}());

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var writeColor = __webpack_require__(46).writeColor;
	    var Tuple = __webpack_require__(14);
	    var sparklineWriter = __webpack_require__(48);
	    var conditionaFormatWriter = __webpack_require__(49);
	    var writeSlicersInWorkSheet = __webpack_require__(50)._writeSlicersInWorkSheet;
	    var writeConditionalFormating = conditionaFormatWriter.writeConditionalFormating;
	    var writeExtensionConditionalFormats = conditionaFormatWriter.writeExtensionConditionalFormats;
	    var needWriteConditionalFormatExtension = conditionaFormatWriter.needWriteConditionalFormatExtension;
	    var writeAutoFilterForSheet = __webpack_require__(51)._writeAutoFilterForSheet;
	    var writeDataValidations = __webpack_require__(52)._writeDataValidations;
	    var writeExtensionDataValidations = __webpack_require__(52)._writeExtensionDataValidations;
	    var writePrint = __webpack_require__(53);
	    var ExcelConstants = excel._ExcelConstants;
	    var XFileConstants = excel._XFileConstants;
	    var StringEx = common._StringEx;
	    var Range = common._Range;
	    var IndexHelper = common._IndexHelper;
	    var Util = common._Util;
	    var keywords_undefined = void 0;
	
	
	    var specialFunction = ['AVERAGEIF',
	        'AVERAGEIFS',
	        'CUBEKPIMEMBER',
	        'CUBEMEMBER',
	        'CUBEMEMBERPROPERTY',
	        'CUBERANKEDMEMBER',
	        'CUBESET',
	        'CUBESETCOUNT',
	        'CUBEVALUE',
	        'COUNTIFS',
	        'IFERROR',
	        'SUMIFS',
	        'ACOT',
	        'ACOTH',
	        'AGGREGATE',
	        'ARABIC',
	        'BASE',
	        'BETA.DIST',
	        'BETA.INV',
	        'BINOM.DIST',
	        'BINOM.DIST.RANGE',
	        'BINOM.INV',
	        'BITAND',
	        'BITLSHIFT',
	        'BITOR',
	        'BITRSHIFT',
	        'BITXOR',
	        'CEILING.MATH',
	        'CEILING.PRECISE',
	        'CHISQ.DIST',
	        'CHISQ.DIST.RT',
	        'CHISQ.INV',
	        'CHISQ.INV.RT',
	        'CHISQ.TEST',
	        'COMBINA',
	        'CONCAT',
	        'CONFIDENCE.T',
	        'COT',
	        'COVARIANCE.P',
	        'COVARIANCE.S',
	        'CSC',
	        'CSCH',
	        'DAYS',
	        'DECIMAL',
	        'ENCODEURL',
	        'ERF.PRECISE',
	        'ERFC.PRECISE',
	        'EXPON.DIST',
	        'F.DIST',
	        'F.DIST.RT',
	        'F.INV',
	        'F.INV.RT',
	        'FILTERXML',
	        'FLOOR.MATH',
	        'FLOOR.PRECISE',
	        'FORMULATEXT',
	        'GAMMA',
	        'GAMMA.DIST',
	        'GAMMA.INV',
	        'GAMMALN.PRECISE',
	        'HYPGEOM.DIST',
	        'IFNA',
	        'IFS',
	        'IMCOSH',
	        'IMCOT',
	        'IMCSCH',
	        'IMSEC',
	        'IMSECH',
	        'IMSINH',
	        'IMTAN',
	        'ISFORMULA',
	        'ISOWEEKNUM',
	        'LOGNORM.DIST',
	        'LOGNORM.INV',
	        'MAXIFS',
	        'MINIFS',
	        'MODE.MULT',
	        'MODE.SNGL',
	        'MUNIT',
	        'NEGBINOM.DIST',
	        'NORM.DIST',
	        'NORM.INV',
	        'NORM.S.DIST',
	        'NORM.S.INV',
	        'NUMBERVALUE',
	        'PDURATION',
	        'PERCENTILE.EXC',
	        'PERCENTILE.INC',
	        'PERCENTRANK.EXC',
	        'PERCENTRANK.INC',
	        'PERMUTATIONA',
	        'PHI',
	        'POISSON.DIST',
	        'QUARTILE.EXC',
	        'QUARTILE.INC',
	        'RANK.AVG',
	        'RANK.EQ',
	        'RRI',
	        'SECH',
	        'SHEET',
	        'SHEETS',
	        'STDEV.P',
	        'STDEV.S',
	        'SWITCH',
	        'T.DIST',
	        'T.DIST.2T',
	        'T.DIST.RT',
	        'T.INV',
	        'T.INV.2T',
	        'TEXTJOIN',
	        'UNICHAR',
	        'UNICODE',
	        'VAR.P',
	        'VAR.S',
	        'WEBSERVICE',
	        'WEIBULL.DIST',
	        'XOR',
	        'Z.TEST'
	    ];
	
	    function writeWorksheet(writerDataModel, sheetName, xfMap, styleOffset, options, sharedString, extensions) {
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('worksheet', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._workbookNameSpace);
	            writer.writeAttributeString('xmlns:r', XFileConstants._relationShipNameSpace);
	            writer.writeAttributeString('xmlns:mc', XFileConstants._markupCompatibility);
	            if (extensions && extensions.attributes) {
	                extensions.attributes.forEach(function (pair) {
	                    writer.writeAttributeString(pair.key, pair.value);
	                });
	            }
	            writer.writeAttributeString('xmlns:x14ac', XFileConstants._ac);
	            writer.writeAttributeString('mc:Ignorable', XFileConstants._ignorable);
	        }, function () {
	            writeSheetPr(writer, sheetName, writerDataModel);
	            writeDimension(writer, sheetName, writerDataModel);
	            writeSheetViews(writer, sheetName, writerDataModel);
	            writeSheetFormatPr(writer, sheetName, writerDataModel);
	            writeColumnInfo(writer, sheetName, writerDataModel, xfMap, styleOffset);
	            writeSheetData(writer, sheetName, writerDataModel, options, xfMap, styleOffset, sharedString);
	            writeSheetProtection(writer, sheetName, writerDataModel);
	            writeAutoFilterForSheet(writer, sheetName, writerDataModel);
	            writeMergeCells(writer, sheetName, writerDataModel);
	            writeConditionalFormating(writer, sheetName, writerDataModel);
	            writeDataValidations(writer, sheetName, writerDataModel);
	           
	            writePrint._writePrintOptions(writer, sheetName, writerDataModel);
	            writePrint._writePageMargins(writer, sheetName, writerDataModel);
	            writePrint._writePageSetup(writer, sheetName, writerDataModel);
	            writePrint._writeHeadFooter(writer, sheetName, writerDataModel);
	            writePrint._writeRowColumnBreaks(writer, sheetName, writerDataModel);
	
	            if (extensions) {
	                var rids = [
	                    {name: 'drawing', value: extensions.drawingId},
	                    {name: 'legacyDrawing', value: extensions.legacyDrawingId}
	                ];
	               
	                for (var i = 0; i < 2; i++) {
	                    var pair = rids[i];
	                    var rid = pair.value;
	                    if (rid) {
	                        writer.writeLeafElement(pair.name, function () { 
	                            writer.writeAttributeString('r:id', rid);
	                        });
	                    }
	                }
	            }
	           
	            writePrint._writeLegacyDrawingHF(writer, writerDataModel);
	            if (writerDataModel._getTables(sheetName) && writerDataModel._getTables(sheetName).length > 0) {
	                writeTableParts(writer, writerDataModel._getTables(sheetName));
	            }
	            if (needwriteExtension(writerDataModel, sheetName)) {
	                writeExtensions(writer, sheetName, writerDataModel);
	            }
	        });
	        return writer.xml;
	    }
	
	    function needwriteExtension(writerDataModel, sheetName) {
	        var slicers = writerDataModel._getSlicers(sheetName);
	        if (slicers && slicers.length > 0) {
	            return true;
	        }
	        var sparklineGroups = writerDataModel._getSparklineGroups(sheetName);
	        if (sparklineGroups && sparklineGroups.length > 0) {
	            return true;
	        }
	        var conditionalFormats = writerDataModel._getConditionalFormatting(sheetName);
	        var rules = conditionalFormats && conditionalFormats.rules;
	        if (rules && needWriteConditionalFormatExtension(rules, sheetName, writerDataModel._getSheetsName())) {
	            return true;
	        }
	        var extensionDataValidations = writerDataModel._extensionDataValidations;
	        if (extensionDataValidations && extensionDataValidations.length > 0) {
	            return true;
	        }
	        return false;
	    }
	
	    function writeSheetPr(writer, sheetName, writerDataModel) {
	        var ret = writerDataModel._getOutlineDirection(sheetName);
	        var colsSumRight = ret.colsSumRight, rowsSumBelow = ret.rowsSumBelow;
	        var sheetTabColor = writerDataModel._getSheetTabColor(sheetName);
	        var printSetting = writerDataModel._getPrintPageSetting(sheetName, true);
	        var useSmartPrint = printSetting && printSetting.useSmartPrint;
	        if (sheetTabColor || !colsSumRight || !rowsSumBelow || useSmartPrint === true) {
	            writer.writeElement('sheetPr', function () {
	                if (sheetTabColor !== null) {
	                    writeColor(writer, 'tabColor', sheetTabColor);
	                }
	                if (!colsSumRight || !rowsSumBelow) {
	                    writer.writeLeafElement('outlinePr', function () {
	                        if (!colsSumRight) {
	                            writer.writeAttributeString('summaryRight', '0');
	                        }
	                        if (!rowsSumBelow) {
	                            writer.writeAttributeString('summaryBelow', '0');
	                        }
	                    });
	                }
	                if (useSmartPrint === true) {
	                    writer.writeLeafElement('pageSetUpPr', function () {
	                        writer.writeAttributeString('fitToPage', '1');
	                    });
	                }
	            });
	        }
	    }
	
	    function writeDimension(writer, sheetName, writerDataModel) {
	        var ret = writerDataModel._getDimensions(sheetName);
	        var columnCount = ret.columnCount, rowCount = ret.rowCount;
	        if (columnCount > 0 && rowCount > 0) {
	            writer.writeLeafElement('dimension', function () {
	                writer.writeAttributeString('ref', 'A1:' + writerDataModel._getColumnIndexInA1LetterForm(columnCount - 1) + rowCount);
	            });
	        } else {
	            writer.writeLeafElement('dimension', function () {
	                writer.writeAttributeString('ref', 'A1');
	            });
	        }
	    }
	
	    function writeSheetViews(writer, sheetName, writerDataModel) {
	        writer.writeElement('sheetViews', keywords_undefined, function () {
	            writer.writeElement('sheetView', function () {
	                var ret = writerDataModel._getDisplayElements(sheetName);
	                var gridlineColor = ret.gridlineColor;
	                if (gridlineColor !== null && gridlineColor.colorType() === 1  && gridlineColor.value() !== 64) {
	                    writer.writeAttributeString('defaultGridColor', '0');
	                    writer.writeAttributeString('colorId', gridlineColor.value().toString());
	                }
	                if (!ret.showGridLine) {
	                    writer.writeAttributeString('showGridLines', '0');
	                }
	                if (!ret.showRowColHeaders) {
	                    writer.writeAttributeString('showRowColHeaders', '0');
	                }
	                var zoom = ret.zoom;
	                if (Math.abs(1 - zoom) > 0.1) {
	                    writer.writeAttributeString('zoomScale', (Math.round(zoom * 100)).toString());
	                }
	                writer.writeAttributeString('workbookViewId', '0');
	            }, function () {
	                var ret = writerDataModel._getFrozen(sheetName);
	                var x = ret.frozenColCount, y = ret.frozenRowCount, colLeft = 0, rowTop = 0, activePane = 3;
	                if (x > 0 || y > 0) {
	                    if (x > 0) {
	                        colLeft = x;
	                    } else {
	                        colLeft = 0;
	                    }
	                    if (y > 0) {
	                        rowTop = y;
	                    } else {
	                        rowTop = 0;
	                    }
	                    if (x > 0 && y === 0) {
	                        activePane = 1 ;
	                    } else if (x === 0 && y > 0) {
	                        activePane = 2 ;
	                    } else if (x > 0 && y > 0) {
	                        activePane = 0 ;
	                    }
	                    writer.writeLeafElement('pane', function () {
	                        if (x > 0) {
	                            writer.writeAttributeString('xSplit', x.toString());
	                        }
	                        if (y > 0) {
	                            writer.writeAttributeString('ySplit', y.toString());
	                        }
	                        writer.writeAttributeString('topLeftCell', '' + writerDataModel._getColumnIndexInA1LetterForm(colLeft) + (rowTop + 1));
	                        writer.writeAttributeString('activePane', excel.PaneType[activePane]);
	                        writer.writeAttributeString('state', 'frozen');
	                    });
	                }
	                var selectionList = [];
	                var activeCell = new Range();
	                var selIndex = 0, selCount = 1, activeCellSelectionIndex = -1;
	                for (var index = 3; index >= 0; index--) {
	                    selectionList.length = 0;
	                    var paneIndex = index;
	                    if (writerDataModel._getSelectionList(sheetName, selectionList, activeCell, paneIndex)) {
	                        selCount = selectionList.length;
	                        for (selIndex = 0; selIndex < selCount; selIndex++) {
	                            var r = selectionList[selIndex];
	                            if (r.col === -1 || r.colCount === -1) {
	                                r = new Range(r.row, 0, r.rowCount, ExcelConstants._openXmlMaxColumn);
	                            }
	                            if (r.row === -1 || r.rowCount === -1) {
	                                r = new Range(0, r.col, ExcelConstants._openXmlMaxRow, r.colCount);
	                            }
	                            if ((activeCell.col >= r.col && activeCell.col <= r.col + r.colCount - 1) &&
	                                (activeCell.row >= r.row && activeCell.row <= r.row + r.rowCount - 1)) {
	                                activeCellSelectionIndex = selIndex;
	                            }
	                        }
	                       
	                        if (activeCellSelectionIndex < 0 && selCount > 0) {
	                            activeCell.row = selectionList[0].row;
	                            activeCell.col = selectionList[0].col;
	                        }
	                        var activeCellStr = '' + writerDataModel._getColumnIndexInA1LetterForm(activeCell.col) + (activeCell.row + 1);
	                        var sqref = '';
	                        if (x > 0 && y > 0 && (paneIndex === 1  || paneIndex === 2 )) {
	                            sqref = activeCellStr;
	                        } else {
	                            for (selIndex = 0; selIndex < selCount; selIndex++) {
	                                var selection = selectionList[selIndex];
	                                var firstRow = Math.min(ExcelConstants._openXmlMaxRow, selection.row + 1),
	                                    firstColumn = Math.min(selection.col, ExcelConstants._openXmlMaxColumn);
	                                sqref += '' + writerDataModel._getColumnIndexInA1LetterForm(firstColumn) + firstRow;
	                                if (selection.colCount > 1 || selection.rowCount > 1) {
	                                    var endColumn = Math.min(firstColumn + selection.colCount - 1, ExcelConstants._openXmlMaxColumn),
	                                        endRow = Math.min(firstRow + selection.rowCount - 1, ExcelConstants._openXmlMaxRow);
	                                    var end = '' + writerDataModel._getColumnIndexInA1LetterForm(endColumn) + endRow;
	                                    sqref += ':' + end;
	                                }
	                                sqref += ' ';
	                            }
	                            sqref = sqref.trim();
	                        }
	                        if (!StringEx._isNullOrWhiteSpace(sqref)) { 
	                            if (paneIndex !== 3  || (!(x > 0 || y > 0) && paneIndex === 3 )) {
	                                writer.writeLeafElement('selection', function () { 
	                                    if (paneIndex !== 3 ) {
	                                        writer.writeAttributeString('pane', excel.PaneType[paneIndex]);
	                                    }
	                                    writer.writeAttributeString('activeCell', activeCellStr);
	                                    if (activeCellSelectionIndex !== 0) {
	                                        writer.writeAttributeString('activeCellId', activeCellSelectionIndex.toString());
	                                    }
	                                    writer.writeAttributeString('sqref', sqref);
	                                });
	                            }
	                        }
	                    }
	                }
	            });
	        });
	    }
	
	    function writeSheetFormatPr(writer, sheetName, writerDataModel) {
	        var rowHeightInfo = writerDataModel._getDefaultRowHeight(sheetName);
	        var defaultRowHeight = rowHeightInfo.height, customHeight = rowHeightInfo.customHeight, defaultColWidth = writerDataModel._getDefaultColumnWidth(sheetName);
	        writer.writeLeafElement('sheetFormatPr', function () {
	            writer.writeAttributeString('defaultColWidth', defaultColWidth.toString());
	            if (customHeight) {
	                writer.writeAttributeString('customHeight', '1');
	            }
	            writer.writeAttributeString('defaultRowHeight', defaultRowHeight.toString());
	
	            var ret = writerDataModel._getGutters(sheetName);
	            var outlineLevelRow = ret.outlineLevelRow - 1, outlineLevelColumn = ret.outlineLevelColumn - 1;
	            if (outlineLevelRow > 0) {
	                writer.writeAttributeString('outlineLevelRow', outlineLevelRow.toString());
	            }
	            if (outlineLevelColumn > 0) {
	                writer.writeAttributeString('outlineLevelCol', outlineLevelColumn.toString());
	            }
	        });
	    }
	
	    function writeColumnInfo(writer, sheetName, writerDataModel, _xfMap, styleOffset) {
	        var columnInfoList = writerDataModel._getNonEmptyColumns(sheetName);
	        var defaultColumnWidth = writerDataModel._getDefaultColumnWidth(sheetName);
	        if (columnInfoList.length === 0) {
	            return;
	        }
	        writer.writeElement('cols', keywords_undefined, function () {
	            for (var i = 0, len = columnInfoList.length; i < len; i++) {
	                var startColumn = columnInfoList[i];
	                var startIndex = startColumn.index;
	                if (startIndex >= ExcelConstants._openXmlMaxColumn) {
	                    break;
	                }
	                var next = i + 1, endColumnIndex = startIndex;
	                while (next < columnInfoList.length) {
	                    var nextColumn = columnInfoList[next];
	                    if (nextColumn.index === (endColumnIndex + 1) && nextColumn.index < ExcelConstants._openXmlMaxColumn && nextColumn.formatId === startColumn.formatId && nextColumn.visible === startColumn.visible && nextColumn.outLineLevel === startColumn.outLineLevel && nextColumn.collapsed === startColumn.collapsed && Math.abs(nextColumn.width - startColumn.width) <= 0.0001) {
	                        endColumnIndex = nextColumn.index;
	                        i = next;
	                        next++;
	                    } else {
	                        break;
	                    }
	                }
	                writer.writeLeafElement('col', function () { 
	                    writer.writeAttributeString('min', (startIndex + 1).toString());
	                    writer.writeAttributeString('max', (endColumnIndex + 1).toString());
	                    if (startColumn.formatId >= 0) {
	                        var styleID = _xfMap[startColumn.formatId + styleOffset];
	                        if (styleID !== keywords_undefined) {
	                            writer.writeAttributeString('style', styleID);
	                        } else {
	                            writer.writeAttributeString('style', '0');
	                        }
	                    }
	                    if (!isNaN(startColumn.width) && (startColumn.width !== keywords_undefined)) {
	                        writer.writeAttributeString('width', startColumn.width.toString());
	                    } else {
	                        writer.writeAttributeString('width', defaultColumnWidth.toString());
	                    }
	                    if (startColumn.visible === false) {
	                        writer.writeAttributeString('hidden', '1');
	                    }
	                    if (startColumn.collapsed) {
	                        writer.writeAttributeString('collapsed', '1');
	                    }
	                    if (!isNaN(startColumn.width) && Math.abs(startColumn.width - defaultColumnWidth) > 0.0001) {
	                        writer.writeAttributeString('customWidth', '1');
	                    }
	                    if (typeof startColumn.outLineLevel === 'number' && startColumn.outLineLevel !== 0) {
	                        writer.writeAttributeString('outlineLevel', startColumn.outLineLevel.toString());
	                    }
	                });
	            }
	        });
	    }
	
	    function writeSheetData(writer, sheetName, writerDataModel, options, _xfMap, styleOffset, sharedString) {
	        var rowInfoList = {};
	        var notEmptyRows = writerDataModel._getNonEmptyRows(sheetName);
	        if (notEmptyRows) {
	            for (var i = 0, len = notEmptyRows.length; i < len; i++) {
	                var row = notEmptyRows[i];
	                if (row && row.index < ExcelConstants._openXmlMaxRow) {
	                    rowInfoList[row.index] = new Tuple(row, []);
	                }
	            }
	        }
	        var cells = writerDataModel._getCells(sheetName);
	        if (cells) {
	            for (var rowIndex in cells) {
	                if (cells.hasOwnProperty(rowIndex)) {
	                    var rowData = cells[rowIndex];
	                    var len1;
	                    for (i = 0, len1 = rowData.length; i < len1; i++) {
	                        var cell = rowData[i];
	                        if (!cell) {
	                            continue;
	                        }
	                        if (rowInfoList[cell.row]) {
	                            rowInfoList[cell.row].item2.push(cell);
	                        } else {
	                            rowInfoList[cell.row] = new Tuple(null, []);
	                            rowInfoList[cell.row].item2.push(cell);
	                        }
	                    }
	                }
	            }
	        }
	        writer.writeElement('sheetData', keywords_undefined, function () {
	            var lastWriteRow = -1;
	            for (var row in rowInfoList) { 
	                if (rowInfoList.hasOwnProperty(row)) {
	                    var rowInfo = rowInfoList[row];
	                    var rowIndex = parseInt(row); 
	                    writeRow(writer, sheetName, rowIndex, lastWriteRow, rowInfo.item2, rowInfo.item1, options, _xfMap, styleOffset, sharedString);
	                    lastWriteRow = rowIndex;
	                }
	            }
	        });
	    }
	
	    function writeRow(writer, sheetName, rowIndex, lastWriteRow, cells, row, options, _xfMap, styleOffset, sharedString) {
	        var rowInA1Style = (rowIndex + 1).toString();
	        var writeRowAttrs = function () {
	            if ((options.keepRowColIndex || rowIndex !== lastWriteRow + 1) && (row || cells)) {
	                writer.writeAttributeString('r', rowInA1Style);
	            }
	            if (row) {
	                if (row.formatId >= 0) {
	                    var formatId = _xfMap[row.formatId + styleOffset];
	                    if (formatId !== keywords_undefined) {
	                        writer.writeAttributeString('s', formatId);
	                        writer.writeAttributeString('customFormat', '1');
	                    }
	                }
	                if (row.customHeight) {
	                    writer.writeAttributeString('customHeight', '1');
	                    if (row.height !== keywords_undefined) {
	                        writer.writeAttributeString('ht', row.height.toString());
	                    }
	                }
	                if (row.visible === false) {
	                    writer.writeAttributeString('hidden', '1');
	                }
	                if (row.collapsed) {
	                    writer.writeAttributeString('collapsed', '1');
	                }
	                if (typeof row.outLineLevel === 'number' && row.outLineLevel !== 0) {
	                    writer.writeAttributeString('outlineLevel', row.outLineLevel.toString());
	                }
	            }
	        };
	        if (cells && cells.length > 0) {
	            writer.writeElement('row', writeRowAttrs, function () {
	                var lastWritenCol = -1;
	                for (var i = 0, len = cells.length; i < len; i++) {
	                    var cell = cells[i];
	                    if (cell.col >= ExcelConstants._openXmlMaxColumn) {
	                        continue;
	                    }
	                    writeCell(writer, cell, rowInA1Style, lastWritenCol, options, _xfMap, styleOffset, sharedString);
	                    lastWritenCol = cell.col;
	                }
	            });
	        } else {
	            writer.writeLeafElement('row', writeRowAttrs);
	        }
	    }
	
	    var errorSet = ['#REF!', '#NULL!', '#DIV/0!', '#VALUE!', '#NAME?', '#NUM!', '#N/A'];
	
	    function processFunction(formula) {
	        var functionName = '';
	        var functionParamBegin = formula.indexOf('(');
	        if (functionParamBegin > -1) {
	            functionName = formula.substring(0, functionParamBegin);
	            if (formula && specialFunction.indexOf(functionName.toUpperCase()) > -1) {
	                return '_xlfn.' + formula;
	            }
	        }
	        return formula;
	    }
	
	    function writeCell(writer, cell, rowInA1Style, lastWritenCol, options, _xfMap, styleOffset, sharedString) {
	        var value = cell.value, formula = cell.formula, cellType = cell.cellType;
	
	        var writeCellAttrs = function () {
	            if (options.keepRowColIndex || cell.col !== lastWritenCol + 1) {
	                writer.writeAttributeString('r', IndexHelper._getColumnIndexInA1Letter(cell.col) + rowInA1Style);
	            }
	            if (cell.formatId === -1) {
	                writer.writeAttributeString('s', '0');
	            } else {
	                var key = cell.formatId + styleOffset;
	                var xfIndex = _xfMap[key];
	                if (xfIndex !== keywords_undefined) {
	                    writer.writeAttributeString('s', xfIndex);
	                }
	            }
	            if (cellType === 0  && !StringEx._isNullOrWhiteSpace(cell.formula)) {
	                cellType = 3 ;
	            }
	            switch (cellType) {
	                case 0 
	                :
	                    break;
	                case 2 
	                :
	                    writer.writeAttributeString('t', 's');
	                    break;
	                case 3 
	                :
	                    var cellValue = cell.value;
	                    if (cellValue !== keywords_undefined && cellValue !== null && !cell.isArrayFormula) {
	                        if (cellValue.toString().substring(0, 1) === '#') {
	                           
	                            var valueStr = cellValue.toString().toUpperCase();
	                            if (errorSet.indexOf(valueStr) !== -1) {
	                                writer.writeAttributeString('t', 'e');
	                            }
	                        } else if (typeof cellValue === 'string') {
	                           
	                            writer.writeAttributeString('t', 'str');
	                        }
	                       
	                    }
	                    break;
	                case 8 
	                :
	                    writer.writeAttributeString('t', 'str');
	                    break;
	                case 5 
	                :
	                    writer.writeAttributeString('t', 'b');
	                    break;
	                case 7 
	                :
	                    writer.writeAttributeString('t', 'e');
	                    break;
	                default:
	                    break;
	            }
	        };
	
	        function addStringToSharedStringTable(str) {
	            var si = sharedString._sstTableDict[str];
	           
	           
	            if (si === keywords_undefined) {
	                si = sharedString._sstTable.length;
	                sharedString._sstTable.push(str);
	                sharedString._sstTableDict[str] = si;
	            }
	            sharedString._sstTableCount++;
	            return si;
	        }
	
	        if ((value === keywords_undefined || value === null) && StringEx._isNullOrEmpty(formula)) {
	            writer.writeLeafElement('c', writeCellAttrs);
	        } else {
	            writer.writeElement('c', writeCellAttrs, function () {
	                if (!StringEx._isNullOrEmpty(formula)) {
	                    var arrayFormulaRange = cell.arrayFormulaRange;
	                    if (cell.isArrayFormula && arrayFormulaRange) {
	                        if (cell.row === arrayFormulaRange.row && cell.col === arrayFormulaRange.col) {
	                            writer.writeElement('f', function () {
	                                writer.writeAttributeString('t', 'array');
	                                var range = IndexHelper._getColumnIndexInA1Letter(arrayFormulaRange.col) +
	                                    (arrayFormulaRange.row + 1) + ':' +
	                                    IndexHelper._getColumnIndexInA1Letter(arrayFormulaRange.col + arrayFormulaRange.colCount - 1) +
	                                    (arrayFormulaRange.row + arrayFormulaRange.rowCount);
	                                writer.writeAttributeString('ref', range);
	                            }, function () {
	                                writer.writeValue(Util._xmlEncode(processFunction(formula)));
	                            });
	                        }
	                    } else {
	                        writer.writeElement('f', keywords_undefined, function () {
	                            writer.writeValue(Util._xmlEncode(processFunction(formula)));
	                        });
	                    }
	                }
	                if (value !== keywords_undefined && value !== null) {
	                    if (value === '') {
	                        writer.writeLeafElement('v');
	                    } else {
	                        writer.writeElement('v', keywords_undefined, function () {
	                            if (typeof value === 'string' && value.substring(0, 7) === '/OADate') {
	                                cellType = 6 ;
	                            }
	                            switch (cellType) {
	                                case 3 
	                                :
	                                    if (typeof value === 'boolean') {
	                                        value = value ? 1 : 0;
	                                    }
	                                   
	                                    writer.writeValue(Util._xmlEncode(value.toString()));
	                                    break;
	                                case 2 
	                                :
	                                    writer.writeValue(addStringToSharedStringTable(value).toString());
	                                    break;
	                                case 7 
	                                :
	                                    writer.writeValue(value._error);
	                                    break;
	                                case 5 
	                                :
	                                    var boolValue = '1';
	                                    if (typeof value === 'boolean' && !value) {
	                                        boolValue = '0';
	                                    } else if (value.toString().toUpperCase() === 'FALSE') {
	                                        boolValue = '0';
	                                    }
	                                    writer.writeValue(boolValue);
	                                    break;
	                                case 6 
	                                :
	                                default:
	                                    writer.writeValue(value.toString());
	                            }
	                        });
	                    }
	                }
	            });
	        }
	    }
	
	    function writeSheetProtection(writer, sheetName, writerDataModel) {
	        var protectionOptions = writerDataModel._getProtectionOptions(sheetName);
	        var isProtect = writerDataModel._getProtect(sheetName);
	        var value;
	        if (isProtect || Object.keys(protectionOptions).length > 0) {
	            writer.writeLeafElement('sheetProtection', function () {
	                if(isProtect) {
	                    writer.writeAttributeString('sheet', '1');
	                }
	                for(var key in protectionOptions) {
	                    if(protectionOptions.hasOwnProperty(key)) {
	                        value = protectionOptions[key] ? '0' : '1';
	                        writer.writeAttributeString(key, value);
	                    }
	                }
	            });
	        }
	    }
	
	    function writeMergeCells(writer, sheetName, writerDataModel) {
	        var spans = writerDataModel._getMergedCells(sheetName);
	        if (spans && spans.length > 0) {
	            writer.writeElement('mergeCells', function () {
	                writer.writeAttributeString('count', spans.length.toString());
	            }, function () {
	                for (var i = 0, len = spans.length; i < len; i++) {
	                    var span = spans[i];
	                    writer.writeLeafElement('mergeCell', function () { 
	                        writer.writeAttributeString('ref',
	                            IndexHelper._getColumnIndexInA1Letter(span.col) + (span.row + 1) + ':' +
	                            IndexHelper._getColumnIndexInA1Letter(span.col + span.colCount - 1) + (span.row + span.rowCount));
	                    });
	                }
	            });
	        }
	    }
	
	    function writeExtensions(writer, sheetName, writerDataModel) {
	        writer.writeElement('extLst', keywords_undefined, function () {
	            writeExtensionConditionalFormats(writer, sheetName, writerDataModel);
	            sparklineWriter._writeSparkline(writer, sheetName, writerDataModel);
	            writeSlicersInWorkSheet(writer, sheetName, writerDataModel);
	            writeExtensionDataValidations(writer, writerDataModel);
	        });
	    }
	
	    function writeTableParts(writer, tables) {
	        writer.writeElement('tableParts', function () {
	            writer.writeAttributeString('count', tables.length.toString());
	        }, function () {
	            tables.forEach(function (sheetTable) {
	                writer.writeLeafElement('tablePart', function () {
	                    writer.writeAttributeString('r:id', sheetTable.rid);
	                });
	            });
	        });
	    }
	
	    module.exports = writeWorksheet;
	
	}());

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var excel = __webpack_require__(21);
	    var XFileConstants = excel._XFileConstants;
	    var common = __webpack_require__(4);
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var getRangeString = __webpack_require__(26)._getRangeString;
	    var excelStyle = __webpack_require__(12);
	    var ColorHelper = excelStyle.ColorHelper;
	    var writeColor = __webpack_require__(46).writeColor;
	    var getSheetName = common._IndexHelper._getSheetName;
	    
	    
	    function writeSparkline(writer, sheetName, writerDataModel) {
	        if (!writerDataModel._getSparklineGroups(sheetName) || writerDataModel._getSparklineGroups(sheetName).length < 1) {
	            return;
	        }
	        writer.writeElement('ext', function () {
	            writer.writeAttributeString('uri', '{05C60535-1F16-4fd2-B633-F4F36F0B64E0}');
	            writer.writeAttributeString('xmlns:x14', XFileConstants._extensionListNameSpace);
	        }, function () {
	            writeSparklineGroups(writer, sheetName, writerDataModel);
	        });
	    }
	    
	    function writeSparklineGroups(writer, sheetName, writerDataModel) {
	        writer.writeElement('x14:sparklineGroups', function () {
	            writer.writeAttributeString('xmlns:xm', XFileConstants._sparklineGroupsNameSpace);
	        }, function () {
	            var sparklineGroup = writerDataModel._getSparklineGroups(sheetName);
	            if (sparklineGroup.length > 0) {
	                sparklineGroup.forEach(function (spGroup) {
	                    writeSparklineGroup(writer, sheetName, spGroup);
	                });
	            }
	        });
	    }
	    
	    var ExcelSparklineType = {
	       
	        0: 'line',
	       
	        1: 'column',
	       
	        2: 'stacked' 
	    };
	    
	    var ExcelSparklineEmptyCellDisplayAs = {
	       
	        2: 'span', 
	       
	        0: 'gap',
	       
	        1: 'zero'
	    };
	    
	    var ExcelSparklineAxisMinMax = {
	       
	       
	       
	        0: 'individual',
	       
	       
	       
	        1: 'group',
	       
	       
	        2: 'custom'
	    };
	    
	    function writeSparklineGroup(writer, sheetName, sparklineGroup) {
	        writer.writeElement('x14:sparklineGroup', function () {
	            var setting = sparklineGroup && sparklineGroup.setting;
	            if (sparklineGroup.sparklineType) {
	                writer.writeAttributeString('type', ExcelSparklineType[sparklineGroup.sparklineType]);
	            }
	            if (sparklineGroup.displayDateAxis) {
	                writer.writeAttributeString('dateAxis', '1');
	            }
	            if (!isNullOrUndefined(setting)) {
	                if (!isNullOrUndefined(setting.lineWeight) && (setting.lineWeight.toString() * 3 / 4.0 - 0.75 > 0.001)) {
	                    writer.writeAttributeString('lineWeight', setting.lineWeight.toString()) * 3 / 4.0;
	                }
	                if (setting.displayEmptyCellsAs) {
	                    writer.writeAttributeString('displayEmptyCellsAs', ExcelSparklineEmptyCellDisplayAs[setting.displayEmptyCellsAs]);
	                } else {
	                    writer.writeAttributeString('displayEmptyCellsAs', ExcelSparklineEmptyCellDisplayAs[0]);
	                }
	                if (setting.showMarkers) {
	                    writer.writeAttributeString('markers', '1');
	                }
	                if (setting.showHigh) {
	                    writer.writeAttributeString('high', '1');
	                }
	                if (setting.showLow) {
	                    writer.writeAttributeString('low', '1');
	                }
	                if (setting.showFirst) {
	                    writer.writeAttributeString('first', '1');
	                }
	                if (setting.showLast) {
	                    writer.writeAttributeString('last', '1');
	                }
	                if (setting.showNegative) {
	                    writer.writeAttributeString('negative', '1');
	                }
	                if (setting.displayXAxis) {
	                    writer.writeAttributeString('displayXAxis', '1');
	                }
	                if (setting.displayHidden) {
	                    writer.writeAttributeString('displayHidden', '1');
	                }
	                if (setting.rightToLeft) {
	                    writer.writeAttributeString('rightToLeft', '1');
	                }
	                if (setting.minAxisType) {
	                    writer.writeAttributeString('minAxisType', ExcelSparklineAxisMinMax[setting.minAxisType]);
	                }
	                if (setting.maxAxisType) {
	                    writer.writeAttributeString('maxAxisType', ExcelSparklineAxisMinMax[setting.maxAxisType]);
	                }
	                if (setting.manualMin) {
	                    writer.writeAttributeString('manualMin', setting.manualMin);
	                }
	                if (setting.manualMax) {
	                    writer.writeAttributeString('manualMax', setting.manualMax);
	                }
	            }
	        }, function () {
	            var setting = sparklineGroup && sparklineGroup.setting;
	            var color;
	            color = ColorHelper.toExcelColor(setting.seriesColor || "rgba(36,64,98,1.0)");
	            writeColor(writer, 'x14:colorSeries', color);
	            color = ColorHelper.toExcelColor(setting.negativeColor || "brown");
	            writeColor(writer, 'x14:colorNegative', color);
	            color = ColorHelper.toExcelColor(setting.axisColor || "black");
	            writeColor(writer, 'x14:colorAxis', color);
	            color = ColorHelper.toExcelColor(setting.markersColor || "rgba(36,64,98,1.0)");
	            writeColor(writer, 'x14:colorMarkers', color);
	            color = ColorHelper.toExcelColor(setting.firstMarkerColor || "rgba(149,179,215,1.0)");
	            writeColor(writer, 'x14:colorFirst', color);
	            color = ColorHelper.toExcelColor(setting.lastMarkerColor || "rgba(149,179,215,1.0)");
	            writeColor(writer, 'x14:colorLast', color);
	            color = ColorHelper.toExcelColor(setting.highMarkerColor || "blue");
	            writeColor(writer, 'x14:colorHigh', color);
	            color = ColorHelper.toExcelColor(setting.lowMarkerColor || "blue");
	            writeColor(writer, 'x14:colorLow', color);
	    
	            if (sparklineGroup.displayDateAxis && sparklineGroup.axisReference) {
	                writer.writeElement('xm:f', function () {
	                    writer.writeValue(convertRangeToExString(sparklineGroup.axisReference.sheetName || sheetName, sparklineGroup.axisReference));
	                });
	            }
	            if (sparklineGroup.sparklines && sparklineGroup.sparklines.length > 0) {
	                writer.writeElement('x14:sparklines', function () {
	                    sparklineGroup.sparklines.forEach(function (sparkline) {
	                        sparklineWrite(writer, sheetName, sparkline);
	                    });
	                });
	            }
	        });
	    }
	    
	    function sparklineWrite(writer, sheetName, sparkline) {
	        writer.writeElement('x14:sparkline', function () {
	            if (!isNullOrUndefined(sparkline.data)) {
	                writer.writeElement('xm:f', function () {
	    
	                }, function () {
	                    writer.writeValue(convertRangeToExString(sparkline.data.sheetName || sheetName, sparkline.data));
	                });
	                writer.writeElement('xm:sqref', function () {
	    
	                }, function () {
	                    writer.writeValue(getRangeString([{row: sparkline.row, col: sparkline.col, rowCount: 1, colCount: 1}]));
	                });
	            }
	        });
	    }
	    
	    function convertRangeToExString(sheetName, range) {
	        return getSheetName(sheetName) + '!' + getRangeString([range]);
	    }
	    
	    
	    exports._writeSparkline = writeSparkline;
	
	}());

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var getRangeString = __webpack_require__(26)._getRangeString;
	    var common = __webpack_require__(4);
	    var excelStyle = __webpack_require__(12);
	    var writeColor = __webpack_require__(46).writeColor;
	    var excel = __webpack_require__(21);
	    var writeDxf = __webpack_require__(45)._writeDxf;
	    var IndexHelper = common._IndexHelper;
	    var ColorHelper = excelStyle.ColorHelper;
	    var Util = common._Util;
	
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var ExcelConstants = excel._ExcelConstants;
	
	    var RuleType = {
	        conditionRuleBase: 0,
	        cellValueRule: 1,
	        specificTextRule: 2,
	        formulaRule: 3,
	        dateOccurringRule: 4,
	        top10Rule: 5,
	        uniqueRule: 6,
	        duplicateRule: 7,
	        averageRule: 8,
	        twoScaleRule: 10,
	        threeScaleRule: 11,
	        dataBarRule: 12,
	        iconSetRule: 13
	    };
	    for (var prop in RuleType) {
	        RuleType[RuleType[prop]] = prop;
	    }
	
	    var ScaleValueType = {
	        0 : 'num',
	        1 : 'min',
	        2 : 'max',
	        3 : 'percent',
	        4 : 'percentile',
	       
	        6 : 'formula',
	        5 : 'autoMin',
	        7 : 'autoMax'
	    };
	
	    var IconSetTypes = {
	        0 : '3Arrows',
	        1 : '3ArrowsGray',
	        4 : '3Flags',
	        5 : '3TrafficLights1',
	        6 : '3TrafficLights2',
	        7 : '3Signs',
	        8 : '3Symbols',
	        9 : '3Symbols2',
	        10 : '4Arrows',
	        11 : '4ArrowsGray',
	        12 : '4RedToBlack',
	        13 : '4Rating',
	        14 : '4TrafficLights',
	        15 : '5Arrows',
	        16 : '5ArrowsGray',
	        17 : '5Rating',
	        18 : '5Quarters',
	        3 : '3Stars',
	        2 : '3Triangles',
	        19 : '5Boxes',
	        20 : 'NoIcons'
	    };
	    var IconValueTypes = {
	        1: 'num',
	        4: 'percent',
	        7: 'formula',
	        5: 'percentile'
	    };
	    var ComparisonOperators = {
	        0: 'equal',
	        1: 'notEqual',
	        2: 'greaterThan',
	        3: 'greaterThanOrEqual',
	        4: 'lessThan',
	        5: 'lessThanOrEqual',
	        6: 'between',
	        7: 'notBetween'
	    };
	
	    function removeEqualSignIfExist(val) {
	        var val2 = '' + val;
	        if ((val2).charAt(0) === '=') {
	            return (val2).substr(1);
	        }
	        return val2;
	    }
	
	    function getFormulaString(formula) {
	        if (typeof formula === 'string') {
	            return formula[0] === '=' ? formula.substr(1) : formula;
	        }
	        return formula;
	    }
	
	    function writeConditionalFormating(writer, sheetName, writerDataModel) {
	        var conditionalformats = writerDataModel._getConditionalFormatting(sheetName);
	        var rules = conditionalformats && conditionalformats.rules;
	        if (rules && rules.length > 0) {
	            for (var i = 0; i < rules.length; i++) {
	                var rule = rules[i];
	                if (isNullOrUndefined(rule.priority)) {
	                    rule.priority = 1;
	                }
	                if (isIconSetTypeExtension(rule) || isFormulaRuleExtension(rule, sheetName, writerDataModel._getSheetsName())) {
	                    continue;
	                }
	                writer.writeElement('conditionalFormatting', function () { 
	                    writer.writeAttributeString('sqref', getRangeString(rule.ranges));
	                }, function () { 
	                    if (rule.ruleType === RuleType.dataBarRule) {
	                        writer.writeElement('cfRule', function () {
	                            writer.writeAttributeString('type', RuleType[rule.ruleType].replace('Rule', ''));
	                            writer.writeAttributeString('priority', rule.priority);
	                        }, function () {
	                            writer.writeElement('dataBar', function () {
	                                if (rule.showBarOnly) {
	                                    writer.writeAttributeString('showValue', '0');
	                                }
	                            }, function () {
	                                var minType = ScaleValueType[rule.minType];
	                                if (isNullOrUndefined(minType) || minType === 'autoMin') {
	                                    minType = 'min';
	                                }
	                                writer.writeLeafElement('cfvo', function () {
	                                    writer.writeAttributeString('type', minType);
	                                    if (!isNullOrUndefined(rule.minValue)) {
	                                        writer.writeAttributeString('val', Util._xmlEncode(removeEqualSignIfExist(rule.minValue)));
	                                    }
	                                });
	                                var maxType = ScaleValueType[rule.maxType];
	                                if (isNullOrUndefined(maxType) || maxType === 'autoMax') {
	                                    maxType = 'max';
	                                }
	                                writer.writeLeafElement('cfvo', function () {
	                                    writer.writeAttributeString('type', maxType);
	                                    if (!isNullOrUndefined(rule.maxValue)) {
	                                        writer.writeAttributeString('val', Util._xmlEncode(removeEqualSignIfExist(rule.maxValue)));
	                                    }
	                                });
	                                writeColor(writer, 'color', convertColor(rule.color));
	
	                            });
	                            writer.writeElement('extLst', function () {
	                                writer.writeElement('ext', function () {
	                                    writer.writeAttributeString('uri', '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}');
	                                    writer.writeAttributeString('xmlns:x14', 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main');
	                                }, function () {
	                                    rule.id = Util._createURI();
	                                    writer.writeElement('x14:id', function () {
	                                        writer.writeValue(rule.id);
	                                    });
	                                });
	                            });
	                        });
	                    } else if (rule.ruleType === RuleType.twoScaleRule || rule.ruleType === RuleType.threeScaleRule) {
	                        writer.writeElement('cfRule', function () {
	                            writer.writeAttributeString('type', 'colorScale');
	                            writer.writeAttributeString('priority', rule.priority);
	                        }, function () {
	                            writer.writeElement('colorScale', function () {
	                                writer.writeLeafElement('cfvo', function () {
	                                    writer.writeAttributeString('type', ScaleValueType[rule.minType]);
	                                    if (!isNullOrUndefined(rule.minValue)) {
	                                        writer.writeAttributeString('val', Util._xmlEncode(removeEqualSignIfExist(rule.minValue)));
	                                    }
	                                });
	                                var hasMiddleNode = rule.ruleType === RuleType.threeScaleRule;
	                                if (hasMiddleNode) {
	                                    writer.writeLeafElement('cfvo', function () {
	                                        writer.writeAttributeString('type', ScaleValueType[rule.midType]);
	                                        if (!isNullOrUndefined(rule.midValue)) {
	                                            writer.writeAttributeString('val', Util._xmlEncode(removeEqualSignIfExist(rule.midValue)));
	                                        } else {
	                                            writer.writeAttributeString('val', '50');
	                                        }
	                                    });
	                                }
	                                writer.writeLeafElement('cfvo', function () {
	                                    writer.writeAttributeString('type', ScaleValueType[rule.maxType]);
	                                    if (!isNullOrUndefined(rule.maxValue)) {
	                                        writer.writeAttributeString('val', Util._xmlEncode(removeEqualSignIfExist(rule.maxValue)));
	                                    }
	                                });
	                                writeColor(writer, 'color', convertColor(rule.minColor));
	                                if (hasMiddleNode) {
	                                    writeColor(writer, 'color', convertColor(rule.midColor));
	                                }
	                                writeColor(writer, 'color', convertColor(rule.maxColor));
	                            });
	                        });
	                    } else if (rule.ruleType === RuleType.iconSetRule) {
	                        if (isIconSetTypeExtension(rule)) {
	                            return;
	                        }
	                        writer.writeElement('cfRule', function () {
	                            writer.writeAttributeString('type', 'iconSet');
	                            writer.writeAttributeString('priority', rule.priority);
	                        }, function () {
	                            writer.writeElement('iconSet', function () {
	                                var iconSetType = rule.iconSetType;
	                                if (isNullOrUndefined(iconSetType)) {
	                                    iconSetType = 0 ;
	                                }
	                                writer.writeAttributeString('iconSet', IconSetTypes[iconSetType]);
	                                if (rule.reverseIconOrder) {
	                                    writer.writeAttributeString('reverse', rule.reverseIconOrder);
	                                }
	                                if (rule.showIconOnly) {
	                                    writer.writeAttributeString('showValue', '0');
	                                }
	                            }, function () {
	                                writer.writeLeafElement('cfvo', function () {
	                                    writer.writeAttributeString('type', 'percent');
	                                    writer.writeAttributeString('val', '0');
	                                });
	                                for (var i = 0; i < rule.iconCriteria.length; i++) { 
	                                    var criteria = rule.iconCriteria[i];
	                                    writer.writeLeafElement('cfvo', function () { 
	                                        writer.writeAttributeString('type', IconValueTypes[criteria.iconValueType]);
	                                        writer.writeAttributeString('val', removeEqualSignIfExist(criteria.iconValue));
	                                        if (criteria.isGreaterThanOrEqualTo === false) {
	                                            writer.writeAttributeString('gte', '0');
	                                        }
	                                    });
	                                }
	                            });
	                        });
	                    } else if (rule.ruleType === RuleType.cellValueRule) {
	                        writer.writeElement('cfRule', function () {
	                            writer.writeAttributeString('type', 'cellIs');
	                            if (rule.priority) {
	                                writer.writeAttributeString('priority', rule.priority);
	                            }
	                            if (rule.dxfId >= 0) {
	                                writer.writeAttributeString('dxfId', rule.dxfId);
	                            }
	                            if (rule.stopIfTrue) {
	                                writer.writeAttributeString('stopIfTrue', '1');
	                            }
	                            if (!isNullOrUndefined(rule.operator)) {
	                                writer.writeAttributeString('operator', ComparisonOperators[rule.operator]);
	                            }
	                        }, function () {
	                            if (!isNullOrUndefined(rule.value1)) {
	                                writer.writeElement('formula', function () {
	                                    writer.writeValue(Util._xmlEncode(getFormulaString(rule.value1)));
	                                });
	                            }
	                            if (!isNullOrUndefined(rule.value2)) {
	                                writer.writeElement('formula', function () {
	                                    writer.writeValue(Util._xmlEncode(getFormulaString(rule.value2)));
	                                });
	                            }
	                        });
	                    } else {
	                        var generalRule = processSpreadJSRule(rule);
	                        writer.writeElement('cfRule', function () {
	                            if (rule.ruleType === 4 ) {
	                                writer.writeAttributeString('type', 'timePeriod');
	                            } else if (rule.ruleType === 8 ) {
	                                writer.writeAttributeString('type', 'aboveAverage');
	                                if (generalRule.type === 'aboveOrEqualToAverage' || generalRule.type === 'belowOrEqualToAverage') {
	                                    generalRule.equalAverage = true;
	                                }
	                                if (generalRule.type === 'belowAverage' || generalRule.type === 'belowOrEqualToAverage') {
	                                    generalRule.aboveAverage = false;
	                                }
	                            } else if (rule.ruleType === 2 ) {
	                                if (!isNullOrUndefined(generalRule.type)) {
	                                    writer.writeAttributeString("type", generalRule.type);
	                                } else {
	                                    writer.writeAttributeString("type", "containsText");
	                                }
	                            } else {
	                                writer.writeAttributeString("type", generalRule.type);
	                            }
	
	
	                            if (generalRule.dxfId >= 0) {
	                                writer.writeAttributeString('dxfId', generalRule.dxfId);
	                            }
	                            if (generalRule.priority >= 0) {
	                                writer.writeAttributeString('priority', generalRule.priority);
	                            }
	                            if (generalRule.stopIfTrue) {
	                                writer.writeAttributeString("stopIfTrue", "1");
	                            }
	                            if (!isNullOrUndefined(generalRule.aboveAverage)) {
	                                if (generalRule.aboveAverage) {
	                                    writer.writeAttributeString("aboveAverage", "1");
	                                } else {
	                                    writer.writeAttributeString("aboveAverage", "0");
	                                }
	                            }
	                            if (!isNullOrUndefined(generalRule.equalAverage)) {
	                                if (generalRule.equalAverage) {
	                                    writer.writeAttributeString("equalAverage", "1");
	                                } else {
	                                    writer.writeAttributeString("equalAverage", "0");
	                                }
	                            }
	                            if (!isNullOrUndefined(generalRule.bottom)) {
	                                if (generalRule.bottom) {
	                                    writer.writeAttributeString("bottom", "1");
	                                } else {
	                                    writer.writeAttributeString("bottom", "0");
	                                }
	                            }
	                            if (generalRule.percent) {
	                                writer.writeAttributeString("percent", "1");
	                            }
	                            if (!isNullOrUndefined(generalRule.operator)) {
	                                writer.writeAttributeString("operator", generalRule.operator);
	                            }
	                            if (!isNullOrUndefined(generalRule.rank)) {
	                                writer.writeAttributeString('rank', generalRule.rank);
	                            }
	                            if (!isNullOrUndefined(generalRule.stdDev)) {
	                                writer.writeAttributeString('stdDev', generalRule.stdDev);
	                            }
	                            if (!isNullOrUndefined(generalRule.text)) {
	                                writer.writeAttributeString('text', Util._xmlEncode(generalRule.text));
	                            }
	                            if (rule.ruleType === 4 ) {
	                                writer.writeAttributeString("timePeriod", generalRule.type);
	                            }
	                        }, function () {
	                            if (!isNullOrUndefined(generalRule.formulas)) {
	                                for (var i = 0; i < generalRule.formulas.length; i++) { 
	                                    writer.writeElement('formula', function () { 
	                                        writer.writeValue(Util._xmlEncode(getFormulaString(generalRule.formulas[i])));
	                                    });
	                                }
	                            }
	                        });
	                    }
	                });
	            }
	        }
	    }
	
	    function processSpreadJSRule(rule) {
	        switch (rule.ruleType) {
	            case 2 : 
	                return processConditionalFormatSpecificTextRule(rule);
	            case 3 : 
	                return processConditionalFormatFormulaRule(rule);
	            case 4 : 
	                return processConditionalFormatDateOccurringRule(rule);
	            case 5 : 
	                return processConditionalFormatTop10Rule(rule);
	            case 6 : 
	            case 7 : 
	                return processConditionalFormatUniqueRule(rule);
	            case 8 : 
	                return processConditionalFormatAverageRule(rule);
	            default:
	                break;
	        }
	    }
	
	    function processConditionalFormatAverageRule(rule) {
	        var stdDev = 0;
	        var type = 'aboveAverage';
	        switch (rule.type) {
	            case 0: 
	                type = 'aboveAverage';
	                break;
	            case 1: 
	                type = 'belowAverage';
	                break;
	            case 2: 
	                type = 'aboveOrEqualToAverage';
	                break;
	            case 3: 
	                type = 'belowOrEqualToAverage';
	                break;
	            case 4: 
	                type = 'aboveAverage';
	                stdDev = 1;
	                break;
	            case 5: 
	                type = 'belowAverage';
	                stdDev = 1;
	                break;
	            case 6: 
	                type = 'aboveAverage';
	                stdDev = 2;
	                break;
	            case 7: 
	                type = 'belowAverage';
	                stdDev = 2;
	                break;
	            case 8: 
	                type = 'aboveAverage';
	                stdDev = 3;
	                break;
	            case 9: 
	                type = 'belowAverage';
	                stdDev = 3;
	                break;
	        }
	        var generalRule = {
	            type: type,
	            ranges: rule.ranges,
	            priority: rule.priority,
	            stopIfTrue: rule.stopIfTrue,
	            stdDev: stdDev,
	            dxfId: rule.dxfId
	        };
	        var formula = createConditionalFormatFormula(generalRule);
	        if (formula) {
	            generalRule.formulas = [formula];
	        }
	        return generalRule;
	    }
	
	    function processConditionalFormatUniqueRule(rule) {
	        var type = 'uniqueValues';
	        if (rule.ruleType === 7 ) {
	            type = 'duplicateValues';
	        }
	        var generalRule = {
	            type: type,
	            ranges: rule.ranges,
	            priority: rule.priority,
	            stopIfTrue: rule.stopIfTrue,
	            dxfId: rule.dxfId
	        };
	        var formula = createConditionalFormatFormula(generalRule);
	        if (formula) {
	            generalRule.formulas = [formula];
	        }
	        return generalRule;
	    }
	
	    function processConditionalFormatTop10Rule(rule) {
	        var bottom = void 0;
	       
	        if (rule.type === 1 ) {
	            bottom = true;
	        }
	        var generalRule = {
	            type: 'top10',
	            ranges: rule.ranges,
	            stopIfTrue: rule.stopIfTrue,
	            percent: false,
	            priority: rule.priority,
	            rank: rule.rank,
	            dxfId: rule.dxfId,
	            bottom: bottom
	        };
	        var formula = createConditionalFormatFormula(generalRule);
	        if (formula) {
	            generalRule.formulas = [formula];
	        }
	        return generalRule;
	    }
	
	    var DateOccurringType = {
	        0: 'today',
	        1: 'yesterday',
	        2: 'tomorrow',
	        3: 'last7Days',
	        4: 'thisMonth',
	        5: 'lastMonth',
	        6: 'nextMonth',
	        7: 'thisWeek',
	        8: 'lastWeek',
	        9: 'nextWeek'
	    };
	
	    function processConditionalFormatDateOccurringRule(rule) {
	        var type = DateOccurringType[rule.type];
	        var generalRule = {
	            type: type,
	            ranges: rule.ranges,
	            priority: rule.priority,
	            stopIfTrue: rule.stopIfTrue,
	            dxfId: rule.dxfId
	        };
	        var formula = createConditionalFormatFormula(generalRule);
	        if (formula) {
	            generalRule.formulas = [formula];
	        }
	        return generalRule;
	    }
	
	    function processConditionalFormatFormulaRule(rule) {
	        return {
	            type: 'expression',
	            ranges: rule.ranges,
	            priority: rule.priority,
	            stopIfTrue: rule.stopIfTrue,
	            dxfId: rule.dxfId,
	            formulas: [rule.formula]
	        };
	    }
	
	    function processConditionalFormatSpecificTextRule(rule) {
	        var operator = rule.operator;
	        var type = 'containsText';
	        var compareOp = 'contains';
	        if (operator === 2 ) {
	            type = 'beginsWith';
	            compareOp = 'beginsWith';
	        } else if (operator === 3 ) {
	            type = 'endsWith';
	            compareOp = 'endsWith';
	        } else if (operator === 1 ) {
	            type = 'notContainsText';
	            compareOp = 'notContains';
	        }
	        var generalRule = {
	            type: type,
	            priority: rule.priority,
	            operator: compareOp,
	            text: rule.text,
	            stopIfTrue: rule.stopIfTrue,
	            dxfId: rule.dxfId,
	            ranges: rule.ranges
	        };
	        var formula = createConditionalFormatFormula(generalRule);
	        if (formula) {
	            generalRule.formulas = [formula];
	        }
	        return generalRule;
	    }
	
	    function createConditionalFormatFormula(rule) {
	        if (!rule || !rule.ranges) {
	            return null;
	        }
	        var range = rule.ranges[0];
	        if (range.row < 0 || range.col < 0) {
	            return null;
	        }
	        var baseCell = IndexHelper._getColumnIndexInA1Letter(range.col) + (range.row + 1);
	        var rangeStr = '';
	
	        if (range.rowCount === ExcelConstants._openXmlMaxRow) {
	            rangeStr = stringFormat("${0}:${1}", IndexHelper._getColumnIndexInA1Letter(range.col),
	                IndexHelper._getColumnIndexInA1Letter(range.col + range.colCount - 1));
	        } else if (range.colCount === ExcelConstants._openXmlMaxColumn) {
	            rangeStr = stringFormat("${0}:${1}", range.row + 1, range.row + range.rowCount);
	        } else {
	            rangeStr = stringFormat("${0}${1}:${2}${3}",
	                IndexHelper._getColumnIndexInA1Letter(range.col), range.row + 1,
	                IndexHelper._getColumnIndexInA1Letter(range.col + range.colCount - 1), range.row + range.rowCount);
	        }
	
	        if (rule.type === 'top10') {
	            if (rule.bottom) {
	                if (rule.percent) {
	                    return stringFormat("IF(INT(COUNT({0})*{1}%)>0,SMALL({0},INT(COUNT({0})*{1}%)),MIN({0}))>={2}",
	                        rangeStr, rule.rank, baseCell);
	                }
	                return stringFormat("SMALL(({0}),MIN({1},COUNT({0})))>={2}", rangeStr, rule.rank, baseCell);
	            } else if (rule.percent) {
	                return stringFormat("IF(INT(COUNT({0})*{1}%)>0,LARGE({0},INT(COUNT({0})*{1}%)),MIN({0}))<={2}",
	                    rangeStr, rule.rank, baseCell);
	            }
	            return stringFormat("LARGE(({0}),MIN({1},COUNT({0})))<={2}", rangeStr, rule.rank, baseCell);
	        } else if (rule.type === 'containsText') {
	            return stringFormat("NOT(ISERROR(SEARCH(\"{0}\",{1})))", rule.text, baseCell);
	        } else if (rule.type === 'notContainsText') {
	            return stringFormat("ISERROR(SEARCH(\"{0}\",{1}))", rule.text, baseCell);
	        } else if (rule.type === 'beginsWith') {
	            return stringFormat("LEFT({0},{1}) = \"{2}\"", baseCell, rule.text.length, rule.text);
	        } else if (rule.type === 'endsWith') {
	            return stringFormat("RIGHT({0},{1}) = \"{2}\"", baseCell, rule.text.length, rule.text);
	        } else if (rule.type === 'duplicateValues') {
	            return stringFormat("AND(COUNTIF({0},{1})>1,NOT(ISBLANK({1})))", rangeStr, baseCell);
	        } else if (rule.type === 'uniqueValues') {
	            return stringFormat("AND(COUNTIF({0},{1})=1,NOT(ISBLANK({1})))", rangeStr, baseCell);
	        } else if (rule.type === 'aboveAverage'
	            || rule.type === 'belowAverage'
	            || rule.type === 'aboveOrEqualToAverage'
	            || rule.type === 'belowOrEqualToAverage') {
	            if (rule.type === 'aboveAverage' && isNullOrUndefined(rule.stdDev)) {
	                return stringFormat("{0}>AVERAGE({1})", baseCell, rangeStr);
	            }
	            if (!isNullOrUndefined(rule.aboveAverage)) {
	                if (!isNullOrUndefined(rule.equalAverage)
	                    && !rule.aboveAverage
	                    && !isNullOrUndefined(rule.equalAverage)
	                    && rule.equalAverage
	                    && isNullOrUndefined(rule.stdDev)) {
	                    return stringFormat("{0}<=AVERAGE({1})", baseCell, rangeStr);
	                } else if (!rule.aboveAverage && isNullOrUndefined(rule.stdDev)) {
	                    return stringFormat("{0}<AVERAGE({1})", baseCell, rangeStr);
	                }
	            }
	            if (!isNullOrUndefined(rule.equalAverage) && rule.equalAverage && isNullOrUndefined(rule.stdDev)) {
	                return stringFormat("{0}>=AVERAGE({1})", baseCell, rangeStr);
	            }
	            if (!isNullOrUndefined(rule.stdDev)) {
	                if (!isNullOrUndefined(rule.aboveAverage)
	                    && !rule.aboveAverage) {
	                    return stringFormat("({0}-AVERAGE({1}))<=STDEVP({1})*(-{2})", baseCell, rangeStr, rule.stdDev);
	                }
	               
	                return stringFormat("({0}-AVERAGE({1}))>=STDEVP({1})*({2})", baseCell, rangeStr, rule.stdDev);
	            }
	        }
	        return null;
	    }
	
	    function stringFormat(format) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return format.replace(/{(\d+)}/g, function (match, number) {
	            return typeof args[number] !== 'undefined' ? args[number] : match;
	        });
	    }
	
	    function convertColor(color) {
	        return ColorHelper.toExcelColor(color);
	    }
	
	    function isIconSetTypeExtension(rule) {
	        return (rule.ruleType === RuleType.iconSetRule) &&
	            (rule.iconSetType === 3  ||
	                rule.iconSetType === 2  ||
	                rule.iconSetType === 19  ||
	                isCustomIconSet(rule.iconSetType, rule.icons));
	    }
	
	    function isDataBarExtension(rule) {
	        if (rule.ruleType !== RuleType.dataBarRule) {
	            return false;
	        }
	        if (isNullOrUndefined(rule.maxType) || rule.maxType === 7 ) {
	            return true;
	        }
	        if (isNullOrUndefined(rule.minType) || rule.minType === 5 ) {
	            return true;
	        }
	        if (rule.gradient) {
	            return true;
	        }
	        if (rule.showBorder) {
	            return true;
	        }
	        if (rule.negativeFillColor) {
	            return true;
	        }
	        if (rule.negativeBorderColor) {
	            return true;
	        }
	        if (rule.axisPosition) {
	            return true;
	        }
	        if (rule.axisColor) {
	            return true;
	        }
	        if (rule.dataBarDirection) {
	            return true;
	        }
	        return false;
	    }
	
	    function isFormulaRuleExtension(rule, currentSheetName, sheetNames) {
	        if (rule.ruleType === RuleType.formulaRule) {
	            return Util._isExternalRange(rule.formula, currentSheetName, sheetNames);
	        }
	        return false;
	    }
	
	    function needWriteConditionalFormatExtension(rules, currentSheetName, sheetNames) {
	        var extensionCount = 0;
	        for (var i = 0; i < rules.length; i++) {
	            var rule = rules[i];
	            if (isDataBarExtension(rule) || isIconSetTypeExtension(rule) || isFormulaRuleExtension(rule, currentSheetName, sheetNames)) {
	                extensionCount++;
	            }
	        }
	        if (extensionCount === 0) {
	            return false;
	        }
	        return true;
	    }
	
	    function writeExtensionConditionalFormats(writer, sheetName, writerDataModel) {
	        var conditionalFormats = writerDataModel._getConditionalFormatting(sheetName);
	        var rules = conditionalFormats && conditionalFormats.rules;
	        if (!rules || rules.length === 0 || !needWriteConditionalFormatExtension(rules, sheetName, writerDataModel._getSheetsName())) {
	            return;
	        }
	
	        writer.writeElement('ext', function () {
	            writer.writeAttributeString('uri', '{78C0D931-6437-407d-A8EE-F0AAD7539E65}');
	            writer.writeAttributeString('xmlns:x14', 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main');
	        }, function () {
	            writer.writeElement('x14:conditionalFormattings', function () {
	                for (var i = 0; i < rules.length; i++) {
	                    var rule = rules[i];
	                    if (isNullOrUndefined(rule.id)) {
	                        rule.id = Util._createURI();
	                    }
	                    if (isDataBarExtension(rule)) {
	                        writeDataBarExtensionRecord(writer, sheetName, rule);
	                    }
	                    if (isIconSetTypeExtension(rule)) {
	                        writeIconSetExtensionRecord(writer, sheetName, rule);
	                    }
	                    if (isFormulaRuleExtension(rule, sheetName, writerDataModel._getSheetsName())) {
	                        writeFormulaRuleExtension(writer, sheetName, rule);
	                    }
	                }
	            });
	        });
	    }
	
	    function writeFormulaRuleExtension(writer, sheetName, rule) {
	        writer.writeElement('x14:conditionalFormatting', function () {
	            writer.writeAttributeString('xmlns:xm', 'http://schemas.microsoft.com/office/excel/2006/main');
	        }, function () {
	            writer.writeElement('x14:cfRule', function () {
	                writer.writeAttributeString('type', 'expression');
	                writer.writeAttributeString('priority', rule.priority);
	                writer.writeAttributeString('id', rule.id);
	            }, function () {
	                writer.writeElement('xm:f', function () {
	                    writer.writeValue(Util._xmlEncode(removeEqualSignIfExist(rule.formula)));
	                });
	                writeDxf(writer, rule.style, 'x14:dxf');
	            });
	            writer.writeElement('xm:sqref', function () {
	                writer.writeValue(getRangeString(rule.ranges));
	            });
	        });
	    }
	
	    function writeDataBarExtensionRecord(writer, sheetName, rule) {
	        writer.writeElement('x14:conditionalFormatting', function () {
	            writer.writeAttributeString('xmlns:xm', 'http://schemas.microsoft.com/office/excel/2006/main');
	        }, function () {
	            writer.writeElement('x14:cfRule', function () {
	                writer.writeAttributeString('type', RuleType[rule.ruleType].replace('Rule', ''));
	                writer.writeAttributeString('id', rule.id);
	            }, function () {
	                writer.writeElement('x14:dataBar', function () {
	                    writer.writeAttributeString('minLength', '0');
	                    writer.writeAttributeString('maxLength', '100');
	                    if (rule.showBarOnly) {
	                        writer.writeAttributeString('showValue', '0');
	                    }
	                    if (rule.showBorder) {
	                        writer.writeAttributeString('border', '1');
	                    }
	                    if (rule.gradient === false) {
	                        writer.writeAttributeString('gradient', '0');
	                    }
	                    if (rule.useNegativeFillColor === false) {
	                        writer.writeAttributeString('negativeBarColorCommunityBuyeAsPositive', '1');
	                    }
	                    if (rule.useNegativeBorderColor) {
	                        writer.writeAttributeString('negativeBarBorderColorCommunityBuyeAsPositive', '0');
	                    }
	                   
	                   
	                   
	                    writer.writeAttributeString('direction', rule.dataBarDirection === 1 ? 'rightToLeft' : 'leftToRight');
	                   
	                    if (rule.axisPosition !== 0) {
	                        if (rule.axisPosition === 1) {
	                            writer.writeAttributeString('axisPosition', 'middle');
	                        }
	                        if (rule.axisPosition === 2) {
	                            writer.writeAttributeString('axisPosition', 'none');
	                        }
	                    }
	                }, function () {
	                    if (isNullOrUndefined(rule.minType) || rule.minType === 5 ) {
	                        writer.writeLeafElement('x14:cfvo', function () {
	                            writer.writeAttributeString('type', 'autoMin');
	                        });
	                    } else if (!isNullOrUndefined(rule.minValue)) {
	                        writer.writeElement('x14:cfvo', function () {
	                            writer.writeAttributeString('type', ScaleValueType[rule.minType]);
	                        }, function () {
	                            writer.writeElement('xm:f', function () {
	                                writer.writeValue(Util._xmlEncode(removeEqualSignIfExist(rule.minValue)));
	                            });
	                        });
	                    } else {
	                        writer.writeLeafElement('x14:cfvo', function () {
	                            writer.writeAttributeString('type', ScaleValueType[rule.minType]);
	                        });
	                    }
	
	                    if (isNullOrUndefined(rule.maxType) || rule.maxType === 7 ) {
	                        writer.writeLeafElement('x14:cfvo', function () {
	                            writer.writeAttributeString('type', 'autoMax');
	                        });
	                    } else if (!isNullOrUndefined(rule.maxValue)) {
	                        writer.writeElement('x14:cfvo', function () {
	                            writer.writeAttributeString('type', ScaleValueType[rule.maxType]);
	                        }, function () {
	                            writer.writeElement('xm:f', function () {
	                                writer.writeValue(Util._xmlEncode(removeEqualSignIfExist(rule.maxValue)));
	                            });
	                        });
	                    } else {
	                        writer.writeLeafElement('x14:cfvo', function () {
	                            writer.writeAttributeString('type', ScaleValueType[rule.maxType]);
	                        });
	                    }
	
	                    if (rule.showBorder && rule.borderColor) {
	                        writeColor(writer, 'x14:borderColor', convertColor(rule.borderColor));
	                    }
	                    if (rule.negativeFillColor) {
	                        writeColor(writer, 'x14:negativeFillColor', convertColor(rule.negativeFillColor));
	                    }
	                    if (rule.negativeBorderColor) {
	                        writeColor(writer, 'x14:negativeBorderColor', convertColor(rule.negativeBorderColor));
	                    }
	                   
	                    if (rule.axisPosition !== 2) {
	                        writeColor(writer, 'x14:axisColor', convertColor(rule.axisColor));
	                    }
	                });
	            });
	            writer.writeElement('xm:sqref', function () {
	                writer.writeValue(getRangeString(rule.ranges));
	            });
	        });
	    }
	
	    function writeIconSetExtensionRecord(writer, sheetName, rule) {
	        writer.writeElement('x14:conditionalFormatting', function () {
	            writer.writeAttributeString('xmlns:xm', 'http://schemas.microsoft.com/office/excel/2006/main');
	        }, function () {
	            writer.writeElement('x14:cfRule', function () {
	                writer.writeAttributeString('type', 'iconSet');
	                if (rule.priority) {
	                    writer.writeAttributeString('priority', rule.priority);
	                }
	                writer.writeAttributeString('id', rule.id);
	            }, function () {
	                writer.writeElement('x14:iconSet', function () {
	                    var iconSetType = rule.iconSetType;
	                    if (isNullOrUndefined(iconSetType)) {
	                        iconSetType = 0 ;
	                    }
	                    writer.writeAttributeString('iconSet', IconSetTypes[iconSetType]);
	                    var isCustomIconSetFlag = isCustomIconSet(iconSetType, rule.icons);
	                    if (isCustomIconSetFlag) {
	                        writer.writeAttributeString('custom', '1');
	                    }
	                    if (rule.showIconOnly) {
	                        writer.writeAttributeString('showValue', '0');
	                    }
	                    if (rule.reverseIconOrder) {
	                        if (isCustomIconSetFlag) {
	                            rule.icons.reverse();
	                        } else {
	                            writer.writeAttributeString('reverse', '1');
	                        }
	                    }
	                }, function () {
	                    writer.writeElement('x14:cfvo', function () {
	                        writer.writeAttributeString('type', 'percent');
	                    }, function () {
	                        writer.writeElement('xm:f', function () {
	                            writer.writeValue('0');
	                        });
	                    });
	                    for (var i = 0; i < rule.iconCriteria.length; i++) {
	                        var criteria = rule.iconCriteria[i];
	                        writer.writeElement('x14:cfvo', function () { 
	                            writer.writeAttributeString('type', IconValueTypes[criteria.iconValueType]);
	                            if (criteria.isGreaterThanOrEqualTo === false) {
	                                writer.writeAttributeString('gte', '0');
	                            }
	                        }, function () { 
	                            writer.writeElement('xm:f', function () {
	                                writer.writeValue(Util._xmlEncode(removeEqualSignIfExist(criteria.iconValue)));
	                            });
	                        });
	                    }
	                    var icons = rule.icons;
	                    for (var j = 0; j < icons.length; j++) {
	                        writer.writeLeafElement('x14:cfIcon', function () { 
	                            var iconSetType = icons[j].iconSetType;
	                            var iconIndex = icons[j].iconIndex;
	                            var iconInfo = distinctIcon(iconSetType, iconIndex);
	                            writer.writeAttributeString('iconSet', IconSetTypes[iconInfo.iconSetType]);
	                            writer.writeAttributeString('iconId', iconInfo.iconIndex);
	                        });
	                    }
	                });
	            });
	            writer.writeElement('xm:sqref', function () {
	                writer.writeValue(getRangeString(rule.ranges));
	            });
	        });
	    }
	
	    function isCustomIconSet(iconSetType, icons) {
	        var isCommunityBuyeIconSetType = true, isAscend = true, isDescend = true;
	        var i;
	        for (i = 0; i < icons.length; i++) {
	            if (icons[i].iconSetType !== iconSetType) {
	                isCommunityBuyeIconSetType = false;
	                break;
	            }
	        }
	        for (i = 0; i < icons.length; i++) {
	            if (icons[i].iconIndex !== i) {
	                isAscend = false;
	                break;
	            }
	        }
	        for (i = 0; i < icons.length; i++) {
	            if (icons[i].iconIndex !== icons.length - 1 - i) {
	                isDescend = false;
	                break;
	            }
	        }
	        if (!isCommunityBuyeIconSetType || !(isAscend || isDescend)) {
	            return true;
	        }
	        return false;
	    }
	
	   
	   
	   
	    function distinctIcon(iconSetType, iconIndex) {
	        if (iconSetType === 10 ) {
	            if (iconIndex === 3) {
	                return {
	                    iconSetType: 0 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 0) {
	                return {
	                    iconSetType: 0 ,
	                    iconIndex: 0
	                };
	            }
	        } else if (iconSetType === 15 ) {
	            if (iconIndex === 4) {
	                return {
	                    iconSetType: 0 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 0) {
	                return {
	                    iconSetType: 0 ,
	                    iconIndex: 0
	                };
	            } else if (iconIndex === 2) {
	                return {
	                    iconSetType: 0 ,
	                    iconIndex: 1
	                };
	            } else if (iconIndex === 3) {
	                return {
	                    iconSetType: 10 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 1) {
	                return {
	                    iconSetType: 10 ,
	                    iconIndex: 1
	                };
	            }
	        } else if (iconSetType === 11 ) {
	            if (iconIndex === 3) {
	                return {
	                    iconSetType: 1 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 0) {
	                return {
	                    iconSetType: 1 ,
	                    iconIndex: 0
	                };
	            }
	        } else if (iconSetType === 16 ) {
	            if (iconIndex === 4) {
	                return {
	                    iconSetType: 1 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 0) {
	                return {
	                    iconSetType: 1 ,
	                    iconIndex: 0
	                };
	            } else if (iconIndex === 2) {
	                return {
	                    iconSetType: 1 ,
	                    iconIndex: 1
	                };
	            } else if (iconIndex === 3) {
	                return {
	                    iconSetType: 11 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 1) {
	                return {
	                    iconSetType: 11 ,
	                    iconIndex: 1
	                };
	            }
	        } else if (iconSetType === 14 ) {
	            if (iconIndex === 3) {
	                return {
	                    iconSetType: 5 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 2) {
	                return {
	                    iconSetType: 5 ,
	                    iconIndex: 1
	                };
	            } else if (iconIndex === 1) {
	                return {
	                    iconSetType: 5 ,
	                    iconIndex: 0
	                };
	            }
	        } else if (iconSetType === 13 ) {
	            if (iconIndex === 0) {
	                return {
	                    iconSetType: 17 ,
	                    iconIndex: 1
	                };
	            } else if (iconIndex === 1) {
	                return {
	                    iconSetType: 17 ,
	                    iconIndex: 2
	                };
	            } else if (iconIndex === 2) {
	                return {
	                    iconSetType: 17 ,
	                    iconIndex: 3
	                };
	            } else if (iconIndex === 3) {
	                return {
	                    iconSetType: 17 ,
	                    iconIndex: 4
	                };
	            }
	        }
	        return {
	            iconSetType: iconSetType,
	            iconIndex: iconIndex
	        };
	    }
	
	    exports.writeConditionalFormating = writeConditionalFormating;
	    exports.writeExtensionConditionalFormats = writeExtensionConditionalFormats;
	    exports.needWriteConditionalFormatExtension = needWriteConditionalFormatExtension;
	
	}());

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var common = __webpack_require__(4);
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var XFileConstants = excel._XFileConstants;
	    var excelStyle = __webpack_require__(12);
	    var UnitHelper = excelStyle.UnitHelper;
	    var pixelToEMU = UnitHelper.pixelToEMU;
	    var Util = common._Util;
	    function writeSlicer(slicers) {
	        if (isNullOrUndefined(slicers)) {
	            return null;
	        }
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('slicers', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._slicerNameSpace);
	            writer.writeAttributeString('xmlns:mc', XFileConstants._slicerCompatibility);
	            writer.writeAttributeString('mc:Ignorable', 'x');
	            writer.writeAttributeString('xmlns:x', XFileConstants._slicerNameSpaceX);
	        }, function () {
	            slicers.forEach(function (slicer) {
	                writer.writeLeafElement('slicer', function () {
	                    writer.writeAttributeString('name', Util._replaceAll(slicer.name, '\n', '_x000a_'));
	                    writer.writeAttributeString('cache', slicer.nameInFormula);
	                    writer.writeAttributeString('caption', slicer.captionName);
	                    if (!isNullOrUndefined(slicer.columnCount)) {
	                        writer.writeAttributeString('columnCount', slicer.columnCount);
	                    }
	                    if (!isNullOrUndefined(slicer.showHeader) && !slicer.showHeader) {
	                        writer.writeAttributeString('showCaption', '0');
	                    }
	    
	                    writer.writeAttributeString('style', slicer.style.name);
	                    var rowHight = 241300;
	                    if (slicer.itemHeight) {
	                        rowHight = pixelToEMU(slicer.itemHeight);
	                    }
	                    writer.writeAttributeString('rowHeight', rowHight);
	                    if (slicer.disableResizingAndMoving) {
	                        writer.writeAttributeString('lockedPosition', '1');
	                    }
	                });
	            });
	        });
	        return writer.xml;
	    }
	
	    function getTableId(tableName, tables) {
	        var tableId = null;
	        tables.forEach(function (table) {
	            if (table.name === tableName) {
	                tableId = table.id;
	            }
	        });
	        return tableId;
	    }
	    function getTableColumnId(tableColumnName, tableName, tables) {
	        var columnID = null;
	        tables.forEach(function (table) {
	            if (table.name === tableName) {
	                table.columns.forEach(function (column) {
	                    if (column.name === tableColumnName) {
	                        columnID = column.id;
	                    }
	                });
	            }
	        });
	        return columnID;
	    }
	    function writeSlicerCache(slicer, tables) {
	        if (isNullOrUndefined(slicer)) {
	            return null;
	        }
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('slicerCacheDefinition', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._slicerNameSpace);
	            writer.writeAttributeString('xmlns:mc', XFileConstants._slicerCompatibility);
	            writer.writeAttributeString('mc:Ignorable', 'x');
	            writer.writeAttributeString('xmlns:x', XFileConstants._slicerNameSpaceX);
	            writer.writeAttributeString('name', slicer.nameInFormula);
	            writer.writeAttributeString('sourceName', slicer.sourceName);
	        }, function () {
	            writer.writeElement('extLst', function () {
	    
	            }, function () {
	                writer.writeElement('x:ext', function () {
	                    writer.writeAttributeString('uri', '{2F2917AC-EB37-4324-AD4E-5DD8C200BD13}');
	                    writer.writeAttributeString('xmlns:x15', XFileConstants._relationship_spreadsheetml_201011);
	                }, function () {
	                    writer.writeLeafElement('x15:tableSlicerCache', function () {
	                        writer.writeAttributeString("tableId", getTableId(slicer.tableName, tables));
	                        writer.writeAttributeString("column", getTableColumnId(slicer.columnName, slicer.tableName, tables));
	                        if (slicer.sortState === 2 ) {
	                            writer.writeAttributeString("sortOrder", "descending");
	                        }
	                        if (slicer.visuallyNoDataItems === false) {
	                            writer.writeAttributeString("crossFilter", "none");
	                        } else if (slicer.showNoDataItemsInLast === false) {
	                            writer.writeAttributeString("crossFilter", "showItemsWithNoData");
	                        }
	                    });
	                });
	                if (slicer.showNoDataItems === false) {
	                    writer.writeElement('x:ext', function () {
	                        writer.writeAttributeString("uri", "{470722E0-AACD-4C17-9CDC-17EF765DBC7E}");
	                        writer.writeAttributeString("xmlns:x15", XFileConstants._relationship_spreadsheetml_201011);
	                    }, function () {
	                        writer.writeLeafElement("x15:slicerCacheHideItemsWithNoData", function () {
	                        });
	                    });
	                }
	            });
	        });
	        return writer.xml;
	    }
	    
	    function writeSlicersInWorkSheet(writer, sheetName, model) {
	        var slicers = model._getSlicers(sheetName);
	        if (!slicers || slicers.length === 0) {
	            return;
	        }
	    
	        writer.writeElement('ext', function () {
	            writer.writeAttributeString("uri", "{3A4CF648-6AED-40f4-86FF-DC5316D8AED3}");
	            writer.writeAttributeString("xmlns:x15", XFileConstants._relationship_spreadsheetml_201011);
	        }, function () {
	            writer.writeElement('x14:slicerList', function () {
	                writer.writeAttributeString("xmlns:x14", XFileConstants._slicerNameSpace);
	            }, function () {
	                if (slicers[0].rid) {
	                    writer.writeLeafElement('x14:slicer', function () {
	                        writer.writeAttributeString("r:id", slicers[0].rid);
	                    });
	                }
	            });
	    
	        });
	    }
	    
	    function writeSlicerCacheInWorkbook(writer, slicers) {
	        writer.writeElement('extLst', function () {
	    
	        }, function () {
	            writer.writeElement('ext', function () {
	                writer.writeAttributeString("uri", "{46BE6895-7355-4a93-B00E-2C351335B9C9}");
	                writer.writeAttributeString("xmlns:x15", XFileConstants._relationship_spreadsheetml_201011);
	            }, function () {
	                writer.writeElement('x15:slicerCaches', function () {
	                    writer.writeAttributeString("xmlns:x14", XFileConstants._slicerNameSpace);
	                }, function () {
	                    for (var key in slicers) {
	                        if (slicers.hasOwnProperty(key) && slicers[key] && slicers[key].length) {
	                            slicers[key].forEach(function (s) {
	                                if (s.cacheRid) {
	                                    writer.writeLeafElement('x14:slicerCache', function () {
	                                        writer.writeAttributeString("r:id", s.cacheRid);
	                                    });
	                                }
	                            });
	                        }
	                    }
	                });
	            });
	        });
	    }
	    
	    
	    function writeSlicerDrawings(slicers, writer, writeAnchorPoint) {
	        slicers.forEach(function (slicer) {
	            writeTwoCellAnchorSlicer(writer, slicer, writeAnchorPoint);
	        });
	    }
	    function writeTwoCellAnchorSlicer(writer, slicer, writeAnchorPoint) {
	        var twoCellAnchor = slicer && slicer.twoCellAnchor;
	        if (twoCellAnchor) {
	            writer.writeElement('xdr:twoCellAnchor', function () {
	                if (!slicer.dynamicMove) {
	                    writer.writeAttributeString("editAs", "absolute");
	                } else if (!slicer.dynamicSize) {
	                    writer.writeAttributeString("editAs", "oneCell");
	                }
	            }, function () {
	                writeAnchorPoint(writer, 'xdr:from', twoCellAnchor.startPoint);
	                writeAnchorPoint(writer, 'xdr:to', twoCellAnchor.endPoint);
	                writeAlternateContent(writer, slicer);
	                writeClientDataSlicer(writer, slicer);
	            });
	        }
	    }
	    function writeClientDataSlicer(writer, slicer) {
	        writer.writeLeafElement('xdr:clientData', function () {
	            if (!slicer.isLocked) {
	                writer.writeAttributeString("fLocksWithSheet", "0");
	            }
	        });
	    }
	    function writeAlternateContent(writer, slicer) {
	        writer.writeElement('mc:AlternateContent', function () {
	            writer.writeAttributeString("xmlns:mc", XFileConstants._slicerCompatibility);
	    
	        }, function () {
	            writeChoice(writer, slicer);
	            writeFallback(writer);
	        });
	    }
	    function writeChoice(writer, slicer) {
	        writer.writeElement('mc:Choice', function () {
	            writer.writeAttributeString("xmlns:sle15", "http://schemas.microsoft.com/office/drawing/2012/slicer");
	            writer.writeAttributeString("Requires", "sle15");
	    
	        }, function () {
	            writegGraphicFrame(writer, slicer);
	        });
	    }
	    function writegGraphicFrame(writer, slicer) {
	        writer.writeElement('xdr:graphicFrame', function () {
	            writer.writeAttributeString("macro", "");
	        }, function () {
	            writeNvGraphicFramePr(writer, slicer);
	            writeXfrm(writer);
	            writeGraphic(writer, slicer);
	        });
	    }
	    function writeNvGraphicFramePr(writer, slicer) {
	    
	        writer.writeElement('xdr:nvGraphicFramePr', function () {
	        }, function () {
	            writeCNvPr(writer, slicer);
	            writeCNvGraphicFramePr(writer);
	        });
	    }
	    function writeXfrm(writer) {
	    
	        writer.writeElement('xdr:xfrm', function () {
	        }, function () {
	            writeOff(writer);
	            writeExt(writer);
	        });
	    }
	    function writeGraphic(writer, slicer) {
	    
	        writer.writeElement('a:graphic', function () {
	        }, function () {
	            writeGraphicData(writer, slicer);
	        });
	    }
	    function writeCNvPr(writer, slicer) {
	        writer.writeLeafElement('xdr:cNvPr', function () {
	            writer.writeAttributeString("id", "2");
	            writer.writeAttributeString("name", Util._replaceAll(slicer.name, '\n', '&#xA;'));
	        });
	    }
	    function writeOff(writer) {
	        writer.writeLeafElement('a:off', function () {
	            writer.writeAttributeString("x", "0");
	            writer.writeAttributeString("y", "0");
	        });
	    }
	    function writeExt(writer) {
	        writer.writeLeafElement('a:ext', function () {
	            writer.writeAttributeString("cx", "0");
	            writer.writeAttributeString("cy", "0");
	        });
	    }
	    function writeGraphicData(writer, slicer) {
	        writer.writeElement('a:graphicData', function () {
	            writer.writeAttributeString("uri", "http://schemas.microsoft.com/office/drawing/2010/slicer");
	        }, function () {
	            writeSleSlicer(writer, slicer);
	        });
	    }
	    function writeSleSlicer(writer, slicer) {
	        writer.writeLeafElement('sle:slicer', function () {
	            writer.writeAttributeString("xmlns:sle", "http://schemas.microsoft.com/office/drawing/2010/slicer");
	            writer.writeAttributeString("name", Util._replaceAll(slicer.name, '\n', '&#xA;'));
	        });
	    }
	    function writeCNvGraphicFramePr(writer) {
	        writer.writeLeafElement('xdr:cNvGraphicFramePr');
	    }
	    
	    function writeFallback(writer) {
	        writer.writeElement('mc:Fallback', function () {
	            writer.writeAttributeString("xmlns", "");
	        }, function () {
	            writeSp(writer);
	        });
	    }
	    function writeSp(writer) {
	        writer.writeElement('xdr:sp', function () {
	            writer.writeAttributeString("macro", "");
	            writer.writeAttributeString("textlink", "");
	        }, function () {
	            writeNvSpPr(writer);
	            writeSpPr(writer);
	            writeTxBody(writer);
	        });
	    }
	    function writeNvSpPr(writer) {
	        writer.writeElement('xdr:nvSpPr', function () {
	        }, function () {
	            writeCNvPrFallback(writer);
	            writeCNvSpPr(writer);
	        });
	    }
	    function writeCNvPrFallback(writer) {
	        writer.writeLeafElement('xdr:cNvPr', function () {
	            writer.writeAttributeString("id", "0");
	            writer.writeAttributeString("name", "");
	        });
	    }
	    function writeCNvSpPr(writer) {
	        writer.writeElement('xdr:cNvSpPr', function () {
	        }, function () {
	            writeSpLocks(writer);
	        });
	    }
	    function writeSpLocks(writer) {
	        writer.writeLeafElement('a:spLocks', function () {
	            writer.writeAttributeString("noTextEdit", "1");
	        });
	    }
	    function writeSpPr(writer) {
	        writer.writeElement('xdr:spPr', function () {
	        }, function () {
	            writeXfrmFallback(writer);
	            writePrstGeom(writer);
	            writeSolidFill(writer);
	            writeLn(writer);
	        });
	    }
	    function writeXfrmFallback(writer) {
	        writer.writeElement('a:xfrm', function () {
	        }, function () {
	            writeOffFallback(writer);
	            writeExtFallback(writer);
	        });
	    }
	    function writeOffFallback(writer) {
	        writer.writeLeafElement('a:off', function () {
	            writer.writeAttributeString("x", "5486400");
	            writer.writeAttributeString("y", "942975");
	        });
	    }
	    function writeExtFallback(writer) {
	        writer.writeLeafElement('a:ext', function () {
	            writer.writeAttributeString("cx", "1828800");
	            writer.writeAttributeString("cy", "2524125");
	        });
	    }
	    
	    function writePrstGeom(writer) {
	        writer.writeElement('a:prstGeom', function () {
	            writer.writeAttributeString("prst", "rect");
	        }, function () {
	            writeAvLst(writer);
	        });
	    }
	    function writeAvLst(writer) {
	        writer.writeLeafElement('a:avLst');
	    }
	    function writeSolidFill(writer) {
	        writer.writeElement('a:solidFill', function () {
	        }, function () {
	            writePrstClr(writer);
	        });
	    }
	    function writePrstClr(writer) {
	        writer.writeLeafElement('a:prstClr', function () {
	            writer.writeAttributeString("val", "white");
	        });
	    }
	    function writeLn(writer) {
	        writer.writeElement('a:ln', function () {
	            writer.writeAttributeString("w", "1");
	        }, function () {
	            writeSolidFillLn(writer);
	        });
	    }
	    function writeSolidFillLn(writer) {
	        writer.writeElement('a:solidFill', function () {
	        }, function () {
	            writePrstClrLn(writer);
	        });
	    }
	    function writePrstClrLn(writer) {
	        writer.writeLeafElement('a:prstClr', function () {
	            writer.writeAttributeString("val", "green");
	        });
	    }
	    function writeTxBody(writer) {
	        writer.writeElement('xdr:txBody', function () {
	        }, function () {
	            writeBodyPr(writer);
	            writeLstStyle(writer);
	            writeP(writer);
	        });
	    }
	    function writeBodyPr(writer) {
	        writer.writeLeafElement('a:bodyPr', function () {
	            writer.writeAttributeString("vertOverflow", "clip");
	            writer.writeAttributeString("horzOverflow", "clip");
	        });
	    }
	    function writeLstStyle(writer) {
	        writer.writeLeafElement('a:lstStyle');
	    }
	    function writeP(writer) {
	        writer.writeElement('a:p', function () {
	        }, function () {
	            writeR(writer);
	        });
	    }
	    function writeR(writer) {
	        writer.writeElement('a:r', function () {
	        }, function () {
	            writeRPr(writer);
	            writeT(writer);
	        });
	    }
	    function writeRPr(writer) {
	        writer.writeLeafElement('a:rPr', function () {
	            writer.writeAttributeString("lang", "en-US");
	            writer.writeAttributeString("sz", "1100");
	        });
	    }
	    function writeT(writer) {
	        var notSupportSlicerNotice = "This shape represents a table slicer. Table slicers are supported in Excel or later.    If the shape was modified in an earlier version of Excel, or if the workbook was saved in Excel 2007 or earlier, the slicer can't be used.";
	        writer.writeElement('a:t', function () {
	            writer.writeValue(notSupportSlicerNotice);
	        });
	    }
	    exports._writeSlicer = writeSlicer;
	    
	    exports._writeSlicerCache = writeSlicerCache;
	    
	    exports._writeSlicerCacheInWorkbook = writeSlicerCacheInWorkbook;
	    
	    exports._writeSlicerDrawings = writeSlicerDrawings;
	    
	    exports._writeSlicersInWorkSheet = writeSlicersInWorkSheet;
	
	}());

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var getRangeString = __webpack_require__(26)._getRangeString;
	    var isNullOrWhiteSpace = common._StringEx._isNullOrWhiteSpace;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var keyword_undefined = void 0;
	    
	    var ComparisonOperators = {        
	        '-1': 'none' ,
	        '0': 'equal' ,
	        '4': 'lessThan' ,
	        '5': 'lessThanOrEqual' ,
	        '1': 'notEqual' ,
	        '2': 'greaterThan' ,
	        '3': 'greaterThanOrEqual' 
	    };
	    var DynamicFilterType = {          
	        '-1': 'null',
	       
	        '100': 'aboveAverage',
	       
	        '101': 'belowAverage'
	    };
	    
	    var DynamicFilterTypeEnum = [
	        ['today', 'yesterday', 'tomorrow', 'lastWeek', 'thisMonth', 'lastMonth', 'nextMonth', 'thisWeek', 'lastWeek', 'nextWeek', 'nextQuarter', 'thisQuarter', 'lastQuarter', 'nextYear', 'thisYear', 'lastYear'],
	        [],
	        ['Q1', 'Q2', 'Q3', 'Q4'], 
	        ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10', 'M11', 'M12'], 
	        [],
	        [],
	        ['yearToDate'] 
	    ];
	    
	    function writeColorFilter(writer, excelColorFilter) {
	        writer.writeLeafElement("colorFilter", function () {
	            if (!excelColorFilter.cellColor) {
	                writer.writeAttributeString("cellColor", "0");
	            }
	            writer.writeAttributeString("dxfId", excelColorFilter.dxfId);
	        });
	    }
	    function writeTop10Filter(writer, excelTop10) {
	        writer.writeLeafElement("top10", function () {
	            if (excelTop10.isBottom) {
	                writer.writeAttributeString("top", "0");
	            }
	            if (excelTop10.percent) {
	                writer.writeAttributeString("percent", "1");
	            }
	            if (!isNaN(excelTop10.value)) {
	                writer.writeAttributeString("val", excelTop10.value);
	            }
	            if (!isNaN(excelTop10.filterValue)) {
	                writer.writeAttributeString("filterVal", excelTop10.filterValue);
	            }
	        });
	    }
	    function writeFilters(writer, excelFilters) {
	        writer.writeElement("filters", function () {
	            if (excelFilters.blank) {
	                writer.writeAttributeString("blank", "1");
	            }
	        }, function () {
	            if (excelFilters.filter) {
	                excelFilters.filter.forEach(function (filter) {
	                    if (!isNullOrWhiteSpace(filter)) {
	                        writer.writeLeafElement("filter", function () {
	                            writer.writeAttributeString("val", filter);
	                        });
	                    }
	                });
	            }
	            if (excelFilters.dateGroupItem) {
	                excelFilters.dateGroupItem.forEach(function (dateItem) {
	                    writer.writeLeafElement("dateGroupItem", function () {
	                        if (dateItem.year > 0) {
	                            writer.writeAttributeString("year", dateItem.year);
	                        }
	                        if (dateItem.month >= 0 && dateItem.month < 12) {
	                            writer.writeAttributeString("month", dateItem.month);
	                        }
	                        if (dateItem.day > 0 && dateItem.day < 32) {
	                            writer.writeAttributeString("day", dateItem.day);
	                        }
	                        if (dateItem.hour < 24) {
	                            writer.writeAttributeString("hour", dateItem.hour);
	                        }
	                        if (dateItem.minute < 60) {
	                            writer.writeAttributeString("minute", dateItem.minute);
	                        }
	                        if (dateItem.second < 60) {
	                            writer.writeAttributeString("second", dateItem.second);
	                        }
	                        writer.writeAttributeString("dateTimeGrouping", "day" );
	                    });
	                });
	            }
	        });
	    }
	    function writeDynamicFilter(writer, dynamicFilter) {
	        if (isNullOrUndefined(dynamicFilter.type)) {
	            return;
	        }
	        writer.writeLeafElement("dynamicFilter", function () {
	            var type = DynamicFilterType[dynamicFilter.type], conType = dynamicFilter.conType,
	                expectTypeId = dynamicFilter.expectTypeId || 0;
	
	            if (conType === 6) {
	                type = DynamicFilterTypeEnum[expectTypeId][dynamicFilter.type];
	            }
	            if (type && type !== 'null') {
	                writer.writeAttributeString("type", type);
	            } else {
	                writer.writeAttributeString("type", "null");
	            }
	            if (type[0] !== 'Q' && type[0] !== 'M') {
	                if (!isNullOrUndefined(dynamicFilter.value)) {
	                    writer.writeAttributeString("val", dynamicFilter.value);
	                }
	                if (!isNullOrUndefined(dynamicFilter.maxValue)) {
	                    writer.writeAttributeString("maxVal", dynamicFilter.maxValue);
	                }
	            }
	        });
	    }
	    function writeCustomFilters(writer, excelCustomFilters) {
	       
	        if (isNullOrUndefined(excelCustomFilters.filter1) && isNullOrUndefined(excelCustomFilters.filter2)) {
	            return;
	        }
	        writer.writeElement("customFilters", function () {
	            if (excelCustomFilters.and) {
	                writer.writeAttributeString("and", "1");
	            }
	        }, function () {
	            if (!isNullOrUndefined(excelCustomFilters.filter1)) {
	                writer.writeLeafElement("customFilter", function () {
	                    var operator = ComparisonOperators[excelCustomFilters.filter1.operator];
	                    if (operator !== 'none') {
	                        writer.writeAttributeString("operator", operator);
	                    }
	                    writer.writeAttributeString("val", excelCustomFilters.filter1.value);
	                });
	            }
	            if (!isNullOrUndefined(excelCustomFilters.filter2)) {
	                writer.writeLeafElement("customFilter", function () {
	                    var operator = ComparisonOperators[excelCustomFilters.filter2.operator];
	                    if (operator !== 'none') {
	                        writer.writeAttributeString("operator", operator);
	                    }
	                    writer.writeAttributeString("val", excelCustomFilters.filter2.value);
	                });
	            }
	        });
	    }
	    
	    function writeSortInfo(writer, sortInfo) {
	        writer.writeElement('sortState', function () {
	            writer.writeAttributeString('ref', getRangeString([sortInfo.range]));
	        }, function () {
	            writer.writeLeafElement('sortCondition', function () {
	                writer.writeAttributeString('ref', getRangeString([sortInfo.range]));
	                if (sortInfo.descending) {
	                    writer.writeAttributeString('descending', '1');
	                }
	                if(sortInfo.isBackColor !== keyword_undefined) {
	                    var sortBy = sortInfo.isBackColor ? 'cellColor' : 'fontColor';
	                    writer.writeAttributeString('sortBy', sortBy);
	                    writer.writeAttributeString('dxfId', sortInfo.dxfid);
	                }
	            });
	        });
	    }
	    exports._writeSortInfo = writeSortInfo;
	    function writeAutoFilter(writer, autoFilter) {
	        if (autoFilter && autoFilter.range) {
	            if (autoFilter.filterColumns.length > 0 || autoFilter.sortInfo) {
	                writer.writeElement('autoFilter', function () {
	                    writer.writeAttributeString('ref', getRangeString([autoFilter.range]));
	                }, function () {
	                    if (autoFilter.filterColumns) {
	                        autoFilter.filterColumns.forEach(function (filterColumn) {
	                            if (filterColumn.colorFilter || filterColumn.top10 || filterColumn.filters || filterColumn.dynamicFilter || filterColumn.customFilters) {
	                                writer.writeElement('filterColumn', function () {
	                                    writer.writeAttributeString('colId', filterColumn.autoFilterColumnId);
	                                    if (!isNullOrUndefined(filterColumn.hiddenButton)) {
	                                        writer.writeAttributeString('hiddenButton', filterColumn.hiddenButton);
	                                    }
	                                }, function () {
	                                    if (!isNullOrUndefined(filterColumn.colorFilter)) {
	                                        writeColorFilter(writer, filterColumn.colorFilter);
	                                    } else if (!isNullOrUndefined(filterColumn.top10)) {
	                                        writeTop10Filter(writer, filterColumn.top10);
	                                    } else if (!isNullOrUndefined(filterColumn.filters)) {
	                                        writeFilters(writer, filterColumn.filters);
	                                    } else if (!isNullOrUndefined(filterColumn.dynamicFilter)) {
	                                        writeDynamicFilter(writer, filterColumn.dynamicFilter);
	                                    } else if (!isNullOrUndefined(filterColumn.customFilters)) {
	                                        writeCustomFilters(writer, filterColumn.customFilters);
	                                    }
	                                });
	                            } else {
	                                writer.writeLeafElement('filterColumn', function () {
	                                    writer.writeAttributeString('colId', filterColumn.autoFilterColumnId);
	                                    if (!isNullOrUndefined(filterColumn.hiddenButton)) {
	                                        writer.writeAttributeString('hiddenButton', filterColumn.hiddenButton);
	                                    }
	                                });
	                            }
	                        });
	                    }
	                    if (autoFilter.sortInfo) {
	                        writeSortInfo(writer, autoFilter.sortInfo);
	                    }
	                });
	            } else {
	                writer.writeLeafElement('autoFilter', function () {
	                    writer.writeAttributeString('ref', getRangeString([autoFilter.range]));
	                });
	            }
	            if (autoFilter.sortInfo) {
	                writeSortInfo(writer, autoFilter.sortInfo);
	            }
	        }
	    }
	    exports._writeAutoFilter = writeAutoFilter;
	    function writeAutoFilterForSheet(writer, sheetName, writerDataModel) {
	        var autoFilter = writerDataModel._getAutoFilter(sheetName);
	        if (autoFilter) {
	            writeAutoFilter(writer, autoFilter);
	        }
	    }
	    exports._writeAutoFilterForSheet = writeAutoFilterForSheet;
	
	}());

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var isNullOrWhiteSpace = common._StringEx._isNullOrWhiteSpace;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var Util = common._Util, xmlEncode = Util._xmlEncode;
	    
	    var keyword_null = null;
	    
	    var ExcelDataValidationType = {
	       
	        '0': 'none', 
	       
	        '1': 'whole', 
	       
	        '2': 'decimal', 
	       
	        '3': 'list',
	       
	        '4': 'date',
	       
	        '5': 'time',
	       
	        '6': 'textLength',
	       
	        '7': 'custom'
	    };
	    var ExcelDataValidationErrorStyle = {
	       
	        '0': 'stop',
	       
	        '1': 'warning',
	       
	        '2': 'information'
	    };
	    var ExcelDataValidationOperator = {
	       
	        '6': 'between',
	       
	        '7': 'notBetween',
	       
	        '0': 'equal',
	       
	        '1': 'notEqual',
	       
	        '2': 'greaterThan',
	       
	        '4': 'lessThan',
	       
	        '3': 'greaterThanOrEqual',
	       
	        '5': 'lessThanOrEqual'
	    };
	    
	    function isNullOrEmpty(value) {
	        return isNullOrUndefined(value) || value === '';
	    }
	    
	    function writeValidationAttribute(writer, item) {
	        if (!isNullOrUndefined(item.type) && item.type !== 0 ) {
	            writer.writeAttributeString("type", ExcelDataValidationType[item.type]);
	        }
	        if (!isNullOrUndefined(item.errorStyle) && item.errorStyle !== 0 ) {
	            writer.writeAttributeString("errorStyle", ExcelDataValidationErrorStyle[item.errorStyle]);
	        }
	        if (!isNullOrUndefined(item.compareOperator) && item.compareOperator !== 6 ) {
	            writer.writeAttributeString("operator", ExcelDataValidationOperator[item.compareOperator]);
	        }
	        if (item.allowBlank !== false) {
	            writer.writeAttributeString("allowBlank", "1");
	        }
	        if (item.showPromptBox === false) {
	            writer.writeAttributeString("showDropDown", "1");
	        }
	        if (item.showInputMessage !== false) {
	            writer.writeAttributeString("showInputMessage", "1");
	        }
	        if (item.showErrorBox !== false) {
	            writer.writeAttributeString("showErrorMessage", "1");
	        }
	        if (!isNullOrEmpty(item.errorTitle)) {
	            writer.writeAttributeString("errorTitle", xmlEncode(item.errorTitle));
	        }
	        if (!isNullOrEmpty(item.error)) {
	            writer.writeAttributeString("error", xmlEncode(Util._encodeSpecialCharacterToXML(item.error)));
	        }
	        if (!isNullOrEmpty(item.promptTitle)) {
	            writer.writeAttributeString("promptTitle", xmlEncode(item.promptTitle));
	        }
	        if (!isNullOrEmpty(item.prompt)) {
	            writer.writeAttributeString("prompt", xmlEncode(Util._encodeSpecialCharacterToXML(item.prompt)));
	        }
	    }
	    
	    function writeDataValidations(writer, sheetName, writerDataModel) {
	        var allDvs = writerDataModel._getValidationData(sheetName);
	        var dvs = [];
	        if (!writerDataModel._extensionDataValidations) {
	            writerDataModel._extensionDataValidations = [];
	        }
	        if (allDvs.length > 0) {
	            allDvs.forEach(function (dv) {
	                if (dv.external) {
	                    writerDataModel._extensionDataValidations.push(dv);
	                } else {
	                    dvs.push(dv);
	                }
	            });
	        }
	        if (dvs.length > 0) {
	            writer.writeElement("dataValidations", function () {
	                writer.writeAttributeString("count", dvs.length);
	            }, function () {
	                dvs.forEach(function (item) {
	                    if (isNullOrUndefined(item) || isNullOrUndefined(item.ranges)) {
	                        return;
	                    }
	                    writer.writeElement("dataValidation", function () {
	                       
	                        writeValidationAttribute(writer, item);
	                       
	                        writer.writeAttributeString("sqref", item.ranges);
	                    }, function () {
	                        if (!isNullOrWhiteSpace(item.firstFormula)) {
	                            writer.writeElementString("formula1", xmlEncode(item.firstFormula));
	                        }
	                        if (!isNullOrWhiteSpace(item.secondFormula)) {
	                            writer.writeElementString("formula2", xmlEncode(item.secondFormula));
	                        }
	                    });
	                });
	            });
	        }
	    }
	    exports._writeDataValidations = writeDataValidations;
	    
	    function writeExtensionDataValidations(writer, writerDataModel) {
	        var _extensionDataValidations = writerDataModel._extensionDataValidations;
	        if (_extensionDataValidations && _extensionDataValidations.length === 0) {
	            return;
	        }
	        writer.writeElement("ext", function () {
	            writer.writeAttributeString("xmlns:x14", "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main");
	            writer.writeAttributeString("uri", "{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}");
	        }, function () {
	            writer.writeElement("x14:dataValidations", function () {
	                writer.writeAttributeString("xmlns:xm", "http://schemas.microsoft.com/office/excel/2006/main");
	                writer.writeAttributeString("count", _extensionDataValidations.length);
	            }, function () {
	                _extensionDataValidations.forEach(function (item) {
	                    writer.writeElement("x14:dataValidation", function () {
	                       
	                        writeValidationAttribute(writer, item);
	                    }, function () {
	                        if (!isNullOrWhiteSpace(item.firstFormula)) {
	                            writer.writeElement("x14:formula1", function () {
	                                writer.writeElementString("xm:f", item.firstFormula);
	                            });
	                        }
	                        if (!isNullOrWhiteSpace(item.secondFormula)) {
	                            writer.writeElement("x14:formula2", function () {
	                                writer.writeElementString("xm:f", item.secondFormula);
	                            });
	                        }
	                       
	                        writer.writeElementString("xm:sqref", item.ranges);
	                    });
	                });
	            });
	        });
	        writerDataModel._extensionDataValidations = keyword_null;
	    }
	    exports._writeExtensionDataValidations = writeExtensionDataValidations;
	
	}());

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var isNullOrWhiteSpace = common._StringEx._isNullOrWhiteSpace;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var xmlEncode = common._Util._xmlEncode;
	    var XmlWriter = __webpack_require__(43);
	    var ExcelConstants = __webpack_require__(21)._ExcelConstants;
	    
	    var ExcelPrintPageOrder = {
	        0: 'auto',
	        1: 'downThenOver',
	        2: 'overThenDown'
	    };
	    var ExcelPrintOrientation = {
	        0: 'auto',
	        1: 'portrait',
	        2: 'landscape'
	    };
	    
	    function writePageMargins(writer, sheetName, writerDataModel) {
	        var printPageMargin = writerDataModel._getPrintPageMargin(sheetName);
	        if (printPageMargin) {
	            writer.writeLeafElement('pageMargins', function () {
	                writer.writeAttributeString('left', printPageMargin.left);
	                writer.writeAttributeString('right', printPageMargin.right);
	                writer.writeAttributeString('top', printPageMargin.top);
	                writer.writeAttributeString('bottom', printPageMargin.bottom);
	                writer.writeAttributeString('header', printPageMargin.header);
	                writer.writeAttributeString('footer', printPageMargin.footer);
	            });
	        }
	    }
	    exports._writePageMargins = writePageMargins;
	    
	    function writePrintOptions(writer, sheetName, writerDataModel) {
	        var option = writerDataModel._getPrintOptions(sheetName);
	        if (option) { 
	            if (option.printGridLine || option.printRowColumnsHeaders || option.horizontalCentered || option.verticalCentered) {
	                writer.writeLeafElement("printOptions", function () {
	                    if (option.printRowColumnsHeaders) {
	                        writer.writeAttributeString("headings", "1");
	                    }
	                    if (option.printGridLine) {
	                        writer.writeAttributeString("gridLines", "1");
	                    }
	                    if (option.horizontalCentered) {
	                        writer.writeAttributeString("horizontalCentered", "1");
	                    }
	                    if (option.verticalCentered) {
	                        writer.writeAttributeString("verticalCentered", "1");
	                    }
	                });
	            }
	        }
	    }
	    exports._writePrintOptions = writePrintOptions;
	    
	    function writePageSetup(writer, sheetName, writerDataModel) {
	        var setting = writerDataModel._getPrintPageSetting(sheetName);
	        if (setting) {
	            writer.writeLeafElement("pageSetup", function () {
	                var paperSizeIndex = setting.paperSizeIndex, zoomFactor = setting.zoomFactor,
	                    firstPageNumber = setting.firstPageNumber, smartPrintPagesWidth = setting.smartPrintPagesWidth,
	                    smartPrintPagesHeight = setting.smartPrintPagesHeight, pageOrder = ExcelPrintPageOrder[setting.pageOrder],
	                    orientation = ExcelPrintOrientation[setting.orientation], copies = setting.copies;
	                if (!isNullOrUndefined(paperSizeIndex) && paperSizeIndex > 1) {
	                    writer.writeAttributeString("paperSize", paperSizeIndex);
	                }
	                if (!isNullOrUndefined(zoomFactor) && Math.abs(zoomFactor - 1.0) > 0.01) {
	                    writer.writeAttributeString("scale", Math.round(zoomFactor * 100));
	                }
	                if (!isNullOrUndefined(firstPageNumber)) {
	                    writer.writeAttributeString("firstPageNumber", firstPageNumber);
	                }
	                if (smartPrintPagesWidth > 0 && smartPrintPagesWidth !== 1) {
	                    writer.writeAttributeString("fitToWidth", smartPrintPagesWidth);
	                }
	                if (smartPrintPagesHeight > 0 && smartPrintPagesHeight !== 1) {
	                    writer.writeAttributeString("fitToHeight", smartPrintPagesHeight);
	                }
	                if (!isNullOrUndefined(pageOrder) && pageOrder !== 0 ) {
	                    writer.writeAttributeString("pageOrder", pageOrder);
	                }
	                if (!isNullOrUndefined(orientation) && orientation !== 0 ) {
	                    writer.writeAttributeString("orientation", orientation);
	                }
	                if (setting.showColor === false) {
	                    writer.writeAttributeString("blackAndWhite", "1");
	                }
	                if (setting.draft === true) {
	                    writer.writeAttributeString("draft", "1");
	                }
	                if (setting.useCustomStartingPage === true) {
	                    writer.writeAttributeString("useFirstPageNumber", "1");
	                }
	                if (copies > 1 && copies < 32767) {
	                    writer.writeAttributeString("copies", copies);
	                }
	            });
	        }
	    }
	    exports._writePageSetup = writePageSetup;
	
	    function needWriteHeaderFooter(setting) {
	        var advancedHeadFooterSetting = setting.advancedHeadFooterSetting;
	        return advancedHeadFooterSetting && (advancedHeadFooterSetting.headerFooterDifferentOddEvenPages ||
	            advancedHeadFooterSetting.headerFooterDifferentFirstPage || !advancedHeadFooterSetting.headerFooterScalesWithDocument || !advancedHeadFooterSetting.headerFooterAlignWithPageMargin || !isNullOrWhiteSpace(setting.header) || !isNullOrWhiteSpace(setting.footer) || !isNullOrWhiteSpace(advancedHeadFooterSetting.headerOddPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.footerOddPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.headerEvenPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.footerEvenPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.headerFirstPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.footerFirstPage));
	    }
	
	    function writeHeadFooter(writer, sheetName, writerDataModel) {
	        var setting = writerDataModel._getPrintPageSetting(sheetName);
	        if (setting && needWriteHeaderFooter(setting)) {
	            var advancedHeadFooterSetting = setting.advancedHeadFooterSetting;
	            writer.writeElement("headerFooter", function () {
	                if (advancedHeadFooterSetting.headerFooterDifferentOddEvenPages === true) {
	                    writer.writeAttributeString("differentOddEven", "1");
	                }
	                if (advancedHeadFooterSetting.headerFooterDifferentFirstPage === true) {
	                    writer.writeAttributeString("differentFirst", "1");
	                }
	                if (advancedHeadFooterSetting.headerFooterScalesWithDocument === false) {
	                    writer.writeAttributeString("scaleWithDoc", "0");
	                }
	                if (advancedHeadFooterSetting.headerFooterAlignWithPageMargin === false) {
	                    writer.writeAttributeString("alignWithMargins", "0");
	                }
	            }, function () {
	                if (!isNullOrWhiteSpace(advancedHeadFooterSetting.headerOddPage)) {
	                    writer.writeElementString("oddHeader", xmlEncode(advancedHeadFooterSetting.headerOddPage));
	                } else if (!isNullOrWhiteSpace(setting.header)) {
	                    writer.writeElementString("oddHeader", xmlEncode(setting.header));
	                }
	                if (!isNullOrWhiteSpace(advancedHeadFooterSetting.footerOddPage)) {
	                    writer.writeElementString("oddFooter", xmlEncode(advancedHeadFooterSetting.footerOddPage));
	                } else if (!isNullOrWhiteSpace(setting.footer)) {
	                    writer.writeElementString("oddFooter", xmlEncode(setting.footer));
	                }
	                if (!isNullOrWhiteSpace(advancedHeadFooterSetting.headerEvenPage)) {
	                    writer.writeElementString("evenHeader", xmlEncode(advancedHeadFooterSetting.headerEvenPage));
	                }
	                if (!isNullOrWhiteSpace(advancedHeadFooterSetting.footerEvenPage)) {
	                    writer.writeElementString("evenFooter", xmlEncode(advancedHeadFooterSetting.footerEvenPage));
	                }
	                if (!isNullOrWhiteSpace(advancedHeadFooterSetting.headerFirstPage)) {
	                    writer.writeElementString("firstHeader", advancedHeadFooterSetting.headerFirstPage);
	                }
	                if (!isNullOrWhiteSpace(advancedHeadFooterSetting.footerFirstPage)) {
	                    writer.writeElementString("firstFooter", advancedHeadFooterSetting.footerFirstPage);
	                }
	            });
	        }
	    }
	    exports._writeHeadFooter = writeHeadFooter;
	    
	    function writeRowOrColumnBreaks(writer, breaks, node) {
	        if (breaks && breaks.length > 0) {
	            writer.writeElement(node, function () {
	                var breakLength = breaks.length;
	                writer.writeAttributeString("count", breakLength);
	               
	                writer.writeAttributeString("manualBreakCount", breakLength);
	            }, function () {
	                breaks.forEach(function (item) {
	                    if (item > 0) {
	                        writer.writeLeafElement("brk", function () {
	                            writer.writeAttributeString("id", item);
	                            writer.writeAttributeString("man", "1");
	                            if (node === "rowBreaks") {
	                                writer.writeAttributeString("max", ExcelConstants._openXmlMaxRow);
	                            } else if (node === "colBreaks") {
	                                writer.writeAttributeString("max", ExcelConstants._openXmlMaxColumn);
	                            }
	                        });
	                    }
	                });
	            });
	        }
	    }
	    function writeRowColumnBreaks(writer, sheetName, writerDataModel) {
	        var setting = writerDataModel._getPrintPageSetting(sheetName);
	        if (setting) {
	            writeRowOrColumnBreaks(writer, setting.rowBreakLines, "rowBreaks");
	            writeRowOrColumnBreaks(writer, setting.columnBreakLines, "colBreaks");
	        }
	    }
	    exports._writeRowColumnBreaks = writeRowColumnBreaks;
	    
	    function writeLegacyDrawingHF(writer, writerDataModel) {
	        if (writerDataModel._legacyDrawingHFId) {
	            writer.writeLeafElement("legacyDrawingHF", function () {
	                writer.writeAttributeString('r:id', writerDataModel._legacyDrawingHFId);
	            });
	            writerDataModel._legacyDrawingHFId = '';
	        }
	    }
	    exports._writeLegacyDrawingHF = writeLegacyDrawingHF;
	    
	    function writeHeaderFooterImage(writer, relid, printHFImage, spid, zIndex) {
	        writer.writeElement("v:shape", function () {
	            writer.writeAttributeString("id", printHFImage);
	            writer.writeAttributeString("o:spid", "_x0000_s10" + spid);
	            writer.writeAttributeString("type", "#_x0000_t75");
	           
	            writer.writeAttributeString("style", "position:absolute;margin-left:0;margin-top:0;width:100%pt;height:100%pt;z-index:" + zIndex);
	        }, function () {
	            writer.writeLeafElement("v:imagedata", function () {
	                writer.writeAttributeString("o:relid", relid);
	                writer.writeAttributeString("o:title", printHFImage);
	            });
	            writer.writeLeafElement("o:lock", function () {
	                writer.writeAttributeString("v:ext", "edit");
	                writer.writeAttributeString("rotation", "t");
	            });
	        });
	    }
	    var writeVmlDrawingFile = function (headerFooterImages) {
	        var writer = new XmlWriter();
	        writer.writeElement("xml", function () {
	            writer.writeAttributeString("xmlns:v", "urn:schemas-microsoft-com:vml");
	            writer.writeAttributeString("xmlns:o", "urn:schemas-microsoft-com:office:office");
	            writer.writeAttributeString("xmlns:x", "urn:schemas-microsoft-com:office:excel");
	        }, function () {
	            writer.writeElement("o:shapelayout", function () {
	                writer.writeAttributeString("v:ext", "edit");
	            }, function () {
	                writer.writeLeafElement("o:idmap", function () {
	                    writer.writeAttributeString("v:ext", "edit");
	                    writer.writeAttributeString("data", "1");
	                });
	            });
	            writer.writeElement("v:shapetype", function () {
	                writer.writeAttributeString("id", "_x0000_t75");
	                writer.writeAttributeString("coordsize", "21600,21600");
	                writer.writeAttributeString("o:spt", "75");
	                writer.writeAttributeString("o:preferrelative", "t");
	                writer.writeAttributeString("path", "m@4@5l@4@11@9@11@9@5xe");
	                writer.writeAttributeString("filled", "f");
	                writer.writeAttributeString("stroked", "f");
	            }, function () {
	                writer.writeLeafElement("v:stroke", function () {
	                    writer.writeAttributeString("joinstyle", "miter");
	                });
	                writer.writeElement("v:formulas", function () {
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "if lineDrawn pixelLineWidth 0");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "sum @0 1 0");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "sum 0 0 @1");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "prod @2 1 2");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "prod @3 21600 pixelWidth");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "prod @3 21600 pixelHeight");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "sum @0 0 1");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "prod @6 1 2");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "prod @7 21600 pixelWidth");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "sum @8 21600 0");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "prod @7 21600 pixelHeight");
	                    });
	                    writer.writeLeafElement("v:f", function () {
	                        writer.writeAttributeString("eqn", "sum @10 21600 0");
	                    });
	                });
	                writer.writeLeafElement("v:path", function () {
	                    writer.writeAttributeString("o:extrusionok", "f");
	                    writer.writeAttributeString("gradientshapeok", "t");
	                    writer.writeAttributeString("o:connecttype", "rect");
	                });
	                writer.writeLeafElement("o:lock", function () {
	                    writer.writeAttributeString("v:ext", "edit");
	                    writer.writeAttributeString("aspectratio", "t");
	                });
	            });
	            var spid = 25, zIndex = 1;
	            headerFooterImages.forEach(function (image) {
	                if (['LH', 'CH', 'RH', 'LF', 'CF', 'RF'].indexOf(image.name) >= 0) {
	                    writeHeaderFooterImage(writer, image.rid, image.name, spid++, zIndex++);
	                }
	            });
	        });
	        return writer.xml;
	    };
	    exports._writeVmlDrawingFile = writeVmlDrawingFile;
	
	}());

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var excel = __webpack_require__(21);
	    var XmlWriter = __webpack_require__(43);
	    
	    var Util = common._Util;
	    var XFileConstants = excel._XFileConstants;
	    
	    
	    function writeSharedString(sharedString) {
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('sst', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._workbookNameSpace);
	            writer.writeAttributeString('count', sharedString._sstTableCount.toString());
	            writer.writeAttributeString('uniqueCount', sharedString._sstTable.length.toString());
	        }, function () {
	            for (var i = 0, len = sharedString._sstTable.length; i < len; i++) {
	                var item = sharedString._sstTable[i];
	                var keepSpace = item.length !== item.trim().length;
	                writer.writeElement('si', undefined, function () { 
	                    writer.writeElement('t', function () {
	                        if (keepSpace) {
	                            writer.writeAttributeString('xml:space', 'preserve');
	                        }
	                    }, function () {
	                        writer.writeValue(Util._xmlEncode(Util._encodeSpecialCharacterToXML(item, true)));
	                    });
	                });
	            }
	        });
	        return writer.xml;
	    }
	    module.exports = writeSharedString;
	
	}());

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var builtInResource = __webpack_require__(13);
	    var writeColorScheme = __webpack_require__(46).writeColorScheme;
	    
	    var XFileConstants = excel._XFileConstants;
	    
	    function writeTheme(writerDataModel) {
	        var theme = writerDataModel._getTheme();
	        if (!theme) {
	            theme = 'Office';
	        }
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('a:theme', function () {
	            writer.writeAttributeString('xmlns:a', XFileConstants._themeNameSpace);
	            if (theme && theme.name) {
	                writer.writeAttributeString('name', theme.name);
	            } else if (theme === 'Office') {
	                writer.writeAttributeString('name', 'Office Theme');
	            } else {
	                writer.writeAttributeString('name', theme);
	            }
	        }, function () {
	            writer.writeElement('a:themeElements', undefined, function () {
	                if (theme && theme.colorScheme) {
	                    var colorScheme = theme.colorScheme;
	                    writer.writeElement('a:clrScheme', function () {
	                        writer.writeAttributeString('name', colorScheme.name);
	                    }, function () {
	                        writeColorScheme(writer, 'a:dk1', colorScheme.schemeColors[1 ]);
	                        writeColorScheme(writer, 'a:lt1', colorScheme.schemeColors[0 ]);
	                        writeColorScheme(writer, 'a:dk2', colorScheme.schemeColors[3 ]);
	                        writeColorScheme(writer, 'a:lt2', colorScheme.schemeColors[2 ]);
	                        writeColorScheme(writer, 'a:accent1', colorScheme.schemeColors[4 ]);
	                        writeColorScheme(writer, 'a:accent2', colorScheme.schemeColors[5 ]);
	                        writeColorScheme(writer, 'a:accent3', colorScheme.schemeColors[6 ]);
	                        writeColorScheme(writer, 'a:accent4', colorScheme.schemeColors[7 ]);
	                        writeColorScheme(writer, 'a:accent5', colorScheme.schemeColors[8 ]);
	                        writeColorScheme(writer, 'a:accent6', colorScheme.schemeColors[9 ]);
	                        writeColorScheme(writer, 'a:hlink', colorScheme.schemeColors[10 ]);
	                        writeColorScheme(writer, 'a:folHlink', colorScheme.schemeColors[11 ]);
	                    });
	                } else if (builtInResource.ThemeClrSchemes[theme]) {
	                    writer.xml += builtInResource.ThemeClrSchemes[theme];
	                } else {
	                    writer.xml += builtInResource.ThemeClrSchemes['Office'];
	                }
	                if (theme && theme.fontScheme) {
	                    var fontScheme = theme.fontScheme;
	                    writer.writeElement('a:fontScheme', function () {
	                        writer.writeAttributeString('name', fontScheme.name);
	                    }, function () {
	                        writer.writeElement('a:majorFont', undefined, function () {
	                            writeThemeFonts(writer, fontScheme.majorFont, true);
	                        });
	                        writer.writeElement('a:minorFont', undefined, function () {
	                            writeThemeFonts(writer, fontScheme.minorFont, false);
	                        });
	                    });
	                } else if (builtInResource.ThemeFontSchemes[theme]) {
	                    writer.xml += builtInResource.ThemeFontSchemes[theme];
	                } else {
	                    writer.xml += builtInResource.ThemeFontSchemes['Office'];
	                }
	    
	               
	                if (builtInResource.ThemeFmtSchemes[theme]) {
	                    writer.xml += builtInResource.ThemeFmtSchemes[theme];
	                } else {
	                    writer.xml += builtInResource.ThemeFmtSchemes['Office'];
	                }
	            });
	            writer.writeLeafElement('a:objectDefaults', undefined);
	            writer.writeLeafElement('a:extraClrSchemeLst', undefined);
	        });
	        return writer.xml;
	    }
	    function writeThemeFonts(writer, themeFonts, isMajorFont) {
	        if (!themeFonts) {
	            return;
	        }
	        if (themeFonts.runFormattings) {
	            writer.writeLeafElement('a:' + excel.FontLanguage[0 ], function () {
	                writer.writeAttributeString('typeface', getRunFormattingTypeface(themeFonts.runFormattings, 0 ));
	            });
	            writer.writeLeafElement('a:' + excel.FontLanguage[2 ], function () {
	                writer.writeAttributeString('typeface', getRunFormattingTypeface(themeFonts.runFormattings, 2 ));
	            });
	            writer.writeLeafElement('a:' + excel.FontLanguage[1 ], function () {
	                writer.writeAttributeString('typeface', getRunFormattingTypeface(themeFonts.runFormattings, 1 ));
	            });
	        }
	        if (themeFonts.themesFonts && themeFonts.themesFonts.length > 0) {
	            for (var i = 0, len = themeFonts.themesFonts.length; i < len; i++) {
	                var item = themeFonts.themesFonts[i];
	                writer.writeLeafElement('a:font', function () { 
	                    writer.writeAttributeString('script', item.script);
	                    writer.writeAttributeString('script', item.typeface);
	                });
	            }
	        } else if (isMajorFont) {
	            writeDefaultMajorFonts(writer);
	        } else {
	            writeDefaultMinorFonts(writer);
	        }
	    }
	    function writeDefaultMajorFonts(writer) {
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Jpan');
	            writer.writeAttributeString('typeface', '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hang');
	            writer.writeAttributeString('typeface', '\ub9d1\uc740 \uace0\ub515');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hans');
	            writer.writeAttributeString('typeface', '\u5b8b\u4f53');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hant');
	            writer.writeAttributeString('typeface', '\u65b0\u7d30\u660e\u9ad4');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Arab');
	            writer.writeAttributeString('typeface', 'Times New Roman');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hebr');
	            writer.writeAttributeString('typeface', 'Times New Roman');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Thai');
	            writer.writeAttributeString('typeface', 'Tahoma');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Ethi');
	            writer.writeAttributeString('typeface', 'Nyala');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Beng');
	            writer.writeAttributeString('typeface', 'Vrinda');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Gujr');
	            writer.writeAttributeString('typeface', 'Shruti');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Khmr');
	            writer.writeAttributeString('typeface', 'MoolBoran');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Knda');
	            writer.writeAttributeString('typeface', 'Tunga');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Guru');
	            writer.writeAttributeString('typeface', 'Raavi');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Cans');
	            writer.writeAttributeString('typeface', 'Euphemia');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Cher');
	            writer.writeAttributeString('typeface', 'Plantagenet Cherokee');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Yiii');
	            writer.writeAttributeString('typeface', 'Microsoft Yi Baiti');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Tibt');
	            writer.writeAttributeString('typeface', 'Microsoft Himalaya');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Thaa');
	            writer.writeAttributeString('typeface', 'MV Boli');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Deva');
	            writer.writeAttributeString('typeface', 'Mangal');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Telu');
	            writer.writeAttributeString('typeface', 'Gautami');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Taml');
	            writer.writeAttributeString('typeface', 'Latha');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Syrc');
	            writer.writeAttributeString('typeface', 'Estrangelo Edessa');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Orya');
	            writer.writeAttributeString('typeface', 'Kalinga');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Mlym');
	            writer.writeAttributeString('typeface', 'Kartika');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Laoo');
	            writer.writeAttributeString('typeface', 'DokChampa');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Sinh');
	            writer.writeAttributeString('typeface', 'Iskoola Pota');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Mong');
	            writer.writeAttributeString('typeface', 'Mongolian Baiti');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Viet');
	            writer.writeAttributeString('typeface', 'Times New Roman');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Uigh');
	            writer.writeAttributeString('typeface', 'Microsoft Uighur');
	        });
	    }
	    function writeDefaultMinorFonts(writer) {
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Jpan');
	            writer.writeAttributeString('typeface', '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hang');
	            writer.writeAttributeString('typeface', '\ub9d1\uc740 \uace0\ub515');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hans');
	            writer.writeAttributeString('typeface', '\u5b8b\u4f53');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hant');
	            writer.writeAttributeString('typeface', '\u65b0\u7d30\u660e\u9ad4');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Arab');
	            writer.writeAttributeString('typeface', 'Arial');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Hebr');
	            writer.writeAttributeString('typeface', 'Arial');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Thai');
	            writer.writeAttributeString('typeface', 'Tahoma');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Ethi');
	            writer.writeAttributeString('typeface', 'Nyala');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Beng');
	            writer.writeAttributeString('typeface', 'Vrinda');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Gujr');
	            writer.writeAttributeString('typeface', 'Shruti');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Khmr');
	            writer.writeAttributeString('typeface', 'DaunPenh');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Knda');
	            writer.writeAttributeString('typeface', 'Tunga');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Guru');
	            writer.writeAttributeString('typeface', 'Raavi');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Cans');
	            writer.writeAttributeString('typeface', 'Euphemia');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Cher');
	            writer.writeAttributeString('typeface', 'Plantagenet Cherokee');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Yiii');
	            writer.writeAttributeString('typeface', 'Microsoft Yi Baiti');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Tibt');
	            writer.writeAttributeString('typeface', 'Microsoft Himalaya');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Thaa');
	            writer.writeAttributeString('typeface', 'MV Boli');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Deva');
	            writer.writeAttributeString('typeface', 'Mangal');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Telu');
	            writer.writeAttributeString('typeface', 'Gautami');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Taml');
	            writer.writeAttributeString('typeface', 'Latha');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Syrc');
	            writer.writeAttributeString('typeface', 'Estrangelo Edessa');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Orya');
	            writer.writeAttributeString('typeface', 'Kalinga');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Mlym');
	            writer.writeAttributeString('typeface', 'Kartika');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Laoo');
	            writer.writeAttributeString('typeface', 'DokChampa');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Sinh');
	            writer.writeAttributeString('typeface', 'Iskoola Pota');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Mong');
	            writer.writeAttributeString('typeface', 'Mongolian Baiti');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Viet');
	            writer.writeAttributeString('typeface', 'Arial');
	        });
	        writer.writeLeafElement('a:font', function () {
	            writer.writeAttributeString('script', 'Uigh');
	            writer.writeAttributeString('typeface', 'Microsoft Uighur');
	        });
	    }
	    function getRunFormattingTypeface(runFormats, targetLanguage) {
	        if (!runFormats) {
	            return '';
	        }
	        for (var i = 0, len = runFormats.length; i < len; i++) {
	            var item = runFormats[i];
	            if (item.fontLanguage === targetLanguage) {
	                return item.typeface;
	            }
	        }
	        return '';
	    }
	    module.exports = writeTheme;
	
	}());

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var common = __webpack_require__(4);
	    var writeSlicerCacheInWorkbook = __webpack_require__(50)._writeSlicerCacheInWorkbook;
	    
	    var XFileConstants = excel._XFileConstants;
	    var Util = common._Util;
	    var IndexHelper = common._IndexHelper;
	    var keyword_undefined = void 0;
	    
	    function writeWorkbook(writerDataModel, sheetIDs, isR1C1) {
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('workbook', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._workbookNameSpace);
	            writer.writeAttributeString('xmlns:r', XFileConstants._relationShipNameSpace);
	        }, function () {
	            saveWorkbookView(writer, writerDataModel);
	            writer.writeElement('sheets', undefined, function () {
	                for (var i = 0, len = sheetIDs.length; i < len; i++) {
	                    var sheet = sheetIDs[i];
	                    if (sheet) {
	                        writer.writeLeafElement('sheet', function () { 
	                            writer.writeAttributeString('name', Util._xmlEncode(sheet.name));
	                            writer.writeAttributeString('sheetId', sheet.sheetId.toString());
	                            if (writerDataModel._isSheetHidden(sheet.name)) {
	                                writer.writeAttributeString('state', 'hidden');
	                            }
	                            writer.writeAttributeString('r:id', sheet.rID.toString());
	                        });
	                    }
	                }
	            });
	            saveDefinedNames(writer, writerDataModel);
	            saveCalcProperty(writer, isR1C1);
	            saveExtLst(writer, writerDataModel, sheetIDs);
	        });
	        return writer.xml;
	    }
	    
	    function saveWorkbookView(writer, writerDataModel) {
	        var ret = writerDataModel._getTabsAndScroll();
	        writer.writeElement('bookViews', undefined, function () {
	            writer.writeLeafElement('workbookView', function () {
	                if (ret.showHorizontalScrollbar === false) {
	                    writer.writeAttributeString('showHorizontalScroll', '0');
	                }
	                if (ret.showVerticalScrollbar === false) {
	                    writer.writeAttributeString('showVerticalScroll', '0');
	                }
	                if (ret.tabStripVisible === false) {
	                    writer.writeAttributeString('showSheetTabs', '0');
	                }
	                if (typeof ret.tabStripRatio === 'number' && ret.tabStripRatio !== 0.6) {
	                    writer.writeAttributeString('tabRatio', (ret.tabStripRatio * 1000).toString());
	                }
	                if (typeof ret.startSheetIndex === 'number' && ret.startSheetIndex > 0) {
	                    writer.writeAttributeString('firstSheet', ret.startSheetIndex.toString());
	                }
	                if (typeof ret.activeSheetIndex === 'number' && ret.activeSheetIndex > 0) {
	                    writer.writeAttributeString('activeTab', ret.activeSheetIndex.toString());
	                }
	            });
	        });
	    }
	    function saveDefinedNames(writer, writerDataModel) {
	        var definedNames = writerDataModel._getDefinedNames();
	        var slicerDefinedNames = getSlicerDefinedNames(writerDataModel);
	        addDefinedNames(definedNames, slicerDefinedNames);
	        var printAreaNames = getPrintNames(writerDataModel);
	        addDefinedNames(definedNames, printAreaNames);
	    
	        if (definedNames.length > 0) {
	            writer.writeElement('definedNames', keyword_undefined, function () {
	                for (var i = 0; i < definedNames.length; i++) {
	                    var definedName = definedNames[i];
	                    writer.writeElement('definedName', function () { 
	                        writer.writeAttributeString('name', Util._xmlEncode(definedName.name));
	                        if(definedName.comment) {
	                            writer.writeAttributeString('comment', Util._xmlEncode(definedName.comment));
	                        }
	                        if (definedName.localSheetId > -1) {
	                            writer.writeAttributeString('localSheetId', definedName.localSheetId);
	                        }
	                    }, function () { 
	                       
	                        writer.writeValue((definedName.formula.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')));
	                    });
	                }
	            });
	        }
	    }
	    function getPrintNames(writerDataModel) {
	        var definedNames = [];
	        var sheetNames = writerDataModel._getSheetsName();
	        for (var i = 0; i < sheetNames.length; i++) {
	            var sheetName = sheetNames[i];
	            var printInfo = writerDataModel._getPrintInfo(sheetName);
	            if (printInfo) {
	                var printAreaExpr = getAbsoluteRangeText(printInfo.rowStart, printInfo.rowEnd, printInfo.columnStart, printInfo.columnEnd, sheetName);
	                if (printAreaExpr) {
	                    definedNames.push({name: '_xlnm.Print_Area', localSheetId: i, formula: printAreaExpr});
	                }
	    
	                var repeatRowExpr = getAbsoluteRangeText(printInfo.repeatRowStart, printInfo.repeatRowEnd, keyword_undefined, keyword_undefined, sheetName);
	                var repeatColumnExpr = getAbsoluteRangeText(keyword_undefined, keyword_undefined, printInfo.repeatColumnStart, printInfo.repeatColumnEnd, sheetName);
	                var printTitleExpr;
	                if (repeatRowExpr && repeatColumnExpr) {
	                    printTitleExpr = repeatColumnExpr + ',' + repeatRowExpr;
	                } else if (repeatRowExpr) {
	                    printTitleExpr = repeatRowExpr;
	                } else if (repeatColumnExpr) {
	                    printTitleExpr = repeatColumnExpr;
	                }
	                if (printTitleExpr) {
	                    definedNames.push({name: '_xlnm.Print_Titles', localSheetId: i, formula: printTitleExpr});
	                }
	    
	            }
	        }
	        return definedNames;
	    }
	    function getAbsoluteRangeText(rowStart, rowEnd, columnStart, columnEnd, sheetName) {
	        if ((columnStart === keyword_undefined) && (columnEnd === keyword_undefined) &&
	            (rowStart === keyword_undefined) && (rowEnd === keyword_undefined)) {
	            return keyword_undefined;
	        }
	        var formula = '';
	        if (columnStart !== keyword_undefined) {
	            formula += '$' + IndexHelper._getColumnIndexInA1Letter(columnStart);
	        }
	        if (rowStart !== keyword_undefined) {
	            formula += '$' + (rowStart + 1);
	        }
	        formula += ':';
	        if (columnEnd !== keyword_undefined) {
	            formula += '$' + IndexHelper._getColumnIndexInA1Letter(columnEnd);
	        }
	        if (rowEnd !== keyword_undefined) {
	            formula += '$' + (rowEnd + 1);
	        }
	    
	        if (sheetName) {
	            return IndexHelper._getSheetName(sheetName) + '!' + formula;
	        }
	        return formula;
	    }
	
	    function isDefinedNameExist(definedNames, slicerDefinedName) {
	        for (var j = 0; j < definedNames.length; j++) {
	            if (definedNames[j].name === slicerDefinedName.name) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    function addDefinedNames(definedNames, slicerDefinedNames) {
	        for (var i = 0; i < slicerDefinedNames.length; i++) {
	            if (!isDefinedNameExist(definedNames, slicerDefinedNames[i])) {
	                definedNames.push(slicerDefinedNames[i]);
	            }
	        }
	    }
	    function getSlicerDefinedNames(writerDataModel) {
	        var definedNames = [];
	        var sheetNames = writerDataModel._getSheetsName();
	        for (var i = 0; i < sheetNames.length; i++) {
	            var slicers = writerDataModel._getSlicers(sheetNames[i]);
	            if (slicers) {
	                for (var j = 0; j < slicers.length; j++) {
	                    definedNames.push({name: slicers[j].nameInFormula, formula: '#N/A'});
	                }
	            }
	        }
	        return definedNames;
	    }
	    function saveCalcProperty(writer, isR1C1) {
	        writer.writeLeafElement('calcPr', function () {
	            writer.writeAttributeString('calcId', '0');
	            if (isR1C1) {
	                writer.writeAttributeString('refMode', 'R1C1');
	            }
	        });
	    }
	    function saveExtLst(writer, writerDataModel, sheetIDs) {
	        var slicers = {};
	        var count = 0;
	        for (var i = 0, len = sheetIDs.length; i < len; i++) {
	            var sheet = sheetIDs[i];
	            if (sheet) {
	                var slicer = writerDataModel._getSlicers(sheet.name);
	                if (slicer && slicer.length) {
	                    slicers[sheet.name] = writerDataModel._getSlicers(sheet.name);
	                    count++;
	                }
	            }
	        }
	        if (count) {
	            writeSlicerCacheInWorkbook(writer, slicers);
	        }
	    
	    }
	    module.exports = writeWorkbook;
	
	}());

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var common = __webpack_require__(4);
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var writeColor = __webpack_require__(46).writeColor;
	
	    var excelStyle = __webpack_require__(12);
	    var ColorHelper = excelStyle.ColorHelper;
	
	    var XFileConstants = excel._XFileConstants;
	    var IndexHelper = common._IndexHelper;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var xmlEncode = common._Util._xmlEncode;
	
	    function writeComments(model, comments) {
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('comments', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._workbookNameSpace);
	        }, function () {
	            writeAuthors(writer);
	            writer.writeElement('commentList', function () {
	                comments.forEach(function (comment) {
	                    writeComment(writer, comment);
	                });
	            });
	        });
	
	        return writer.xml;
	    }
	
	    exports.writeComments = writeComments;
	
	    function writeComment(writer, comment) {
	       
	        function isFontBold(fontWeight) {
	            var value = fontWeight;
	            if (value) {
	                return (value.toLowerCase().indexOf('bold') !== -1 || parseInt(value) > 400 );
	            }
	
	            return false;
	        }
	
	       
	        function isFontItalic(fontStyle) {
	            var value = fontStyle;
	            if (value) {
	                return ['italic', 'oblique'].indexOf(value.toLowerCase().trim()) !== -1;
	            }
	
	            return false;
	        }
	
	        writer.writeElement('comment', function () {
	            writer.writeAttributeString('ref', IndexHelper._getColumnIndexInA1Letter(comment.col) + (comment.row + 1));
	            writer.writeAttributeString('authorId', '0');
	        }, function () {
	            writer.writeElement('text', function () {
	                writer.writeElement('r', function () {
	                    writer.writeElement('rPr', function () {
	                        var value = comment.fontWeight;
	                        if (isFontBold(value)) {
	                            writer.writeLeafElement('b');
	                        }
	                        value = comment.fontStyle;
	                        if (isFontItalic(value)) {
	                            writer.writeLeafElement('i');
	                        }
	                        var textDecoration = comment.textDecoration;
	                        if (textDecoration) {
	                            if (textDecoration & 1 ) {
	                                writer.writeLeafElement('u');
	                            }
	                            if (textDecoration & 8 ) {
	                                writer.writeLeafElement('u', function () {
	                                    writer.writeAttributeString('val', excelStyle.UnderLineStyle[2]);
	                                });
	                            }
	                            if (textDecoration & 2 ) {
	                                writer.writeLeafElement('strike');
	                            }
	                        }
	                        value = comment.fontSize;
	                        if (value) {
	                            writer.writeLeafElement('sz', function () {
	                                writer.writeAttributeString('val', value);
	                            });
	                        }
	                        value = comment.foreColor;
	                        if (value) {
	                            writeColor(writer, 'color', value);
	                        } else {
	                            writer.writeLeafElement('color', function () {
	                                writer.writeAttributeString('indexed', '81');
	                            });
	                        }
	                        value = comment.fontFamily;
	                        if (value) {
	                            writer.writeLeafElement('rFont', function () {
	                                writer.writeAttributeString('val', value);
	                            });
	                        }
	                        writer.writeLeafElement('family', function () {
	                            writer.writeAttributeString('val', '2');
	                        });
	                    });
	
	                    var commentText = comment.text;
	                    var text = isNullOrUndefined(commentText) ? '' : commentText,
	                        keepSpace = text.length !== text.trim().length;
	                    writer.writeElement('t', function () {
	                        if (keepSpace) {
	                            writer.writeAttributeString('xml:space', 'preserve');
	                        }
	                    }, function () {
	                        writer.writeValue(xmlEncode(text));
	                    });
	                });
	            });
	        });
	    }
	
	    function writeAuthors(writer) {
	        writer.writeElement('authors', undefined, function () {
	            writer.writeElement('author', undefined, function () {
	                writer.writeValue('Author');
	            });
	        });
	    }
	
	    function writeCommentShapes(model, sheetIndex, comments) {
	        var writer = new XmlWriter();
	
	        writer.writeElement('xml', writeAttribues, writeConent);
	
	        function writeAttribues() {
	            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
	            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
	            writer.writeAttributeString('xmlns:x', 'urn:schemas-microsoft-com:office:excel');
	        }
	
	        function writeConent() {
	            var shapetypeIDPrefix = '_x0000_t';
	            var shapetypeIDValue = '202';
	            var shapeIDPrefix = '_x0000_s';
	            var shapeIDValue = 1024 * (sheetIndex + 1) + 1;
	
	            writer.writeElement('o:shapelayout', function () {
	                writer.writeAttributeString('v:ext', 'edit');
	            }, function () {
	                writer.writeLeafElement('o:idmap', function () {
	                    writer.writeAttributeString('v:ext', 'edit');
	                    writer.writeAttributeString('data', '1');
	                });
	            });
	            writer.writeElement('v:shapetype', function () {
	                writer.writeAttributeString('id', shapetypeIDPrefix + shapetypeIDValue);
	                writer.writeAttributeString('coordsize', '21600,21600');
	                writer.writeAttributeString('o:spt', shapetypeIDValue);
	                writer.writeAttributeString('path', 'm,l,21600r21600,l21600,xe');
	            }, function () {
	                writer.writeLeafElement('v:stroke', function () {
	                    writer.writeAttributeString('joinstyle', 'miter');
	                });
	
	                writer.writeLeafElement('v:path', function () {
	                    writer.writeAttributeString('gradientshapeok', 't');
	                    writer.writeAttributeString('o:connecttype', 'rect');
	                });
	            });
	            comments.forEach(writeComment);
	
	            function getColorString(color) {
	                if (color && color.indexOf('rgb') >= 0) {
	                    var value = ColorHelper.fromHtmlColor(color),
	                        rgb = value.toString(16).substr(-6);   
	
	                    return '#' + rgb;
	                }
	                return color;
	            }
	
	            function writeComment(comment) {
	                var inset = comment.inset;
	
	                writer.writeElement('v:shape', function () {
	                    writer.writeAttributeString('id', shapeIDPrefix + shapeIDValue);
	                    shapeIDValue++;
	                    writer.writeAttributeString('type', '#' + shapetypeIDPrefix + shapetypeIDValue);
	                    writer.writeAttributeString('style', getStyleString(comment));
	                    writer.writeAttributeString('fillcolor', getColorString(comment.backColor));
	                    writer.writeAttributeString('strokecolor', getColorString(comment.borderColor));
	                    writer.writeAttributeString('strokeweight', comment.borderWidth.toString());
	                    if (!inset) {
	                        writer.writeAttributeString('o:insetmode', 'auto');
	                    }
	                }, function () {
	                    var dashStyle = comment.dashStyle, lineStyle = comment.lineStyle;
	                    if (dashStyle) {
	                        writer.writeLeafElement('v:stroke', function () {
	                            writer.writeAttributeString('dashstyle', dashStyle);
	                        });
	                    } else if (lineStyle) {
	                        writer.writeLeafElement('v:stroke', function () {
	                            writer.writeAttributeString('linestyle', lineStyle);
	                        });
	                    }
	                    writer.writeLeafElement('v:fill', function () {
	                        var opacity = comment.opacity;
	                        if (!isNullOrUndefined(opacity) && opacity !== 1) {
	                            writer.writeAttributeString('opacity', Math.floor(opacity * 65535) + 'f');
	                        }
	                        writer.writeAttributeString('color2', '#ffffe1');
	                    });
	                    writer.writeLeafElement('v:shadow', function () {
	                        writer.writeAttributeString('color', 'black');
	                        writer.writeAttributeString('obscured', 't');
	                    });
	                    writer.writeLeafElement('v:path', function () {
	                        writer.writeAttributeString('o:connecttype', 'none');
	                    });
	                    writer.writeElement('v:textbox', function () {
	                        writer.writeAttributeString('style', 'mso-direction-alt:auto' + (comment.autoSize ? ';mso-fit-shape-to-text:t' : ''));
	                        if (inset) {
	                            writer.writeAttributeString('inset', inset);
	                        }
	                    }, function () {
	                        writer.writeElement('div', function () {
	                            writer.writeAttributeString('style', 'text-align:' + comment.hAlign.toLowerCase());
	                        }, null);
	                    });
	                    writer.writeElement('x:ClientData', function () {
	                        writer.writeAttributeString('ObjectType', 'Note');
	                    }, function () {
	                        if (comment.dynamicMove === false) {
	                            writer.writeLeafElement('x:MoveWithCells');
	                        }
	                        if (comment.dynamicSize === false) {
	                            writer.writeLeafElement('x:SizeWithCells');
	                        }
	                       
	                        if (comment.locked === false) {
	                            writer.writeElementString('x:Locked', 'False');
	                        }
	                        if (comment.lockText === false) {
	                            writer.writeElementString('x:LockText', 'False');
	                        }
	                        writer.writeElementString('x:AutoFill', 'False');
	                        var hAlign = comment.hAlign;
	                        if (hAlign !== 'Left') {
	                            writer.writeElementString('x:TextHAlign', hAlign);
	                        }
	                        writer.writeElementString('x:Row', comment.row);
	                        writer.writeElementString('x:Column', comment.col);
	                        if (comment.displayMode === 1 ) {
	                            writer.writeLeafElement('x:Visible');
	                        }
	                    });
	                });
	
	                function getStyleString(item) {
	                    var style = ['position:absolute'];
	
	                    var value = item.marginLeft;
	                    if (value >= 0) {
	                        style.push('margin-left:' + value + 'pt');
	                    }
	                    value = item.marginTop;
	                    if (value >= 0) {
	                        style.push('margin-top:' + value + 'pt');
	                    }
	                    value = item.width;
	                    if (value) {
	                        style.push('width:' + value);
	                    }
	                    value = item.height;
	                    if (value) {
	                        style.push('height:' + value);
	                    }
	                    style.push('z-index:' + item.zIndex);
	                    value = item.visibility;
	                    if (value) {
	                        style.push('visibility:' + value);
	                    }
	
	                    return style.join(';');
	                }
	            }
	        }
	
	        return writer.xml;
	    }
	
	    exports.writeCommentShapes = writeCommentShapes;
	
	}());

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var excelStyle = __webpack_require__(12);
	    var writeSlicerDrawings = __webpack_require__(50)._writeSlicerDrawings;
	    var UnitHelper = excelStyle.UnitHelper;
	    var pixelToEMU = UnitHelper.pixelToEMU;
	    var XFileConstants = excel._XFileConstants;
	    var writeColorScheme = __webpack_require__(46).writeColorScheme;
	    var DrawingWriterClass = __webpack_require__(59);
	    
	    function writeDrawing(model, pictures, slicers, charts) {
	        var writer = new XmlWriter();
	        writer.writeDocument(true);
	        writer.writeElement('xdr:wsDr', function () {
	            writer.writeAttributeString('xmlns:xdr', XFileConstants._drawingNameSpace);
	            writer.writeAttributeString('xmlns:a', XFileConstants._drawingNameSpace2);
	        }, function () {
	            if (pictures && pictures.length) {
	                writePictures(pictures, writer);
	            }
	            if (slicers && slicers.length) {
	                writeSlicerDrawings(slicers, writer, writeAnchorPoint);
	            }
	            if(charts && charts.length) {
	                writeChartCellAnchorInfo(writer, charts);
	            }
	        });
	    
	        return writer.xml;
	    }
	
	    function preprocessChartWriter(charts) {
	        var chartDrawingInfo = {
	            AnchorBaseList: []
	        };
	        charts.forEach(function (chartInfo) {
	            if(!chartInfo.graphicFrame) {
	                chartInfo.graphicFrame = {};
	            }
	            chartInfo.graphicFrame.graphic = {
	                graphicData: {
	                    chart: {
	                        id: chartInfo.chartId,
	                        typeName: 'chartSpace'
	                    }
	                }
	            };
	            chartDrawingInfo.AnchorBaseList.push(chartInfo);
	        });
	        return chartDrawingInfo;
	    }
	
	    function writeChartCellAnchorInfo(writer, charts) {
	        var chartDrawingInfo = preprocessChartWriter(charts);
	        chartDrawingInfo.AnchorBaseList.forEach(function (item) {
	            if (item.anchorType === 1) {
	                DrawingWriterClass.WriteCT_OneCellAnchor(writer, "xdr", "oneCellAnchor", item);
	            } else if (item.anchorType === 0) {
	                DrawingWriterClass.WriteCT_TwoCellAnchor(writer, "xdr", "twoCellAnchor", item);
	            } else if (item.anchorType === 2) {
	                DrawingWriterClass.WriteCT_AbsoluteAnchor(writer, "xdr", "absoluteAnchor", item);
	            }
	        });
	    }
	
	    function writePictures(pictures, writer) {
	        var id = 1;
	        pictures.forEach(function (picture) {
	            writeTwoCellAnchor(writer, picture, id);
	            id++;
	        });
	    }
	    
	    function writeTwoCellAnchor(writer, picture, id) {
	        var twoCellAnchor = picture && picture.twoCellAnchor;
	        if (twoCellAnchor) {
	            writer.writeElement('xdr:twoCellAnchor', function () {
	                writeAnchorPoint(writer, 'xdr:from', twoCellAnchor.startPoint);
	                writeAnchorPoint(writer, 'xdr:to', twoCellAnchor.endPoint);
	                writePicture(writer, picture, id.toString());
	                writeClientData(writer, picture);
	            });
	        }
	    }
	    
	    function writeAnchorPoint(writer, name, anchorPoint) {
	        writer.writeElement(name, function () {
	            writer.writeElementString('xdr:col', anchorPoint.col);
	            writer.writeElementString('xdr:colOff', pixelToEMU(anchorPoint.colOffset));
	            writer.writeElementString('xdr:row', anchorPoint.row);
	            writer.writeElementString('xdr:rowOff', pixelToEMU(anchorPoint.rowOffset));
	        });
	    }
	    
	    function writePicture(writer, picture, id) {
	        writer.writeElement('xdr:pic', function () {
	            writer.writeElement('xdr:nvPicPr', function () {
	                writer.writeLeafElement('xdr:cNvPr', function () {
	                    writer.writeAttributeString('id', id);
	                    writer.writeAttributeString('name', picture.name);
	                    if (picture.hidden) {
	                        writer.writeAttributeString('hidden', '1');
	                    }
	                });
	                writer.writeElement('xdr:cNvPicPr', function () {
	                    writer.writeLeafElement('a:picLocks', function () {
	                        writer.writeAttributeString('noChangeAspect', '1');
	                    });
	                });
	            });
	            writer.writeElement('xdr:blipFill', function () {
	                writer.writeElement('a:blip', function () {
	                    writer.writeAttributeString('xmlns:r', XFileConstants._relationShipNameSpace);
	                    writer.writeAttributeString('r:embed', picture.rid);
	                    writer.writeAttributeString('cstate', 'print');
	                }, function () {
	                    writer.writeElement('a:extLst', function () {
	                        writer.writeElement('a:ext', function () {
	                            writer.writeAttributeString('uri', '{28A0092B-C50C-407E-A947-70E740481C1C}');
	                        }, function () {
	                            writer.writeLeafElement('a14:useLocalDpi', function () {
	                                writer.writeAttributeString('xmlns:a14', XFileConstants._a14);
	                                writer.writeAttributeString('val', '0');
	                            });
	                        });
	                    });
	                });
	                writer.writeElement('a:stretch', function () {
	                    writer.writeLeafElement('a:fillRect');
	                });
	            });
	    
	            writeShapeProperties(writer, picture);
	        });
	    }
	    
	    function writeShapeProperties(writer, picture) {
	       
	        writer.writeElement('xdr:spPr', function () {
	            writer.writeElement('a:xfrm', function () {
	                writer.writeLeafElement('a:off', function () {
	                    writer.writeAttributeString('x', '0');
	                    writer.writeAttributeString('y', '0');
	                });
	                writer.writeLeafElement('a:ext', function () {
	                    writer.writeAttributeString('cx', '0');
	                    writer.writeAttributeString('cy', '0');
	                });
	            });
	            writer.writeElement('a:prstGeom', function () {
	                writer.writeAttributeString('prst', 'rect');
	            }, function () {
	                writer.writeLeafElement('a:avLst');
	            });
	            var fillColor = picture.fillColor;
	            if (fillColor) {
	                writeColorScheme(writer, 'a:solidFill', fillColor);
	            }
	            var lineBorder = picture.lineBorder, width = lineBorder.width, color = lineBorder.color, style = lineBorder.style;
	            writer.writeElement('a:ln', function () {
	                if (width) {
	                    writer.writeAttributeString('w', pixelToEMU(width));
	                }
	                if (style === 'dbl') {
	                    writer.writeAttributeString('cmpd', 'dbl');
	                }
	            }, function () {
	                writeColorScheme(writer, 'a:solidFill', color);
	                if (style !== 'dbl') {
	                    writer.writeLeafElement('a:prstDash', function () {
	                        writer.writeAttributeString('val', style);
	                    });
	                }
	            });
	        });
	    }
	    
	    function writeClientData(writer, picture) {
	        writer.writeLeafElement('xdr:clientData', function () {
	            if (picture.locked === false) {
	                writer.writeAttributeString('fLocksWithSheet', '0');
	            }
	        });
	    }
	    
	    exports.writeDrawing = writeDrawing;
	
	}());

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Charts = __webpack_require__(24);
	    var excelStyle = __webpack_require__(12);
	    var UnitHelper = excelStyle.UnitHelper;
	    var pixelToEMU = UnitHelper.pixelToEMU;
	    var ChartHelper = __webpack_require__(39)._ChartHelper;
	    var common = __webpack_require__(4);
	    var xmlEncode = common._Util._xmlEncode;
	    var isNullOrUndefined = common._isNullOrUndefined;
	
	    var keyword_null = null,
	        CONST_VAL = 'val', CONST_NAME = 'name', CONST_TYPE = 'type', CONST_PRST = 'prst', CONST_EXTLST = 'extLst',
	        CONST_CNVPR = 'cNvPr', CONST_MACRO = 'macro', CONST_EFFECTLST = 'effectLst', CONST_EFFECT_DAG = 'effectDag',
	        CONST_FPUBLISHED = 'fPublished', CONST_GRAPHIC_FRAME = 'graphicFrame', CONST_EXT = 'ext',
	        CONST_SCRGBCLR = 'scrgbClr', CONST_SRGBCLR = 'srgbClr', CONST_HSLCLR = 'hslClr',
	        CONST_SYSCLR = 'sysClr', CONST_SCHEMECLR = 'schemeClr', CONST_PRSTCLR = 'prstClr',
	        CONST_NO_FILL = 'noFill', CONST_SOLID_FILL = 'solidFill', CONST_GRAD_FILL = 'gradFill',
	        CONST_BLIP_FILL = 'blipFill', CONST_PATT_FILL = 'pattFill', CONST_GRP_FILL = 'grpFill',
	        CONST_DELETE = 'delete', CONST_SCENE_3D = 'scene3d', CONST_SPPR = 'spPr',
	        CONST_TXPR = 'txPr', CONST_INVERT_IF_NEGATIVE = 'invertIfNegative',
	        CONST_BUBBLE_3D = 'bubble3D', CONST_MARKER = 'marker', CONST_GRPSP = 'grpSp', CONST_CXNSP = 'cxnSp',
	        CONST_CLR_SCHEME = 'clrScheme', CONST_FONT_SCHEME = 'fontScheme', CONST_FMT_SCHEME = 'fmtScheme',
	        CONST_LAYOUT = 'layout', CONST_PICTURE_OPTIONS = 'pictureOptions', CONST_ORDER = 'order',
	        CONST_GAP_WIDTH = 'gapWidth', COSNT_DLBLS = 'dLbls', CONST_TRENDLINE = 'trendline',
	        CONST_ERR_BARS = 'errBars', CONST_SER = 'ser', CONST_DROP_LINES = 'dropLines', CONST_AXID = 'axId',
	        CONST_GROUPING = 'grouping', CONST_VARY_COLORS = 'varyColors', CONST_SCALING = 'scaling',
	        CONST_AX_POS = 'axPos', CONST_MAJOR_GRIDLINES = 'majorGridlines', CONST_MINOR_GRIDLINES = 'minorGridlines',
	        CONST_TITLE = 'title', CONST_NUMFMT = 'numFmt', CONST_MAJOR_TICK_MARK = 'majorTickMark',
	        CONST_MINOR_TICK_MARK = 'minorTickMark', CONST_TICK_LBLPOS = 'tickLblPos', CONST_CROSSAX = 'crossAx',
	        CONST_CROSSES = 'crosses', CONST_STYLE = 'style', CONST_TOT_WITH_SHAPE = 'rotWithShape',
	        CONST_CNV_PIC_PR = 'cNvPicPr', CONST_NV_PIC_PR = 'nvPicPr', CONST_CNV_GRAPHIC_FRAME_PR = 'cNvGraphicFramePr',
	        CONST_ALTERNATE_CONTENT = 'AlternateContent', CONST_CLIENT_DATA = 'clientData';
	    var CONST_A = 'a', CONST_CDR = 'cdr', CONST_R = 'r', CONST_XDR = 'xdr', CONST_C = 'c', CONST_C15 = 'c15',
	        COSNT_A14 = 'a14', CONST_C14 = 'c14', CONST_MC = 'mc';
	
	
	    function isNullOrUndefinedOrEmpty(value) {
	        return isNullOrUndefined(value) || value === '';
	    }
	    function writeEmptyNode(writer, prefix, localName) {
	        writer.writeLeafElement(prefix + ":" + localName);
	    }
	    function writeSingleAttributeNode(writer, prefix, localName, attrValue, attrName, defaultValue, enumObj, convertEnumFunc) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(attrValue) && (isNullOrUndefined(defaultValue) || attrValue !== defaultValue)) {
	                if (convertEnumFunc) {
	                    attrValue = convertEnumFunc(attrValue);
	                }
	                if (enumObj) {
	                    attrValue = enumObj[attrValue];
	                }
	                writer.writeAttributeString(attrName, attrValue);
	            }
	        });
	    }
	    function writeSingleSubElementNode(writer, prefix, localName, instance, subElementWriterFunc, nameSpaceString, subElementName) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var subElementValue = instance[subElementName];
	            if (!isNullOrUndefined(subElementValue)) {
	                subElementWriterFunc(writer, nameSpaceString, subElementName, subElementValue);
	            }
	        });
	    }
	    function writeSubSqrefElement(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.sqref)) {
	                writer.writeElementString("c15:sqref", instance.sqref);
	            }
	        });
	    }
	    function writeDoubleSubElementNode(writer, prefix, localName, instance, subElementName1, subElementName2) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var subElementValue1 = instance[subElementName1], subElementValue2 = instance[subElementName2];
	            if (!isNullOrUndefined(subElementValue1)) {
	                writer.writeAttributeString(subElementName1, subElementValue1);
	            }
	            if (!isNullOrUndefined(subElementValue2)) {
	                writer.writeAttributeString(subElementName2, subElementValue2);
	            }
	        });
	    }
	    function writeSubColorElements(writer, instance) {
	        var scrgbClr = instance.scrgbClr, srgbClr = instance.srgbClr, hslClr = instance.hslClr,
	            sysClr = instance.sysClr, schemeClr = instance.schemeClr, prstClr = instance.prstClr;
	        if (!isNullOrUndefined(scrgbClr)) {
	            WriteCT_ScRgbColor(writer, CONST_A, CONST_SCRGBCLR, scrgbClr);
	        } else if (!isNullOrUndefined(srgbClr)) {
	            WriteCT_SRgbColor(writer, CONST_A, CONST_SRGBCLR, srgbClr);
	        } else if (!isNullOrUndefined(hslClr)) {
	            WriteCT_HslColor(writer, CONST_A, CONST_HSLCLR, hslClr);
	        } else if (!isNullOrUndefined(sysClr)) {
	            WriteCT_SystemColor(writer, CONST_A, CONST_SYSCLR, sysClr);
	        } else if (!isNullOrUndefined(schemeClr)) {
	            WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClr);
	        } else if (!isNullOrUndefined(prstClr)) {
	            WriteCT_PresetColor(writer, CONST_A, CONST_PRSTCLR, prstClr);
	        }
	    }
	    function writeFillProperties(writer, instance) {
	        var noFill = instance.noFill, solidFill = instance.solidFill, gradFill = instance.gradFill,
	            blipFill = instance.blipFill, pattFill = instance.pattFill, grpFill = instance.grpFill;
	        if (!isNullOrUndefined(noFill)) {
	            WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
	        } else if (!isNullOrUndefined(solidFill)) {
	            WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFill);
	        } else if (!isNullOrUndefined(gradFill)) {
	            WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFill);
	        } else if (!isNullOrUndefined(blipFill)) {
	            WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFill);
	        } else if (!isNullOrUndefined(pattFill)) {
	            WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFill);
	        } else if (!isNullOrUndefined(grpFill)) {
	            WriteCT_GroupFillProperties(writer, CONST_A, CONST_GRP_FILL);
	        }
	    }
	    function writeFillPropertiesFromArray(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.noFill) {
	                writeArrayItem(instance.noFill, function () {
	                    WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
	                });
	            } else if (instance.solidFill) {
	                writeArrayItem(instance.solidFill, function (solidFillItem) {
	                    WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFillItem);
	                });
	            } else if (instance.gradFill) {
	                writeArrayItem(instance.gradFill, function (gradFillItem) {
	                    WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFillItem);
	                });
	            } else if (instance.blipFill) {
	                writeArrayItem(instance.blipFill, function (blipFillItem) {
	                    WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFillItem);
	                });
	            } else if (instance.pattFill) {
	                writeArrayItem(instance.pattFill, function (pattFillItem) {
	                    WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFillItem);
	                });
	            } else if (instance.grpFill) {
	                writeArrayItem(instance.grpFill, function () {
	                    WriteCT_GroupFillProperties(writer, CONST_A, CONST_GRP_FILL);
	                });
	            }
	        });
	    }
	    function writeColorSubElement(writer, instance) {
	        writeArrayItem(instance.tint, function (tintItem) {
	            WriteCT_PositiveFixedPercentage(writer, CONST_A, "tint", tintItem);
	        });
	
	        writeArrayItem(instance.shade, function (shadeItem) {
	            WriteCT_PositiveFixedPercentage(writer, CONST_A, "shade", shadeItem);
	        });
	
	        writeArrayItem(instance.comp, function () {
	            WriteCT_ComplementTransform(writer, CONST_A, "comp");
	        });
	
	        writeArrayItem(instance.inv, function () {
	            WriteCT_InverseTransform(writer, CONST_A, "inv");
	        });
	
	        writeArrayItem(instance.gray, function () {
	            WriteCT_GrayscaleTransform(writer, CONST_A, "gray");
	        });
	
	        writeArrayItem(instance.alpha, function (alphaItem) {
	            WriteCT_PositiveFixedPercentage(writer, CONST_A, "alpha", alphaItem);
	        });
	
	        writeArrayItem(instance.alphaMod, function (alphaModItem) {
	            WriteCT_PositivePercentage(writer, CONST_A, "alphaMod", alphaModItem);
	        });
	
	        writeArrayItem(instance.alphaOff, function (alphaOffItem) {
	            WriteCT_FixedPercentage(writer, CONST_A, "alphaOff", alphaOffItem);
	        });
	
	        writeArrayItem(instance.hue, function (hueItem) {
	            WriteCT_PositiveFixedAngle(writer, CONST_A, "hue", hueItem);
	        });
	
	        writeArrayItem(instance.hueMod, function (hueModItem) {
	            WriteCT_PositivePercentage(writer, CONST_A, "hueMod", hueModItem);
	        });
	
	        writeArrayItem(instance.hueOff, function (hueOffItem) {
	            WriteCT_Angle(writer, CONST_A, "hueOff", hueOffItem);
	        });
	
	        writeArrayItem(instance.sat, function (satItem) {
	            WriteCT_Percentage(writer, CONST_A, "sat", satItem);
	        });
	
	        writeArrayItem(instance.satMod, function (satModItem) {
	            WriteCT_Percentage(writer, CONST_A, "satMod", satModItem);
	        });
	
	        writeArrayItem(instance.satOff, function (satOffItem) {
	            WriteCT_Percentage(writer, CONST_A, "satOff", satOffItem);
	        });
	
	        writeArrayItem(instance.lum, function (lumItem) {
	            WriteCT_Percentage(writer, CONST_A, "lum", lumItem);
	        });
	
	        writeArrayItem(instance.lumMod, function (lumModItem) {
	            WriteCT_Percentage(writer, CONST_A, "lumMod", lumModItem);
	        });
	
	        writeArrayItem(instance.lumOff, function (lumOffItem) {
	            WriteCT_Percentage(writer, CONST_A, "lumOff", lumOffItem);
	        });
	
	        writeArrayItem(instance.red, function (redItem) {
	            WriteCT_Percentage(writer, CONST_A, "red", redItem);
	        });
	
	        writeArrayItem(instance.redMod, function (redModItem) {
	            WriteCT_Percentage(writer, CONST_A, "redMod", redModItem);
	        });
	
	        writeArrayItem(instance.redOff, function (redOffItem) {
	            WriteCT_Percentage(writer, CONST_A, "redOff", redOffItem);
	        });
	
	        writeArrayItem(instance.green, function (greenItem) {
	            WriteCT_Percentage(writer, CONST_A, "green", greenItem);
	        });
	
	        writeArrayItem(instance.greenMod, function (greenModItem) {
	            WriteCT_Percentage(writer, CONST_A, "greenMod", greenModItem);
	        });
	
	        writeArrayItem(instance.greenOff, function (greenOffItem) {
	            WriteCT_Percentage(writer, CONST_A, "greenOff", greenOffItem);
	        });
	
	        writeArrayItem(instance.blue, function (blueItem) {
	            WriteCT_Percentage(writer, CONST_A, "blue", blueItem);
	        });
	
	        writeArrayItem(instance.blueMod, function (blueModItem) {
	            WriteCT_Percentage(writer, CONST_A, "blueMod", blueModItem);
	        });
	
	        writeArrayItem(instance.blueOff, function (blueOffItem) {
	            WriteCT_Percentage(writer, CONST_A, "blueOff", blueOffItem);
	        });
	
	        writeArrayItem(instance.gamma, function () {
	            WriteCT_GammaTransform(writer, CONST_A, "gamma");
	        });
	
	        writeArrayItem(instance.invGamma, function () {
	            WriteCT_InverseGammaTransform(writer, CONST_A, "invGamma");
	        });
	    }
	    function writeSurfaceChartSubElement(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var wireframe = instance.wireframe, bandFmts = instance.bandFmts, extLst = instance.extLst;
	            if (!isNullOrUndefined(wireframe)) {
	                WriteCT_Boolean(writer, CONST_C, "wireframe", wireframe);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_SurfaceSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(bandFmts)) {
	                WriteCT_BandFmts(writer, CONST_C, "bandFmts", bandFmts);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	    function writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, nameSpaceString) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, nameSpaceString, CONST_CNVPR, cNvPr);
	            }
	            WriteCT_NonVisualGraphicFrameProperties(writer, nameSpaceString, CONST_CNV_GRAPHIC_FRAME_PR);
	        });
	    }
	    function writeAxisSubElement(writer, instance) {
	        var axId = instance.axId, scaling = instance.scaling, deleteField = instance.delete,
	            axPos = instance.axPos, majorGridlines = instance.majorGridlines,
	            minorGridlines = instance.minorGridlines, title = instance.title,
	            numFmt = instance.numFmt, majorTickMark = instance.majorTickMark,
	            minorTickMark = instance.minorTickMark, tickLblPos = instance.tickLblPos,
	            spPr = instance.spPr, txPr = instance.txPr, crossAx = instance.crossAx,
	            crosses = instance.crosses, crossesAt = instance.crossesAt;
	        if (!isNullOrUndefined(axId)) {
	            WriteCT_Int(writer, CONST_C, CONST_AXID, axId);
	        }
	        if (!isNullOrUndefined(scaling)) {
	            WriteCT_Scaling(writer, CONST_C, CONST_SCALING, scaling);
	        }
	        if (!isNullOrUndefined(deleteField)) {
	            WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
	        }
	        if (!isNullOrUndefined(axPos)) {
	            WriteCT_AxPos(writer, CONST_C, CONST_AX_POS, axPos);
	        }
	        if (!isNullOrUndefined(majorGridlines)) {
	            WriteCT_ChartLines(writer, CONST_C, CONST_MAJOR_GRIDLINES, majorGridlines);
	        }
	        if (!isNullOrUndefined(minorGridlines)) {
	            WriteCT_ChartLines(writer, CONST_C, CONST_MINOR_GRIDLINES, minorGridlines);
	        }
	        if (!isNullOrUndefined(title)) {
	            WriteCT_Title(writer, CONST_C, CONST_TITLE, title);
	        }
	        if (!isNullOrUndefined(numFmt)) {
	            WriteCT_NumFmt(writer, CONST_C, CONST_NUMFMT, numFmt);
	        }
	        if (!isNullOrUndefined(majorTickMark)) {
	            WriteCT_TickMark(writer, CONST_C, CONST_MAJOR_TICK_MARK, majorTickMark);
	        }
	        if (!isNullOrUndefined(minorTickMark)) {
	            WriteCT_TickMark(writer, CONST_C, CONST_MINOR_TICK_MARK, minorTickMark);
	        }
	        if (!isNullOrUndefined(tickLblPos)) {
	            WriteCT_TickLblPos(writer, CONST_C, CONST_TICK_LBLPOS, tickLblPos);
	        }
	        if (!isNullOrUndefined(spPr)) {
	            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	        }
	        if (!isNullOrUndefined(txPr)) {
	            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	        }
	        if (!isNullOrUndefined(crossAx)) {
	            WriteCT_Int(writer, CONST_C, CONST_CROSSAX, crossAx);
	        }
	        if (!isNullOrUndefined(crosses)) {
	            WriteCT_Crosses(writer, CONST_C, CONST_CROSSES, crosses);
	        }
	        if (!isNullOrUndefined(crossesAt)) {
	            WriteCT_Double(writer, CONST_C, "crossesAt", crossesAt);
	        }
	    }
	    function writeArrayItem(items, callback) {
	        if (!isNullOrUndefined(items)) {
	            for (var i = 0, count = items.length; i < count; i++) {
	                var item = items[i];
	                if (!isNullOrUndefined(item)) {
	                    callback(item, i);
	                }
	            }
	        }
	    }
	    function writeLineOrScatterSerSubElement(writer, instance) {
	        var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr,
	            marker = instance.marker, dLbls = instance.dLbls, smooth = instance.smooth, extLst = instance.extLst;
	        if (!isNullOrUndefined(idx)) {
	            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	        }
	        if (!isNullOrUndefined(order)) {
	            WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
	        }
	        if (!isNullOrUndefined(tx)) {
	            WriteCT_SerTx(writer, CONST_C, "tx", tx);
	        }
	        if (!isNullOrUndefined(spPr)) {
	            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	        }
	        if (!isNullOrUndefined(marker)) {
	            WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
	        }
	        writeArrayItem(instance.dPt, function (dPtItem) {
	            WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
	        });
	        if (!isNullOrUndefined(dLbls)) {
	            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	        }
	        writeArrayItem(instance.trendline, function (trendlineItem) {
	            WriteCT_Trendline(writer, CONST_C, CONST_TRENDLINE, trendlineItem);
	        });
	        writeArrayItem(instance.errBars, function (errBarsItem) {
	            WriteCT_ErrBars(writer, CONST_C, CONST_ERR_BARS, errBarsItem);
	        });
	
	        if (!isNullOrUndefined(smooth)) {
	            WriteCT_Boolean(writer, CONST_C, "smooth", smooth);
	        }
	        if (!isNullOrUndefined(extLst)) {
	            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	        }
	    }
	    function writeAreaOrBarSerSubElement(writer, instance) {
	        var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr,
	            pictureOptions = instance.pictureOptions, dLbls = instance.dLbls, cat = instance.cat,
	            val = instance.val, extLst = instance.extLst;
	        if (!isNullOrUndefined(idx)) {
	            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	        }
	        if (!isNullOrUndefined(order)) {
	            WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
	        }
	        if (!isNullOrUndefined(tx)) {
	            WriteCT_SerTx(writer, CONST_C, "tx", tx);
	        }
	        if (!isNullOrUndefined(spPr)) {
	            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	        }
	        if (!isNullOrUndefined(pictureOptions)) {
	            WriteCT_PictureOptions(writer, CONST_C, CONST_PICTURE_OPTIONS, pictureOptions);
	        }
	        writeArrayItem(instance.dPt, function (dPtItem) {
	            WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
	        });
	        if (!isNullOrUndefined(dLbls)) {
	            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	        }
	        writeArrayItem(instance.trendline, function (trendlineItem) {
	            WriteCT_Trendline(writer, CONST_C, CONST_TRENDLINE, trendlineItem);
	        });
	        writeArrayItem(instance.errBars, function (errBarsItem) {
	            WriteCT_ErrBars(writer, CONST_C, CONST_ERR_BARS, errBarsItem);
	        });
	        if (!isNullOrUndefined(cat)) {
	            WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
	        }
	        if (!isNullOrUndefined(val)) {
	            WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
	        }
	        if (!isNullOrUndefined(extLst)) {
	            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	        }
	    }
	    function writeLockingElementAttribute(writer, instance) {
	        if (instance.noGrp === true) {
	            writer.writeAttributeString("noGrp", "1");
	        }
	        if (instance.noSelect === true) {
	            writer.writeAttributeString("noSelect", "1");
	        }
	        if (instance.noRot === true) {
	            writer.writeAttributeString("noRot", "1");
	        }
	        if (instance.noChangeAspect === true) {
	            writer.writeAttributeString("noChangeAspect", "1");
	        }
	        if (instance.noMove === true) {
	            writer.writeAttributeString("noMove", "1");
	        }
	        if (instance.noResize === true) {
	            writer.writeAttributeString("noResize", "1");
	        }
	        if (instance.noEditPoints === true) {
	            writer.writeAttributeString("noEditPoints", "1");
	        }
	        if (instance.noAdjustHandles === true) {
	            writer.writeAttributeString("noAdjustHandles", "1");
	        }
	        if (instance.noChangeArrowheads === true) {
	            writer.writeAttributeString("noChangeArrowheads", "1");
	        }
	        if (instance.noChangeShapeType === true) {
	            writer.writeAttributeString("noChangeShapeType", "1");
	        }
	    }
	    function writeDLblSubElement(writer, instance) {
	        var numFmt = instance.numFmt, spPr = instance.spPr, txPr = instance.txPr,
	            dLblPos = instance.dLblPos, showLegendKey = instance.showLegendKey, showVal = instance.showVal,
	            showCatName = instance.showCatName, showSerName = instance.showSerName,
	            showPercent = instance.showPercent, showBubbleSize = instance.showBubbleSize;
	        if (!isNullOrUndefined(numFmt)) {
	            WriteCT_NumFmt(writer, CONST_C, CONST_NUMFMT, numFmt);
	        }
	        if (!isNullOrUndefined(spPr)) {
	            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	        }
	        if (!isNullOrUndefined(txPr)) {
	            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	        }
	        if (!isNullOrUndefined(dLblPos)) {
	            WriteCT_DLblPos(writer, CONST_C, "dLblPos", dLblPos);
	        }
	        if (!isNullOrUndefined(showLegendKey)) {
	            WriteCT_Boolean(writer, CONST_C, "showLegendKey", showLegendKey);
	        }
	        if (!isNullOrUndefined(showVal)) {
	            WriteCT_Boolean(writer, CONST_C, "showVal", showVal);
	        }
	        if (!isNullOrUndefined(showCatName)) {
	            WriteCT_Boolean(writer, CONST_C, "showCatName", showCatName);
	        }
	        if (!isNullOrUndefined(showSerName)) {
	            WriteCT_Boolean(writer, CONST_C, "showSerName", showSerName);
	        }
	        if (!isNullOrUndefined(showPercent)) {
	            WriteCT_Boolean(writer, CONST_C, "showPercent", showPercent);
	        }
	        if (!isNullOrUndefined(showBubbleSize)) {
	            WriteCT_Boolean(writer, CONST_C, "showBubbleSize", showBubbleSize);
	        }
	        if (!isNullOrUndefined(instance.separator)) {
	            writer.writeElementString("c:separator", instance.separator);
	        }
	    }
	    function writeEffectElementAttribute(writer, instance) {
	        var sx = instance.sx, sy = instance.sy,
	            kx = instance.kx, ky = instance.ky, algn = instance.algn;
	        if (!isNullOrUndefined(sx) && sx !== 100000) {
	            writer.writeAttributeString("sx", sx);
	        }
	        if (!isNullOrUndefined(sy) && sy !== 100000) {
	            writer.writeAttributeString("sy", sy);
	        }
	        if (!isNullOrUndefined(kx) && kx !== 0) {
	            writer.writeAttributeString("kx", kx);
	        }
	        if (!isNullOrUndefined(ky) && ky !== 0) {
	            writer.writeAttributeString("ky", ky);
	        }
	        if (!isNullOrUndefined(algn) && algn !== 7 ) {
	           
	            writer.writeAttributeString("algn", Charts.ST_RectAlignment[algn]);
	        }
	        if (instance.rotWithShape === false) {
	            writer.writeAttributeString(CONST_TOT_WITH_SHAPE, "0");
	        }
	    }
	    function writeShapeElement(writer, prefix, localName, instance, nameSpaceString, specialWriterFunc) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro, textlink = instance.textlink;
	            if (!isNullOrUndefined(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (!isNullOrUndefined(textlink)) {
	                writer.writeAttributeString("textlink", textlink);
	            }
	            if (instance.fLocksText === false) {
	                writer.writeAttributeString("fLocksText", "0");
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvSpPr = instance.nvSpPr, spPr = instance.spPr, style = instance.style, txBody = instance.txBody;
	            if (!isNullOrUndefined(nvSpPr)) {
	                specialWriterFunc(writer, nameSpaceString, "nvSpPr", nvSpPr);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, nameSpaceString, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, nameSpaceString, CONST_STYLE, style);
	            }
	            if (!isNullOrUndefined(txBody)) {
	                WriteCT_TextBody(writer, nameSpaceString, "txBody", txBody);
	            }
	        });
	    }
	    function writeShapeNonVisualElement(writer, prefix, localName, instance, nameSpaceString) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvSpPr = instance.cNvSpPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, nameSpaceString, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvSpPr)) {
	                WriteCT_NonVisualDrawingShapeProps(writer, nameSpaceString, "cNvSpPr", cNvSpPr);
	            }
	        });
	    }
	    function writeAnchorSubElement(writer, instance) {
	        var ext = instance.ext, sp = instance.sp, grpSp = instance.grpSp,
	            graphicFrame = instance.graphicFrame, cxnSp = instance.cxnSp,
	            alternateContent = instance.AlternateContent, clientData = instance.clientData;
	        if (!isNullOrUndefined(ext)) {
	            WriteCT_PositiveSize2D(writer, CONST_XDR, CONST_EXT, ext, true);
	        }
	        if (!isNullOrUndefined(sp)) {
	            WriteCT_Shape(writer, CONST_XDR, "sp", sp);
	        }
	        if (!isNullOrUndefined(grpSp)) {
	            WriteCT_GroupShape(writer, CONST_XDR, CONST_GRPSP, grpSp);
	        }
	        if (!isNullOrUndefined(graphicFrame)) {
	            WriteCT_GraphicalObjectFrame(writer, CONST_XDR, CONST_GRAPHIC_FRAME, graphicFrame);
	        }
	        if (!isNullOrUndefined(cxnSp)) {
	            WriteCT_Connector(writer, CONST_XDR, CONST_CXNSP, cxnSp);
	        }
	        if (!isNullOrUndefined(alternateContent)) {
	            WriteCT_AlternateContent(writer, CONST_MC, CONST_ALTERNATE_CONTENT);
	        }
	        if (!isNullOrUndefined(clientData)) {
	            WriteCT_AnchorClientData(writer, CONST_XDR, CONST_CLIENT_DATA, clientData);
	        }
	    }
	
	
	    var DrawingWriter = {
	        a: "http://schemas.openxmlformats.org/drawingml/2006/main",
	        cdr: "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing",
	        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
	        xdr: "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
	        c: "http://schemas.openxmlformats.org/drawingml/2006/chart",
	        c15: "http://schemas.microsoft.com/office/drawing/2012/chart",
	        a14: "http://schemas.microsoft.com/office/drawing/2010/main",
	        c14: "http://schemas.microsoft.com/office/drawing/2007/8/2/chart",
	        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006"
	    };
	
	    function WriteCT_ColorScheme(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.name)) {
	                writer.writeAttributeString(CONST_NAME, instance.name);
	            }
	        }, function () {
	           
	            var dk1 = instance.dk1, lt1 = instance.lt1, dk2 = instance.dk2, lt2 = instance.lt2,
	                accent1 = instance.accent1, accent2 = instance.accent2, accent3 = instance.accent3,
	                accent4 = instance.accent4, accent5 = instance.accent5, accent6 = instance.accent6,
	                hlink = instance.hlink, folHlink = instance.folHlink, extLst = instance.extLst;
	            if (!isNullOrUndefined(dk1)) {
	                WriteCT_Color(writer, CONST_A, "dk1", dk1);
	            }
	            if (!isNullOrUndefined(lt1)) {
	                WriteCT_Color(writer, CONST_A, "lt1", lt1);
	            }
	            if (!isNullOrUndefined(dk2)) {
	                WriteCT_Color(writer, CONST_A, "dk2", dk2);
	            }
	            if (!isNullOrUndefined(lt2)) {
	                WriteCT_Color(writer, CONST_A, "lt2", lt2);
	            }
	            if (!isNullOrUndefined(accent1)) {
	                WriteCT_Color(writer, CONST_A, "accent1", accent1);
	            }
	            if (!isNullOrUndefined(accent2)) {
	                WriteCT_Color(writer, CONST_A, "accent2", accent2);
	            }
	            if (!isNullOrUndefined(accent3)) {
	                WriteCT_Color(writer, CONST_A, "accent3", accent3);
	            }
	            if (!isNullOrUndefined(accent4)) {
	                WriteCT_Color(writer, CONST_A, "accent4", accent4);
	            }
	            if (!isNullOrUndefined(accent5)) {
	                WriteCT_Color(writer, CONST_A, "accent5", accent5);
	            }
	            if (!isNullOrUndefined(accent6)) {
	                WriteCT_Color(writer, CONST_A, "accent6", accent6);
	            }
	            if (!isNullOrUndefined(hlink)) {
	                WriteCT_Color(writer, CONST_A, "hlink", hlink);
	            }
	            if (!isNullOrUndefined(folHlink)) {
	                WriteCT_Color(writer, CONST_A, "folHlink", folHlink);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorScheme = WriteCT_ColorScheme;
	
	    function WriteCT_CustomColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefinedOrEmpty(instance.name)) {
	                writer.writeAttributeString(CONST_NAME, instance.name);
	            }
	        }, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_CustomColor = WriteCT_CustomColor;
	
	    function WriteCT_SupplementalFont(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var script = instance.script, typeface = instance.typeface;
	            if (!isNullOrUndefined(script)) {
	                writer.writeAttributeString("script", script);
	            }
	            if (!isNullOrUndefined(typeface)) {
	                writer.writeAttributeString("typeface", typeface);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_SupplementalFont = WriteCT_SupplementalFont;
	
	    function WriteCT_CustomColorList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.custClr, function (custClrItem) {
	                WriteCT_CustomColor(writer, CONST_A, "custClr", custClrItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_CustomColorList = WriteCT_CustomColorList;
	
	    function WriteCT_FontCollection(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var latin = instance.latin, ea = instance.ea, cs = instance.cs, extLst = instance.extLst;
	            if (!isNullOrUndefined(latin)) {
	                WriteCT_TextFont(writer, CONST_A, "latin", latin);
	            }
	            if (!isNullOrUndefined(ea)) {
	                WriteCT_TextFont(writer, CONST_A, "ea", ea);
	            }
	            if (!isNullOrUndefined(cs)) {
	                WriteCT_TextFont(writer, CONST_A, "cs", cs);
	            }
	            writeArrayItem(instance.font, function (fontItem) {
	                WriteCT_SupplementalFont(writer, CONST_A, "font", fontItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_FontCollection = WriteCT_FontCollection;
	
	    function WriteCT_EffectStyleItem(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var effectLst = instance.effectLst, effectDag = instance.effectDag,
	                scene3d = instance.scene3d, sp3d = instance.sp3d;
	            if (!isNullOrUndefined(effectLst)) {
	                WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
	            }
	            if (!isNullOrUndefined(effectDag)) {
	                WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
	            }
	            if (!isNullOrUndefined(scene3d)) {
	                WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
	            }
	            if (!isNullOrUndefined(sp3d)) {
	                WriteCT_Shape3D(writer, CONST_A, "sp3d", sp3d);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_EffectStyleItem = WriteCT_EffectStyleItem;
	
	    function WriteCT_FontScheme(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.name)) {
	                writer.writeAttributeString(CONST_NAME, instance.name);
	            }
	        }, function () {
	           
	            var majorFont = instance.majorFont, minorFont = instance.minorFont, extLst = instance.extLst;
	            if (!isNullOrUndefined(majorFont)) {
	                WriteCT_FontCollection(writer, CONST_A, "majorFont", majorFont);
	            }
	            if (!isNullOrUndefined(minorFont)) {
	                WriteCT_FontCollection(writer, CONST_A, "minorFont", minorFont);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_FontScheme = WriteCT_FontScheme;
	
	    function WriteCT_FillStyleList(writer, prefix, localName, instance) {
	        writeFillPropertiesFromArray(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_FillStyleList = WriteCT_FillStyleList;
	
	    function WriteCT_LineStyleList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.ln, function (lnItem) {
	                WriteCT_LineProperties(writer, CONST_A, "ln", lnItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_LineStyleList = WriteCT_LineStyleList;
	
	    function WriteCT_EffectStyleList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.effectStyle, function (effectStyleItem) {
	                WriteCT_EffectStyleItem(writer, CONST_A, "effectStyle", effectStyleItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_EffectStyleList = WriteCT_EffectStyleList;
	
	    function WriteCT_BackgroundFillStyleList(writer, prefix, localName, instance) {
	        writeFillPropertiesFromArray(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_BackgroundFillStyleList = WriteCT_BackgroundFillStyleList;
	
	    function WriteCT_StyleMatrix(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefinedOrEmpty(instance.name)) {
	                writer.writeAttributeString(CONST_NAME, instance.name);
	            }
	        }, function () {
	           
	            var fillStyleLst = instance.fillStyleLst, lnStyleLst = instance.lnStyleLst,
	                effectStyleLst = instance.effectStyleLst, bgFillStyleLst = instance.bgFillStyleLst;
	            if (!isNullOrUndefined(fillStyleLst)) {
	                WriteCT_FillStyleList(writer, CONST_A, "fillStyleLst", fillStyleLst);
	            }
	            if (!isNullOrUndefined(lnStyleLst)) {
	                WriteCT_LineStyleList(writer, CONST_A, "lnStyleLst", lnStyleLst);
	            }
	            if (!isNullOrUndefined(effectStyleLst)) {
	                WriteCT_EffectStyleList(writer, CONST_A, "effectStyleLst", effectStyleLst);
	            }
	            if (!isNullOrUndefined(bgFillStyleLst)) {
	                WriteCT_BackgroundFillStyleList(writer, CONST_A, "bgFillStyleLst", bgFillStyleLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_StyleMatrix = WriteCT_StyleMatrix;
	
	    function WriteCT_BaseStyles(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var clrScheme = instance.clrScheme, fontScheme = instance.fontScheme,
	                fmtScheme = instance.fmtScheme, extLst = instance.extLst;
	            if (!isNullOrUndefined(clrScheme)) {
	                WriteCT_ColorScheme(writer, CONST_A, CONST_CLR_SCHEME, clrScheme);
	            }
	            if (!isNullOrUndefined(fontScheme)) {
	                WriteCT_FontScheme(writer, CONST_A, CONST_FONT_SCHEME, fontScheme);
	            }
	            if (!isNullOrUndefined(fmtScheme)) {
	                WriteCT_StyleMatrix(writer, CONST_A, CONST_FMT_SCHEME, fmtScheme);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BaseStyles = WriteCT_BaseStyles;
	
	   
	    function ConvertArrayNumberToString(value) {
	        return value.map(function (n) {
	            return ("00" + n.toString(16)).substr(-2);
	        }).join('');
	    }
	
	    function WriteCT_OfficeArtExtension(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.uri)) {
	                writer.writeAttributeString("uri", instance.uri);
	            }
	        }, function () {
	           
	           
	            if (!isNullOrUndefined(instance.dataObject)) {
	                writer.writeValue(instance.dataObject);
	            }
	            if (instance.hiddenExtensionType === 0) {
	                WriteCT_Scene3D(writer, COSNT_A14, "hiddenScene3d", instance.Scene3d);
	            }
	            if (instance.hiddenExtensionType === 3) {
	                WriteCT_Shape3D(writer, COSNT_A14, "hiddenSp3d", instance.Shape3d);
	            }
	            if (instance.hiddenExtensionType === 1) {
	                WriteCT_FillProperties(writer, COSNT_A14, "hiddenFill", instance.Fill);
	            }
	            if (instance.hiddenExtensionType === 2) {
	                WriteCT_LineProperties(writer, COSNT_A14, "hiddenLine", instance.Line);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_OfficeArtExtension = WriteCT_OfficeArtExtension;
	
	    function WriteCT_Angle(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Angle = WriteCT_Angle;
	
	    function WriteCT_PositiveFixedAngle(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_PositiveFixedAngle = WriteCT_PositiveFixedAngle;
	
	    function WriteCT_Percentage(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Percentage = WriteCT_Percentage;
	
	    function WriteCT_PositivePercentage(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_PositivePercentage = WriteCT_PositivePercentage;
	
	    function WriteCT_FixedPercentage(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_FixedPercentage = WriteCT_FixedPercentage;
	
	    function WriteCT_PositiveFixedPercentage(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var value = instance;
	            if (!isNullOrUndefined(value)) {
	                var s = "" + value, pos = s.indexOf(".");
	               
	                if (pos !== -1 && (s.length > pos + 3)) {
	                    s = numberToFixedString(value);
	                }
	                writer.writeAttributeString(CONST_VAL, s);
	            }
	        });
	    }
	
	    function numberToFixedString(value) {
	       
	        var s = value.toFixed(2), digits = s.substr(-2);
	       
	        if (digits[1] === "0") {
	            var n = 1; 
	            if (digits[0] === "0") {
	                n = 3;
	            }
	            s = s.substr(0, s.length - n);
	        }
	        return s;
	    }
	
	    DrawingWriter.WriteCT_PositiveFixedPercentage = WriteCT_PositiveFixedPercentage;
	
	    function WriteCT_Ratio(writer, prefix, localName, instance) {
	        writeDoubleSubElementNode(writer, prefix, localName, instance, "n", "d");
	    }
	
	    DrawingWriter.WriteCT_Ratio = WriteCT_Ratio;
	
	    function WriteCT_Point2D(writer, prefix, localName, instance, needPixel) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var xValue = instance.x, yValue = instance.y;
	            if (!isNullOrUndefined(xValue)) {
	                if (needPixel) {
	                    xValue = pixelToEMU(xValue);
	                }
	                writer.writeAttributeString('x', xValue);
	            }
	            if (!isNullOrUndefined(yValue)) {
	                if (needPixel) {
	                    yValue = pixelToEMU(yValue);
	                }
	                writer.writeAttributeString('y', yValue);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Point2D = WriteCT_Point2D;
	
	    function WriteCT_PositiveSize2D(writer, prefix, localName, instance, needPixel) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var cxValue = instance.cx, cyValue = instance.cy;
	            if (!isNullOrUndefined(cxValue)) {
	                if (needPixel) {
	                    cxValue = pixelToEMU(cxValue);
	                }
	                writer.writeAttributeString('cx', cxValue);
	            }
	            if (!isNullOrUndefined(cyValue)) {
	                if (needPixel) {
	                    cyValue = pixelToEMU(cyValue);
	                }
	                writer.writeAttributeString('cy', cyValue);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PositiveSize2D = WriteCT_PositiveSize2D;
	
	    function WriteCT_ComplementTransform(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_ComplementTransform = WriteCT_ComplementTransform;
	
	    function WriteCT_InverseTransform(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_InverseTransform = WriteCT_InverseTransform;
	
	    function WriteCT_GrayscaleTransform(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_GrayscaleTransform = WriteCT_GrayscaleTransform;
	
	    function WriteCT_GammaTransform(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_GammaTransform = WriteCT_GammaTransform;
	
	    function WriteCT_InverseGammaTransform(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_InverseGammaTransform = WriteCT_InverseGammaTransform;
	
	    function WriteCT_ScRgbColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.r)) {
	                writer.writeAttributeString(CONST_R, instance.r);
	            }
	            if (!isNullOrUndefined(instance.g)) {
	                writer.writeAttributeString("g", instance.g);
	            }
	            if (!isNullOrUndefined(instance.b)) {
	                writer.writeAttributeString("b", instance.b);
	            }
	        }, function () {
	           
	            writeColorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_ScRgbColor = WriteCT_ScRgbColor;
	
	    function WriteCT_SRgbColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var val = instance.val;
	            if (!isNullOrUndefined(val)) {
	               
	               
	               
	                var tempValue = typeof val === 'string' ? val : ConvertArrayNumberToString(val);
	                writer.writeAttributeString(CONST_VAL, tempValue);
	            }
	        }, function () {
	           
	            writeColorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_SRgbColor = WriteCT_SRgbColor;
	
	    function WriteCT_HslColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.hue1)) {
	                writer.writeAttributeString("hue", instance.hue1);
	            }
	            if (!isNullOrUndefined(instance.sat1)) {
	                writer.writeAttributeString("sat", instance.sat1);
	            }
	            if (!isNullOrUndefined(instance.lum1)) {
	                writer.writeAttributeString("lum", instance.lum1);
	            }
	        }, function () {
	           
	            writeColorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_HslColor = WriteCT_HslColor;
	
	    function WriteCT_SystemColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.val)) {
	                writer.writeAttributeString(CONST_VAL, Charts.ST_SystemColorVal[ChartHelper.ToST_SystemColorVal(instance.val)]);
	            }
	            if (!isNullOrUndefined(instance.lastClr)) {
	                writer.writeAttributeString("lastClr", ConvertArrayNumberToString(instance.lastClr));
	            }
	        }, function () {
	           
	            writeColorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_SystemColor = WriteCT_SystemColor;
	
	    function WriteCT_SchemeColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.val)) {
	                writer.writeAttributeString(CONST_VAL, Charts.ST_SchemeColorVal[ChartHelper.ToST_SchemeColorVal(instance.val)]);
	            }
	        }, function () {
	           
	            writeColorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_SchemeColor = WriteCT_SchemeColor;
	
	    function WriteCT_PresetColor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.val)) {
	                writer.writeAttributeString(CONST_VAL, Charts.ST_PresetColorVal[instance.val]);
	            }
	        }, function () {
	           
	            writeColorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_PresetColor = WriteCT_PresetColor;
	
	    function WriteCT_OfficeArtExtensionList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.ext, function (extItem) {
	                WriteCT_OfficeArtExtension(writer, CONST_A, CONST_EXT, extItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_OfficeArtExtensionList = WriteCT_OfficeArtExtensionList;
	
	    function WriteCT_Scale2D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.sx)) {
	                WriteCT_Ratio(writer, CONST_A, "sx", instance.sx);
	            }
	            if (!isNullOrUndefined(instance.sy)) {
	                WriteCT_Ratio(writer, CONST_A, "sy", instance.sy);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Scale2D = WriteCT_Scale2D;
	
	    function WriteCT_Transform2D(writer, prefix, localName, instance, isGraphicFrame) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isGraphicFrame) {
	                var rot = instance.rot;
	                if (!isNullOrUndefined(rot) && rot !== 0) {
	                    writer.writeAttributeString("rot", rot);
	                }
	                if (instance.flipH === true) {
	                    writer.writeAttributeString("flipH", "1");
	                }
	                if (instance.flipV === true) {
	                    writer.writeAttributeString("flipV", "1");
	                }
	            }
	        }, function () {
	           
	            if (isGraphicFrame) {
	                WriteCT_Point2D(writer, CONST_A, "off", { x: 0, y: 0 });
	                WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, { cx: 0, cy: 0 });
	            } else {
	                if (!isNullOrUndefined(instance.off)) {
	                    WriteCT_Point2D(writer, CONST_A, "off", instance.off);
	                }
	                if (!isNullOrUndefined(instance.ext)) {
	                    WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, instance.ext);
	                }
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Transform2D = WriteCT_Transform2D;
	
	    function WriteCT_GroupTransform2D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var rot = instance.rot;
	            if (!isNullOrUndefined(rot) && rot !== 0) {
	                writer.writeAttributeString("rot", rot);
	            }
	            if (instance.flipH === true) {
	                writer.writeAttributeString("flipH", "1");
	            }
	            if (instance.flipV === true) {
	                writer.writeAttributeString("flipV", "1");
	            }
	        }, function () {
	           
	            var off = instance.off, ext = instance.ext, chOff = instance.chOff, chExt = instance.chExt;
	            if (!isNullOrUndefined(off)) {
	                WriteCT_Point2D(writer, CONST_A, "off", off);
	            }
	            if (!isNullOrUndefined(ext)) {
	                WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, ext);
	            }
	            if (!isNullOrUndefined(chOff)) {
	                WriteCT_Point2D(writer, CONST_A, "chOff", chOff);
	            }
	            if (!isNullOrUndefined(chExt)) {
	                WriteCT_PositiveSize2D(writer, CONST_A, "chExt", chExt);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GroupTransform2D = WriteCT_GroupTransform2D;
	
	    function WriteCT_Point3D(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.x)) {
	                writer.writeAttributeString("x", instance.x);
	            }
	            if (!isNullOrUndefined(instance.y)) {
	                writer.writeAttributeString("y", instance.y);
	            }
	            if (!isNullOrUndefined(instance.z)) {
	                writer.writeAttributeString("z", instance.z);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Point3D = WriteCT_Point3D;
	
	    function WriteCT_Vector3D(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.dx)) {
	                writer.writeAttributeString("dx", instance.dx);
	            }
	            if (!isNullOrUndefined(instance.dy)) {
	                writer.writeAttributeString("dy", instance.dy);
	            }
	            if (!isNullOrUndefined(instance.dz)) {
	                writer.writeAttributeString("dz", instance.dz);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Vector3D = WriteCT_Vector3D;
	
	    function WriteCT_SphereCoords(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.lat)) {
	                writer.writeAttributeString("lat", instance.lat);
	            }
	            if (!isNullOrUndefined(instance.lon)) {
	                writer.writeAttributeString("lon", instance.lon);
	            }
	            if (!isNullOrUndefined(instance.rev)) {
	                writer.writeAttributeString("rev", instance.rev);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_SphereCoords = WriteCT_SphereCoords;
	
	    function WriteCT_RelativeRect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.l) && instance.l !== 0) {
	                writer.writeAttributeString("l", instance.l);
	            }
	            if (!isNullOrUndefined(instance.t) && instance.t !== 0) {
	                writer.writeAttributeString("t", instance.t);
	            }
	            if (!isNullOrUndefined(instance.r) && instance.r !== 0) {
	                writer.writeAttributeString(CONST_R, instance.r);
	            }
	            if (!isNullOrUndefined(instance.b) && instance.b !== 0) {
	                writer.writeAttributeString("b", instance.b);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_RelativeRect = WriteCT_RelativeRect;
	
	    function WriteCT_Color(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_Color = WriteCT_Color;
	
	    function WriteCT_ColorMRU(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.scrgbClr) {
	                writeArrayItem(instance.scrgbClr, function (scrgbClrItem) {
	                    WriteCT_ScRgbColor(writer, CONST_A, CONST_SCRGBCLR, scrgbClrItem);
	                });
	            } else if (instance.srgbClr) {
	                writeArrayItem(instance.srgbClr, function (srgbClrItem) {
	                    WriteCT_SRgbColor(writer, CONST_A, CONST_SRGBCLR, srgbClrItem);
	                });
	            } else if (instance.hslClr) {
	                writeArrayItem(instance.hslClr, function (hslClrItem) {
	                    WriteCT_HslColor(writer, CONST_A, CONST_HSLCLR, hslClrItem);
	                });
	            } else if (instance.sysClr) {
	                writeArrayItem(instance.sysClr, function (sysClrItem) {
	                    WriteCT_SystemColor(writer, CONST_A, CONST_SYSCLR, sysClrItem);
	                });
	            } else if (instance.schemeClr) {
	                writeArrayItem(instance.schemeClr, function (schemeClrItem) {
	                    WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClrItem);
	                });
	            } else if (instance.prstClr) {
	                writeArrayItem(instance.prstClr, function (prstClrItem) {
	                    WriteCT_PresetColor(writer, CONST_A, CONST_PRSTCLR, prstClrItem);
	                });
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorMRU = WriteCT_ColorMRU;
	
	    function WriteCT_EmbeddedWAVAudioFile(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var embed = instance.embed, name = instance.name;
	            if (!isNullOrUndefined(embed)) {
	                writer.writeAttributeString("embed", embed);
	            }
	            if (!isNullOrUndefinedOrEmpty(name)) {
	                writer.writeAttributeString(CONST_NAME, name);
	            }
	            if (instance.builtIn === true) {
	                writer.writeAttributeString("builtIn", "1");
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_EmbeddedWAVAudioFile = WriteCT_EmbeddedWAVAudioFile;
	
	    function WriteCT_Hyperlink(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var action = instance.action, tgtFrame = instance.tgtFrame, tooltip = instance.tooltip;
	            writer.writeAttributeString("xmlns:r", DrawingWriter.r);
	            if (!isNullOrUndefined(instance.id)) {
	                writer.writeAttributeString("id", instance.id);
	            }
	           
	           
	           
	            if (!isNullOrUndefinedOrEmpty(action)) {
	                writer.writeAttributeString("action", instance.action);
	            }
	            if (!isNullOrUndefinedOrEmpty(tgtFrame)) {
	                writer.writeAttributeString("tgtFrame", tgtFrame);
	            }
	            if (!isNullOrUndefinedOrEmpty(tooltip)) {
	                writer.writeAttributeString("tooltip", tooltip);
	            }
	            if (instance.history === false) {
	                writer.writeAttributeString("history", "0");
	            }
	            if (instance.highlightClick === true) {
	                writer.writeAttributeString("highlightClick", "1");
	            }
	            if (instance.endSnd === true) {
	                writer.writeAttributeString("endSnd", "1");
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.snd)) {
	                WriteCT_EmbeddedWAVAudioFile(writer, CONST_A, "snd", instance.snd);
	            }
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Hyperlink = WriteCT_Hyperlink;
	
	    function WriteCT_Boolean(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            writer.writeAttributeString(CONST_VAL, instance ? "1" : "0");
	        });
	    }
	
	    DrawingWriter.WriteCT_Boolean = WriteCT_Boolean;
	
	    function WriteCT_Double(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Double = WriteCT_Double;
	
	    function WriteCT_UnsignedInt(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_UnsignedInt = WriteCT_UnsignedInt;
	
	    function WriteCT_Int(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Int = WriteCT_Int;
	
	    function WriteCT_RelId(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.id, 'id');
	    }
	
	    DrawingWriter.WriteCT_RelId = WriteCT_RelId;
	
	    function WriteCT_Extension(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.uri)) {
	                writer.writeAttributeString("uri", instance.uri);
	            }
	            writer.writeAttributeString("xmlns:c14", DrawingWriter.c14);
	        }, function () {
	           
	           
	            var dataObject = instance.dataObject;
	            if (dataObject) {
	                if (dataObject.extDataType === 0 ) {
	                    WriteCT_InvertSolidFillFmt(writer, CONST_C14, "invertSolidFillFmt", dataObject);
	                } else if (dataObject.extDataType === 1 ) {
	                    WriteCT_SeriesDataLabelsRange(writer, CONST_C15, "datalabelsRange", dataObject);
	                }
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Extension = WriteCT_Extension;
	
	    function WriteCT_ExtensionList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.ext, function (item) {
	                WriteCT_Extension(writer, CONST_C14, CONST_EXT, item);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_ExtensionList = WriteCT_ExtensionList;
	
	    function WriteCT_NumVal(writer, prefix, localName, value, idx) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(idx)) {
	                writer.writeAttributeString("idx", idx);
	            }
	           
	           
	           
	           
	        }, function () {
	           
	            if (!isNullOrUndefined(value)) {
	               
	                var n = value.replace(/,/g, '');  
	                writer.writeElementString("c:v", n);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NumVal = WriteCT_NumVal;
	
	    function WriteCT_NumData(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var ptCount = instance.ptCount, extLst = instance.extLst;
	            if (!isNullOrUndefined(instance.formatCode)) {
	                writer.writeElementString("c:formatCode", xmlEncode(instance.formatCode));
	            }
	            if (!isNullOrUndefined(ptCount)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "ptCount", ptCount);
	            }
	            writeArrayItem(instance.pt, function (ptItem, i) {
	                WriteCT_NumVal(writer, CONST_C, "pt", ptItem, i);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NumData = WriteCT_NumData;
	
	    function WriteCT_NumRef(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var numCache = instance.numCache, extLst = instance.extLst;
	            if (!isNullOrUndefined(instance.f)) {
	                writer.writeElementString("c:f", xmlEncode(instance.f));
	            }
	            if (!isNullOrUndefined(numCache)) {
	                WriteCT_NumData(writer, CONST_C, "numCache", numCache);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NumRef = WriteCT_NumRef;
	
	    function WriteCT_NumDataSource(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var numRef = instance.numRef, numLit = instance.numLit;
	            if (!isNullOrUndefined(numRef)) {
	                WriteCT_NumRef(writer, CONST_C, "numRef", numRef);
	            }
	            if (!isNullOrUndefined(numLit)) {
	                WriteCT_NumData(writer, CONST_C, "numLit", numLit);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NumDataSource = WriteCT_NumDataSource;
	
	    function WriteCT_StrVal(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.idx)) {
	                writer.writeAttributeString("idx", instance.idx);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.v)) {
	                writer.writeElementString("c:v", xmlEncode(instance.v));
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_StrVal = WriteCT_StrVal;
	
	    function WriteCT_StrData(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var ptCount = instance.ptCount, extLst = instance.extLst;
	            if (!isNullOrUndefined(ptCount)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "ptCount", ptCount);
	            }
	            writeArrayItem(instance.pt, function (item, i) {
	                WriteCT_StrVal(writer, CONST_C, "pt", { idx: i, v: item });
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_StrData = WriteCT_StrData;
	
	    function WriteCT_StrRef(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var extLst = instance.extLst;
	            if (!isNullOrUndefined(instance.f)) {
	                writer.writeElementString("c:f", xmlEncode(instance.f));
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_StrRef = WriteCT_StrRef;
	
	    function WriteCT_Tx(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var strRef = instance.strRef, rich = instance.rich;
	            if (!isNullOrUndefined(strRef)) {
	                WriteCT_StrRef(writer, CONST_C, "strRef", strRef);
	            }
	            if (!isNullOrUndefined(rich)) {
	                WriteCT_TextBody(writer, CONST_C, "rich", rich);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Tx = WriteCT_Tx;
	
	    function WriteCT_TextLanguageID(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_TextLanguageID = WriteCT_TextLanguageID;
	
	    function WriteCT_Lvl(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.pt, function (ptItem) {
	                WriteCT_StrVal(writer, CONST_C, "pt", ptItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_Lvl = WriteCT_Lvl;
	
	    function WriteCT_MultiLvlStrData(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var ptCount = instance.ptCount, extLst = instance.extLst;
	            if (!isNullOrUndefined(ptCount)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "ptCount", ptCount);
	            }
	            writeArrayItem(instance.lvl, function (lvlItem) {
	                WriteCT_StrData(writer, CONST_C, "lvl", lvlItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_MultiLvlStrData = WriteCT_MultiLvlStrData;
	
	    function WriteCT_MultiLvlStrRef(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var multiLvlStrCache = instance.multiLvlStrCache, extLst = instance.extLst;
	            if (!isNullOrUndefined(instance.f)) {
	                writer.writeElementString("c:f", xmlEncode(instance.f));
	            }
	            if (!isNullOrUndefined(multiLvlStrCache)) {
	                WriteCT_MultiLvlStrData(writer, CONST_C, "multiLvlStrCache", multiLvlStrCache);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_MultiLvlStrRef = WriteCT_MultiLvlStrRef;
	
	    function WriteCT_AxDataSource(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var multiLvlStrRef = instance.multiLvlStrRef, numRef = instance.numRef, numLit = instance.numLit,
	                strRef = instance.strRef, strLit = instance.strLit;
	            if (!isNullOrUndefined(multiLvlStrRef)) {
	                WriteCT_MultiLvlStrRef(writer, CONST_C, "multiLvlStrRef", multiLvlStrRef);
	            }
	            if (!isNullOrUndefined(numRef)) {
	                WriteCT_NumRef(writer, CONST_C, "numRef", numRef);
	            }
	            if (!isNullOrUndefined(numLit)) {
	                WriteCT_NumData(writer, CONST_C, "numLit", numLit);
	            }
	            if (!isNullOrUndefined(strRef)) {
	                WriteCT_StrRef(writer, CONST_C, "strRef", strRef);
	            }
	            if (!isNullOrUndefined(strLit)) {
	                WriteCT_StrData(writer, CONST_C, "strLit", strLit);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_AxDataSource = WriteCT_AxDataSource;
	
	    function WriteCT_SerTx(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.strRef)) {
	                WriteCT_StrRef(writer, CONST_C, "strRef", instance.strRef);
	            }
	            if (!isNullOrUndefined(instance.v)) {
	                writer.writeElementString("c:v", instance.v);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_SerTx = WriteCT_SerTx;
	
	    function WriteCT_LayoutTarget(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 1 , Charts.ST_LayoutTarget);
	    }
	
	    DrawingWriter.WriteCT_LayoutTarget = WriteCT_LayoutTarget;
	
	    function WriteCT_LayoutMode(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 1 , Charts.ST_LayoutMode);
	    }
	
	    DrawingWriter.WriteCT_LayoutMode = WriteCT_LayoutMode;
	
	    function WriteCT_ManualLayout(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var layoutTarget = instance.layoutTarget, xMode = instance.xMode, yMode = instance.yMode,
	                wMode = instance.wMode, hMode = instance.hMode, extLst = instance.extLst;
	            if (!isNullOrUndefined(layoutTarget)) {
	                WriteCT_LayoutTarget(writer, CONST_C, "layoutTarget", layoutTarget);
	            }
	            if (!isNullOrUndefined(xMode)) {
	                WriteCT_LayoutMode(writer, CONST_C, "xMode", xMode);
	            }
	            if (!isNullOrUndefined(yMode)) {
	                WriteCT_LayoutMode(writer, CONST_C, "yMode", yMode);
	            }
	            if (!isNullOrUndefined(wMode)) {
	                WriteCT_LayoutMode(writer, CONST_C, "wMode", wMode);
	            }
	            if (!isNullOrUndefined(hMode)) {
	                WriteCT_LayoutMode(writer, CONST_C, "hMode", hMode);
	            }
	            if (!isNullOrUndefined(instance.x)) {
	                WriteCT_Double(writer, CONST_C, "x", instance.x);
	            }
	            if (!isNullOrUndefined(instance.y)) {
	                WriteCT_Double(writer, CONST_C, "y", instance.y);
	            }
	            if (!isNullOrUndefined(instance.w)) {
	                WriteCT_Double(writer, CONST_C, "w", instance.w);
	            }
	            if (!isNullOrUndefined(instance.h)) {
	                WriteCT_Double(writer, CONST_C, "h", instance.h);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ManualLayout = WriteCT_ManualLayout;
	
	    function WriteCT_Layout(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var manualLayout = instance.manualLayout, extLst = instance.extLst;
	            if (!isNullOrUndefined(manualLayout)) {
	                WriteCT_ManualLayout(writer, CONST_C, "manualLayout", manualLayout);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Layout = WriteCT_Layout;
	
	    function WriteCT_Title(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var tx = instance.tx, layout = instance.layout, overlay = instance.overlay,
	                spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_Tx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
	            }
	            if (!isNullOrUndefined(overlay)) {
	                WriteCT_Boolean(writer, CONST_C, "overlay", overlay);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Title = WriteCT_Title;
	
	    function WriteCT_RotX(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0);
	    }
	
	    DrawingWriter.WriteCT_RotX = WriteCT_RotX;
	
	    function WriteCT_HPercent(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_HPercent = WriteCT_HPercent;
	
	    function WriteCT_RotY(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_RotY = WriteCT_RotY;
	
	    function WriteCT_DepthPercent(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_DepthPercent = WriteCT_DepthPercent;
	
	    function WriteCT_Perspective(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 30);
	    }
	
	    DrawingWriter.WriteCT_Perspective = WriteCT_Perspective;
	
	    function WriteCT_View3D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var rotX = instance.rotX, hPercent = instance.hPercent, rotY = instance.rotY,
	                depthPercent = instance.depthPercent, rAngAx = instance.rAngAx,
	                perspective = instance.perspective, extLst = instance.extLst;
	            if (!isNullOrUndefined(rotX)) {
	                WriteCT_RotX(writer, CONST_C, "rotX", rotX);
	            }
	            if (!isNullOrUndefined(hPercent)) {
	                WriteCT_HPercent(writer, CONST_C, "hPercent", hPercent);
	            }
	            if (!isNullOrUndefined(rotY)) {
	                WriteCT_RotY(writer, CONST_C, "rotY", rotY);
	            }
	            if (!isNullOrUndefined(depthPercent)) {
	                WriteCT_DepthPercent(writer, CONST_C, "depthPercent", depthPercent);
	            }
	            if (!isNullOrUndefined(rAngAx)) {
	                WriteCT_Boolean(writer, CONST_C, "rAngAx", rAngAx);
	            }
	            if (!isNullOrUndefined(perspective)) {
	                WriteCT_Perspective(writer, CONST_C, "perspective", perspective);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_View3D = WriteCT_View3D;
	
	    function WriteCT_Surface(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var thickness = instance.thickness, spPr = instance.spPr,
	                pictureOptions = instance.pictureOptions, extLst = instance.extLst;
	            if (!isNullOrUndefined(thickness)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "thickness", thickness);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(pictureOptions)) {
	                WriteCT_PictureOptions(writer, CONST_C, CONST_PICTURE_OPTIONS, pictureOptions);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Surface = WriteCT_Surface;
	
	    function WriteCT_DTable(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var showHorzBorder = instance.showHorzBorder, showVertBorder = instance.showVertBorder,
	                showOutline = instance.showOutline, showKeys = instance.showKeys,
	                spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(showHorzBorder)) {
	                WriteCT_Boolean(writer, CONST_C, "showHorzBorder", showHorzBorder);
	            }
	            if (!isNullOrUndefined(showVertBorder)) {
	                WriteCT_Boolean(writer, CONST_C, "showVertBorder", showVertBorder);
	            }
	            if (!isNullOrUndefined(showOutline)) {
	                WriteCT_Boolean(writer, CONST_C, "showOutline", showOutline);
	            }
	            if (!isNullOrUndefined(showKeys)) {
	                WriteCT_Boolean(writer, CONST_C, "showKeys", showKeys);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DTable = WriteCT_DTable;
	
	    function WriteCT_GapAmount(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_GapAmount = WriteCT_GapAmount;
	
	    function WriteCT_Overlap(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0);
	    }
	
	    DrawingWriter.WriteCT_Overlap = WriteCT_Overlap;
	
	    function WriteCT_BubbleScale(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 100);
	    }
	
	    DrawingWriter.WriteCT_BubbleScale = WriteCT_BubbleScale;
	
	    function WriteCT_SizeRepresents(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0 , Charts.ST_SizeRepresents);
	    }
	
	    DrawingWriter.WriteCT_SizeRepresents = WriteCT_SizeRepresents;
	
	    function WriteCT_FirstSliceAng(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0);
	    }
	
	    DrawingWriter.WriteCT_FirstSliceAng = WriteCT_FirstSliceAng;
	
	    function WriteCT_HoleSize(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_HoleSize = WriteCT_HoleSize;
	
	    function WriteCT_SplitType(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0 , Charts.ST_SplitType, ChartHelper.ToST_SplitType);
	    }
	
	    DrawingWriter.WriteCT_SplitType = WriteCT_SplitType;
	
	    function WriteCT_CustSplit(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.secondPiePt, function (secondPiePtItem) {
	                WriteCT_UnsignedInt(writer, CONST_C, "secondPiePt", secondPiePtItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_CustSplit = WriteCT_CustSplit;
	
	    function WriteCT_SecondPieSize(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 75);
	    }
	
	    DrawingWriter.WriteCT_SecondPieSize = WriteCT_SecondPieSize;
	
	    function WriteCT_NumFmt(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.formatCode)) {
	                writer.writeAttributeString("formatCode", xmlEncode(instance.formatCode));
	            }
	            if (instance.sourceLinked === false) {
	                writer.writeAttributeString("sourceLinked", "0");  
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NumFmt = WriteCT_NumFmt;
	
	    function WriteCT_LblAlgn(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_LblAlgn);
	    }
	
	    DrawingWriter.WriteCT_LblAlgn = WriteCT_LblAlgn;
	
	    function WriteCT_DLblPos(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_DLblPos);
	    }
	
	    DrawingWriter.WriteCT_DLblPos = WriteCT_DLblPos;
	
	    function WriteCT_DLbl(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, deleteField = instance.delete, layout = instance.layout,
	                tx = instance.tx, extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(deleteField)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
	            }
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_Tx(writer, CONST_C, "tx", tx);
	            }
	            writeDLblSubElement(writer, instance);
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_DLblExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DLbl = WriteCT_DLbl;
	
	    function WriteCT_DLbls(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var deleteField = instance.delete, showLeaderLines = instance.showLeaderLines,
	                leaderLines = instance.leaderLines, extLst = instance.extLst;
	
	            writeArrayItem(instance.dLbl, function (dLblItem) {
	                WriteCT_DLbl(writer, CONST_C, "dLbl", dLblItem);
	            });
	
	            if (!isNullOrUndefined(deleteField)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
	            }
	            writeDLblSubElement(writer, instance);
	            if (!isNullOrUndefined(showLeaderLines)) {
	                WriteCT_Boolean(writer, CONST_C, "showLeaderLines", showLeaderLines);
	            }
	            if (!isNullOrUndefined(leaderLines)) {
	                WriteCT_ChartLines(writer, CONST_C, "leaderLines", leaderLines);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_DLblsExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DLbls = WriteCT_DLbls;
	
	    function WriteCT_MarkerStyle(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_MarkerStyle, ChartHelper.ToST_MarkerStyle);
	    }
	
	    DrawingWriter.WriteCT_MarkerStyle = WriteCT_MarkerStyle;
	
	    function WriteCT_MarkerSize(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_MarkerSize = WriteCT_MarkerSize;
	
	    function WriteCT_Marker(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var symbol = instance.symbol, size = instance.size, spPr = instance.spPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(symbol)) {
	                WriteCT_MarkerStyle(writer, CONST_C, "symbol", symbol);
	            }
	            if (!isNullOrUndefined(size)) {
	                WriteCT_MarkerSize(writer, CONST_C, "size", size);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Marker = WriteCT_Marker;
	
	    function WriteCT_DPt(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, invertIfNegative = instance.invertIfNegative, marker = instance.marker,
	                bubble3D = instance.bubble3D, explosion = instance.explosion, spPr = instance.spPr,
	                pictureOptions = instance.pictureOptions, extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(invertIfNegative)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
	            }
	            if (!isNullOrUndefined(marker)) {
	                WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
	            }
	            if (!isNullOrUndefined(bubble3D)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
	            }
	            if (!isNullOrUndefined(explosion)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "explosion", explosion);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(pictureOptions)) {
	                WriteCT_PictureOptions(writer, CONST_C, CONST_PICTURE_OPTIONS, pictureOptions);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DPt = WriteCT_DPt;
	
	    function WriteCT_TrendlineType(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_TrendlineType);
	    }
	
	    DrawingWriter.WriteCT_TrendlineType = WriteCT_TrendlineType;
	
	    function WriteCT_Order(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Order = WriteCT_Order;
	
	    function WriteCT_Period(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Period = WriteCT_Period;
	
	    function WriteCT_TrendlineLbl(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var layout = instance.layout, tx = instance.tx, numFmt = instance.numFmt,
	                spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_Tx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(numFmt)) {
	                WriteCT_NumFmt(writer, CONST_C, CONST_NUMFMT, numFmt);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TrendlineLbl = WriteCT_TrendlineLbl;
	
	    function WriteCT_Trendline(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var spPr = instance.spPr, trendlineType = instance.trendlineType, order = instance.order,
	                period = instance.period, forward = instance.forward, backward = instance.backward,
	                intercept = instance.intercept, dispRSqr = instance.dispRSqr, dispEq = instance.dispEq,
	                trendlineLbl = instance.trendlineLbl, extLst = instance.extLst;
	            if (!isNullOrUndefined(instance.name)) {
	                writer.writeElementString("c:name", instance.name);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(trendlineType)) {
	                WriteCT_TrendlineType(writer, CONST_C, "trendlineType", trendlineType);
	            }
	            if (!isNullOrUndefined(order)) {
	                WriteCT_Order(writer, CONST_C, CONST_ORDER, order);
	            }
	            if (!isNullOrUndefined(period)) {
	                WriteCT_Period(writer, CONST_C, "period", period);
	            }
	            if (!isNullOrUndefined(forward)) {
	                WriteCT_Double(writer, CONST_C, "forward", forward);
	            }
	            if (!isNullOrUndefined(backward)) {
	                WriteCT_Double(writer, CONST_C, "backward", backward);
	            }
	            if (!isNullOrUndefined(intercept)) {
	                WriteCT_Double(writer, CONST_C, "intercept", intercept);
	            }
	            if (!isNullOrUndefined(dispRSqr)) {
	                WriteCT_Boolean(writer, CONST_C, "dispRSqr", dispRSqr);
	            }
	            if (!isNullOrUndefined(dispEq)) {
	                WriteCT_Boolean(writer, CONST_C, "dispEq", dispEq);
	            }
	            if (!isNullOrUndefined(trendlineLbl)) {
	                WriteCT_TrendlineLbl(writer, CONST_C, "trendlineLbl", trendlineLbl);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Trendline = WriteCT_Trendline;
	
	    function WriteCT_ErrDir(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_ErrDir);
	    }
	
	    DrawingWriter.WriteCT_ErrDir = WriteCT_ErrDir;
	
	    function WriteCT_ErrBarType(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_ErrBarType);
	    }
	
	    DrawingWriter.WriteCT_ErrBarType = WriteCT_ErrBarType;
	
	    function WriteCT_ErrValType(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_ErrValType);
	    }
	
	    DrawingWriter.WriteCT_ErrValType = WriteCT_ErrValType;
	
	    function WriteCT_ErrBars(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var errDir = instance.errDir, errBarType = instance.errBarType, errValType = instance.errValType,
	                noEndCap = instance.noEndCap, plus = instance.plus, minus = instance.minus, val = instance.val,
	                spPr = instance.spPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(errDir)) {
	                WriteCT_ErrDir(writer, CONST_C, "errDir", errDir);
	            }
	            if (!isNullOrUndefined(errBarType)) {
	                WriteCT_ErrBarType(writer, CONST_C, "errBarType", errBarType);
	            }
	            if (!isNullOrUndefined(errValType)) {
	                WriteCT_ErrValType(writer, CONST_C, "errValType", errValType);
	            }
	            if (!isNullOrUndefined(noEndCap)) {
	                WriteCT_Boolean(writer, CONST_C, "noEndCap", noEndCap);
	            }
	            if (!isNullOrUndefined(plus)) {
	                WriteCT_NumDataSource(writer, CONST_C, "plus", plus);
	            }
	            if (!isNullOrUndefined(minus)) {
	                WriteCT_NumDataSource(writer, CONST_C, "minus", minus);
	            }
	            if (!isNullOrUndefined(val)) {
	                WriteCT_Double(writer, CONST_C, CONST_VAL, val);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ErrBars = WriteCT_ErrBars;
	
	    function WriteCT_UpDownBar(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ShapeProperties, CONST_C, CONST_SPPR);
	    }
	
	    DrawingWriter.WriteCT_UpDownBar = WriteCT_UpDownBar;
	
	    function WriteCT_UpDownBars(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var gapWidth = instance.gapWidth, upBars = instance.upBars, downBars = instance.downBars,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(gapWidth)) {
	                WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
	            }
	            if (!isNullOrUndefined(upBars)) {
	                WriteCT_UpDownBar(writer, CONST_C, "upBars", upBars);
	            }
	            if (!isNullOrUndefined(downBars)) {
	                WriteCT_UpDownBar(writer, CONST_C, "downBars", downBars);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_UpDownBars = WriteCT_UpDownBars;
	
	    function WriteCT_LineSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cat = instance.cat, val = instance.val;
	            writeLineOrScatterSerSubElement(writer, instance);
	            if (!isNullOrUndefined(cat)) {
	                WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
	            }
	            if (!isNullOrUndefined(val)) {
	                WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LineSer = WriteCT_LineSer;
	
	    function WriteCT_ScatterSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var xVal = instance.xVal, yVal = instance.yVal;
	            writeLineOrScatterSerSubElement(writer, instance);
	            if (!isNullOrUndefined(xVal)) {
	                WriteCT_AxDataSource(writer, CONST_C, "xVal", xVal);
	            }
	            if (!isNullOrUndefined(yVal)) {
	                WriteCT_NumDataSource(writer, CONST_C, "yVal", yVal);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ScatterSer = WriteCT_ScatterSer;
	
	    function WriteCT_RadarSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr,
	                marker = instance.marker, dLbls = instance.dLbls, cat = instance.cat,
	                val = instance.val, extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(order)) {
	                WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_SerTx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(marker)) {
	                WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
	            }
	            writeArrayItem(instance.dPt, function (dPtItem) {
	                WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(cat)) {
	                WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
	            }
	            if (!isNullOrUndefined(val)) {
	                WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_RadarSer = WriteCT_RadarSer;
	
	    function WriteCT_BarSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var invertIfNegative = instance.invertIfNegative, shape = instance.shape;
	            writeAreaOrBarSerSubElement(writer, instance);
	            if (!isNullOrUndefined(invertIfNegative)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
	            }
	            if (!isNullOrUndefined(shape)) {
	                WriteCT_ShapeBox(writer, CONST_C, "shape", shape);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BarSer = WriteCT_BarSer;
	
	    function WriteCT_AreaSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeAreaOrBarSerSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_AreaSer = WriteCT_AreaSer;
	
	    function WriteCT_PieSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr,
	                explosion = instance.explosion, dLbls = instance.dLbls, cat = instance.cat,
	                val = instance.val, extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(order)) {
	                WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_SerTx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(explosion)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "explosion", explosion);
	            }
	            writeArrayItem(instance.dPt, function (dPtItem) {
	                WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(cat)) {
	                WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
	            }
	            if (!isNullOrUndefined(val)) {
	                WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PieSer = WriteCT_PieSer;
	
	    function WriteCT_BubbleSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr,
	                invertIfNegative = instance.invertIfNegative, dLbls = instance.dLbls,
	                xVal = instance.xVal, yVal = instance.yVal, bubbleSize = instance.bubbleSize,
	                bubble3D = instance.bubble3D, extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(order)) {
	                WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_SerTx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(invertIfNegative)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
	            }
	            writeArrayItem(instance.dPt, function (dPtItem) {
	                WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            writeArrayItem(instance.trendline, function (trendlineItem) {
	                WriteCT_Trendline(writer, CONST_C, CONST_TRENDLINE, trendlineItem);
	            });
	            writeArrayItem(instance.errBars, function (errBarsItem) {
	                WriteCT_ErrBars(writer, CONST_C, CONST_ERR_BARS, errBarsItem);
	            });
	            if (!isNullOrUndefined(xVal)) {
	                WriteCT_AxDataSource(writer, CONST_C, "xVal", xVal);
	            }
	            if (!isNullOrUndefined(yVal)) {
	                WriteCT_NumDataSource(writer, CONST_C, "yVal", yVal);
	            }
	            if (!isNullOrUndefined(bubbleSize)) {
	                WriteCT_NumDataSource(writer, CONST_C, "bubbleSize", bubbleSize);
	            }
	            if (!isNullOrUndefined(bubble3D)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BubbleSer = WriteCT_BubbleSer;
	
	    function WriteCT_SurfaceSer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, order = instance.order, tx = instance.tx,
	                spPr = instance.spPr, cat = instance.cat, val = instance.val,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(order)) {
	                WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_SerTx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(cat)) {
	                WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
	            }
	            if (!isNullOrUndefined(val)) {
	                WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_SurfaceSer = WriteCT_SurfaceSer;
	
	    function WriteCT_Grouping(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_Grouping);
	    }
	
	    DrawingWriter.WriteCT_Grouping = WriteCT_Grouping;
	
	    function WriteCT_ChartLines(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ShapeProperties, CONST_C, CONST_SPPR);
	    }
	
	    DrawingWriter.WriteCT_ChartLines = WriteCT_ChartLines;
	
	    function WriteCT_LineChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls,
	                dropLines = instance.dropLines, hiLowLines = instance.hiLowLines, upDownBars = instance.upDownBars,
	                marker = instance.marker, smooth = instance.smooth, extLst = instance.extLst;
	            if (!isNullOrUndefined(grouping)) {
	                WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_LineSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(dropLines)) {
	                WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
	            }
	            if (!isNullOrUndefined(hiLowLines)) {
	                WriteCT_ChartLines(writer, CONST_C, "hiLowLines", hiLowLines);
	            }
	            if (!isNullOrUndefined(upDownBars)) {
	                WriteCT_UpDownBars(writer, CONST_C, "upDownBars", upDownBars);
	            }
	            if (!isNullOrUndefined(marker)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_MARKER, marker);
	            }
	            if (!isNullOrUndefined(smooth)) {
	                WriteCT_Boolean(writer, CONST_C, "smooth", smooth);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LineChart = WriteCT_LineChart;
	
	    function WriteCT_Line3DChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls,
	                dropLines = instance.dropLines, gapDepth = instance.gapDepth, extLst = instance.extLst;
	            if (!isNullOrUndefined(grouping)) {
	                WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_LineSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(dropLines)) {
	                WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
	            }
	            if (!isNullOrUndefined(gapDepth)) {
	                WriteCT_GapAmount(writer, CONST_C, "gapDepth", gapDepth);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Line3DChart = WriteCT_Line3DChart;
	
	    function WriteCT_StockChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var dLbls = instance.dLbls, dropLines = instance.dropLines, hiLowLines = instance.hiLowLines,
	                upDownBars = instance.upDownBars, extLst = instance.extLst;
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_LineSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(dropLines)) {
	                WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
	            }
	            if (!isNullOrUndefined(hiLowLines)) {
	                WriteCT_ChartLines(writer, CONST_C, "hiLowLines", hiLowLines);
	            }
	            if (!isNullOrUndefined(upDownBars)) {
	                WriteCT_UpDownBars(writer, CONST_C, "upDownBars", upDownBars);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_StockChart = WriteCT_StockChart;
	
	    function WriteCT_ScatterStyle(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 3 , Charts.ST_ScatterStyle);
	    }
	
	    DrawingWriter.WriteCT_ScatterStyle = WriteCT_ScatterStyle;
	
	    function WriteCT_ScatterChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var scatterStyle = instance.scatterStyle, varyColors = instance.varyColors,
	                dLbls = instance.dLbls, extLst = instance.extLst;
	            if (!isNullOrUndefined(scatterStyle)) {
	               
	               
	                var value = scatterStyle;
	                if (value === 1  || value === 3 ) {
	                    scatterStyle = 2 ;
	                } else if (value === 4 ) {
	                    scatterStyle = 5 ;
	                }
	                WriteCT_ScatterStyle(writer, CONST_C, "scatterStyle", scatterStyle);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_ScatterSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ScatterChart = WriteCT_ScatterChart;
	
	    function WriteCT_RadarStyle(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0 , Charts.ST_RadarStyle);
	    }
	
	    DrawingWriter.WriteCT_RadarStyle = WriteCT_RadarStyle;
	
	    function WriteCT_RadarChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var radarStyle = instance.radarStyle, varyColors = instance.varyColors,
	                dLbls = instance.dLbls, extLst = instance.extLst;
	            if (!isNullOrUndefined(radarStyle)) {
	                WriteCT_RadarStyle(writer, CONST_C, "radarStyle", radarStyle);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_RadarSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_RadarChart = WriteCT_RadarChart;
	
	    function WriteCT_BarGrouping(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_BarGrouping);
	    }
	
	    DrawingWriter.WriteCT_BarGrouping = WriteCT_BarGrouping;
	
	    function WriteCT_BarDir(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_BarDir);
	    }
	
	    DrawingWriter.WriteCT_BarDir = WriteCT_BarDir;
	
	    function WriteCT_ShapeBox(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 2 , Charts.ST_Shape);
	    }
	
	    DrawingWriter.WriteCT_ShapeBox = WriteCT_ShapeBox;
	
	    function WriteCT_BarChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var barDir = instance.barDir, grouping = instance.grouping, varyColors = instance.varyColors,
	                dLbls = instance.dLbls, gapWidth = instance.gapWidth, overlap = instance.overlap,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(barDir)) {
	                WriteCT_BarDir(writer, CONST_C, "barDir", barDir);
	            }
	            if (!isNullOrUndefined(grouping)) {
	                WriteCT_BarGrouping(writer, CONST_C, CONST_GROUPING, grouping);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_BarSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(gapWidth)) {
	                WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
	            }
	            if (!isNullOrUndefined(overlap)) {
	                WriteCT_Overlap(writer, CONST_C, "overlap", overlap);
	            }
	            writeArrayItem(instance.serLines, function (serLinesItem) {
	                WriteCT_ChartLines(writer, CONST_C, "serLines", serLinesItem);
	            });
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BarChart = WriteCT_BarChart;
	
	    function WriteCT_Bar3DChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var barDir = instance.barDir, grouping = instance.grouping, varyColors = instance.varyColors,
	                dLbls = instance.dLbls, gapWidth = instance.gapWidth, gapDepth = instance.gapDepth,
	                shape = instance.shape, extLst = instance.extLst;
	            if (!isNullOrUndefined(barDir)) {
	                WriteCT_BarDir(writer, CONST_C, "barDir", barDir);
	            }
	            if (!isNullOrUndefined(grouping)) {
	                WriteCT_BarGrouping(writer, CONST_C, CONST_GROUPING, grouping);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_BarSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(gapWidth)) {
	                WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
	            }
	            if (!isNullOrUndefined(gapDepth)) {
	                WriteCT_GapAmount(writer, CONST_C, "gapDepth", gapDepth);
	            }
	            if (!isNullOrUndefined(shape)) {
	                WriteCT_ShapeBox(writer, CONST_C, "shape", shape);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Bar3DChart = WriteCT_Bar3DChart;
	
	    function WriteCT_AreaChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls,
	                dropLines = instance.dropLines, extLst = instance.extLst;
	            if (!isNullOrUndefined(grouping)) {
	                WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_AreaSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(dropLines)) {
	                WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_AreaChart = WriteCT_AreaChart;
	
	    function WriteCT_Area3DChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls,
	                dropLines = instance.dropLines, gapDepth = instance.gapDepth, extLst = instance.extLst;
	            if (!isNullOrUndefined(grouping)) {
	                WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_AreaSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(dropLines)) {
	                WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
	            }
	            if (!isNullOrUndefined(gapDepth)) {
	                WriteCT_GapAmount(writer, CONST_C, "gapDepth", gapDepth);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Area3DChart = WriteCT_Area3DChart;
	
	    function WriteCT_PieChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var varyColors = instance.varyColors, dLbls = instance.dLbls,
	                firstSliceAng = instance.firstSliceAng, extLst = instance.extLst;
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(firstSliceAng)) {
	                WriteCT_FirstSliceAng(writer, CONST_C, "firstSliceAng", firstSliceAng);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PieChart = WriteCT_PieChart;
	
	    function WriteCT_Pie3DChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var varyColors = instance.varyColors, dLbls = instance.dLbls, extLst = instance.extLst;
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Pie3DChart = WriteCT_Pie3DChart;
	
	    function WriteCT_DoughnutChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var varyColors = instance.varyColors, dLbls = instance.dLbls,
	                firstSliceAng = instance.firstSliceAng, holeSize = instance.holeSize,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(firstSliceAng)) {
	                WriteCT_FirstSliceAng(writer, CONST_C, "firstSliceAng", firstSliceAng);
	            }
	            if (!isNullOrUndefined(holeSize)) {
	                WriteCT_HoleSize(writer, CONST_C, "holeSize", holeSize);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DoughnutChart = WriteCT_DoughnutChart;
	
	    function WriteCT_OfPieType(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_OfPieType);
	    }
	
	    DrawingWriter.WriteCT_OfPieType = WriteCT_OfPieType;
	
	    function WriteCT_OfPieChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var ofPieType = instance.ofPieType, varyColors = instance.varyColors, dLbls = instance.dLbls,
	                gapWidth = instance.gapWidth, splitType = instance.splitType, splitPos = instance.splitPos,
	                custSplit = instance.custSplit, secondPieSize = instance.secondPieSize, extLst = instance.extLst;
	            if (!isNullOrUndefined(ofPieType)) {
	                WriteCT_OfPieType(writer, CONST_C, "ofPieType", ofPieType);
	            }
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(gapWidth)) {
	                WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
	            }
	            if (!isNullOrUndefined(splitType)) {
	                WriteCT_SplitType(writer, CONST_C, "splitType", splitType);
	            }
	            if (!isNullOrUndefined(splitPos)) {
	                WriteCT_Double(writer, CONST_C, "splitPos", splitPos);
	            }
	           
	           
	           
	           
	           
	            if (!isNullOrUndefined(custSplit)) {
	                WriteCT_CustSplit(writer, CONST_C, "custSplit", custSplit);
	            }
	            if (!isNullOrUndefined(secondPieSize)) {
	                WriteCT_SecondPieSize(writer, CONST_C, "secondPieSize", secondPieSize);
	            }
	            writeArrayItem(instance.serLines, function (serLinesItem) {
	                WriteCT_ChartLines(writer, CONST_C, "serLines", serLinesItem);
	            });
	
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_OfPieChart = WriteCT_OfPieChart;
	
	    function WriteCT_BubbleChart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var varyColors = instance.varyColors, dLbls = instance.dLbls, bubble3D = instance.bubble3D,
	                bubbleScale = instance.bubbleScale, showNegBubbles = instance.showNegBubbles,
	                sizeRepresents = instance.sizeRepresents, extLst = instance.extLst;
	            if (!isNullOrUndefined(varyColors)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
	            }
	            writeArrayItem(instance.ser, function (seriesItem) {
	                WriteCT_BubbleSer(writer, CONST_C, CONST_SER, seriesItem);
	            });
	
	            if (!isNullOrUndefined(dLbls)) {
	                WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
	            }
	            if (!isNullOrUndefined(bubble3D)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
	            }
	            if (!isNullOrUndefined(bubbleScale)) {
	                WriteCT_BubbleScale(writer, CONST_C, "bubbleScale", bubbleScale);
	            }
	            if (!isNullOrUndefined(showNegBubbles)) {
	                WriteCT_Boolean(writer, CONST_C, "showNegBubbles", showNegBubbles);
	            }
	            if (!isNullOrUndefined(sizeRepresents)) {
	                WriteCT_SizeRepresents(writer, CONST_C, "sizeRepresents", sizeRepresents);
	            }
	            writeArrayItem(instance.axId, function (axIdItem) {
	                WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
	            });
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BubbleChart = WriteCT_BubbleChart;
	
	    function WriteCT_BandFmt(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", instance.idx);
	            }
	            if (!isNullOrUndefined(instance.spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, instance.spPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BandFmt = WriteCT_BandFmt;
	
	    function WriteCT_BandFmts(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.bandFmt, function (bandFmtItem) {
	                WriteCT_BandFmt(writer, CONST_C, "bandFmt", bandFmtItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_BandFmts = WriteCT_BandFmts;
	
	    function WriteCT_SurfaceChart(writer, prefix, localName, instance) {
	        writeSurfaceChartSubElement(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_SurfaceChart = WriteCT_SurfaceChart;
	
	    function WriteCT_Surface3DChart(writer, prefix, localName, instance) {
	        writeSurfaceChartSubElement(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_Surface3DChart = WriteCT_Surface3DChart;
	
	    function WriteCT_AxPos(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_AxPos);
	    }
	
	    DrawingWriter.WriteCT_AxPos = WriteCT_AxPos;
	
	    function WriteCT_Crosses(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_Crosses, ChartHelper.ToST_Crosses);
	    }
	
	    DrawingWriter.WriteCT_Crosses = WriteCT_Crosses;
	
	    function WriteCT_CrossBetween(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_CrossBetween);
	    }
	
	    DrawingWriter.WriteCT_CrossBetween = WriteCT_CrossBetween;
	
	    function WriteCT_TickMark(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0 , Charts.ST_TickMark);
	    }
	
	    DrawingWriter.WriteCT_TickMark = WriteCT_TickMark;
	
	    function WriteCT_TickLblPos(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_TickLblPos);
	    }
	
	    DrawingWriter.WriteCT_TickLblPos = WriteCT_TickLblPos;
	
	    function WriteCT_Skip(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Skip = WriteCT_Skip;
	
	    function WriteCT_TimeUnit(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_TimeUnit);
	    }
	
	    DrawingWriter.WriteCT_TimeUnit = WriteCT_TimeUnit;
	
	    function WriteCT_AxisUnit(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_AxisUnit = WriteCT_AxisUnit;
	
	    function WriteCT_BuiltInUnit(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_BuiltInUnit, ChartHelper.ToST_BuiltInUnit);
	    }
	
	    DrawingWriter.WriteCT_BuiltInUnit = WriteCT_BuiltInUnit;
	
	    function WriteCT_PictureFormat(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_PictureFormat);
	    }
	
	    DrawingWriter.WriteCT_PictureFormat = WriteCT_PictureFormat;
	
	    function WriteCT_PictureStackUnit(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_PictureStackUnit = WriteCT_PictureStackUnit;
	
	    function WriteCT_PictureOptions(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var applyToFront = instance.applyToFront, applyToSides = instance.applyToSides,
	                applyToEnd = instance.applyToEnd, pictureFormat = instance.pictureFormat,
	                pictureStackUnit = instance.pictureStackUnit;
	            if (!isNullOrUndefined(applyToFront)) {
	                WriteCT_Boolean(writer, CONST_C, "applyToFront", applyToFront);
	            }
	            if (!isNullOrUndefined(applyToSides)) {
	                WriteCT_Boolean(writer, CONST_C, "applyToSides", applyToSides);
	            }
	            if (!isNullOrUndefined(applyToEnd)) {
	                WriteCT_Boolean(writer, CONST_C, "applyToEnd", applyToEnd);
	            }
	            if (!isNullOrUndefined(pictureFormat)) {
	                WriteCT_PictureFormat(writer, CONST_C, "pictureFormat", pictureFormat);
	            }
	            if (!isNullOrUndefined(pictureStackUnit)) {
	                WriteCT_PictureStackUnit(writer, CONST_C, "pictureStackUnit", pictureStackUnit);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureOptions = WriteCT_PictureOptions;
	
	    function WriteCT_DispUnitsLbl(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var layout = instance.layout, tx = instance.tx, spPr = instance.spPr, txPr = instance.txPr;
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
	            }
	            if (!isNullOrUndefined(tx)) {
	                WriteCT_Tx(writer, CONST_C, "tx", tx);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DispUnitsLbl = WriteCT_DispUnitsLbl;
	
	    function WriteCT_DispUnits(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var custUnit = instance.custUnit, builtInUnit = instance.builtInUnit,
	                dispUnitsLbl = instance.dispUnitsLbl, extLst = instance.extLst;
	            if (!isNullOrUndefined(custUnit)) {
	                WriteCT_Double(writer, CONST_C, "custUnit", custUnit);
	            }
	            if (!isNullOrUndefined(builtInUnit)) {
	                WriteCT_BuiltInUnit(writer, CONST_C, "builtInUnit", builtInUnit);
	            }
	            if (!isNullOrUndefined(dispUnitsLbl)) {
	                WriteCT_DispUnitsLbl(writer, CONST_C, "dispUnitsLbl", dispUnitsLbl);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DispUnits = WriteCT_DispUnits;
	
	    function WriteCT_Orientation(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_Orientation);
	    }
	
	    DrawingWriter.WriteCT_Orientation = WriteCT_Orientation;
	
	    function WriteCT_LogBase(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_LogBase = WriteCT_LogBase;
	
	    function WriteCT_Scaling(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var logBase = instance.logBase, orientation = instance.orientation,
	                max = instance.max, min = instance.min, extLst = instance.extLst;
	            if (!isNullOrUndefined(logBase)) {
	                WriteCT_LogBase(writer, CONST_C, "logBase", logBase);
	            }
	            if (!isNullOrUndefined(orientation)) {
	                WriteCT_Orientation(writer, CONST_C, "orientation", orientation);
	            }
	            if (!isNullOrUndefined(max)) {
	                WriteCT_Double(writer, CONST_C, "max", max);
	            }
	            if (!isNullOrUndefined(min)) {
	                WriteCT_Double(writer, CONST_C, "min", min);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Scaling = WriteCT_Scaling;
	
	    function WriteCT_LblOffset(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 100);
	    }
	
	    DrawingWriter.WriteCT_LblOffset = WriteCT_LblOffset;
	
	    function WriteCT_CatAx(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var auto = instance.auto, lblAlgn = instance.lblAlgn, lblOffset = instance.lblOffset,
	                tickLblSkip = instance.tickLblSkip, tickMarkSkip = instance.tickMarkSkip,
	                noMultiLvlLbl = instance.noMultiLvlLbl, extLst = instance.extLst;
	            writeAxisSubElement(writer, instance);
	            if (!isNullOrUndefined(auto)) {
	                WriteCT_Boolean(writer, CONST_C, "auto", auto);
	            }
	            if (!isNullOrUndefined(lblAlgn)) {
	                WriteCT_LblAlgn(writer, CONST_C, "lblAlgn", lblAlgn);
	            }
	            if (!isNullOrUndefined(lblOffset)) {
	                WriteCT_LblOffset(writer, CONST_C, "lblOffset", lblOffset);
	            }
	            if (!isNullOrUndefined(tickLblSkip)) {
	                WriteCT_Skip(writer, CONST_C, "tickLblSkip", tickLblSkip);
	            }
	            if (!isNullOrUndefined(tickMarkSkip)) {
	                WriteCT_Skip(writer, CONST_C, "tickMarkSkip", tickMarkSkip);
	            }
	            if (!isNullOrUndefined(noMultiLvlLbl)) {
	                WriteCT_Boolean(writer, CONST_C, "noMultiLvlLbl", noMultiLvlLbl);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_CatAx = WriteCT_CatAx;
	
	    function WriteCT_DateAx(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var auto = instance.auto, lblOffset = instance.lblOffset, baseTimeUnit = instance.baseTimeUnit,
	                majorUnit = instance.majorUnit, majorTimeUnit = instance.majorTimeUnit,
	                minorUnit = instance.minorUnit, minorTimeUnit = instance.minorTimeUnit,
	                extLst = instance.extLst;
	            writeAxisSubElement(writer, instance);
	            if (!isNullOrUndefined(auto)) {
	                WriteCT_Boolean(writer, CONST_C, "auto", auto);
	            }
	            if (!isNullOrUndefined(lblOffset)) {
	                WriteCT_LblOffset(writer, CONST_C, "lblOffset", lblOffset);
	            }
	            if (!isNullOrUndefined(baseTimeUnit)) {
	                WriteCT_TimeUnit(writer, CONST_C, "baseTimeUnit", baseTimeUnit);
	            }
	            if (!isNullOrUndefined(majorUnit)) {
	                WriteCT_AxisUnit(writer, CONST_C, "majorUnit", majorUnit);
	            }
	            if (!isNullOrUndefined(majorTimeUnit)) {
	                WriteCT_TimeUnit(writer, CONST_C, "majorTimeUnit", majorTimeUnit);
	            }
	            if (!isNullOrUndefined(minorUnit)) {
	                WriteCT_AxisUnit(writer, CONST_C, "minorUnit", minorUnit);
	            }
	            if (!isNullOrUndefined(minorTimeUnit)) {
	                WriteCT_TimeUnit(writer, CONST_C, "minorTimeUnit", minorTimeUnit);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DateAx = WriteCT_DateAx;
	
	    function WriteCT_SerAx(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var tickLblSkip = instance.tickLblSkip, tickMarkSkip = instance.tickMarkSkip,
	                extLst = instance.extLst;
	            writeAxisSubElement(writer, instance);
	            if (!isNullOrUndefined(tickLblSkip)) {
	                WriteCT_Skip(writer, CONST_C, "tickLblSkip", tickLblSkip);
	            }
	            if (!isNullOrUndefined(tickMarkSkip)) {
	                WriteCT_Skip(writer, CONST_C, "tickMarkSkip", tickMarkSkip);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_SerAx = WriteCT_SerAx;
	
	    function WriteCT_ValAx(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var crossBetween = instance.crossBetween, majorUnit = instance.majorUnit,
	                minorUnit = instance.minorUnit, dispUnits = instance.dispUnits,
	                extLst = instance.extLst;
	            writeAxisSubElement(writer, instance);
	            if (!isNullOrUndefined(crossBetween)) {
	                WriteCT_CrossBetween(writer, CONST_C, "crossBetween", crossBetween);
	            }
	            if (!isNullOrUndefined(majorUnit)) {
	                WriteCT_AxisUnit(writer, CONST_C, "majorUnit", majorUnit);
	            }
	            if (!isNullOrUndefined(minorUnit)) {
	                WriteCT_AxisUnit(writer, CONST_C, "minorUnit", minorUnit);
	            }
	            if (!isNullOrUndefined(dispUnits)) {
	                WriteCT_DispUnits(writer, CONST_C, "dispUnits", dispUnits);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ValAx = WriteCT_ValAx;
	
	    function WriteCT_PlotArea(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var layout = instance.layout, dTable = instance.dTable, spPr = instance.spPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
	            }
	            writeArrayItem(instance.chartGroups, function (chart) {
	                var chartType = chart.chartType;
	                if (chartType === 4) {
	                    WriteCT_AreaChart(writer, CONST_C, "areaChart", chart);
	                } else if (chartType === 5) {
	                    WriteCT_Area3DChart(writer, CONST_C, "area3DChart", chart);
	                } else if (chartType === 6) {
	                    WriteCT_BarChart(writer, CONST_C, "barChart", chart);
	                } else if (chartType === 7) {
	                    WriteCT_Bar3DChart(writer, CONST_C, "bar3DChart", chart);
	                } else if (chartType === 8) {
	                    WriteCT_LineChart(writer, CONST_C, "lineChart", chart);
	                } else if (chartType === 9) {
	                    WriteCT_Line3DChart(writer, CONST_C, "line3DChart", chart);
	                } else if (chartType === 0) {
	                    WriteCT_StockChart(writer, CONST_C, "stockChart", chart);
	                } else if (chartType === 2) {
	                    WriteCT_RadarChart(writer, CONST_C, "radarChart", chart);
	                } else if (chartType === 1) {
	                    WriteCT_ScatterChart(writer, CONST_C, "scatterChart", chart);
	                } else if (chartType === 10) {
	                    WriteCT_PieChart(writer, CONST_C, "pieChart", chart);
	                } else if (chartType === 11) {
	                    WriteCT_Pie3DChart(writer, CONST_C, "pie3DChart", chart);
	                } else if (chartType === 12) {
	                    WriteCT_DoughnutChart(writer, CONST_C, "doughnutChart", chart);
	                } else if (chartType === 13) {
	                    WriteCT_OfPieChart(writer, CONST_C, "ofPieChart", chart);
	                } else if (chartType === 14) {
	                    WriteCT_SurfaceChart(writer, CONST_C, "surfaceChart", chart);
	                } else if (chartType === 15) {
	                    WriteCT_Surface3DChart(writer, CONST_C, "surface3DChart", chart);
	                } else if (chartType === 3) {
	                    WriteCT_BubbleChart(writer, CONST_C, "bubbleChart", chart);
	                }
	            });
	            var axes = instance.axes;
	            if (axes) {
	                var primeCatAx = axes.filter(function (item) {
	                return item.AxisGroup === 0 && item.AxisType === 0;
	                })[0];
	                if (primeCatAx) {
	                    if (primeCatAx.axisType === 0) {
	                        WriteCT_CatAx(writer, CONST_C, "catAx", primeCatAx);
	                    } else if (primeCatAx.axisType === 1) {
	                        WriteCT_DateAx(writer, CONST_C, "dateAx", primeCatAx);
	                    } else if (primeCatAx.axisType === 3) {
	                        WriteCT_ValAx(writer, CONST_C, "valAx", primeCatAx);
	                    }
	                }
	                var primeValAx = axes.filter(function (item) {
	                return item.AxisGroup === 0 && item.AxisType === 1;
	                })[0];
	                if (!isNullOrUndefined(primeValAx)) {
	                    WriteCT_ValAx(writer, CONST_C, "valAx", primeValAx);
	                }
	                var secondValAx = axes.filter(function (item) {
	                return item.AxisGroup === 1 && item.AxisType === 1;
	                })[0];
	                if (!isNullOrUndefined(secondValAx)) {
	                    WriteCT_ValAx(writer, CONST_C, "valAx", secondValAx);
	                }
	                var secondCatAx = axes.filter(function (item) {
	                return item.AxisGroup === 1 && item.AxisType === 0;
	                })[0];
	                if (secondCatAx) {
	                    if (secondCatAx.axisType === 0) {
	                        WriteCT_CatAx(writer, CONST_C, "catAx", secondCatAx);
	                    } else if (secondCatAx.axisType === 1) {
	                        WriteCT_DateAx(writer, CONST_C, "dateAx", secondCatAx);
	                    } else if (secondCatAx.axisType === 3) {
	                        WriteCT_ValAx(writer, CONST_C, "valAx", secondCatAx);
	                    }
	                }
	                var serAx = axes.filter(function (item) {
	                    return item.axisType === 2 ;
	                });
	                writeArrayItem(serAx, function (item) {
	                    WriteCT_SerAx(writer, CONST_C, "serAx", item);
	                });
	            }
	            if (!isNullOrUndefined(dTable)) {
	                WriteCT_DTable(writer, CONST_C, "dTable", dTable);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PlotArea = WriteCT_PlotArea;
	
	    function WriteCT_PivotFmt(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, spPr = instance.spPr, txPr = instance.txPr, marker = instance.marker,
	                dLbl = instance.dLbl, extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(marker)) {
	                WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
	            }
	            if (!isNullOrUndefined(dLbl)) {
	                WriteCT_DLbl(writer, CONST_C, "dLbl", dLbl);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PivotFmt = WriteCT_PivotFmt;
	
	    function WriteCT_PivotFmts(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.pivotFmt, function (pivotFmtItem) {
	                WriteCT_PivotFmt(writer, CONST_C, "pivotFmt", pivotFmtItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_PivotFmts = WriteCT_PivotFmts;
	
	    function WriteCT_LegendPos(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_LegendPos, ChartHelper.ToST_LegendPos);
	    }
	
	    DrawingWriter.WriteCT_LegendPos = WriteCT_LegendPos;
	
	    function WriteCT_LegendEntry(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var idx = instance.idx, deleteField = instance.delete, txPr = instance.txPr,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(idx)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
	            }
	            if (!isNullOrUndefined(deleteField)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LegendEntry = WriteCT_LegendEntry;
	
	    function WriteCT_Legend(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var legendPos = instance.legendPos, layout = instance.layout, overlay = instance.overlay || false,
	                spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(legendPos)) {
	                WriteCT_LegendPos(writer, CONST_C, "legendPos", legendPos);
	            }
	            writeArrayItem(instance.legendEntry, function (legendEntryItem) {
	                WriteCT_LegendEntry(writer, CONST_C, "legendEntry", legendEntryItem);
	            });
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
	            }
	
	            WriteCT_Boolean(writer, CONST_C, "overlay", overlay);
	
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Legend = WriteCT_Legend;
	
	    function WriteCT_DispBlanksAs(writer, prefix, localName, instance) {
	       
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 2 , Charts.ST_DispBlanksAs);
	    }
	
	    DrawingWriter.WriteCT_DispBlanksAs = WriteCT_DispBlanksAs;
	
	    function WriteCT_Chart(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var title = instance.title, autoTitleDeleted = instance.autoTitleDeleted, view3D = instance.view3D,
	                floor = instance.floor, sideWall = instance.sideWall, backWall = instance.backWall,
	                plotArea = instance.plotArea, legend = instance.legend, plotVisOnly = instance.plotVisOnly,
	                dispBlanksAs = instance.dispBlanksAs, showDLblsOverMax = instance.showDLblsOverMax,
	                extLst = instance.extLst, pivotFmts = instance.pivotFmts;
	            if (!isNullOrUndefined(title)) {
	                WriteCT_Title(writer, CONST_C, CONST_TITLE, title);
	            }
	            if (!isNullOrUndefined(autoTitleDeleted)) {
	                WriteCT_Boolean(writer, CONST_C, "autoTitleDeleted", autoTitleDeleted);
	            }
	            if (!isNullOrUndefined(pivotFmts)) {
	                var count = pivotFmts.length;
	                if (count > 0) {
	                    writer.writeElement("c:pivotFmts", function () {
	                        for (var i = 0; i < count; i++) {
	                            var pivotFmtsItem = pivotFmts[i];
	                            if (!isNullOrUndefined(pivotFmtsItem)) {
	                                WriteCT_PivotFmt(writer, CONST_C, "pivotFmt", pivotFmtsItem);
	                            }
	                        }
	                    });
	                }
	            }
	            if (!isNullOrUndefined(view3D)) {
	                WriteCT_View3D(writer, CONST_C, "view3D", view3D);
	            }
	            if (!isNullOrUndefined(floor)) {
	                WriteCT_Surface(writer, CONST_C, "floor", floor);
	            }
	            if (!isNullOrUndefined(sideWall)) {
	                WriteCT_Surface(writer, CONST_C, "sideWall", sideWall);
	            }
	            if (!isNullOrUndefined(backWall)) {
	                WriteCT_Surface(writer, CONST_C, "backWall", backWall);
	            }
	            if (!isNullOrUndefined(plotArea)) {
	                WriteCT_PlotArea(writer, CONST_C, "plotArea", plotArea);
	            }
	            if (!isNullOrUndefined(legend)) {
	                WriteCT_Legend(writer, CONST_C, "legend", legend);
	            }
	            if (!isNullOrUndefined(plotVisOnly)) {
	                WriteCT_Boolean(writer, CONST_C, "plotVisOnly", plotVisOnly);
	            }
	            if (!isNullOrUndefined(dispBlanksAs)) {
	                WriteCT_DispBlanksAs(writer, CONST_C, "dispBlanksAs", dispBlanksAs);
	            }
	            if (!isNullOrUndefined(showDLblsOverMax)) {
	                WriteCT_Boolean(writer, CONST_C, "showDLblsOverMax", showDLblsOverMax);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Chart = WriteCT_Chart;
	
	    function WriteCT_Style(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_Style = WriteCT_Style;
	
	    function WriteCT_PivotSource(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.name)) {
	                writer.writeElementString("c:name", instance.name);
	            }
	            var fmtId = instance.fmtId;
	            if (!isNullOrUndefined(fmtId)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "fmtId", fmtId);
	            }
	            writeArrayItem(instance.extLst, function (extLstItem) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLstItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_PivotSource = WriteCT_PivotSource;
	
	    function WriteCT_Protection(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var chartObject = instance.chartObject, data = instance.data, formatting = instance.formatting,
	                selection = instance.selection, userInterface = instance.userInterface;
	            if (!isNullOrUndefined(chartObject)) {
	                WriteCT_Boolean(writer, CONST_C, "chartObject", chartObject);
	            }
	            if (!isNullOrUndefined(data)) {
	                WriteCT_Boolean(writer, CONST_C, "data", data);
	            }
	            if (!isNullOrUndefined(formatting)) {
	                WriteCT_Boolean(writer, CONST_C, "formatting", formatting);
	            }
	            if (!isNullOrUndefined(selection)) {
	                WriteCT_Boolean(writer, CONST_C, "selection", selection);
	            }
	            if (!isNullOrUndefined(userInterface)) {
	                WriteCT_Boolean(writer, CONST_C, "userInterface", userInterface);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Protection = WriteCT_Protection;
	
	    function WriteCT_HeaderFooter(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.alignWithMargins === false) {
	                writer.writeAttributeString("alignWithMargins", "0");
	            }
	            if (instance.differentOddEven === true) {
	                writer.writeAttributeString("differentOddEven", "1");
	            }
	            if (instance.differentFirst === true) {
	                writer.writeAttributeString("differentFirst", "1");
	            }
	        }, function () {
	           
	            var oddHeader = instance.oddHeader, oddFooter = instance.oddFooter,
	                evenHeader = instance.evenHeader, evenFooter = instance.evenFooter,
	                firstHeader = instance.firstHeader, firstFooter = instance.firstFooter;
	            if (!isNullOrUndefined(oddHeader)) {
	                writer.writeElementString("c:oddHeader", oddHeader);
	            }
	            if (!isNullOrUndefined(oddFooter)) {
	                writer.writeElementString("c:oddFooter", oddFooter);
	            }
	            if (!isNullOrUndefined(evenHeader)) {
	                writer.writeElementString("c:evenHeader", evenHeader);
	            }
	            if (!isNullOrUndefined(evenFooter)) {
	                writer.writeElementString("c:evenFooter", evenFooter);
	            }
	            if (!isNullOrUndefined(firstHeader)) {
	                writer.writeElementString("c:firstHeader", firstHeader);
	            }
	            if (!isNullOrUndefined(firstFooter)) {
	                writer.writeElementString("c:firstFooter", firstFooter);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_HeaderFooter = WriteCT_HeaderFooter;
	
	    function WriteCT_PageMargins(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var header = instance.header, footer = instance.footer;
	            if (!isNullOrUndefined(instance.l)) {
	                writer.writeAttributeString("l", instance.l);
	            }
	            if (!isNullOrUndefined(instance.r)) {
	                writer.writeAttributeString(CONST_R, instance.r);
	            }
	            if (!isNullOrUndefined(instance.t)) {
	                writer.writeAttributeString("t", instance.t);
	            }
	            if (!isNullOrUndefined(instance.b)) {
	                writer.writeAttributeString("b", instance.b);
	            }
	            if (!isNullOrUndefined(header)) {
	                writer.writeAttributeString("header", header);
	            }
	            if (!isNullOrUndefined(footer)) {
	                writer.writeAttributeString("footer", footer);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PageMargins = WriteCT_PageMargins;
	
	    function WriteCT_ExternalData(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.id)) {
	                writer.writeAttributeString("id", instance.id);
	            }
	        }, function () {
	           
	            var autoUpdate = instance.autoUpdate;
	            if (!isNullOrUndefined(autoUpdate)) {
	                WriteCT_Boolean(writer, CONST_C, "autoUpdate", autoUpdate);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ExternalData = WriteCT_ExternalData;
	
	    function WriteCT_PageSetup(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var paperSize = instance.paperSize, firstPageNumber = instance.firstPageNumber,
	                orientation = instance.orientation, horizontalDpi = instance.horizontalDpi,
	                verticalDpi = instance.verticalDpi, copies = instance.copies;
	            if (!isNullOrUndefined(paperSize) && paperSize !== 1) {
	                writer.writeAttributeString("paperSize", paperSize);
	            }
	            if (!isNullOrUndefined(firstPageNumber) && firstPageNumber !== 1) {
	                writer.writeAttributeString("firstPageNumber", firstPageNumber);
	            }
	            if (!isNullOrUndefined(orientation) && orientation !== 0 ) {
	                writer.writeAttributeString("orientation", Charts.ST_PageSetupOrientation[orientation]);
	            }
	            if (instance.blackAndWhite === true) {
	                writer.writeAttributeString("blackAndWhite", "1");
	            }
	            if (instance.draft === true) {
	                writer.writeAttributeString("draft", "1");
	            }
	            if (instance.useFirstPageNumber === true) {
	                writer.writeAttributeString("useFirstPageNumber", "1");
	            }
	            if (!isNullOrUndefined(horizontalDpi) && horizontalDpi !== 600) {
	                writer.writeAttributeString("horizontalDpi", horizontalDpi);
	            }
	            if (!isNullOrUndefined(verticalDpi) && verticalDpi !== 600) {
	                writer.writeAttributeString("verticalDpi", verticalDpi);
	            }
	            if (!isNullOrUndefined(copies) && copies !== 1) {
	                writer.writeAttributeString("copies", copies);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PageSetup = WriteCT_PageSetup;
	
	    function WriteCT_PrintSettings(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var headerFooter = instance.headerFooter, pageMargins = instance.pageMargins,
	                pageSetup = instance.pageSetup, legacyDrawingHF = instance.legacyDrawingHF;
	            if (!isNullOrUndefined(headerFooter)) {
	                WriteCT_HeaderFooter(writer, CONST_C, "headerFooter", headerFooter);
	            }
	            if (!isNullOrUndefined(pageMargins)) {
	                WriteCT_PageMargins(writer, CONST_C, "pageMargins", pageMargins);
	            }
	            if (!isNullOrUndefined(pageSetup)) {
	                WriteCT_PageSetup(writer, CONST_C, "pageSetup", pageSetup);
	            }
	            if (!isNullOrUndefined(legacyDrawingHF)) {
	                WriteCT_RelId(writer, CONST_C, "legacyDrawingHF", legacyDrawingHF);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PrintSettings = WriteCT_PrintSettings;
	
	    function WriteCT_ChartSpace(writer, prefix, localName, instance) {
	        writer.writeElement("c:" + localName, function () {
	            writer.writeAttributeString("xmlns:c", DrawingWriter.c);
	            writer.writeAttributeString("xmlns:a", DrawingWriter.a);
	            writer.writeAttributeString("xmlns:r", DrawingWriter.r);
	        }, function () {
	           
	            var roundedCorners = instance.roundedCorners,
	                style = instance.style, clrMapOvr = instance.clrMapOvr, pivotSource = instance.pivotSource,
	                protection = instance.protection, chart = instance.chart, spPr = instance.spPr,
	                txPr = instance.txPr, externalData = instance.externalData,
	                printSettings = instance.printSettings, userShapes = instance.userShapes,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(roundedCorners)) {
	                WriteCT_Boolean(writer, CONST_C, "roundedCorners", roundedCorners);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_Style(writer, CONST_C, CONST_STYLE, style);
	            }
	            if (!isNullOrUndefined(clrMapOvr)) {
	                WriteCT_ColorMapping(writer, CONST_A, "clrMapOvr", clrMapOvr);
	            }
	            if (!isNullOrUndefined(pivotSource)) {
	                WriteCT_PivotSource(writer, CONST_C, "pivotSource", pivotSource);
	            }
	            if (!isNullOrUndefined(protection)) {
	                WriteCT_Protection(writer, CONST_C, "protection", protection);
	            }
	            if (!isNullOrUndefined(chart)) {
	                WriteCT_Chart(writer, CONST_C, "chart", chart);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(txPr)) {
	                WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
	            }
	            if (!isNullOrUndefined(externalData)) {
	                WriteCT_ExternalData(writer, CONST_C, "externalData", externalData);
	            }
	            if (!isNullOrUndefined(printSettings)) {
	                WriteCT_PrintSettings(writer, CONST_C, "printSettings", printSettings);
	            }
	            if (!isNullOrUndefined(userShapes)) {
	                WriteCT_UserShapes(writer, CONST_C, "userShapes", userShapes);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ChartSpace = WriteCT_ChartSpace;
	
	    function WriteCT_DLblExtensionList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.ext, function (extItem) {
	                WriteCT_DLblExt(writer, CONST_C, CONST_EXT, extItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_DLblExtensionList = WriteCT_DLblExtensionList;
	
	    function WriteCT_DLblExt(writer, prefix, localName, instance) {
	        writer.writeElement("c:" + localName, function () {
	            writer.writeAttributeString("xmlns:c15", DrawingWriter.c15);
	           
	            if (!isNullOrUndefined(instance.uri)) {
	                writer.writeAttributeString("uri", instance.uri);
	            }
	        }, function () {
	           
	            var layout = instance.layout, dlblFieldTable = instance.dlblFieldTable,
	                showDataLabelsRange = instance.showDataLabelsRange;
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C15, CONST_LAYOUT, layout);
	            }
	            if (!isNullOrUndefined(dlblFieldTable)) {
	                WriteCT_DataLabelFieldTable(writer, CONST_C15, "dlblFieldTable", dlblFieldTable);
	            }
	            if (!isNullOrUndefined(showDataLabelsRange)) {
	                WriteCT_Boolean(writer, CONST_C15, "showDataLabelsRange", showDataLabelsRange);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DLblExt = WriteCT_DLblExt;
	
	    function WriteCT_DLblsExtensionList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.ext, function (extItem) {
	                WriteCT_DLblsExt(writer, CONST_C, CONST_EXT, extItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_DLblsExtensionList = WriteCT_DLblsExtensionList;
	
	    function WriteCT_DLblsExt(writer, prefix, localName, instance) {
	        writer.writeElement("c:" + localName, function () {
	            writer.writeAttributeString("xmlns:c15", DrawingWriter.c15);
	           
	            if (!isNullOrUndefined(instance.uri)) {
	                writer.writeAttributeString("uri", instance.uri);
	            }
	        }, function () {
	           
	            var layout = instance.layout, showLeaderLines = instance.showLeaderLines,
	                showDataLabelsRange = instance.showDataLabelsRange, leaderLines = instance.leaderLines,
	                spPr = instance.spPr;
	            if (!isNullOrUndefined(layout)) {
	                WriteCT_Layout(writer, CONST_C15, CONST_LAYOUT, layout);
	            }
	            if (!isNullOrUndefined(showLeaderLines)) {
	                WriteCT_Boolean(writer, CONST_C15, "showLeaderLines", showLeaderLines);
	            }
	            if (!isNullOrUndefined(showDataLabelsRange)) {
	                WriteCT_Boolean(writer, CONST_C15, "showDataLabelsRange", showDataLabelsRange);
	            }
	            if (!isNullOrUndefined(leaderLines)) {
	                WriteCT_ChartLines(writer, CONST_C15, "leaderLines", leaderLines);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_C15, CONST_SPPR, spPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DLblsExt = WriteCT_DLblsExt;
	
	    function WriteCT_UserShapes(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.id)) {
	                writer.writeAttributeString("r:id", instance.id);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_UserShapes = WriteCT_UserShapes;
	
	    function WriteCT_InvertSolidFillFmt(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ShapeProperties, CONST_C14, CONST_SPPR);
	    }
	
	    DrawingWriter.WriteCT_InvertSolidFillFmt = WriteCT_InvertSolidFillFmt;
	
	    function WriteCT_ColorMapping(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var ST_ColorSchemeIndex = Charts.ST_ColorSchemeIndex;
	            writer.writeAttributeString("bg1", ST_ColorSchemeIndex[instance.bg1]);
	            writer.writeAttributeString("tx1", ST_ColorSchemeIndex[instance.tx1]);
	            writer.writeAttributeString("bg2", ST_ColorSchemeIndex[instance.bg2]);
	            writer.writeAttributeString("tx2", ST_ColorSchemeIndex[instance.tx2]);
	            writer.writeAttributeString("accent1", ST_ColorSchemeIndex[instance.accent1]);
	            writer.writeAttributeString("accent2", ST_ColorSchemeIndex[instance.accent2]);
	            writer.writeAttributeString("accent3", ST_ColorSchemeIndex[instance.accent3]);
	            writer.writeAttributeString("accent4", ST_ColorSchemeIndex[instance.accent4]);
	            writer.writeAttributeString("accent5", ST_ColorSchemeIndex[instance.accent5]);
	            writer.writeAttributeString("accent6", ST_ColorSchemeIndex[instance.accent6]);
	            writer.writeAttributeString("hlink", ST_ColorSchemeIndex[instance.hlink]);
	            writer.writeAttributeString("folHlink", ST_ColorSchemeIndex[instance.folHlink]);
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorMapping = WriteCT_ColorMapping;
	
	    function WriteCT_FullRef(writer, prefix, localName, instance) {
	        writeSubSqrefElement(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_FullRef = WriteCT_FullRef;
	
	    function WriteCT_LevelRef(writer, prefix, localName, instance) {
	        writeSubSqrefElement(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_LevelRef = WriteCT_LevelRef;
	
	    function WriteCT_FormulaRef(writer, prefix, localName, instance) {
	        writeSubSqrefElement(writer, prefix, localName, instance);
	    }
	
	    DrawingWriter.WriteCT_FormulaRef = WriteCT_FormulaRef;
	
	    function WriteCT_FilteredSeriesTitle(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_Tx, CONST_C, "tx");
	    }
	
	    DrawingWriter.WriteCT_FilteredSeriesTitle = WriteCT_FilteredSeriesTitle;
	
	    function WriteCT_FilteredCategoryTitle(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AxDataSource, CONST_C, "cat");
	    }
	
	    DrawingWriter.WriteCT_FilteredCategoryTitle = WriteCT_FilteredCategoryTitle;
	
	    function WriteCT_FilteredBarSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_BarSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredBarSer = WriteCT_FilteredBarSer;
	
	    function WriteCT_FilteredLineSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_LineSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredLineSer = WriteCT_FilteredLineSer;
	
	    function WriteCT_FilteredScatterSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ScatterSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredScatterSer = WriteCT_FilteredScatterSer;
	
	    function WriteCT_FilteredAreaSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AreaSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredAreaSer = WriteCT_FilteredAreaSer;
	
	    function WriteCT_FilteredPieSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_PieSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredPieSer = WriteCT_FilteredPieSer;
	
	    function WriteCT_FilteredBubbleSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_BubbleSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredBubbleSer = WriteCT_FilteredBubbleSer;
	
	    function WriteCT_FilteredRadarSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_RadarSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredRadarSer = WriteCT_FilteredRadarSer;
	
	    function WriteCT_FilteredSurfaceSer(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_SurfaceSer, CONST_C, CONST_SER);
	    }
	
	    DrawingWriter.WriteCT_FilteredSurfaceSer = WriteCT_FilteredSurfaceSer;
	
	    function WriteCT_SeriesDataLabelsRange(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	            writer.writeAttributeString("xmlns:c15", DrawingWriter.c15);
	        }, function () {
	           
	            var dlblRangeCache = instance.dlblRangeCache;
	            if (!isNullOrUndefined(instance.f)) {
	                writer.writeElementString("c15:f", xmlEncode(instance.f));
	            }
	            if (!isNullOrUndefined(dlblRangeCache)) {
	                WriteCT_StrData(writer, CONST_C, "dlblRangeCache", dlblRangeCache);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_SeriesDataLabelsRange = WriteCT_SeriesDataLabelsRange;
	
	    function WriteCT_CategoryFilterException(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var sqref = instance.sqref, spPr = instance.spPr, explosion = instance.explosion,
	                invertIfNegative = instance.invertIfNegative, bubble3D = instance.bubble3D,
	                marker = instance.marker, dLbl = instance.dLbl;
	            if (!isNullOrUndefined(sqref)) {
	                writer.writeElementString("c15:sqref", sqref);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_A, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(explosion)) {
	                WriteCT_UnsignedInt(writer, CONST_C, "explosion", explosion);
	            }
	            if (!isNullOrUndefined(invertIfNegative)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
	            }
	            if (!isNullOrUndefined(bubble3D)) {
	                WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
	            }
	            if (!isNullOrUndefined(marker)) {
	                WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
	            }
	            if (!isNullOrUndefined(dLbl)) {
	                WriteCT_DLbl(writer, CONST_C, "dLbl", dLbl);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_CategoryFilterException = WriteCT_CategoryFilterException;
	
	    function WriteCT_CategoryFilterExceptions(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.categoryFilterException, function (categoryFilterExceptionItem) {
	                WriteCT_CategoryFilterException(writer, CONST_C15, "categoryFilterException", categoryFilterExceptionItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_CategoryFilterExceptions = WriteCT_CategoryFilterExceptions;
	
	    function WriteCT_DataLabelFieldTableEntry(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var dlblFieldTableCache = instance.dlblFieldTableCache;
	            if (!isNullOrUndefined(instance.txfldGUID)) {
	                writer.writeElementString("c15:txfldGUID", instance.txfldGUID);
	            }
	            if (!isNullOrUndefined(instance.f)) {
	                writer.writeElementString("c15:f", xmlEncode(instance.f));
	            }
	            if (!isNullOrUndefined(dlblFieldTableCache)) {
	                WriteCT_StrData(writer, CONST_C15, "dlblFieldTableCache", dlblFieldTableCache);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DataLabelFieldTableEntry = WriteCT_DataLabelFieldTableEntry;
	
	    function WriteCT_DataLabelFieldTable(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.dlblFTEntry, function (dlblFTEntryItem) {
	                WriteCT_DataLabelFieldTableEntry(writer, CONST_C15, "dlblFTEntry", dlblFTEntryItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_DataLabelFieldTable = WriteCT_DataLabelFieldTable;
	
	    function WriteCT_GraphicFrame(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro;
	            if (!isNullOrUndefined(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvGraphicFramePr = instance.nvGraphicFramePr, xfrm = instance.xfrm;
	            if (!isNullOrUndefined(nvGraphicFramePr)) {
	                WriteCT_GraphicFrameNonVisual(writer, CONST_CDR, "nvGraphicFramePr", nvGraphicFramePr);
	            }
	            if (!isNullOrUndefined(xfrm)) {
	                WriteCT_Transform2D(writer, CONST_A, "xfrm", xfrm);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicFrame = WriteCT_GraphicFrame;
	
	    function WriteCT_GraphicFrameNonVisual(writer, prefix, localName, instance) {
	        writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, CONST_A);
	    }
	
	    DrawingWriter.WriteCT_GraphicFrameNonVisual = WriteCT_GraphicFrameNonVisual;
	
	    function WriteCT_CdrPosition(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.x)) {
	                writer.writeElementString("cdr:x", instance.x);
	            }
	            if (!isNullOrUndefined(instance.y)) {
	                writer.writeElementString("cdr:y", instance.y);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_CdrPosition = WriteCT_CdrPosition;
	
	    function WriteCT_RelSizeAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var from = instance.startPoint, to = instance.endPoint, sp = instance.sp, grpSp = instance.grpSp;
	            if (!isNullOrUndefined(from)) {
	                WriteCT_CdrPosition(writer, CONST_CDR, "from", from);
	            }
	            if (!isNullOrUndefined(to)) {
	                WriteCT_CdrPosition(writer, CONST_CDR, "to", to);
	            }
	            if (!isNullOrUndefined(sp)) {
	                WriteCT_ShapeForCdr(writer, CONST_CDR, "sp", sp);
	            }
	            if (!isNullOrUndefined(grpSp)) {
	                WriteCT_GroupShape(writer, CONST_CDR, CONST_GRPSP, grpSp);
	            }
	            if (!isNullOrUndefined(instance.graphicFrame)) {
	               
	                WriteCT_GraphicalObjectFrame_cdr(writer, CONST_CDR, CONST_GRAPHIC_FRAME, instance.graphicFrame);
	            }
	            if (!isNullOrUndefined(instance.cxnSp)) {
	               
	                WriteCT_ConnectorCdr(writer, CONST_CDR, CONST_CXNSP, instance.cxnSp);
	            }
	            if (!isNullOrUndefined(instance.pic)) {
	               
	                WriteCT_PictureRelSizeAnchor(writer, CONST_CDR, "pic", instance.pic);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_RelSizeAnchor = WriteCT_RelSizeAnchor;
	
	    function WriteCT_AbsSizeAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	            writer.writeAttributeString('xmlns:cdr', DrawingWriter.cdr);
	        }, function () {
	           
	            var from = instance.from, ext = instance.ext, sp = instance.sp, grpSp = instance.grpSp,
	                cxnSp = instance.cxnSp, pic = instance.pic;
	            if (!isNullOrUndefined(from)) {
	                WriteCT_CdrPosition(writer, CONST_CDR, "from", from);
	            }
	            if (!isNullOrUndefined(ext)) {
	                WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, ext);
	            }
	            if (!isNullOrUndefined(sp)) {
	                WriteCT_Shape(writer, CONST_XDR, "sp", sp);
	            }
	            if (!isNullOrUndefined(grpSp)) {
	                WriteCT_GroupShape(writer, CONST_XDR, CONST_GRPSP, grpSp);
	            }
	            if (!isNullOrUndefined(instance.graphicFrame)) {
	               
	                WriteCT_GraphicalObjectFrame(writer, CONST_CDR, CONST_GRAPHIC_FRAME, instance.graphicFrame);
	            }
	            if (!isNullOrUndefined(cxnSp)) {
	                WriteCT_Connector(writer, CONST_XDR, CONST_CXNSP, cxnSp);
	            }
	            if (!isNullOrUndefined(pic)) {
	                WriteCT_Picture(writer, CONST_XDR, "pic", pic);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_AbsSizeAnchor = WriteCT_AbsSizeAnchor;
	
	    function WriteCT_ChartDrawing(writer, prefix, localName, instance) {
	        writer.writeElement("c:" + localName, function () {
	            writer.writeAttributeString('xmlns:c', DrawingWriter.c);
	           
	            writer.writeAttributeString('xmlns:cdr', DrawingWriter.cdr);
	            writer.writeAttributeString('xmlns:a', DrawingWriter.a);
	        }, function () {
	           
	            var relSizeAnchor = instance.relSizeAnchor, absSizeAnchor = instance.absSizeAnchor;
	            relSizeAnchor && relSizeAnchor.forEach(function (relSizeAnchorItem) {
	                if (relSizeAnchorItem) {
	                    WriteCT_RelSizeAnchor(writer, CONST_CDR, "relSizeAnchor", relSizeAnchorItem);
	                }
	            });
	            absSizeAnchor && absSizeAnchor.forEach(function (absSizeAnchorItem) {
	                if (absSizeAnchorItem) {
	                    WriteCT_AbsSizeAnchor(writer, CONST_CDR, "absSizeAnchor", absSizeAnchorItem);
	                }
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_ChartDrawing = WriteCT_ChartDrawing;
	
	    function WriteCT_ConnectorLocking(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeLockingElementAttribute(writer, instance);
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ConnectorLocking = WriteCT_ConnectorLocking;
	
	    function WriteCT_ShapeLocking(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeLockingElementAttribute(writer, instance);
	            if (instance.noTextEdit === true) {
	                writer.writeAttributeString("noTextEdit", "1");
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ShapeLocking = WriteCT_ShapeLocking;
	
	    function WriteCT_PictureLocking(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeLockingElementAttribute(writer, instance);
	            if (instance.noCrop === true) {
	                writer.writeAttributeString("noCrop", "1");
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureLocking = WriteCT_PictureLocking;
	
	    function WriteCT_GroupLocking(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.noGrp === true) {
	                writer.writeAttributeString("noGrp", "1");
	            }
	            if (instance.noUngrp === true) {
	                writer.writeAttributeString("noUngrp", "1");
	            }
	            if (instance.noSelect === true) {
	                writer.writeAttributeString("noSelect", "1");
	            }
	            if (instance.noRot === true) {
	                writer.writeAttributeString("noRot", "1");
	            }
	            if (instance.noChangeAspect === true) {
	                writer.writeAttributeString("noChangeAspect", "1");
	            }
	            if (instance.noMove === true) {
	                writer.writeAttributeString("noMove", "1");
	            }
	            if (instance.noResize === true) {
	                writer.writeAttributeString("noResize", "1");
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GroupLocking = WriteCT_GroupLocking;
	
	    function WriteCT_GraphicalObjectFrameLocking(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.noGrp === true) {
	                writer.writeAttributeString("noGrp", "1");
	            }
	            if (instance.noDrilldown === true) {
	                writer.writeAttributeString("noDrilldown", "1");
	            }
	            if (instance.noSelect === true) {
	                writer.writeAttributeString("noSelect", "1");
	            }
	            if (instance.noChangeAspect === true) {
	                writer.writeAttributeString("noChangeAspect", "1");
	            }
	            if (instance.noMove === true) {
	                writer.writeAttributeString("noMove", "1");
	            }
	            if (instance.noResize === true) {
	                writer.writeAttributeString("noResize", "1");
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectFrameLocking = WriteCT_GraphicalObjectFrameLocking;
	
	    function WriteCT_NonVisualDrawingProps(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var descr = instance.descr, title = instance.title;
	            if (!isNullOrUndefined(instance.id)) {
	                writer.writeAttributeString("id", instance.id);
	            }
	            if (!isNullOrUndefined(instance.name)) {
	                writer.writeAttributeString(CONST_NAME, xmlEncode(instance.name));
	            }
	            if (!isNullOrUndefinedOrEmpty(descr)) {
	                writer.writeAttributeString("descr", descr);
	            }
	            if (!isNullOrUndefinedOrEmpty(title)) {
	                writer.writeAttributeString(CONST_TITLE, title);
	            }
	            if (instance.hidden === true) {
	                writer.writeAttributeString("hidden", "1");
	            }
	        }, function () {
	           
	            var hlinkClick = instance.hlinkClick, hlinkHover = instance.hlinkHover, extLst = instance.extLst;
	            if (!isNullOrUndefined(hlinkClick)) {
	                WriteCT_Hyperlink(writer, CONST_A, "hlinkClick", hlinkClick);
	            }
	            if (!isNullOrUndefined(hlinkHover)) {
	                WriteCT_Hyperlink(writer, CONST_A, "hlinkHover", hlinkHover);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NonVisualDrawingProps = WriteCT_NonVisualDrawingProps;
	
	    function WriteCT_NonVisualDrawingShapeProps(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.txBox === true) {
	                writer.writeAttributeString("txBox", "1");
	            }
	        }, function () {
	           
	            var spLocks = instance.spLocks, extLst = instance.extLst;
	            if (!isNullOrUndefined(spLocks)) {
	                WriteCT_ShapeLocking(writer, CONST_A, "spLocks", spLocks);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NonVisualDrawingShapeProps = WriteCT_NonVisualDrawingShapeProps;
	
	    function WriteCT_NonVisualConnectorProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cxnSpLocks = instance.cxnSpLocks, stCxn = instance.stCxn,
	                endCxn = instance.endCxn, extLst = instance.extLst;
	            if (!isNullOrUndefined(cxnSpLocks)) {
	                WriteCT_ConnectorLocking(writer, CONST_A, "cxnSpLocks", cxnSpLocks);
	            }
	            if (!isNullOrUndefined(stCxn)) {
	                WriteCT_Connection(writer, CONST_A, "stCxn", stCxn);
	            }
	            if (!isNullOrUndefined(endCxn)) {
	                WriteCT_Connection(writer, CONST_A, "endCxn", endCxn);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NonVisualConnectorProperties = WriteCT_NonVisualConnectorProperties;
	
	    function WriteCT_NonVisualPictureProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.preferRelativeResize === false) {
	                writer.writeAttributeString("preferRelativeResize", "0");
	            }
	        }, function () {
	           
	            var picLocks = instance.picLocks, extLst = instance.extLst;
	            if (!isNullOrUndefined(picLocks)) {
	                WriteCT_PictureLocking(writer, CONST_A, "picLocks", picLocks);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NonVisualPictureProperties = WriteCT_NonVisualPictureProperties;
	
	    function WriteCT_NonVisualGroupDrawingShapeProps(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var grpSpLocks = instance.grpSpLocks, extLst = instance.extLst;
	            if (!isNullOrUndefined(grpSpLocks)) {
	                WriteCT_GroupLocking(writer, CONST_A, "grpSpLocks", grpSpLocks);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_NonVisualGroupDrawingShapeProps = WriteCT_NonVisualGroupDrawingShapeProps;
	
	    function WriteCT_NonVisualGraphicFrameProperties(writer, prefix, localName) {
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        writer.writeLeafElement(prefix + ":" + localName);
	    }
	
	    DrawingWriter.WriteCT_NonVisualGraphicFrameProperties = WriteCT_NonVisualGraphicFrameProperties;
	
	    function WriteCT_GraphicalObjectDataContent(writer, prefix, localName, instance) {
	        writer.writeLeafElement("c:" + localName, function () {
	            if (instance.typeName === 'chartSpace') {
	                writer.writeAttributeString("xmlns:c", DrawingWriter.c);
	            }
	            writer.writeAttributeString("xmlns:r", DrawingWriter.r);
	           
	            if (!isNullOrUndefined(instance.id)) {
	                writer.writeAttributeString("r:id", instance.id);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectDataContent = WriteCT_GraphicalObjectDataContent;
	
	    function WriteCT_GraphicalObjectData(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	           
	            writer.writeAttributeString("uri", "http://schemas.openxmlformats.org/drawingml/2006/chart");
	           
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.chart)) {
	                WriteCT_GraphicalObjectDataContent(writer, CONST_C, "chart", instance.chart);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectData = WriteCT_GraphicalObjectData;
	
	    function WriteCT_GraphicalObject(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var graphicData = instance.graphicData;
	            if (!isNullOrUndefined(graphicData)) {
	                WriteCT_GraphicalObjectData(writer, CONST_A, "graphicData", graphicData);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicalObject = WriteCT_GraphicalObject;
	
	    function WriteCT_Camera(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.prst)) {
	                writer.writeAttributeString(CONST_PRST, Charts.ST_PresetCameraType[ChartHelper.ToST_PresetCameraType(instance.prst)]);
	            }
	            if (!isNullOrUndefined(instance.fov) && instance.fov !== 0) {
	                writer.writeAttributeString("fov", instance.fov);
	            }
	            if (!isNullOrUndefined(instance.zoom) && instance.zoom !== 100000) {
	                writer.writeAttributeString("zoom", instance.zoom);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.rot)) {
	                WriteCT_SphereCoords(writer, CONST_A, "rot", instance.rot);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Camera = WriteCT_Camera;
	
	    function WriteCT_LightRig(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.rig)) {
	               
	                writer.writeAttributeString("rig", Charts.ST_LightRigType[instance.rig]);
	            }
	            if (!isNullOrUndefined(instance.dir)) {
	                writer.writeAttributeString("dir", Charts.ST_LightRigDirection[ChartHelper.ToST_LightRigDirection(instance.dir)]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.rot)) {
	                WriteCT_SphereCoords(writer, CONST_A, "rot", instance.rot);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LightRig = WriteCT_LightRig;
	
	    function WriteCT_Scene3D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var camera = instance.camera, lightRig = instance.lightRig,
	                backdrop = instance.backdrop, extLst = instance.extLst;
	            if (!isNullOrUndefined(camera)) {
	                WriteCT_Camera(writer, CONST_A, "camera", camera);
	            }
	            if (!isNullOrUndefined(lightRig)) {
	                WriteCT_LightRig(writer, CONST_A, "lightRig", lightRig);
	            }
	            if (!isNullOrUndefined(backdrop)) {
	                WriteCT_Backdrop(writer, CONST_A, "backdrop", backdrop);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Scene3D = WriteCT_Scene3D;
	
	    function WriteCT_Backdrop(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var anchor = instance.anchor, norm = instance.norm, up = instance.up, extLst = instance.extLst;
	            if (!isNullOrUndefined(anchor)) {
	                WriteCT_Point3D(writer, CONST_A, "anchor", anchor);
	            }
	            if (!isNullOrUndefined(norm)) {
	                WriteCT_Vector3D(writer, CONST_A, "norm", norm);
	            }
	            if (!isNullOrUndefined(up)) {
	                WriteCT_Vector3D(writer, CONST_A, "up", up);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Backdrop = WriteCT_Backdrop;
	
	    function WriteCT_Bevel(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.w) && instance.w !== 76200) {
	                writer.writeAttributeString("w", instance.w);
	            }
	            if (!isNullOrUndefined(instance.h) && instance.h !== 76200) {
	                writer.writeAttributeString("h", instance.h);
	            }
	            if (!isNullOrUndefined(instance.prst) && instance.prst !== 1 ) {
	                writer.writeAttributeString(CONST_PRST, Charts.ST_BevelPresetType[instance.prst]);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Bevel = WriteCT_Bevel;
	
	    function WriteCT_Shape3D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var z = instance.z, extrusionH = instance.extrusionH, contourW = instance.contourW,
	                prstMaterial = instance.prstMaterial;
	            if (!isNullOrUndefined(z) && z !== 0) {
	                writer.writeAttributeString("z", pixelToEMU(z));
	            }
	            if (!isNullOrUndefined(extrusionH) && extrusionH !== 0) {
	                writer.writeAttributeString("extrusionH", pixelToEMU(extrusionH));
	            }
	            if (!isNullOrUndefined(contourW) && contourW !== 0) {
	                writer.writeAttributeString("contourW", pixelToEMU(contourW));
	            }
	            if (!isNullOrUndefined(prstMaterial) && prstMaterial !== 7 ) {
	                writer.writeAttributeString("prstMaterial", Charts.ST_PresetMaterialType[prstMaterial]);
	            }
	        }, function () {
	           
	            var bevelT = instance.bevelT, bevelB = instance.bevelB, extrusionClr = instance.extrusionClr,
	                contourClr = instance.contourClr, extLst = instance.extLst;
	            if (!isNullOrUndefined(bevelT)) {
	                WriteCT_Bevel(writer, CONST_A, "bevelT", bevelT);
	            }
	            if (!isNullOrUndefined(bevelB)) {
	                WriteCT_Bevel(writer, CONST_A, "bevelB", bevelB);
	            }
	            if (!isNullOrUndefined(extrusionClr)) {
	                WriteCT_Color(writer, CONST_A, "extrusionClr", extrusionClr);
	            }
	            if (!isNullOrUndefined(contourClr)) {
	                WriteCT_Color(writer, CONST_A, "contourClr", contourClr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Shape3D = WriteCT_Shape3D;
	
	    function WriteCT_FlatText(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.z, "z", 0);
	    }
	
	    DrawingWriter.WriteCT_FlatText = WriteCT_FlatText;
	
	    function WriteCT_AlphaBiLevelEffect(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.thresh, "thresh");
	    }
	
	    DrawingWriter.WriteCT_AlphaBiLevelEffect = WriteCT_AlphaBiLevelEffect;
	
	    function WriteCT_AlphaCeilingEffect(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_AlphaCeilingEffect = WriteCT_AlphaCeilingEffect;
	
	    function WriteCT_AlphaFloorEffect(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_AlphaFloorEffect = WriteCT_AlphaFloorEffect;
	
	    function WriteCT_AlphaInverseEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_AlphaInverseEffect = WriteCT_AlphaInverseEffect;
	
	    function WriteCT_AlphaModulateFixedEffect(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.amt, "amt", 100000);
	    }
	
	    DrawingWriter.WriteCT_AlphaModulateFixedEffect = WriteCT_AlphaModulateFixedEffect;
	
	    function WriteCT_AlphaOutsetEffect(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.rad, "rad", 0);
	    }
	
	    DrawingWriter.WriteCT_AlphaOutsetEffect = WriteCT_AlphaOutsetEffect;
	
	    function WriteCT_AlphaReplaceEffect(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance[CONST_A], CONST_A);
	    }
	
	    DrawingWriter.WriteCT_AlphaReplaceEffect = WriteCT_AlphaReplaceEffect;
	
	    function WriteCT_BiLevelEffect(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.thresh, "thresh");
	    }
	
	    DrawingWriter.WriteCT_BiLevelEffect = WriteCT_BiLevelEffect;
	
	    function WriteCT_BlurEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.rad) && instance.rad !== 0) {
	                writer.writeAttributeString("rad", instance.rad);
	            }
	            if (instance.grow === false) {
	                writer.writeAttributeString("grow", "0");
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BlurEffect = WriteCT_BlurEffect;
	
	    function WriteCT_ColorChangeEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (instance.useA === false) {
	                writer.writeAttributeString("useA", "0");
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.clrFrom)) {
	                WriteCT_Color(writer, CONST_A, "clrFrom", instance.clrFrom);
	            }
	            if (!isNullOrUndefined(instance.clrTo)) {
	                WriteCT_Color(writer, CONST_A, "clrTo", instance.clrTo);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorChangeEffect = WriteCT_ColorChangeEffect;
	
	    function WriteCT_ColorReplaceEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorReplaceEffect = WriteCT_ColorReplaceEffect;
	
	    function WriteCT_DuotoneEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var scrgbClr = instance.scrgbClr, hslClr = instance.hslClr, sysClr = instance.sysClr,
	                schemeClr = instance.schemeClr, prstClr = instance.prstClr, srgbClr = instance.srgbClr;
	            if (!isNullOrUndefined(scrgbClr)) {
	                WriteCT_ScRgbColor(writer, CONST_A, CONST_SCRGBCLR, scrgbClr);
	            }
	            if (!isNullOrUndefined(hslClr)) {
	                WriteCT_HslColor(writer, CONST_A, CONST_HSLCLR, hslClr);
	            }
	            if (!isNullOrUndefined(sysClr)) {
	                WriteCT_SystemColor(writer, CONST_A, CONST_SYSCLR, sysClr);
	            }
	            if (!isNullOrUndefined(schemeClr)) {
	                WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClr);
	            }
	            if (!isNullOrUndefined(prstClr)) {
	                WriteCT_PresetColor(writer, CONST_A, CONST_PRSTCLR, prstClr);
	            }
	            if (!isNullOrUndefined(srgbClr)) {
	                WriteCT_SRgbColor(writer, CONST_A, CONST_SRGBCLR, srgbClr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DuotoneEffect = WriteCT_DuotoneEffect;
	
	    function WriteCT_GlowEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.rad) && instance.rad !== 0) {
	                writer.writeAttributeString("rad", instance.rad);
	            }
	        }, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_GlowEffect = WriteCT_GlowEffect;
	
	    function WriteCT_GrayscaleEffect(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_GrayscaleEffect = WriteCT_GrayscaleEffect;
	
	    function WriteCT_HSLEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var hue = instance.hue, sat = instance.sat, lum = instance.lum;
	            if (!isNullOrUndefined(hue) && hue !== 0) {
	                writer.writeAttributeString("hue", hue);
	            }
	            if (!isNullOrUndefined(sat) && sat !== 0) {
	                writer.writeAttributeString("sat", sat);
	            }
	            if (!isNullOrUndefined(lum) && lum !== 0) {
	                writer.writeAttributeString("lum", lum);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_HSLEffect = WriteCT_HSLEffect;
	
	    function WriteCT_InnerShadowEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var blurRad = instance.blurRad, dist = instance.dist, dir = instance.dir;
	            if (!isNullOrUndefined(blurRad) && blurRad !== 0) {
	                writer.writeAttributeString("blurRad", blurRad);
	            }
	            if (!isNullOrUndefined(dist) && dist !== 0) {
	                writer.writeAttributeString("dist", dist);
	            }
	            if (!isNullOrUndefined(dir) && dir !== 0) {
	                writer.writeAttributeString("dir", dir);
	            }
	        }, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_InnerShadowEffect = WriteCT_InnerShadowEffect;
	
	    function WriteCT_LuminanceEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var bright = instance.bright, contrast = instance.contrast;
	            if (!isNullOrUndefined(bright) && bright !== 0) {
	                writer.writeAttributeString("bright", bright);
	            }
	            if (!isNullOrUndefined(contrast) && contrast !== 0) {
	                writer.writeAttributeString("contrast", contrast);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LuminanceEffect = WriteCT_LuminanceEffect;
	
	    function WriteCT_OuterShadowEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var blurRad = instance.blurRad, dist = instance.dist, dir = instance.dir;
	            if (!isNullOrUndefined(blurRad) && blurRad !== 0) {
	                writer.writeAttributeString("blurRad", blurRad);
	            }
	            if (!isNullOrUndefined(dist) && dist !== 0) {
	                writer.writeAttributeString("dist", dist);
	            }
	            if (!isNullOrUndefined(dir) && dir !== 0) {
	                writer.writeAttributeString("dir", dir);
	            }
	            writeEffectElementAttribute(writer, instance);
	        }, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_OuterShadowEffect = WriteCT_OuterShadowEffect;
	
	    function WriteCT_PresetShadowEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.prst)) {
	                writer.writeAttributeString(CONST_PRST, Charts.ST_PresetShadowVal[ChartHelper.ToST_PresetShadowVal(instance.prst)]);
	            }
	            var dist = instance.dist, dir = instance.dir;
	            if (!isNullOrUndefined(dist) && dist !== 0) {
	                writer.writeAttributeString("dist", dist);
	            }
	            if (!isNullOrUndefined(dir) && dir !== 0) {
	                writer.writeAttributeString("dir", dir);
	            }
	        }, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_PresetShadowEffect = WriteCT_PresetShadowEffect;
	
	    function WriteCT_ReflectionEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var blurRad = instance.blurRad, stA = instance.stA, stPos = instance.stPos,
	                endA = instance.endA, endPos = instance.endPos, dist = instance.dist,
	                dir = instance.dir, fadeDir = instance.fadeDir;
	            if (!isNullOrUndefined(blurRad) && blurRad !== 0) {
	                writer.writeAttributeString("blurRad", blurRad);
	            }
	            if (!isNullOrUndefined(stA) && stA !== 100000) {
	                writer.writeAttributeString("stA", stA);
	            }
	            if (!isNullOrUndefined(stPos) && stPos !== 0) {
	                writer.writeAttributeString("stPos", stPos);
	            }
	            if (!isNullOrUndefined(endA) && endA !== 0) {
	                writer.writeAttributeString("endA", endA);
	            }
	            if (!isNullOrUndefined(endPos) && endPos !== 100000) {
	                writer.writeAttributeString("endPos", endPos);
	            }
	            if (!isNullOrUndefined(dist) && dist !== 0) {
	                writer.writeAttributeString("dist", dist);
	            }
	            if (!isNullOrUndefined(dir) && dir !== 0) {
	                writer.writeAttributeString("dir", dir);
	            }
	            if (!isNullOrUndefined(fadeDir) && fadeDir !== 5400000) {
	                writer.writeAttributeString("fadeDir", fadeDir);
	            }
	            writeEffectElementAttribute(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_ReflectionEffect = WriteCT_ReflectionEffect;
	
	    function WriteCT_RelativeOffsetEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.tx) && instance.tx !== 0) {
	                writer.writeAttributeString("tx", instance.tx);
	            }
	            if (!isNullOrUndefined(instance.ty) && instance.ty !== 0) {
	                writer.writeAttributeString("ty", instance.ty);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_RelativeOffsetEffect = WriteCT_RelativeOffsetEffect;
	
	    function WriteCT_SoftEdgesEffect(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.rad, "rad");
	    }
	
	    DrawingWriter.WriteCT_SoftEdgesEffect = WriteCT_SoftEdgesEffect;
	
	    function WriteCT_TintEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.hue) && instance.hue !== 0) {
	                writer.writeAttributeString("hue", instance.hue);
	            }
	            if (!isNullOrUndefined(instance.amt) && instance.amt !== 0) {
	                writer.writeAttributeString("amt", instance.amt);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TintEffect = WriteCT_TintEffect;
	
	    function WriteCT_TransformEffect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.sx) && instance.sx !== 100000) {
	                writer.writeAttributeString("sx", instance.sx);
	            }
	            if (!isNullOrUndefined(instance.sy) && instance.sy !== 100000) {
	                writer.writeAttributeString("sy", instance.sy);
	            }
	            if (!isNullOrUndefined(instance.kx) && instance.kx !== 0) {
	                writer.writeAttributeString("kx", instance.kx);
	            }
	            if (!isNullOrUndefined(instance.ky) && instance.ky !== 0) {
	                writer.writeAttributeString("ky", instance.ky);
	            }
	            if (!isNullOrUndefined(instance.tx) && instance.tx !== 0) {
	                writer.writeAttributeString("tx", instance.tx);
	            }
	            if (!isNullOrUndefined(instance.ty) && instance.ty !== 0) {
	                writer.writeAttributeString("ty", instance.ty);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TransformEffect = WriteCT_TransformEffect;
	
	    function WriteCT_NoFillProperties(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_NoFillProperties = WriteCT_NoFillProperties;
	
	    function WriteCT_SolidColorFillProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_SolidColorFillProperties = WriteCT_SolidColorFillProperties;
	
	    function WriteCT_LinearShadeProperties(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.ang)) {
	                writer.writeAttributeString("ang", instance.ang);
	            }
	            if (!isNullOrUndefined(instance.scaled)) {
	                writer.writeAttributeString("scaled", instance.scaled ? "1" : "0");
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LinearShadeProperties = WriteCT_LinearShadeProperties;
	
	    function WriteCT_PathShadeProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.path)) {
	                writer.writeAttributeString("path", Charts.ST_PathShadeType[instance.path]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.fillToRect)) {
	                WriteCT_RelativeRect(writer, CONST_A, "fillToRect", instance.fillToRect);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PathShadeProperties = WriteCT_PathShadeProperties;
	
	    function WriteCT_GradientStop(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.pos)) {
	                writer.writeAttributeString("pos", instance.pos.toFixed(0));
	            }
	        }, function () {
	           
	            writeSubColorElements(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_GradientStop = WriteCT_GradientStop;
	
	    function WriteCT_GradientStopList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.gs, function (gsItem) {
	                WriteCT_GradientStop(writer, CONST_A, "gs", gsItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_GradientStopList = WriteCT_GradientStopList;
	
	    function WriteCT_GradientFillProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.flip)) {
	                writer.writeAttributeString("flip", Charts.ST_TileFlipMode[instance.flip]);
	            }
	           
	           
	           
	            if (instance.rotWithShape === false) {
	                writer.writeAttributeString(CONST_TOT_WITH_SHAPE, "0");
	            }
	        }, function () {
	           
	            var gsLst = instance.gsLst, lin = instance.lin, path = instance.path, tileRect = instance.tileRect;
	            if (!isNullOrUndefined(gsLst)) {
	                WriteCT_GradientStopList(writer, CONST_A, "gsLst", gsLst);
	            }
	            if (!isNullOrUndefined(lin)) {
	                WriteCT_LinearShadeProperties(writer, CONST_A, "lin", lin);
	            }
	            if (!isNullOrUndefined(path)) {
	                WriteCT_PathShadeProperties(writer, CONST_A, "path", path);
	            }
	            if (!isNullOrUndefined(tileRect)) {
	                WriteCT_RelativeRect(writer, CONST_A, "tileRect", tileRect);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GradientFillProperties = WriteCT_GradientFillProperties;
	
	    function WriteCT_TileInfoProperties(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.tx)) {
	                writer.writeAttributeString("tx", pixelToEMU(instance.tx));
	            }
	            if (!isNullOrUndefined(instance.ty)) {
	                writer.writeAttributeString("ty", pixelToEMU(instance.ty));
	            }
	            if (!isNullOrUndefined(instance.sx)) {
	                writer.writeAttributeString("sx", instance.sx);
	            }
	            if (!isNullOrUndefined(instance.sy)) {
	                writer.writeAttributeString("sy", instance.sy);
	            }
	            if (!isNullOrUndefined(instance.flip)) {
	                writer.writeAttributeString("flip", Charts.ST_TileFlipMode[instance.flip]);
	            }
	            if (!isNullOrUndefined(instance.algn)) {
	               
	                writer.writeAttributeString("algn", Charts.ST_RectAlignment[instance.algn]);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TileInfoProperties = WriteCT_TileInfoProperties;
	
	    function WriteCT_StretchInfoProperties(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_RelativeRect, CONST_A, "fillRect");
	    }
	
	    DrawingWriter.WriteCT_StretchInfoProperties = WriteCT_StretchInfoProperties;
	
	    function WriteCT_Blip(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	            writer.writeAttributeString("xmlns:r", DrawingWriter.r);
	           
	            if (!isNullOrUndefined(instance.embed) && instance.embed !== "") {
	                writer.writeAttributeString("r:embed", instance.embed);
	            }
	            var link = instance.link, cstate = instance.cstate;
	            if (!isNullOrUndefinedOrEmpty(link)) {
	                writer.writeAttributeString("link", link);
	            }
	            if (!isNullOrUndefined(cstate) && cstate !== 4 ) {
	                writer.writeAttributeString("cstate", Charts.ST_BlipCompression[cstate]);
	            }
	        }, function () {
	           
	            var alphaBiLevel = instance.alphaBiLevel, alphaCeiling = instance.alphaCeiling,
	                alphaFloor = instance.alphaFloor, alphaInv = instance.alphaInv,
	                alphaMod = instance.alphaMod, alphaModFix = instance.alphaModFix,
	                alphaRepl = instance.alphaRepl, biLevel = instance.biLevel, blur = instance.blur,
	                clrChange = instance.clrChange, clrRepl = instance.clrRepl, duotone = instance.duotone,
	                fillOverlay = instance.fillOverlay, grayscl = instance.grayscl,
	                hsl = instance.hsl, lum = instance.lum, tint = instance.tint,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(alphaBiLevel)) {
	                WriteCT_AlphaBiLevelEffect(writer, CONST_A, "alphaBiLevel", alphaBiLevel);
	            }
	            if (!isNullOrUndefined(alphaCeiling)) {
	                WriteCT_AlphaCeilingEffect(writer, CONST_A, "alphaCeiling");
	            }
	            if (!isNullOrUndefined(alphaFloor)) {
	                WriteCT_AlphaFloorEffect(writer, CONST_A, "alphaFloor");
	            }
	            if (!isNullOrUndefined(alphaInv)) {
	                WriteCT_AlphaInverseEffect(writer, CONST_A, "alphaInv", alphaInv);
	            }
	            if (!isNullOrUndefined(alphaMod)) {
	                WriteCT_AlphaModulateEffect(writer, CONST_A, "alphaMod", alphaMod);
	            }
	            if (!isNullOrUndefined(alphaModFix)) {
	                WriteCT_AlphaModulateFixedEffect(writer, CONST_A, "alphaModFix", alphaModFix);
	            }
	            if (!isNullOrUndefined(alphaRepl)) {
	                WriteCT_AlphaReplaceEffect(writer, CONST_A, "alphaRepl", alphaRepl);
	            }
	            if (!isNullOrUndefined(biLevel)) {
	                WriteCT_BiLevelEffect(writer, CONST_A, "biLevel", biLevel);
	            }
	            if (!isNullOrUndefined(blur)) {
	                WriteCT_BlurEffect(writer, CONST_A, "blur", blur);
	            }
	            if (!isNullOrUndefined(clrChange)) {
	                WriteCT_ColorChangeEffect(writer, CONST_A, "clrChange", clrChange);
	            }
	            if (!isNullOrUndefined(clrRepl)) {
	                WriteCT_ColorReplaceEffect(writer, CONST_A, "clrRepl", clrRepl);
	            }
	            if (!isNullOrUndefined(duotone)) {
	                WriteCT_DuotoneEffect(writer, CONST_A, "duotone", duotone);
	            }
	            if (!isNullOrUndefined(fillOverlay)) {
	                WriteCT_FillOverlayEffect(writer, CONST_A, "fillOverlay", fillOverlay);
	            }
	            if (!isNullOrUndefined(grayscl)) {
	                WriteCT_GrayscaleEffect(writer, CONST_A, "grayscl");
	            }
	            if (!isNullOrUndefined(hsl)) {
	                WriteCT_HSLEffect(writer, CONST_A, "hsl", hsl);
	            }
	            if (!isNullOrUndefined(lum)) {
	                WriteCT_LuminanceEffect(writer, CONST_A, "lum", lum);
	            }
	            if (!isNullOrUndefined(tint)) {
	                WriteCT_TintEffect(writer, CONST_A, "tint", tint);
	            }
	            if (!isNullOrUndefined(instance.blipBlob)) {
	               
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Blip = WriteCT_Blip;
	
	    function WriteCT_BlipBlob(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.type) && instance.type !== 0 ) {
	                writer.writeAttributeString(CONST_TYPE, Charts.ST_BobType[instance.type]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.blob)) {
	                writer.writeElementString("a:blob", instance.blob);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BlipBlob = WriteCT_BlipBlob;
	
	    function WriteCT_BlipFillProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.dpi)) {
	                writer.writeAttributeString("dpi", instance.dpi);
	            }
	            if (!isNullOrUndefined(instance.rotWithShape)) {
	                writer.writeAttributeString(CONST_TOT_WITH_SHAPE, instance.rotWithShape ? "1" : "0");
	            }
	        }, function () {
	           
	            var blip = instance.blip, srcRect = instance.srcRect, tile = instance.tile, stretch = instance.stretch;
	            if (!isNullOrUndefined(blip)) {
	                WriteCT_Blip(writer, CONST_A, "blip", blip);
	            }
	            if (!isNullOrUndefined(srcRect)) {
	                WriteCT_RelativeRect(writer, CONST_A, "srcRect", srcRect);
	            }
	            if (!isNullOrUndefined(tile)) {
	                WriteCT_TileInfoProperties(writer, CONST_A, "tile", tile);
	            }
	            if (!isNullOrUndefined(stretch)) {
	                WriteCT_StretchInfoProperties(writer, CONST_A, "stretch", stretch);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BlipFillProperties = WriteCT_BlipFillProperties;
	
	    function WriteCT_PatternFillProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.prst)) {
	                writer.writeAttributeString(CONST_PRST, Charts.ST_PresetPatternVal[ChartHelper.ToST_PresetPatternVal(instance.prst)]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.fgClr)) {
	                WriteCT_Color(writer, CONST_A, "fgClr", instance.fgClr);
	            }
	            if (!isNullOrUndefined(instance.bgClr)) {
	                WriteCT_Color(writer, CONST_A, "bgClr", instance.bgClr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PatternFillProperties = WriteCT_PatternFillProperties;
	
	    function WriteCT_GroupFillProperties(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_GroupFillProperties = WriteCT_GroupFillProperties;
	
	    function WriteCT_FillProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeFillProperties(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_FillProperties = WriteCT_FillProperties;
	
	    function WriteCT_FillEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeFillProperties(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_FillEffect = WriteCT_FillEffect;
	
	    function WriteCT_FillOverlayEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.blend)) {
	                writer.writeAttributeString("blend", Charts.ST_BlendMode[instance.blend]);
	            }
	        }, function () {
	           
	            writeFillProperties(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_FillOverlayEffect = WriteCT_FillOverlayEffect;
	
	    function WriteCT_EffectReference(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.ref, "ref");
	    }
	
	    DrawingWriter.WriteCT_EffectReference = WriteCT_EffectReference;
	
	    function WriteCT_EffectContainer(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var type = instance.type, name = instance.name;
	            if (!isNullOrUndefined(type) && type !== 0 ) {
	                writer.writeAttributeString(CONST_TYPE, Charts.ST_EffectContainerType[type]);
	            }
	            if (!isNullOrUndefined(name)) {
	                writer.writeAttributeString(CONST_NAME, name);
	            }
	        }, function () {
	           
	            var cont = instance.cont, effect = instance.effect, alphaBiLevel = instance.alphaBiLevel,
	                alphaCeiling = instance.alphaCeiling, alphaFloor = instance.alphaFloor, alphaInv = instance.alphaInv,
	                alphaMod = instance.alphaMod, alphaModFix = instance.alphaModFix, alphaOutset = instance.alphaOutset,
	                alphaRepl = instance.alphaRepl, biLevel = instance.biLevel, blend = instance.blend,
	                blur = instance.blur, clrChange = instance.clrChange, clrRepl = instance.clrRepl,
	                duotone = instance.duotone, fill = instance.fill, fillOverlay = instance.fillOverlay,
	                glow = instance.glow, grayscl = instance.grayscl, hsl = instance.hsl,
	                innerShdw = instance.innerShdw, lum = instance.lum, outerShdw = instance.outerShdw,
	                prstShdw = instance.prstShdw, reflection = instance.reflection, relOff = instance.relOff,
	                softEdge = instance.softEdge, tint = instance.tint, xfrm = instance.xfrm;
	            if (!isNullOrUndefined(cont)) {
	                WriteCT_EffectContainer(writer, CONST_A, "cont", cont);
	            }
	            if (!isNullOrUndefined(effect)) {
	                WriteCT_EffectReference(writer, CONST_A, "effect", effect);
	            }
	            if (!isNullOrUndefined(alphaBiLevel)) {
	                WriteCT_AlphaBiLevelEffect(writer, CONST_A, "alphaBiLevel", alphaBiLevel);
	            }
	            if (!isNullOrUndefined(alphaCeiling)) {
	                WriteCT_AlphaCeilingEffect(writer, CONST_A, "alphaCeiling");
	            }
	            if (!isNullOrUndefined(alphaFloor)) {
	                WriteCT_AlphaFloorEffect(writer, CONST_A, "alphaFloor");
	            }
	            if (!isNullOrUndefined(alphaInv)) {
	                WriteCT_AlphaInverseEffect(writer, CONST_A, "alphaInv", alphaInv);
	            }
	            if (!isNullOrUndefined(alphaMod)) {
	                WriteCT_AlphaModulateEffect(writer, CONST_A, "alphaMod", alphaMod);
	            }
	            if (!isNullOrUndefined(alphaModFix)) {
	                WriteCT_AlphaModulateFixedEffect(writer, CONST_A, "alphaModFix", alphaModFix);
	            }
	            if (!isNullOrUndefined(alphaOutset)) {
	                WriteCT_AlphaOutsetEffect(writer, CONST_A, "alphaOutset", alphaOutset);
	            }
	            if (!isNullOrUndefined(alphaRepl)) {
	                WriteCT_AlphaReplaceEffect(writer, CONST_A, "alphaRepl", alphaRepl);
	            }
	            if (!isNullOrUndefined(biLevel)) {
	                WriteCT_BiLevelEffect(writer, CONST_A, "biLevel", biLevel);
	            }
	            if (!isNullOrUndefined(blend)) {
	                WriteCT_BlendEffect(writer, CONST_A, "blend", blend);
	            }
	            if (!isNullOrUndefined(blur)) {
	                WriteCT_BlurEffect(writer, CONST_A, "blur", blur);
	            }
	            if (!isNullOrUndefined(clrChange)) {
	                WriteCT_ColorChangeEffect(writer, CONST_A, "clrChange", clrChange);
	            }
	            if (!isNullOrUndefined(clrRepl)) {
	                WriteCT_ColorReplaceEffect(writer, CONST_A, "clrRepl", clrRepl);
	            }
	            if (!isNullOrUndefined(duotone)) {
	                WriteCT_DuotoneEffect(writer, CONST_A, "duotone", duotone);
	            }
	            if (!isNullOrUndefined(fill)) {
	                WriteCT_FillEffect(writer, CONST_A, "fill", fill);
	            }
	            if (!isNullOrUndefined(fillOverlay)) {
	                WriteCT_FillOverlayEffect(writer, CONST_A, "fillOverlay", fillOverlay);
	            }
	            if (!isNullOrUndefined(glow)) {
	                WriteCT_GlowEffect(writer, CONST_A, "glow", glow);
	            }
	            if (!isNullOrUndefined(grayscl)) {
	                WriteCT_GrayscaleEffect(writer, CONST_A, "grayscl");
	            }
	            if (!isNullOrUndefined(hsl)) {
	                WriteCT_HSLEffect(writer, CONST_A, "hsl", hsl);
	            }
	            if (!isNullOrUndefined(innerShdw)) {
	                WriteCT_InnerShadowEffect(writer, CONST_A, "innerShdw", innerShdw);
	            }
	            if (!isNullOrUndefined(lum)) {
	                WriteCT_LuminanceEffect(writer, CONST_A, "lum", lum);
	            }
	            if (!isNullOrUndefined(outerShdw)) {
	                WriteCT_OuterShadowEffect(writer, CONST_A, "outerShdw", outerShdw);
	            }
	            if (!isNullOrUndefined(prstShdw)) {
	                WriteCT_PresetShadowEffect(writer, CONST_A, "prstShdw", prstShdw);
	            }
	            if (!isNullOrUndefined(reflection)) {
	                WriteCT_ReflectionEffect(writer, CONST_A, "reflection", reflection);
	            }
	            if (!isNullOrUndefined(relOff)) {
	                WriteCT_RelativeOffsetEffect(writer, CONST_A, "relOff", relOff);
	            }
	            if (!isNullOrUndefined(softEdge)) {
	                WriteCT_SoftEdgesEffect(writer, CONST_A, "softEdge", softEdge);
	            }
	            if (!isNullOrUndefined(tint)) {
	                WriteCT_TintEffect(writer, CONST_A, "tint", tint);
	            }
	            if (!isNullOrUndefined(xfrm)) {
	                WriteCT_TransformEffect(writer, CONST_A, "xfrm", xfrm);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_EffectContainer = WriteCT_EffectContainer;
	
	    function WriteCT_AlphaModulateEffect(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_EffectContainer, CONST_A, "cont");
	    }
	
	    DrawingWriter.WriteCT_AlphaModulateEffect = WriteCT_AlphaModulateEffect;
	
	    function WriteCT_BlendEffect(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.blend)) {
	                writer.writeAttributeString("blend", Charts.ST_BlendMode[instance.blend]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.cont)) {
	                WriteCT_EffectContainer(writer, CONST_A, "cont", instance.cont);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BlendEffect = WriteCT_BlendEffect;
	
	    function WriteCT_EffectList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var blur = instance.blur, fillOverlay = instance.fillOverlay, glow = instance.glow,
	                innerShdw = instance.innerShdw, outerShdw = instance.outerShdw, prstShdw = instance.prstShdw,
	                reflection = instance.reflection, softEdge = instance.softEdge;
	            if (!isNullOrUndefined(blur)) {
	                WriteCT_BlurEffect(writer, CONST_A, "blur", blur);
	            }
	            if (!isNullOrUndefined(fillOverlay)) {
	                WriteCT_FillOverlayEffect(writer, CONST_A, "fillOverlay", fillOverlay);
	            }
	            if (!isNullOrUndefined(glow)) {
	                WriteCT_GlowEffect(writer, CONST_A, "glow", glow);
	            }
	            if (!isNullOrUndefined(innerShdw)) {
	                WriteCT_InnerShadowEffect(writer, CONST_A, "innerShdw", innerShdw);
	            }
	            if (!isNullOrUndefined(outerShdw)) {
	                WriteCT_OuterShadowEffect(writer, CONST_A, "outerShdw", outerShdw);
	            }
	            if (!isNullOrUndefined(prstShdw)) {
	                WriteCT_PresetShadowEffect(writer, CONST_A, "prstShdw", prstShdw);
	            }
	            if (!isNullOrUndefined(reflection)) {
	                WriteCT_ReflectionEffect(writer, CONST_A, "reflection", reflection);
	            }
	            if (!isNullOrUndefined(softEdge)) {
	                WriteCT_SoftEdgesEffect(writer, CONST_A, "softEdge", softEdge);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_EffectList = WriteCT_EffectList;
	
	    function WriteCT_EffectProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var effectLst = instance.effectLst, effectDag = instance.effectDag;
	            if (!isNullOrUndefined(effectLst)) {
	                WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
	            }
	            if (!isNullOrUndefined(effectDag)) {
	                WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_EffectProperties = WriteCT_EffectProperties;
	
	    function WriteCT_GeomGuide(writer, prefix, localName, instance) {
	        writeDoubleSubElementNode(writer, prefix, localName, instance, CONST_NAME, "fmla");
	    }
	
	    DrawingWriter.WriteCT_GeomGuide = WriteCT_GeomGuide;
	
	    function WriteCT_GeomGuideList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.gd, function (gdItem) {
	                WriteCT_GeomGuide(writer, CONST_A, "gd", gdItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_GeomGuideList = WriteCT_GeomGuideList;
	
	    function WriteCT_AdjPoint2D(writer, prefix, localName, instance) {
	        writeDoubleSubElementNode(writer, prefix, localName, instance, "x", "y");
	    }
	
	    DrawingWriter.WriteCT_AdjPoint2D = WriteCT_AdjPoint2D;
	
	    function WriteCT_GeomRect(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.l)) {
	                writer.writeAttributeString("l", instance.l);
	            }
	            if (!isNullOrUndefined(instance.t)) {
	                writer.writeAttributeString("t", instance.t);
	            }
	            if (!isNullOrUndefined(instance.r)) {
	                writer.writeAttributeString(CONST_R, instance.r);
	            }
	            if (!isNullOrUndefined(instance.b)) {
	                writer.writeAttributeString("b", instance.b);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GeomRect = WriteCT_GeomRect;
	
	    function WriteCT_XYAdjustHandle(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var gdRefX = instance.gdRefX, minX = instance.minX, maxX = instance.maxX,
	                gdRefY = instance.gdRefY, minY = instance.minY, maxY = instance.maxY;
	            if (!isNullOrUndefined(gdRefX)) {
	                writer.writeAttributeString("gdRefX", gdRefX);
	            }
	            if (!isNullOrUndefined(minX)) {
	                writer.writeAttributeString("minX", minX);
	            }
	            if (!isNullOrUndefined(maxX)) {
	                writer.writeAttributeString("maxX", maxX);
	            }
	            if (!isNullOrUndefined(gdRefY)) {
	                writer.writeAttributeString("gdRefY", gdRefY);
	            }
	            if (!isNullOrUndefined(minY)) {
	                writer.writeAttributeString("minY", minY);
	            }
	            if (!isNullOrUndefined(maxY)) {
	                writer.writeAttributeString("maxY", maxY);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.pos)) {
	                WriteCT_AdjPoint2D(writer, CONST_A, "pos", instance.pos);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_XYAdjustHandle = WriteCT_XYAdjustHandle;
	
	    function WriteCT_PolarAdjustHandle(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var gdRefR = instance.gdRefR, minR = instance.minR, maxR = instance.maxR,
	                gdRefAng = instance.gdRefAng, minAng = instance.minAng, maxAng = instance.maxAng;
	            if (!isNullOrUndefined(gdRefR)) {
	                writer.writeAttributeString("gdRefR", gdRefR);
	            }
	            if (!isNullOrUndefined(minR)) {
	                writer.writeAttributeString("minR", minR);
	            }
	            if (!isNullOrUndefined(maxR)) {
	                writer.writeAttributeString("maxR", maxR);
	            }
	            if (!isNullOrUndefined(gdRefAng)) {
	                writer.writeAttributeString("gdRefAng", gdRefAng);
	            }
	            if (!isNullOrUndefined(minAng)) {
	                writer.writeAttributeString("minAng", minAng);
	            }
	            if (!isNullOrUndefined(maxAng)) {
	                writer.writeAttributeString("maxAng", maxAng);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.pos)) {
	                WriteCT_AdjPoint2D(writer, CONST_A, "pos", instance.pos);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PolarAdjustHandle = WriteCT_PolarAdjustHandle;
	
	    function WriteCT_ConnectionSite(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.ang)) {
	                writer.writeAttributeString("ang", instance.ang);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.pos)) {
	                WriteCT_AdjPoint2D(writer, CONST_A, "pos", instance.pos);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ConnectionSite = WriteCT_ConnectionSite;
	
	    function WriteCT_AdjustHandleList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.ahXY)) {
	                WriteCT_XYAdjustHandle(writer, CONST_A, "ahXY", instance.ahXY);
	            }
	            if (!isNullOrUndefined(instance.ahPolar)) {
	                WriteCT_PolarAdjustHandle(writer, CONST_A, "ahPolar", instance.ahPolar);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_AdjustHandleList = WriteCT_AdjustHandleList;
	
	    function WriteCT_ConnectionSiteList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.cxn, function (cxnItem) {
	                WriteCT_ConnectionSite(writer, CONST_A, "cxn", cxnItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_ConnectionSiteList = WriteCT_ConnectionSiteList;
	
	    function WriteCT_Connection(writer, prefix, localName, instance) {
	        writeDoubleSubElementNode(writer, prefix, localName, instance, "id", "idx");
	    }
	
	    DrawingWriter.WriteCT_Connection = WriteCT_Connection;
	
	    function WriteCT_Path2DMoveTo(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AdjPoint2D, CONST_A, "pt");
	    }
	
	    DrawingWriter.WriteCT_Path2DMoveTo = WriteCT_Path2DMoveTo;
	
	    function WriteCT_Path2DLineTo(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AdjPoint2D, CONST_A, "pt");
	    }
	
	    DrawingWriter.WriteCT_Path2DLineTo = WriteCT_Path2DLineTo;
	
	    function WriteCT_Path2DArcTo(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var wR = instance.wR, hR = instance.hR, stAng = instance.stAng, swAng = instance.swAng;
	            if (!isNullOrUndefined(wR)) {
	                writer.writeAttributeString("wR", wR);
	            }
	            if (!isNullOrUndefined(hR)) {
	                writer.writeAttributeString("hR", hR);
	            }
	            if (!isNullOrUndefined(stAng)) {
	                writer.writeAttributeString("stAng", stAng);
	            }
	            if (!isNullOrUndefined(swAng)) {
	                writer.writeAttributeString("swAng", swAng);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Path2DArcTo = WriteCT_Path2DArcTo;
	
	    function WriteCT_Path2DQuadBezierTo(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.pt, function (ptItem) {
	                WriteCT_AdjPoint2D(writer, CONST_A, "pt", ptItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_Path2DQuadBezierTo = WriteCT_Path2DQuadBezierTo;
	
	    function WriteCT_Path2DCubicBezierTo(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.pt, function (ptItem) {
	                WriteCT_AdjPoint2D(writer, CONST_A, "pt", ptItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_Path2DCubicBezierTo = WriteCT_Path2DCubicBezierTo;
	
	    function WriteCT_Path2DClose(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_Path2DClose = WriteCT_Path2DClose;
	
	    function WriteCT_Path2D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var w = instance.w, h = instance.h, fill = instance.fill;
	            if (!isNullOrUndefined(w) && w !== 0) {
	                writer.writeAttributeString("w", w);
	            }
	            if (!isNullOrUndefined(h) && h !== 0) {
	                writer.writeAttributeString("h", h);
	            }
	            if (!isNullOrUndefined(fill) && fill !== 1 ) {
	                writer.writeAttributeString("fill", Charts.ST_PathFillMode[fill]);
	            }
	            if (instance.stroke === false) {
	                writer.writeAttributeString("stroke", "0");
	            }
	            if (instance.extrusionOk === false) {
	                writer.writeAttributeString("extrusionOk", "0");
	            }
	        }, function () {
	           
	            writeArrayItem(instance.pathToList, function (item) {
	                if (item.typeName === Charts.CT_PathType.CT_Path2DClose) {
	                    WriteCT_Path2DClose(writer, CONST_A, "close");
	                } else if (item.typeName === Charts.CT_PathType.CT_PathToList) {
	                    var pathToList = item;
	                    switch (pathToList.pathToType) {
	                        case 0 :
	                            WriteCT_AdjPoint2DList(writer, CONST_A, "lnTo", item);
	                            break;
	                        case 1 :
	                            WriteCT_AdjPoint2DList(writer, CONST_A, "moveTo", item);
	                            break;
	                        case 2 :
	                            WriteCT_AdjPoint2DList(writer, CONST_A, "quadBezTo", item);
	                            break;
	                        case 3 :
	                            WriteCT_AdjPoint2DList(writer, CONST_A, "cubicBezTo", item);
	                            break;
	                    }
	                } else if (item.typeName === Charts.CT_PathType.CT_Path2DArcTo) {
	                    WriteCT_Path2DArcTo(writer, CONST_A, "arcTo", item);
	                }
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_Path2D = WriteCT_Path2D;
	
	    function WriteCT_AdjPoint2DList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.PtList, function (item) {
	                WriteCT_AdjPoint2D(writer, CONST_A, "pt", item);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_AdjPoint2DList = WriteCT_AdjPoint2DList;
	
	    function WriteCT_Path2DList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance, function (item) {
	                WriteCT_Path2D(writer, CONST_A, "path", item);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_Path2DList = WriteCT_Path2DList;
	
	    function WriteCT_PresetGeometry2D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.prst)) {
	                writer.writeAttributeString(CONST_PRST, Charts.ST_ShapeType[ChartHelper.ToST_ShapeType(instance.prst)]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.avLst)) {
	                WriteCT_GeomGuideList(writer, CONST_A, "avLst", instance.avLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PresetGeometry2D = WriteCT_PresetGeometry2D;
	
	    function WriteCT_PresetTextShape(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.prst)) {
	                writer.writeAttributeString(CONST_PRST, Charts.ST_TextShapeType[instance.prst]);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.avLst)) {
	                WriteCT_GeomGuideList(writer, CONST_A, "avLst", instance.avLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PresetTextShape = WriteCT_PresetTextShape;
	
	    function WriteCT_CustomGeometry2D(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var avLst = instance.avLst, gdLst = instance.gdLst, ahLst = instance.ahLst,
	                cxnLst = instance.cxnLst, rect = instance.rect;
	            if (!isNullOrUndefined(avLst)) {
	                WriteCT_GeomGuideList(writer, CONST_A, "avLst", avLst);
	            }
	            if (!isNullOrUndefined(gdLst)) {
	                WriteCT_GeomGuideList(writer, CONST_A, "gdLst", gdLst);
	            }
	            if (!isNullOrUndefined(ahLst)) {
	                WriteCT_AdjustHandleList(writer, CONST_A, "ahLst", ahLst);
	            }
	            if (!isNullOrUndefined(cxnLst)) {
	                WriteCT_ConnectionSiteList(writer, CONST_A, "cxnLst", cxnLst);
	            }
	            if (!isNullOrUndefined(rect)) {
	                WriteCT_GeomRect(writer, CONST_A, "rect", rect);
	            }
	            WriteCT_Path2DList(writer, CONST_A, "pathLst", instance.pathLst);
	        });
	    }
	
	    DrawingWriter.WriteCT_CustomGeometry2D = WriteCT_CustomGeometry2D;
	
	    function WriteCT_LineEndProperties(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.type)) {
	               
	                writer.writeAttributeString(CONST_TYPE, Charts.ST_LineEndType[instance.type]);
	            }
	            if (!isNullOrUndefined(instance.w)) {
	               
	                writer.writeAttributeString("w", Charts.ST_LineEndWidth[instance.w]);
	            }
	            if (!isNullOrUndefined(instance.len)) {
	                writer.writeAttributeString("len", Charts.ST_LineEndLength[instance.len]);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LineEndProperties = WriteCT_LineEndProperties;
	
	    function WriteCT_LineJoinBevel(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_LineJoinBevel = WriteCT_LineJoinBevel;
	
	    function WriteCT_LineJoinRound(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_LineJoinRound = WriteCT_LineJoinRound;
	
	    function WriteCT_LineJoinMiterProperties(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance.lim, "lim");
	    }
	
	    DrawingWriter.WriteCT_LineJoinMiterProperties = WriteCT_LineJoinMiterProperties;
	
	    function WriteCT_PresetLineDashProperties(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, Charts.ST_PresetLineDashVal, ChartHelper.ToST_PresetLineDashVal);
	    }
	
	    DrawingWriter.WriteCT_PresetLineDashProperties = WriteCT_PresetLineDashProperties;
	
	    function WriteCT_DashStop(writer, prefix, localName, instance) {
	        writeDoubleSubElementNode(writer, prefix, localName, instance, "d", "sp");
	    }
	
	    DrawingWriter.WriteCT_DashStop = WriteCT_DashStop;
	
	    function WriteCT_DashStopList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.ds, function (dsItem) {
	                WriteCT_DashStop(writer, CONST_A, "ds", dsItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_DashStopList = WriteCT_DashStopList;
	
	    function WriteCT_LineProperties(writer, prefix, localName, instance) {
	       
	       
	        if (instance.w <= 0) {
	            instance.noFill = true;
	        }
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.w) && instance.w >= 0) {
	                writer.writeAttributeString("w", pixelToEMU(instance.w));
	            }
	            if (!isNullOrUndefined(instance.cap) ) {
	                writer.writeAttributeString("cap", Charts.ST_LineCap[instance.cap]);
	            }
	           
	            if (!isNullOrUndefined(instance.cmpd) && instance.cmpd !== 0 ) {
	                writer.writeAttributeString("cmpd", Charts.ST_CompoundLine[instance.cmpd]);
	            }
	            if (!isNullOrUndefined(instance.algn) && instance.algn !== 0 ) {
	                writer.writeAttributeString("algn", Charts.ST_PenAlignment[instance.algn]);
	            }
	        }, function () {
	           
	            var noFill = instance.noFill, solidFill = instance.solidFill, gradFill = instance.gradFill,
	                pattFill = instance.pattFill, prstDash = instance.prstDash, custDash = instance.custDash,
	                round = instance.round, bevel = instance.bevel, miter = instance.miter, headEnd = instance.headEnd,
	                tailEnd = instance.tailEnd, extLst = instance.extLst;
	            if (!isNullOrUndefined(noFill)) {
	                WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
	            } else if (!isNullOrUndefined(solidFill)) {
	                WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFill);
	            } else if (!isNullOrUndefined(gradFill)) {
	                WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFill);
	            } else if (!isNullOrUndefined(pattFill)) {
	                WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFill);
	            }
	            if (!isNullOrUndefined(prstDash)) {
	                WriteCT_PresetLineDashProperties(writer, CONST_A, "prstDash", prstDash);
	            } else if (!isNullOrUndefined(custDash)) {
	                WriteCT_DashStopList(writer, CONST_A, "custDash", custDash);
	            }
	            if (!isNullOrUndefined(round)) {
	                WriteCT_LineJoinRound(writer, CONST_A, "round");
	            }
	            if (!isNullOrUndefined(bevel)) {
	                WriteCT_LineJoinBevel(writer, CONST_A, "bevel");
	            }
	            if (!isNullOrUndefined(miter)) {
	                WriteCT_LineJoinMiterProperties(writer, CONST_A, "miter", miter);
	            }
	            if (!isNullOrUndefined(headEnd)) {
	                WriteCT_LineEndProperties(writer, CONST_A, "headEnd", headEnd);
	            }
	            if (!isNullOrUndefined(tailEnd)) {
	                WriteCT_LineEndProperties(writer, CONST_A, "tailEnd", tailEnd);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_LineProperties = WriteCT_LineProperties;
	
	    function WriteCT_ShapeProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var bwMode = instance.bwMode;
	            if (!isNullOrUndefined(bwMode) && bwMode !== 0 ) {
	                writer.writeAttributeString("bwMode", Charts.ST_BlackWhiteMode[bwMode]);
	            }
	        }, function () {
	           
	            var xfrm = instance.xfrm, custGeom = instance.custGeom, prstGeom = instance.prstGeom,
	                noFill = instance.noFill, solidFill = instance.solidFill, gradFill = instance.gradFill,
	                blipFill = instance.blipFill, pattFill = instance.pattFill, grpFill = instance.grpFill,
	                ln = instance.ln, effectLst = instance.effectLst, effectDag = instance.effectDag,
	                scene3d = instance.scene3d, sp3d = instance.sp3d, extLst = instance.extLst;
	            WriteCT_Transform2D(writer, CONST_A, "xfrm", xfrm, true);
	            if (!isNullOrUndefined(custGeom)) {
	                WriteCT_CustomGeometry2D(writer, CONST_A, "custGeom", custGeom);
	            } else if (!isNullOrUndefined(prstGeom)) {
	                WriteCT_PresetGeometry2D(writer, CONST_A, "prstGeom", prstGeom);
	            }
	            if (!isNullOrUndefined(noFill)) {
	                WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
	            } else if (!isNullOrUndefined(solidFill)) {
	                WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFill);
	            } else if (!isNullOrUndefined(gradFill)) {
	                WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFill);
	            } else if (!isNullOrUndefined(blipFill)) {
	                WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFill);
	            } else if (!isNullOrUndefined(pattFill)) {
	                WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFill);
	            } else if (!isNullOrUndefined(grpFill)) {
	                WriteCT_GroupFillProperties(writer, CONST_A, CONST_GRP_FILL);
	            }
	            if (!isNullOrUndefined(ln)) {
	                WriteCT_LineProperties(writer, CONST_A, "ln", ln);
	            }
	            if (!isNullOrUndefined(effectLst)) {
	                WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
	            }
	            if (!isNullOrUndefined(effectDag)) {
	                WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
	            }
	            if (!isNullOrUndefined(scene3d)) {
	                WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
	            }
	            if (!isNullOrUndefined(sp3d)) {
	                WriteCT_Shape3D(writer, CONST_A, "sp3d", sp3d);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ShapeProperties = WriteCT_ShapeProperties;
	
	    function WriteCT_GroupShapeProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var bwMode = instance.bwMode;
	            if (!isNullOrUndefined(bwMode) && bwMode !== 0 ) {
	                writer.writeAttributeString("bwMode", Charts.ST_BlackWhiteMode[bwMode]);
	            }
	        }, function () {
	           
	            var xfrm = instance.xfrm, scene3d = instance.scene3d, extLst = instance.extLst,
	                effectLst = instance.effectLst, effectDag = instance.effectDag;
	            if (!isNullOrUndefined(xfrm)) {
	                WriteCT_GroupTransform2D(writer, CONST_A, "xfrm", xfrm);
	            }
	            writeFillProperties(writer, instance);
	            if (!isNullOrUndefined(effectLst)) {
	                WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
	            }
	            if (!isNullOrUndefined(effectDag)) {
	                WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
	            }
	            if (!isNullOrUndefined(scene3d)) {
	                WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GroupShapeProperties = WriteCT_GroupShapeProperties;
	
	    function WriteCT_StyleMatrixReference(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.idx)) {
	                writer.writeAttributeString("idx", instance.idx);
	            }
	        }, function () {
	           
	            writeSubColorElements(writer, instance.ColorProp);
	        });
	    }
	
	    DrawingWriter.WriteCT_StyleMatrixReference = WriteCT_StyleMatrixReference;
	
	    function WriteCT_FontReference(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.idx)) {
	                writer.writeAttributeString("idx", Charts.ST_FontCollectionIndex[instance.idx]);
	            }
	        }, function () {
	           
	            var solidFillProperties = instance.TextCharacterProperties.solidFill;
	            if (solidFillProperties) {
	                writeSubColorElements(writer, solidFillProperties);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_FontReference = WriteCT_FontReference;
	
	    function WriteCT_ShapeStyle(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var lnRef = instance.lnRef, fillRef = instance.fillRef,
	                effectRef = instance.effectRef, fontRef = instance.fontRef;
	            if (!isNullOrUndefined(lnRef)) {
	                WriteCT_StyleMatrixReference(writer, CONST_A, "lnRef", lnRef);
	            }
	            if (!isNullOrUndefined(fillRef)) {
	                WriteCT_StyleMatrixReference(writer, CONST_A, "fillRef", fillRef);
	            }
	            if (!isNullOrUndefined(effectRef)) {
	                WriteCT_StyleMatrixReference(writer, CONST_A, "effectRef", effectRef);
	            }
	            if (!isNullOrUndefined(fontRef)) {
	                WriteCT_FontReference(writer, CONST_A, "fontRef", fontRef);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ShapeStyle = WriteCT_ShapeStyle;
	
	    function WriteCT_AnchorClientData(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (instance.fLocksWithSheet === false) {
	                writer.writeAttributeString("fLocksWithSheet", "0");
	            }
	            if (instance.fPrintsWithSheet === false) {
	                writer.writeAttributeString("fPrintsWithSheet", "0");
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_AnchorClientData = WriteCT_AnchorClientData;
	
	    function WriteCT_ShapeNonVisual(writer, prefix, localName, instance) {
	        writeShapeNonVisualElement(writer, prefix, localName, instance, prefix);
	    }
	
	    DrawingWriter.WriteCT_ShapeNonVisual = WriteCT_ShapeNonVisual;
	
	    function WriteCT_ShapeNonVisualForCdr(writer, prefix, localName, instance) {
	        writeShapeNonVisualElement(writer, prefix, localName, instance, CONST_CDR);
	    }
	
	    DrawingWriter.WriteCT_ShapeNonVisualForCdr = WriteCT_ShapeNonVisualForCdr;
	
	    function WriteCT_ShapeNonVisualForXdr(writer, prefix, localName, instance) {
	        writeShapeNonVisualElement(writer, prefix, localName, instance, CONST_XDR);
	    }
	
	    DrawingWriter.WriteCT_ShapeNonVisualForXdr = WriteCT_ShapeNonVisualForXdr;
	
	    function WriteCT_Shape(writer, prefix, localName, instance) {
	        writeShapeElement(writer, prefix, localName, instance, prefix, WriteCT_ShapeNonVisual);
	    }
	
	    DrawingWriter.WriteCT_Shape = WriteCT_Shape;
	
	    function WriteCT_ShapeForCdr(writer, prefix, localName, instance) {
	        writeShapeElement(writer, prefix, localName, instance, CONST_CDR, WriteCT_ShapeNonVisualForCdr);
	    }
	
	    DrawingWriter.WriteCT_ShapeForCdr = WriteCT_ShapeForCdr;
	
	    function WriteCT_ShapeForXdr(writer, prefix, localName, instance) {
	        writeShapeElement(writer, prefix, localName, instance, CONST_XDR, WriteCT_ShapeNonVisualForXdr);
	    }
	
	    DrawingWriter.WriteCT_ShapeForXdr = WriteCT_ShapeForXdr;
	
	    function WriteCT_ConnectorNonVisual(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvCxnSpPr = instance.cNvCxnSpPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvCxnSpPr)) {
	                WriteCT_NonVisualConnectorProperties(writer, CONST_XDR, "cNvCxnSpPr", cNvCxnSpPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ConnectorNonVisual = WriteCT_ConnectorNonVisual;
	
	    function WriteCT_ConnectorNonVisualCdr(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvCxnSpPr = instance.cNvCxnSpPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_CDR, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvCxnSpPr)) {
	                WriteCT_NonVisualConnectorProperties(writer, CONST_CDR, "cNvCxnSpPr", cNvCxnSpPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ConnectorNonVisualCdr = WriteCT_ConnectorNonVisualCdr;
	
	    function WriteCT_Connector(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro;
	            if (!isNullOrUndefined(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvCxnSpPr = instance.nvCxnSpPr, spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvCxnSpPr)) {
	                WriteCT_ConnectorNonVisual(writer, CONST_XDR, "nvCxnSpPr", nvCxnSpPr);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_XDR, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Connector = WriteCT_Connector;
	
	    function WriteCT_ConnectorCdr(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro;
	            if (!isNullOrUndefined(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvCxnSpPr = instance.nvCxnSpPr, spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvCxnSpPr)) {
	                WriteCT_ConnectorNonVisual(writer, CONST_CDR, "nvCxnSpPr", nvCxnSpPr);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_CDR, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_CDR, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ConnectorCdr = WriteCT_ConnectorCdr;
	
	    function WriteCT_PictureNonVisualGroup(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvPicPr)) {
	                WriteCT_NonVisualPictureProperties(writer, CONST_XDR, CONST_CNV_PIC_PR, cNvPicPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureNonVisualGroup = WriteCT_PictureNonVisualGroup;
	
	    function WriteCT_PictureNonVisual(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_A, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvPicPr)) {
	                WriteCT_NonVisualPictureProperties(writer, CONST_A, CONST_CNV_PIC_PR, cNvPicPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureNonVisual = WriteCT_PictureNonVisual;
	
	    function WriteCT_PictureNonVisualrelSizeAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_CDR, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvPicPr)) {
	                WriteCT_NonVisualPictureProperties(writer, CONST_CDR, CONST_CNV_PIC_PR, cNvPicPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureNonVisualrelSizeAnchor = WriteCT_PictureNonVisualrelSizeAnchor;
	
	    function WriteCT_PictureNonVisualOneCellAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvPicPr)) {
	                WriteCT_NonVisualPictureProperties(writer, CONST_XDR, CONST_CNV_PIC_PR, cNvPicPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureNonVisualOneCellAnchor = WriteCT_PictureNonVisualOneCellAnchor;
	
	    function WriteCT_PictureNonVisualForXdr(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvPicPr)) {
	                WriteCT_NonVisualPictureProperties(writer, CONST_XDR, CONST_CNV_PIC_PR, cNvPicPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureNonVisualForXdr = WriteCT_PictureNonVisualForXdr;
	
	    function WriteCT_PictureGroup(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefinedOrEmpty(instance.macro)) {
	                writer.writeAttributeString(CONST_MACRO, instance.macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill,
	                spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvPicPr)) {
	                WriteCT_PictureNonVisualGroup(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
	            }
	            if (!isNullOrUndefined(blipFill)) {
	                WriteCT_BlipFillProperties(writer, CONST_XDR, CONST_BLIP_FILL, blipFill);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureGroup = WriteCT_PictureGroup;
	
	    function WriteCT_PictureRelSizeAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefinedOrEmpty(instance.macro)) {
	                writer.writeAttributeString(CONST_MACRO, instance.macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill,
	                spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvPicPr)) {
	                WriteCT_PictureNonVisualrelSizeAnchor(writer, CONST_CDR, CONST_NV_PIC_PR, nvPicPr);
	            }
	            if (!isNullOrUndefined(blipFill)) {
	                WriteCT_BlipFillProperties(writer, CONST_CDR, CONST_BLIP_FILL, blipFill);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_CDR, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_CDR, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureRelSizeAnchor = WriteCT_PictureRelSizeAnchor;
	
	    function WriteCT_Picture(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro;
	            if (!isNullOrUndefinedOrEmpty(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill,
	                spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvPicPr)) {
	                WriteCT_PictureNonVisual(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
	            }
	            if (!isNullOrUndefined(blipFill)) {
	                WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFill);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_A, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Picture = WriteCT_Picture;
	
	    function WriteCT_PictureOneCellAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro;
	            if (!isNullOrUndefinedOrEmpty(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill,
	                spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvPicPr)) {
	                WriteCT_PictureNonVisual(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
	            }
	            if (!isNullOrUndefined(blipFill)) {
	                WriteCT_BlipFillProperties(writer, CONST_XDR, CONST_BLIP_FILL, blipFill);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureOneCellAnchor = WriteCT_PictureOneCellAnchor;
	
	    function WriteCT_PictureForXdr(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var macro = instance.macro;
	            if (!isNullOrUndefinedOrEmpty(macro)) {
	                writer.writeAttributeString(CONST_MACRO, macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill,
	                spPr = instance.spPr, style = instance.style;
	            if (!isNullOrUndefined(nvPicPr)) {
	                WriteCT_PictureNonVisualForXdr(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
	            }
	            if (!isNullOrUndefined(blipFill)) {
	                WriteCT_BlipFillProperties(writer, CONST_XDR, CONST_BLIP_FILL, blipFill);
	            }
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_XDR, CONST_STYLE, style);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_PictureForXdr = WriteCT_PictureForXdr;
	
	    function WriteCT_GraphicalObjectFrameNonVisual(writer, prefix, localName, instance) {
	        writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, CONST_XDR);
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectFrameNonVisual = WriteCT_GraphicalObjectFrameNonVisual;
	
	    function WriteCT_GraphicalObjectFrameNonVisual_cdr(writer, prefix, localName, instance) {
	        writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, CONST_CDR);
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectFrameNonVisual_cdr = WriteCT_GraphicalObjectFrameNonVisual_cdr;
	
	    function WriteCT_GraphicalObjectFrame(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writer.writeAttributeString(CONST_MACRO, '');
	           
	           
	           
	        }, function () {
	           
	            var nvGraphicFramePr = instance.nvGraphicFramePr, graphic = instance.graphic;
	            if (!isNullOrUndefined(nvGraphicFramePr)) {
	                WriteCT_GraphicalObjectFrameNonVisual(writer, CONST_XDR, "nvGraphicFramePr", nvGraphicFramePr);
	            }
	            WriteCT_Transform2D(writer, CONST_XDR, "xfrm", keyword_null, true);
	            if (!isNullOrUndefined(graphic)) {
	                WriteCT_GraphicalObject(writer, CONST_A, "graphic", graphic);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectFrame = WriteCT_GraphicalObjectFrame;
	
	    function WriteCT_GraphicalObjectFrame_cdr(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.macro)) {
	                writer.writeAttributeString(CONST_MACRO, instance.macro);
	            }
	            if (instance.fPublished === true) {
	                writer.writeAttributeString(CONST_FPUBLISHED, "1");
	            }
	        }, function () {
	           
	            var nvGraphicFramePr = instance.nvGraphicFramePr, xfrm = instance.xfrm, graphic = instance.graphic;
	            if (!isNullOrUndefined(nvGraphicFramePr)) {
	                WriteCT_GraphicalObjectFrameNonVisual_cdr(writer, CONST_CDR, "nvGraphicFramePr", nvGraphicFramePr);
	            }
	            WriteCT_Transform2D(writer, CONST_CDR, "xfrm", xfrm, true);
	            if (!isNullOrUndefined(graphic)) {
	                WriteCT_GraphicalObject(writer, CONST_A, "graphic", graphic);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GraphicalObjectFrame_cdr = WriteCT_GraphicalObjectFrame_cdr;
	
	    function WriteCT_GroupShapeNonVisual(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var cNvPr = instance.cNvPr, cNvGrpSpPr = instance.cNvGrpSpPr;
	            if (!isNullOrUndefined(cNvPr)) {
	                WriteCT_NonVisualDrawingProps(writer, prefix, CONST_CNVPR, cNvPr);
	            }
	            if (!isNullOrUndefined(cNvGrpSpPr)) {
	                WriteCT_NonVisualGroupDrawingShapeProps(writer, prefix, "cNvGrpSpPr", cNvGrpSpPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_GroupShapeNonVisual = WriteCT_GroupShapeNonVisual;
	
	    function WriteCT_GroupShape(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var nvGrpSpPr = instance.nvGrpSpPr, grpSpPr = instance.grpSpPr;
	            if (!isNullOrUndefined(nvGrpSpPr)) {
	                WriteCT_GroupShapeNonVisual(writer, CONST_XDR, "nvGrpSpPr", nvGrpSpPr);
	            }
	            if (!isNullOrUndefined(grpSpPr)) {
	                WriteCT_GroupShapeProperties(writer, CONST_A, "grpSpPr", grpSpPr);
	            }
	            instance.sp.forEach(function (item) {
	                if (item.shapeType === 5) {
	                    WriteCT_Shape(writer, prefix, "sp", item);
	                } else if (item.shapeType === 3) {
	                    WriteCT_GroupShape(writer, prefix, CONST_GRPSP, item);
	                } else if (item.shapeType === 2) {
	                    WriteCT_GraphicalObjectFrame(writer, prefix, CONST_GRAPHIC_FRAME, item);
	                } else if (item.shapeType === 4) {
	                    WriteCT_Connector(writer, prefix, CONST_CXNSP, item);
	                } else if (item.shapeType === 1) {
	                    WriteCT_PictureGroup(writer, prefix, "pic", item);
	                } else if (item.shapeType === 0) {
	                    WriteCT_AlternateContent(writer, CONST_MC, CONST_ALTERNATE_CONTENT);
	                }
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_GroupShape = WriteCT_GroupShape;
	
	    function WriteCT_Position(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.col)) {
	                writer.writeElementString("xdr:col", instance.col);
	            }
	            var colOffset = instance.colOffset;
	            if (!isNullOrUndefined(colOffset)) {
	                writer.writeElementString("xdr:colOff", pixelToEMU(colOffset));
	            }
	            if (!isNullOrUndefined(instance.row)) {
	                writer.writeElementString("xdr:row", instance.row);
	            }
	            var rowOffset = instance.rowOffset;
	            if (!isNullOrUndefined(rowOffset)) {
	                writer.writeElementString("xdr:rowOff", pixelToEMU(rowOffset));
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_Position = WriteCT_Position;
	
	    function WriteCT_TwoCellAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var editAs = instance.editAs;
	            if (!isNullOrUndefined(editAs) && editAs !== 0 ) {
	                writer.writeAttributeString("editAs", Charts.ST_EditAs[editAs]);
	            }
	        }, function () {
	           
	            var from = instance.startPoint, to = instance.endPoint, AlternateContent = instance.AlternateContent,
	                sp = instance.sp, grpSp = instance.grpSp, graphicFrame = instance.graphicFrame,
	                cxnSp = instance.cxnSp, pic = instance.pic, clientData = instance.clientData;
	            if (!isNullOrUndefined(from)) {
	                WriteCT_Position(writer, CONST_XDR, "from", from);
	            }
	            if (!isNullOrUndefined(to)) {
	                WriteCT_Position(writer, CONST_XDR, "to", to);
	            }
	            if (!isNullOrUndefined(AlternateContent)) {
	                WriteCT_AlternateContent(writer, CONST_MC, CONST_ALTERNATE_CONTENT);
	            }
	            if (!isNullOrUndefined(sp)) {
	                WriteCT_ShapeForXdr(writer, CONST_XDR, "sp", sp);
	            }
	            if (!isNullOrUndefined(grpSp)) {
	                WriteCT_GroupShape(writer, CONST_XDR, CONST_GRPSP, grpSp);
	            }
	            if (!isNullOrUndefined(graphicFrame)) {
	                WriteCT_GraphicalObjectFrame(writer, CONST_XDR, CONST_GRAPHIC_FRAME, graphicFrame);
	            }
	            if (!isNullOrUndefined(cxnSp)) {
	                WriteCT_Connector(writer, CONST_XDR, CONST_CXNSP, cxnSp);
	            }
	            if (!isNullOrUndefined(pic)) {
	                WriteCT_PictureForXdr(writer, CONST_XDR, "pic", pic);
	            }
	            if (!isNullOrUndefined(clientData)) {
	                WriteCT_AnchorClientData(writer, CONST_XDR, CONST_CLIENT_DATA, clientData);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TwoCellAnchor = WriteCT_TwoCellAnchor;
	
	    function WriteCT_AlternateContent(writer, prefix, localName) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	        });
	    }
	
	    DrawingWriter.WriteCT_AlternateContent = WriteCT_AlternateContent;
	
	    function WriteCT_OneCellAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var from = instance.startPoint, pic = instance.pic;
	            if (!isNullOrUndefined(from)) {
	                WriteCT_Position(writer, CONST_XDR, "from", from);
	            }
	            if (!isNullOrUndefined(pic)) {
	                WriteCT_PictureOneCellAnchor(writer, CONST_XDR, "pic", pic);
	            }
	            writeAnchorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_OneCellAnchor = WriteCT_OneCellAnchor;
	
	    function WriteCT_AbsoluteAnchor(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var pos = instance.pos, pic = instance.pic;
	            if (!isNullOrUndefined(pos)) {
	                WriteCT_Point2D(writer, CONST_XDR, "pos", pos, true);
	            }
	            if (!isNullOrUndefined(pic)) {
	                WriteCT_Picture(writer, CONST_XDR, "pic", pic);
	            }
	            writeAnchorSubElement(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_AbsoluteAnchor = WriteCT_AbsoluteAnchor;
	
	    function WriteCT_Drawing(writer, prefix, localName, instance) {
	        writer.writeElement("xdr:" + localName, function () {
	            writer.writeAttributeString("xmlns:a", DrawingWriter.a);
	            writer.writeAttributeString("xmlns:xdr", DrawingWriter.xdr);
	        }, function () {
	           
	            instance.AnchorBaseList.forEach(function (item) {
	                if (item.anchorType === 1 ) {
	                    WriteCT_OneCellAnchor(writer, CONST_XDR, "oneCellAnchor", item);
	                } else if (item.anchorType === 0 ) {
	                    WriteCT_TwoCellAnchor(writer, CONST_XDR, "twoCellAnchor", item);
	                } else if (item.anchorType === 2 ) {
	                    WriteCT_AbsoluteAnchor(writer, CONST_XDR, "absoluteAnchor", item);
	                }
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_Drawing = WriteCT_Drawing;
	
	    function WriteCT_DefaultShapeDefinition(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var spPr = instance.spPr, bodyPr = instance.bodyPr, lstStyle = instance.lstStyle,
	                style = instance.style, extLst = instance.extLst;
	            if (!isNullOrUndefined(spPr)) {
	                WriteCT_ShapeProperties(writer, CONST_A, CONST_SPPR, spPr);
	            }
	            if (!isNullOrUndefined(bodyPr)) {
	                WriteCT_TextBodyProperties(writer, CONST_A, "bodyPr", bodyPr);
	            }
	            if (!isNullOrUndefined(lstStyle)) {
	                WriteCT_TextListStyle(writer, CONST_A, "lstStyle", lstStyle);
	            }
	            if (!isNullOrUndefined(style)) {
	                WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_DefaultShapeDefinition = WriteCT_DefaultShapeDefinition;
	
	    function WriteCT_ObjectStyleDefaults(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var spDef = instance.spDef, lnDef = instance.lnDef,
	                txDef = instance.txDef, extLst = instance.extLst;
	            if (!isNullOrUndefined(spDef)) {
	                WriteCT_DefaultShapeDefinition(writer, CONST_A, "spDef", spDef);
	            }
	            if (!isNullOrUndefined(lnDef)) {
	                WriteCT_DefaultShapeDefinition(writer, CONST_A, "lnDef", lnDef);
	            }
	            if (!isNullOrUndefined(txDef)) {
	                WriteCT_DefaultShapeDefinition(writer, CONST_A, "txDef", txDef);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ObjectStyleDefaults = WriteCT_ObjectStyleDefaults;
	
	    function WriteCT_EmptyElement(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_EmptyElement = WriteCT_EmptyElement;
	
	    function WriteCT_ColorMappingOverride(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var masterClrMapping = instance.masterClrMapping,
	                overrideClrMapping = instance.overrideClrMapping;
	            if (!isNullOrUndefined(masterClrMapping)) {
	                WriteCT_EmptyElement(writer, CONST_A, "masterClrMapping");
	            }
	            if (!isNullOrUndefined(overrideClrMapping)) {
	                WriteCT_ColorMapping(writer, CONST_A, "overrideClrMapping", overrideClrMapping);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorMappingOverride = WriteCT_ColorMappingOverride;
	
	    function WriteCT_ColorSchemeAndMapping(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var clrScheme = instance.clrScheme, clrMap = instance.clrMap;
	            if (!isNullOrUndefined(clrScheme)) {
	                WriteCT_ColorScheme(writer, CONST_A, CONST_CLR_SCHEME, clrScheme);
	            }
	            if (!isNullOrUndefined(clrMap)) {
	                WriteCT_ColorMapping(writer, CONST_A, "clrMap", clrMap);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorSchemeAndMapping = WriteCT_ColorSchemeAndMapping;
	
	    function WriteCT_ColorSchemeList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.extraClrScheme, function (extraClrSchemeItem) {
	                WriteCT_ColorSchemeAndMapping(writer, CONST_A, "extraClrScheme", extraClrSchemeItem);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_ColorSchemeList = WriteCT_ColorSchemeList;
	
	    function WriteCT_OfficeStyleSheet(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var name = instance.name;
	            if (!isNullOrUndefinedOrEmpty(name)) {
	                writer.writeAttributeString(CONST_NAME, name);
	            }
	        }, function () {
	           
	            var themeElements = instance.themeElements, objectDefaults = instance.objectDefaults,
	                extraClrSchemeLst = instance.extraClrSchemeLst, custClrLst = instance.custClrLst,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(themeElements)) {
	                WriteCT_BaseStyles(writer, CONST_A, "themeElements", themeElements);
	            }
	            if (!isNullOrUndefined(objectDefaults)) {
	                WriteCT_ObjectStyleDefaults(writer, CONST_A, "objectDefaults", objectDefaults);
	            }
	            if (!isNullOrUndefined(extraClrSchemeLst)) {
	                WriteCT_ColorSchemeList(writer, CONST_A, "extraClrSchemeLst", extraClrSchemeLst);
	            }
	            if (!isNullOrUndefined(custClrLst)) {
	                WriteCT_CustomColorList(writer, CONST_A, "custClrLst", custClrLst);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_OfficeStyleSheet = WriteCT_OfficeStyleSheet;
	
	    function WriteCT_BaseStylesOverride(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var clrScheme = instance.clrScheme, fontScheme = instance.fontScheme,
	                fmtScheme = instance.fmtScheme;
	            if (!isNullOrUndefined(clrScheme)) {
	                WriteCT_ColorScheme(writer, CONST_A, CONST_CLR_SCHEME, clrScheme);
	            }
	            if (!isNullOrUndefined(fontScheme)) {
	                WriteCT_FontScheme(writer, CONST_A, CONST_FONT_SCHEME, fontScheme);
	            }
	            if (!isNullOrUndefined(fmtScheme)) {
	                WriteCT_StyleMatrix(writer, CONST_A, CONST_FMT_SCHEME, fmtScheme);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_BaseStylesOverride = WriteCT_BaseStylesOverride;
	
	    function WriteCT_ClipboardStyleSheet(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var themeElements = instance.themeElements, clrMap = instance.clrMap;
	            if (!isNullOrUndefined(themeElements)) {
	                WriteCT_BaseStyles(writer, CONST_A, "themeElements", themeElements);
	            }
	            if (!isNullOrUndefined(clrMap)) {
	                WriteCT_ColorMapping(writer, CONST_A, "clrMap", clrMap);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_ClipboardStyleSheet = WriteCT_ClipboardStyleSheet;
	
	    function WriteCT_TextParagraph(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var pPr = instance.pPr, endParaRPr = instance.endParaRPr, elements = instance.elements;
	            if (!isNullOrUndefined(pPr)) {
	                WriteCT_TextParagraphProperties(writer, prefix, "pPr", pPr);
	            }
	            if (!isNullOrUndefined(elements)) {
	                elements.forEach(function (item) {
	                    if (item.elementType === 0 ) {
	                        WriteCT_RegularTextRun(writer, prefix, CONST_R, item);
	                    } else if (item.elementType === 1 ) {
	                        WriteCT_TextLineBreak(writer, prefix, "br", item);
	                    } else if (item.elementType === 2 ) {
	                        WriteCT_TextField(writer, prefix, "fld", item);
	                    }
	                });
	            }
	            if (!isNullOrUndefined(endParaRPr)) {
	                WriteCT_TextCharacterProperties(writer, prefix, "endParaRPr", endParaRPr);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextParagraph = WriteCT_TextParagraph;
	
	    function WriteCT_TextListStyle(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var defPPr = instance.defPPr, lvl1pPr = instance.lvl1pPr, lvl2pPr = instance.lvl2pPr,
	                lvl3pPr = instance.lvl3pPr, lvl4pPr = instance.lvl4pPr, lvl5pPr = instance.lvl5pPr,
	                lvl6pPr = instance.lvl6pPr, lvl7pPr = instance.lvl7pPr, lvl8pPr = instance.lvl8pPr,
	                lvl9pPr = instance.lvl9pPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(defPPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "defPPr", defPPr);
	            }
	            if (!isNullOrUndefined(lvl1pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl1pPr", lvl1pPr);
	            }
	            if (!isNullOrUndefined(lvl2pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl2pPr", lvl2pPr);
	            }
	            if (!isNullOrUndefined(lvl3pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl3pPr", lvl3pPr);
	            }
	            if (!isNullOrUndefined(lvl4pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl4pPr", lvl4pPr);
	            }
	            if (!isNullOrUndefined(lvl5pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl5pPr", lvl5pPr);
	            }
	            if (!isNullOrUndefined(lvl6pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl6pPr", lvl6pPr);
	            }
	            if (!isNullOrUndefined(lvl7pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl7pPr", lvl7pPr);
	            }
	            if (!isNullOrUndefined(lvl8pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl8pPr", lvl8pPr);
	            }
	            if (!isNullOrUndefined(lvl9pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "lvl9pPr", lvl9pPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextListStyle = WriteCT_TextListStyle;
	
	    function WriteCT_TextNormalAutofit(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var fontScale = instance.fontScale, lnSpcReduction = instance.lnSpcReduction;
	            if (!isNullOrUndefined(fontScale) && fontScale !== 100000) {
	                writer.writeAttributeString("fontScale", fontScale);
	            }
	            if (!isNullOrUndefined(lnSpcReduction) && lnSpcReduction !== 0) {
	                writer.writeAttributeString("lnSpcReduction", lnSpcReduction);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextNormalAutofit = WriteCT_TextNormalAutofit;
	
	    function WriteCT_TextShapeAutofit(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextShapeAutofit = WriteCT_TextShapeAutofit;
	
	    function WriteCT_TextNoAutofit(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextNoAutofit = WriteCT_TextNoAutofit;
	
	    function getRotationData(rotationDegree) {
	       
	        return rotationDegree * 60000;
	    }
	    function WriteCT_TextBodyProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var rot = instance.rot, vertOverflow = instance.vertOverflow, horzOverflow = instance.horzOverflow,
	                wrap = instance.wrap, lIns = instance.lIns, tIns = instance.tIns, rIns = instance.rIns,
	                bIns = instance.bIns, numCol = instance.numCol, spcCol = instance.spcCol, anchor = instance.anchor;
	            if (!isNullOrUndefined(rot)) {
	                writer.writeAttributeString("rot", getRotationData(rot));
	            }
	            if (instance.spcFirstLastPara === true) {
	                writer.writeAttributeString("spcFirstLastPara", "1");
	            }
	            if (!isNullOrUndefined(vertOverflow) && vertOverflow !== 0 ) {
	                writer.writeAttributeString("vertOverflow", Charts.ST_TextVertOverflowType[vertOverflow]);
	            }
	            if (!isNullOrUndefined(horzOverflow) && horzOverflow !== 0 ) {
	                writer.writeAttributeString("horzOverflow", Charts.ST_TextHorzOverflowType[horzOverflow]);
	            }
	            if (!isNullOrUndefined(instance.vert)) {
	                writer.writeAttributeString("vert", Charts.ST_TextVerticalType[instance.vert]);
	            }
	            if (!isNullOrUndefined(wrap) && wrap !== 0 ) {
	                writer.writeAttributeString("wrap", Charts.ST_TextWrappingType[wrap]);
	            }
	            if (!isNullOrUndefined(lIns) && lIns !== 0) {
	                writer.writeAttributeString("lIns", lIns);
	            }
	            if (!isNullOrUndefined(tIns) && tIns !== 0) {
	                writer.writeAttributeString("tIns", tIns);
	            }
	            if (!isNullOrUndefined(rIns) && rIns !== 0) {
	                writer.writeAttributeString("rIns", rIns);
	            }
	            if (!isNullOrUndefined(bIns) && bIns !== 0) {
	                writer.writeAttributeString("bIns", bIns);
	            }
	            if (!isNullOrUndefined(numCol) && numCol !== 0) {
	                writer.writeAttributeString("numCol", numCol);
	            }
	            if (!isNullOrUndefined(spcCol) && spcCol !== 0) {
	                writer.writeAttributeString("spcCol", spcCol);
	            }
	            if (instance.rtlCol === true) {
	                writer.writeAttributeString("rtlCol", "1");
	            }
	            if (instance.fromWordArt === true) {
	                writer.writeAttributeString("fromWordArt", "1");
	            }
	            if (!isNullOrUndefined(anchor) && anchor !== 0 ) {
	                writer.writeAttributeString("anchor", Charts.ST_TextAnchoringType[anchor]);
	            }
	            if (instance.anchorCtr === true) {
	                writer.writeAttributeString("anchorCtr", "1");
	            }
	            if (instance.forceAA === true) {
	                writer.writeAttributeString("forceAA", "1");
	            }
	            if (instance.upright === true) {
	                writer.writeAttributeString("upright", "1");
	            }
	            if (instance.compatLnSpc === true) {
	                writer.writeAttributeString("compatLnSpc", "1");
	            }
	        }, function () {
	           
	            var prstTxWarp = instance.prstTxWarp, noAutofit = instance.noAutofit,
	                normAutofit = instance.normAutofit, spAutoFit = instance.spAutoFit,
	                scene3d = instance.scene3d, sp3d = instance.sp3d, flatTx = instance.flatTx,
	                extLst = instance.extLst;
	            if (!isNullOrUndefined(prstTxWarp)) {
	                WriteCT_PresetTextShape(writer, CONST_A, "prstTxWarp", prstTxWarp);
	            }
	            if (!isNullOrUndefined(noAutofit)) {
	                WriteCT_TextNoAutofit(writer, CONST_A, "noAutofit");
	            }
	            if (!isNullOrUndefined(normAutofit)) {
	                WriteCT_TextNormalAutofit(writer, CONST_A, "normAutofit", normAutofit);
	            }
	            if (!isNullOrUndefined(spAutoFit)) {
	                WriteCT_TextShapeAutofit(writer, CONST_A, "spAutoFit");
	            }
	            if (!isNullOrUndefined(scene3d)) {
	                WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
	            }
	            if (!isNullOrUndefined(sp3d)) {
	                WriteCT_Shape3D(writer, CONST_A, "sp3d", sp3d);
	            }
	            if (!isNullOrUndefined(flatTx)) {
	                WriteCT_FlatText(writer, CONST_A, "flatTx", flatTx);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextBodyProperties = WriteCT_TextBodyProperties;
	
	    function WriteCT_TextBody(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var bodyPr = instance.bodyPr, lstStyle = instance.lstStyle;
	            WriteCT_TextBodyProperties(writer, CONST_A, "bodyPr", bodyPr || {});   
	            if (!isNullOrUndefined(lstStyle)) {
	                WriteCT_TextListStyle(writer, CONST_A, "lstStyle", lstStyle);
	            }
	            var p = instance.p;
	            if (isNullOrUndefined(p)) {
	                var defaultP = {"pPr": {"defRPr": {}}, "endParaRPr": {}, "elements": []};
	                WriteCT_TextParagraph(writer, CONST_A, "p", defaultP);
	            } else {
	                writeArrayItem(instance.p, function (item) {
	                    WriteCT_TextParagraph(writer, CONST_A, "p", item);
	                });
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextBody = WriteCT_TextBody;
	
	    function WriteCT_TextBulletColorFollowText(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextBulletColorFollowText = WriteCT_TextBulletColorFollowText;
	
	    function WriteCT_TextBulletSizeFollowText(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextBulletSizeFollowText = WriteCT_TextBulletSizeFollowText;
	
	    function WriteCT_TextBulletSizePercent(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_TextBulletSizePercent = WriteCT_TextBulletSizePercent;
	
	    function WriteCT_TextBulletSizePoint(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_TextBulletSizePoint = WriteCT_TextBulletSizePoint;
	
	    function WriteCT_TextBulletTypefaceFollowText(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextBulletTypefaceFollowText = WriteCT_TextBulletTypefaceFollowText;
	
	    function WriteCT_TextAutonumberBullet(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var startAt = instance.startAt;
	            if (!isNullOrUndefined(instance.type)) {
	                writer.writeAttributeString(CONST_TYPE, Charts.ST_TextAutonumberScheme[instance.type]);
	            }
	            if (!isNullOrUndefined(startAt) && startAt !== 1) {
	                writer.writeAttributeString("startAt", startAt);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextAutonumberBullet = WriteCT_TextAutonumberBullet;
	
	    function WriteCT_TextCharBullet(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.charField)) {
	                writer.writeAttributeString("char", instance.charField);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextCharBullet = WriteCT_TextCharBullet;
	
	    function WriteCT_TextBlipBullet(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_Blip, CONST_A, "blip");
	    }
	
	    DrawingWriter.WriteCT_TextBlipBullet = WriteCT_TextBlipBullet;
	
	    function WriteCT_TextNoBullet(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextNoBullet = WriteCT_TextNoBullet;
	
	    function WriteCT_TextFont(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            var typeface = instance.typeface, panose = instance.panose,
	                pitchFamily = instance.pitchFamily, charset = instance.charset;
	            if (!isNullOrUndefined(typeface)) {
	                writer.writeAttributeString("typeface", typeface);
	            }
	            if (!isNullOrUndefined(panose)) {
	                writer.writeAttributeString("panose", panose);
	            }
	            if (!isNullOrUndefined(pitchFamily) && pitchFamily !== 0) {
	                writer.writeAttributeString("pitchFamily", pitchFamily);
	            }
	            if (!isNullOrUndefined(charset) && charset !== 1) {
	                writer.writeAttributeString("charset", charset);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextFont = WriteCT_TextFont;
	
	    function WriteCT_TextUnderlineLineFollowText(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextUnderlineLineFollowText = WriteCT_TextUnderlineLineFollowText;
	
	    function WriteCT_TextUnderlineFillFollowText(writer, prefix, localName) {
	        writeEmptyNode(writer, prefix, localName);
	    }
	
	    DrawingWriter.WriteCT_TextUnderlineFillFollowText = WriteCT_TextUnderlineFillFollowText;
	
	    function WriteCT_TextUnderlineFillGroupWrapper(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeFillProperties(writer, instance);
	        });
	    }
	
	    DrawingWriter.WriteCT_TextUnderlineFillGroupWrapper = WriteCT_TextUnderlineFillGroupWrapper;
	
	    function WriteCT_TextCharacterProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var altLang = instance.altLang, sz = instance.sz, kern = instance.kern,
	                cap = instance.cap, spc = instance.spc, baseline = instance.baseline,
	                smtId = instance.smtId, bmk = instance.bmk;
	            if (instance.kumimoji === true) {
	                writer.writeAttributeString("kumimoji", "1");
	            }
	            if (!isNullOrUndefined(altLang)) {
	                writer.writeAttributeString("altLang", altLang);
	            }
	            if (!isNullOrUndefined(sz) && sz !== 0) {
	                writer.writeAttributeString("sz", Math.round(UnitHelper.pixelToPoint(sz) * 100));
	            }
	
	           
	            if (!isNullOrUndefined(instance.b)) {
	                writer.writeAttributeString("b", instance.b ? "1" : "0");
	            }
	
	            if (!isNullOrUndefined(instance.i)) {
	                writer.writeAttributeString("i", instance.i ? "1" : "0");
	            }
	            if (!isNullOrUndefined(instance.u)) {
	               
	                writer.writeAttributeString("u", Charts.ST_TextUnderlineType[instance.u]);
	            }
	            if (!isNullOrUndefined(instance.strike)) {
	                writer.writeAttributeString("strike", Charts.ST_TextStrikeType[instance.strike]);
	            }
	            if (!isNullOrUndefined(kern) && kern !== 0) {
	                writer.writeAttributeString("kern", kern);
	            }
	            if (!isNullOrUndefined(cap) && cap !== 0 ) {
	                writer.writeAttributeString("cap", Charts.ST_TextCapsType[cap]);
	            }
	            if (!isNullOrUndefined(spc)) {
	                writer.writeAttributeString("spc", spc);
	            }
	            if (instance.normalizeH === true) {
	                writer.writeAttributeString("normalizeH", "1");
	            }
	            if (!isNullOrUndefined(baseline)) {
	                writer.writeAttributeString("baseline", baseline);
	            }
	            if (instance.noProof === true) {
	                writer.writeAttributeString("noProof", "1");
	            }
	            if (instance.dirty === false) {
	                writer.writeAttributeString("dirty", "0");
	            }
	            if (instance.err === true) {
	                writer.writeAttributeString("err", "1");
	            }
	            if (instance.smtClean === false) {
	                writer.writeAttributeString("smtClean", "0");
	            }
	            if (!isNullOrUndefined(smtId) && smtId !== 0) {
	                writer.writeAttributeString("smtId", smtId);
	            }
	            if (!isNullOrUndefined(bmk)) {
	                writer.writeAttributeString("bmk", bmk);
	            }
	        }, function () {
	           
	            var ln = instance.ln, highlight = instance.highlight, uLnTx = instance.uLnTx, uLn = instance.uLn,
	                uFillTx = instance.uFillTx, uFill = instance.uFill, latin = instance.latin,
	                ea = instance.ea, cs = instance.cs, sym = instance.sym, hlinkClick = instance.hlinkClick,
	                hlinkMouseOver = instance.hlinkMouseOver, extLst = instance.extLst,
	                effectLst = instance.effectLst, effectDag = instance.effectDag;
	            if (!isNullOrUndefined(ln)) {
	                WriteCT_LineProperties(writer, CONST_A, "ln", ln);
	            }
	            writeFillProperties(writer, instance);
	            if (!isNullOrUndefined(effectLst)) {
	                WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
	            }
	            if (!isNullOrUndefined(effectDag)) {
	                WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
	            }
	            if (!isNullOrUndefined(highlight)) {
	                WriteCT_Color(writer, CONST_A, "highlight", highlight);
	            }
	            if (!isNullOrUndefined(uLnTx)) {
	                WriteCT_TextUnderlineLineFollowText(writer, CONST_A, "uLnTx");
	            }
	            if (!isNullOrUndefined(uLn)) {
	                WriteCT_LineProperties(writer, CONST_A, "uLn", uLn);
	            }
	            if (!isNullOrUndefined(uFillTx)) {
	                WriteCT_TextUnderlineFillFollowText(writer, CONST_A, "uFillTx");
	            }
	            if (!isNullOrUndefined(uFill)) {
	                WriteCT_TextUnderlineFillGroupWrapper(writer, CONST_A, "uFill", uFill);
	            }
	            if (!isNullOrUndefined(latin)) {
	                WriteCT_TextFont(writer, CONST_A, "latin", latin);
	            }
	            if (!isNullOrUndefined(ea)) {
	                WriteCT_TextFont(writer, CONST_A, "ea", ea);
	            }
	            if (!isNullOrUndefined(cs)) {
	                WriteCT_TextFont(writer, CONST_A, "cs", cs);
	            }
	            if (!isNullOrUndefined(sym)) {
	                WriteCT_TextFont(writer, CONST_A, "sym", sym);
	            }
	            if (!isNullOrUndefined(hlinkClick)) {
	                WriteCT_Hyperlink(writer, CONST_A, "hlinkClick", hlinkClick);
	            }
	            if (!isNullOrUndefined(hlinkMouseOver)) {
	                WriteCT_Hyperlink(writer, CONST_A, "hlinkMouseOver", hlinkMouseOver);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextCharacterProperties = WriteCT_TextCharacterProperties;
	
	    function WriteCT_TextSpacingPercent(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_TextSpacingPercent = WriteCT_TextSpacingPercent;
	
	    function WriteCT_TextSpacingPoint(writer, prefix, localName, instance) {
	        writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
	    }
	
	    DrawingWriter.WriteCT_TextSpacingPoint = WriteCT_TextSpacingPoint;
	
	    function WriteCT_TextTabStop(writer, prefix, localName, instance) {
	        writer.writeLeafElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.pos)) {
	                writer.writeAttributeString("pos", instance.pos);
	            }
	            if (!isNullOrUndefined(instance.algn)) {
	                writer.writeAttributeString("algn", Charts.ST_TextTabAlignType[instance.algn]);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextTabStop = WriteCT_TextTabStop;
	
	    function WriteCT_TextTabStopList(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            writeArrayItem(instance.tab, function (item) {
	                WriteCT_TextTabStop(writer, CONST_A, "tab", item);
	            });
	        });
	    }
	
	    DrawingWriter.WriteCT_TextTabStopList = WriteCT_TextTabStopList;
	
	    function WriteCT_TextLineBreak(writer, prefix, localName, instance) {
	        writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_TextCharacterProperties, CONST_A, "rPr");
	    }
	
	    DrawingWriter.WriteCT_TextLineBreak = WriteCT_TextLineBreak;
	
	    function WriteCT_TextSpacing(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.spcPct)) {
	                WriteCT_TextSpacingPercent(writer, CONST_A, "spcPct", instance.spcPct);
	            }
	            if (!isNullOrUndefined(instance.spcPts)) {
	                WriteCT_TextSpacingPoint(writer, CONST_A, "spcPts", instance.spcPts);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextSpacing = WriteCT_TextSpacing;
	
	    function WriteCT_TextParagraphProperties(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            var marL = instance.marL, marR = instance.marR, lvl = instance.lvl, indent = instance.indent,
	                algn = instance.algn, defTabSz = instance.defTabSz, fontAlgn = instance.fontAlgn;
	            if (!isNullOrUndefined(marL) && marL !== 0) {
	                writer.writeAttributeString("marL", marL);
	            }
	            if (!isNullOrUndefined(marR) && marR !== 0) {
	                writer.writeAttributeString("marR", marR);
	            }
	            if (!isNullOrUndefined(lvl) && lvl !== 0) {
	                writer.writeAttributeString("lvl", lvl);
	            }
	            if (!isNullOrUndefined(indent) && indent !== 0) {
	                writer.writeAttributeString("indent", indent);
	            }
	            if (!isNullOrUndefined(algn) && algn !== 0 ) {
	                writer.writeAttributeString("algn", Charts.ST_TextAlignType[algn]);
	            }
	            if (!isNullOrUndefined(defTabSz) && defTabSz !== 0) {
	                writer.writeAttributeString("defTabSz", defTabSz);
	            }
	            if (instance.rtl === true) {
	                writer.writeAttributeString("rtl", "1");
	            }
	            if (instance.eaLnBrk === true) {
	                writer.writeAttributeString("eaLnBrk", "1");
	            }
	            if (!isNullOrUndefined(fontAlgn) && fontAlgn !== 0 ) {
	                writer.writeAttributeString("fontAlgn", Charts.ST_TextFontAlignType[fontAlgn]);
	            }
	            if (instance.latinLnBrk === true) {
	                writer.writeAttributeString("latinLnBrk", "1");
	            }
	            if (instance.hangingPunct === true) {
	                writer.writeAttributeString("hangingPunct", "1");
	            }
	        }, function () {
	           
	            var lnSpc = instance.lnSpc, spcBef = instance.spcBef, spcAft = instance.spcAft,
	                buClrTx = instance.buClrTx, buClr = instance.buClr, buSzTx = instance.buSzTx,
	                buSzPct = instance.buSzPct, buSzPts = instance.buSzPts, buFontTx = instance.buFontTx,
	                buFont = instance.buFont, buNone = instance.buNone, buAutoNum = instance.buAutoNum,
	                buChar = instance.buChar, buBlip = instance.buBlip, tabLst = instance.tabLst,
	                defRPr = instance.defRPr, extLst = instance.extLst;
	            if (!isNullOrUndefined(lnSpc)) {
	                WriteCT_TextSpacing(writer, CONST_A, "lnSpc", lnSpc);
	            }
	            if (!isNullOrUndefined(spcBef)) {
	                WriteCT_TextSpacing(writer, CONST_A, "spcBef", spcBef);
	            }
	            if (!isNullOrUndefined(spcAft)) {
	                WriteCT_TextSpacing(writer, CONST_A, "spcAft", spcAft);
	            }
	            if (!isNullOrUndefined(buClrTx)) {
	                WriteCT_TextBulletColorFollowText(writer, CONST_A, "buClrTx");
	            }
	            if (!isNullOrUndefined(buClr)) {
	                WriteCT_Color(writer, CONST_A, "buClr", buClr);
	            }
	            if (!isNullOrUndefined(buSzTx)) {
	                WriteCT_TextBulletSizeFollowText(writer, CONST_A, "buSzTx");
	            }
	            if (!isNullOrUndefined(buSzPct)) {
	                WriteCT_TextBulletSizePercent(writer, CONST_A, "buSzPct", buSzPct);
	            }
	            if (!isNullOrUndefined(buSzPts)) {
	                WriteCT_TextBulletSizePoint(writer, CONST_A, "buSzPts", buSzPts);
	            }
	            if (!isNullOrUndefined(buFontTx)) {
	                WriteCT_TextBulletTypefaceFollowText(writer, CONST_A, "buFontTx");
	            }
	            if (!isNullOrUndefined(buFont)) {
	                WriteCT_TextFont(writer, CONST_A, "buFont", buFont);
	            }
	            if (!isNullOrUndefined(buNone)) {
	                WriteCT_TextNoBullet(writer, CONST_A, "buNone");
	            }
	            if (!isNullOrUndefined(buAutoNum)) {
	                WriteCT_TextAutonumberBullet(writer, CONST_A, "buAutoNum", buAutoNum);
	            }
	            if (!isNullOrUndefined(buChar)) {
	                WriteCT_TextCharBullet(writer, CONST_A, "buChar", buChar);
	            }
	            if (!isNullOrUndefined(buBlip)) {
	                WriteCT_TextBlipBullet(writer, CONST_A, "buBlip", buBlip);
	            }
	            if (!isNullOrUndefined(tabLst)) {
	                WriteCT_TextTabStopList(writer, CONST_A, "tabLst", tabLst);
	            }
	            if (!isNullOrUndefined(defRPr)) {
	                WriteCT_TextCharacterProperties(writer, CONST_A, "defRPr", defRPr);
	            }
	            if (!isNullOrUndefined(extLst)) {
	                WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextParagraphProperties = WriteCT_TextParagraphProperties;
	
	    function WriteCT_TextField(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.id)) {
	                writer.writeAttributeString("id", instance.id);
	            }
	            if (!isNullOrUndefined(instance.type)) {
	                writer.writeAttributeString(CONST_TYPE, instance.type);
	            }
	        }, function () {
	           
	            if (!isNullOrUndefined(instance.rPr)) {
	                WriteCT_TextCharacterProperties(writer, CONST_A, "rPr", instance.rPr);
	            }
	            if (!isNullOrUndefined(instance.pPr)) {
	                WriteCT_TextParagraphProperties(writer, CONST_A, "pPr", instance.pPr);
	            }
	            if (!isNullOrUndefined(instance.t)) {
	                writer.writeElementString("a:t", instance.t);
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_TextField = WriteCT_TextField;
	
	    function WriteCT_RegularTextRun(writer, prefix, localName, instance) {
	        writer.writeElement(prefix + ":" + localName, function () {
	           
	            if (!isNullOrUndefined(instance.rPr)) {
	                WriteCT_TextCharacterProperties(writer, CONST_A, "rPr", instance.rPr);
	            }
	            if (!isNullOrUndefined(instance.t)) {
	                writer.writeElementString("a:t", xmlEncode(instance.t));
	            }
	        });
	    }
	
	    DrawingWriter.WriteCT_RegularTextRun = WriteCT_RegularTextRun;
	
	    module.exports = DrawingWriter;
	
	}());

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var XmlWriter = __webpack_require__(43);
	    var excel = __webpack_require__(21);
	    var common = __webpack_require__(4);
	    var getRangeString = __webpack_require__(26)._getRangeString;
	    var writeAutoFilter = __webpack_require__(51)._writeAutoFilter;
	    var writeSortInfo = __webpack_require__(51)._writeSortInfo;
	    var isNullOrUndefined = common._isNullOrUndefined;
	    var XFileConstants = excel._XFileConstants;
	    var Util = common._Util;
	    
	    
	    function writeTable(sheetTable, writerDataModel, sheetName) {
	        if (isNullOrUndefined(sheetTable)) {
	            return null;
	        }
	        var writer = new XmlWriter();
	        writer.writeDocument();
	        writer.writeElement('table', function () {
	            writer.writeAttributeString('xmlns', XFileConstants._tableNameSpace);
	            writer.writeAttributeString('id', sheetTable.id);
	           
	            var tableName = sheetTable.name.split(' ').join('_');
	            writer.writeAttributeString('name', tableName);
	           
	            writer.writeAttributeString('displayName', tableName.split('-').join('_'));
	            writer.writeAttributeString('ref', getRangeString([{
	                row: sheetTable.row,
	                col: sheetTable.col,
	                rowCount: sheetTable.rowCount,
	                colCount: sheetTable.colCount
	            }]));
	            if (sheetTable.showHeader === false) {
	                writer.writeAttributeString('headerRowCount', '0');
	            }
	            if (sheetTable.showFooter) {
	                writer.writeAttributeString('totalsRowCount', '1');
	            }
	        }, function () {
	            if (sheetTable.rowFilter && !isNullOrUndefined(sheetTable.rowFilter)) {
	                var sortInfo;
	                var autoFilter = writerDataModel._convertAutoFilterFromJSON(sheetName, sheetTable.rowFilter, sheetTable.tableSortInfo);
	                if (autoFilter && autoFilter.sortInfo) {
	                    sortInfo = autoFilter.sortInfo;
	                    autoFilter.sortInfo = null;
	                }
	                if (sheetTable.showHeader !== false) {
	                    if (!needShowFilterButton(sheetTable.rowFilter)) {
	                        setAutoFilterButtonHidden(autoFilter);
	                    }
	                    writeAutoFilter(writer, autoFilter);
	                }
	                if (sortInfo) {
	                    writeSortInfo(writer, sortInfo);
	                }
	            }
	            if (sheetTable.columns && sheetTable.columns.length > 0) {
	                writer.writeElement('tableColumns', function () {
	                    writer.writeAttributeString('count', sheetTable.columns.length);
	                }, function () {
	                    sheetTable.columns.forEach(function (column) {
	                        var formula = convertTotalRowFunction(column.footerFormula);
	                        if (formula !== 'custom') {
	                            writer.writeLeafElement('tableColumn', function () {
	                                writer.writeAttributeString('id', column.id.toString());
	                                var columnName = column.name;
	                                writer.writeAttributeString('name', Util._xmlEncode(Util._replaceAll(columnName, '\n', '_x000a_')));
	                                if (!isNullOrUndefined(column.footerValue)) {
	                                    writer.writeAttributeString('totalsRowLabel', column.footerValue);
	                                }
	                                if (!isNullOrUndefined(column.footerFormula)) {
	                                    writer.writeAttributeString('totalsRowFunction', formula);
	                                }
	                            });
	                        } else {
	                            writer.writeElement('tableColumn', function () {
	                                writer.writeAttributeString('id', column.id.toString());
	                                var columnName = column.name;
	                                writer.writeAttributeString('name', Util._xmlEncode(Util._replaceAll(columnName, '\n', '_x000a_')));
	                                writer.writeAttributeString('totalsRowFunction', 'custom');
	                            }, function () {
	                                writer.writeElement('totalsRowFormula', function () {
	                                    writer.writeValue(Util._xmlEncode(column.footerFormula));
	                                });
	                            });
	                        }
	                    });
	                });
	            }
	            if (sheetTable.style) {
	                writer.writeLeafElement('tableStyleInfo', function () {
	                    var styleName = '';
	                    if (!isNullOrUndefined(sheetTable.style.buildInName)) {
	                        styleName = 'TableStyle' + sheetTable.style.buildInName;
	                    } else {
	                        styleName = sheetTable.style.name;
	                    }
	                    writer.writeAttributeString('name', styleName);
	                    if (sheetTable.highlightFirstColumn) {
	                        writer.writeAttributeString('showFirstColumn', '1');
	                    } else {
	                        writer.writeAttributeString('showFirstColumn', '0');
	                    }
	                    if (sheetTable.highlightLastColumn) {
	                        writer.writeAttributeString('showLastColumn', '1');
	                    } else {
	                        writer.writeAttributeString('showLastColumn', '0');
	                    }
	                    if (!isNullOrUndefined(sheetTable.bandRows)) {
	                        writer.writeAttributeString('showRowStripes', '0');
	                    } else {
	                        writer.writeAttributeString('showRowStripes', '1');
	                    }
	                    if (sheetTable.bandColumns) {
	                        writer.writeAttributeString('showColumnStripes', '1');
	                    } else {
	                        writer.writeAttributeString('showColumnStripes', '0');
	                    }
	                });
	            }
	        });
	    
	        return writer.xml;
	    }
	
	    function needShowFilterButton(rowFilter) {
	        if (!rowFilter.showFilterButton) {
	            return false;
	        }
	        var filterButtonVisibleInfo = rowFilter.filterButtonVisibleInfo;
	        for (var colID in filterButtonVisibleInfo) {
	            if (!filterButtonVisibleInfo.hasOwnProperty(colID)) {
	                continue;
	            }
	            if (!filterButtonVisibleInfo[colID]) {
	                return false;
	            }
	        }
	        return true;
	    }
	    
	    
	    var TotalRowFunction2ExcelTotalRowFunction = {
	        101: 'average',
	        102: 'countNums',
	        103: 'count',
	        104: 'max',
	        105: 'min',
	        107: 'stdDev',
	        109: 'sum',
	        110: 'var'
	    };
	    
	    function convertTotalRowFunction(formula) {
	        if (isNullOrUndefined(formula)) {
	            return;
	        }
	        var re = /\[\S[\S\s]*\S\]/;
	        formula = formula.trim();
	        if (formula.substr(0, 9) !== 'SUBTOTAL(') {
	            return 'custom';
	        } else if (!re.test(formula)) {
	            return 'custom';
	        }
	        var formulaIndex = formula.substr(9, 3);
	        return TotalRowFunction2ExcelTotalRowFunction[formulaIndex] || 'custom';
	    }
	    
	    function setAutoFilterButtonHidden(autoFilter) {
	        if (autoFilter.filterColumns.length === 0) {
	            for (var i = 0; i < autoFilter.range.colCount; i++) {
	                autoFilter.filterColumns.push({autoFilterColumnId: i});
	            }
	        }
	        autoFilter.filterColumns.forEach(function (filterColumn) {
	            filterColumn.hiddenButton = '1';
	        });
	    }
	    
	    
	    module.exports = writeTable;
	
	}());

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    
	    
	    module.exports = {
	        _productType: 0
	    };
	
	}());

/***/ })
/******/ ])
});
;
//# sourceMappingURL=gc.spread.excelio.11.2.2.js.map